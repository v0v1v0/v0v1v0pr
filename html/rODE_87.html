<div class="container">

<table style="width: 100%;"><tr>
<td>RK4-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>RK4 class</h2>

<h3>Description</h3>

<p>RK4 class
</p>
<p>RK4 generic
</p>
<p>RK4 class constructor
</p>


<h3>Usage</h3>

<pre><code class="language-R">RK4(ode, ...)

## S4 method for signature 'RK4'
init(object, stepSize, ...)

## S4 replacement method for signature 'RK4'
init(object, ...) &lt;- value

## S4 method for signature 'RK4'
step(object, ...)

## S4 method for signature 'ODE'
RK4(ode, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ode</code></td>
<td>
<p>an ODE object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>internal passing object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepSize</code></td>
<td>
<p>the size of the step</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>value for the step</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  base class: Projectile.R
# Projectile class to be solved with Euler method


setClass("Projectile", slots = c(
    g = "numeric",
    odeSolver = "RK4"
    ),
    prototype = prototype(
        g = 9.8
    ),
    contains = c("ODE")
    )

setMethod("initialize", "Projectile", function(.Object) {
    .Object@odeSolver &lt;- RK4(.Object)
    return(.Object)
})

setMethod("setStepSize", "Projectile", function(object, stepSize, ...) {
    # use explicit parameter declaration
    # setStepSize generic has two step parameters: stepSize and dt
    object@odeSolver &lt;- setStepSize(object@odeSolver, stepSize)
    object
})


setMethod("step", "Projectile", function(object) {
    object@odeSolver &lt;- step(object@odeSolver)
    object@rate  &lt;- object@odeSolver@ode@rate
    object@state &lt;- object@odeSolver@ode@state
    object
})


setMethod("setState", signature("Projectile"), function(object, x, vx, y, vy, ...) {
    object@state[1] &lt;- x
    object@state[2] &lt;- vx
    object@state[3] &lt;- y
    object@state[4] &lt;- vy
    object@state[5] &lt;- 0     # t + dt
    object@odeSolver@ode@state &lt;- object@state
    object
})


setMethod("getState", "Projectile", function(object) {
    object@state
})


setMethod("getRate", "Projectile", function(object, state, ...) {
    object@rate[1] &lt;- state[2]     # rate of change of x
    object@rate[2] &lt;- 0            # rate of change of vx
    object@rate[3] &lt;- state[4]     # rate of change of y
    object@rate[4] &lt;- - object@g   # rate of change of vy
    object@rate[5] &lt;- 1            # dt/dt = 1

    object@rate
})


# constructor
Projectile &lt;- function()  new("Projectile")
# ++++++++++++++++++++++++++++++++++++++++++++++++++      example: PendulumApp.R
# Simulation of a pendulum using the EulerRichardson ODE solver

suppressPackageStartupMessages(library(ggplot2))

importFromExamples("Pendulum.R")      # source the class

PendulumApp &lt;- function(verbose = FALSE) {
    # initial values
    theta &lt;- 0.2
    thetaDot &lt;- 0
    dt &lt;- 0.1
    pendulum &lt;- Pendulum()
    # pendulum@state[3] &lt;- 0      # set time to zero, t = 0
    pendulum &lt;- setState(pendulum, theta, thetaDot)
    pendulum &lt;- setStepSize(pendulum, dt = dt) # using stepSize in RK4
    pendulum@odeSolver &lt;- setStepSize(pendulum@odeSolver, dt) # set new step size
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(pendulum)[3] &lt;= 40)    {
        rowvec[[i]] &lt;- list(t        = getState(pendulum)[3],    # time
                            theta    = getState(pendulum)[1], # angle
                            thetadot = getState(pendulum)[2]) # derivative of angle
        pendulum &lt;- step(pendulum)
        i &lt;- i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}
# show solution
solution &lt;- PendulumApp()
plot(solution)
# +++++++++++++++++++++++++++++++++++++++++++++++++++ application: ReactionApp.R
# ReactionApp solves an autocatalytic oscillating chemical
# reaction (Brusselator model) using
# a fourth-order Runge-Kutta algorithm.

importFromExamples("Reaction.R")      # source the class

ReactionApp &lt;- function(verbose = FALSE) {
    X &lt;- 1; Y &lt;- 5;
    dt &lt;- 0.1

    reaction &lt;- Reaction(c(X, Y, 0))
    solver &lt;- RK4(reaction)
    rowvec &lt;- vector("list")
    i &lt;- 1
    while (getState(reaction)[3] &lt; 100) {             # stop at t = 100
        rowvec[[i]] &lt;- list(t = getState(reaction)[3],
                            X = getState(reaction)[1],
                            Y = getState(reaction)[2])
        solver   &lt;- step(solver)
        reaction &lt;- getODE(solver)
        i &lt;-  i + 1
    }
    DT &lt;- data.table::rbindlist(rowvec)
    return(DT)
}


solution &lt;- ReactionApp()
plot(solution)


</code></pre>


</div>