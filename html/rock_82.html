<div class="container">

<table style="width: 100%;"><tr>
<td>parse_source</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parsing sources</h2>

<h3>Description</h3>

<p>These function parse one (<code>parse_source</code>) or more (<code>parse_sources</code>) sources and the
contained identifiers, sections, and codes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_source(
  text,
  file,
  utteranceLabelRegexes = NULL,
  ignoreOddDelimiters = FALSE,
  checkClassInstanceIds = rock::opts$get(checkClassInstanceIds),
  postponeDeductiveTreeBuilding = FALSE,
  filesWithYAML = NULL,
  removeSectionBreakRows = rock::opts$get("removeSectionBreakRows"),
  removeIdentifierRows = rock::opts$get("removeIdentifierRows"),
  removeEmptyRows = rock::opts$get("removeEmptyRows"),
  rlWarn = rock::opts$get("rlWarn"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)

## S3 method for class 'rock_parsedSource'
print(x, prefix = "### ", ...)

parse_sources(
  path,
  extension = "rock|dct",
  regex = NULL,
  recursive = TRUE,
  removeSectionBreakRows = rock::opts$get("removeSectionBreakRows"),
  removeIdentifierRows = rock::opts$get("removeIdentifierRows"),
  removeEmptyRows = rock::opts$get("removeEmptyRows"),
  ignoreOddDelimiters = FALSE,
  checkClassInstanceIds = rock::opts$get(checkClassInstanceIds),
  mergeInductiveTrees = FALSE,
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

## S3 method for class 'rock_parsedSources'
print(x, prefix = "### ", ...)

## S3 method for class 'rock_parsedSources'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>text, file</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code>base::readLines()</code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code>base::readLines()</code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">⁠\\n⁠</code>) is provided as <code>text</code>, it is split at the newline
characters using <code>base::strsplit()</code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>utteranceLabelRegexes</code></td>
<td>
<p>Optionally, a list with two-element vectors
to preprocess utterances before they are stored as labels (these 'utterance
perl regular expression!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignoreOddDelimiters</code></td>
<td>
<p>If an odd number of YAML delimiters is encountered, whether this
should result in an error (<code>FALSE</code>) or just be silently ignored (<code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkClassInstanceIds</code></td>
<td>
<p>Whether to check for the occurrence of class
instance identifiers specified in the attributes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>postponeDeductiveTreeBuilding</code></td>
<td>
<p>Whether to imediately try to build the deductive
tree(s) based on the information in this file (<code>FALSE</code>) or whether to skip that. Skipping
this is useful if the full tree information is distributed over multiple files (in which case
you should probably call <code>parse_sources</code> instead of <code>parse_source</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filesWithYAML</code></td>
<td>
<p>Any additional files to process to look for YAML fragments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeSectionBreakRows, removeIdentifierRows, removeEmptyRows</code></td>
<td>
<p>Whether to
remove from the QDT, respectively: rows containing section breaks; rows
containing only (class instance) identifiers; and empty rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlWarn</code></td>
<td>
<p>Whether to let <code>readLines()</code> warn, e.g. if files do not end
with a newline character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>The encoding of the file to read (in <code>file</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The object to print.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>The prefix to use before the 'headings' of the printed result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any additional arguments are passed on to the default print method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>The path containing the files to read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extension</code></td>
<td>
<p>The extension of the files to read; files with other extensions will
be ignored. Multiple extensions can be separated by a pipe (<code>|</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>Instead of specifing an extension, it's also possible to specify a regular
expression; only files matching this regular expression are read. If specified, <code>regex</code>
takes precedece over <code>extension</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>Whether to also process subdirectories (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mergeInductiveTrees</code></td>
<td>
<p>Merge multiple inductive code trees into one; this
functionality is currently not yet implemented.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>rock::parse_source()</code>, an object of class <code>rock_parsedSource</code>;
for <code>rock::parse_sources()</code>, an object of class <code>rock_parsedSources</code>. These
objects contain the original source(s) as well as the final data frame with
utterances and codes, as well as the code structures.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source(exampleFile);

### Show inductive code tree for the codes
### extracted with the regular expression specified with
### the name 'codes':
parsedExample$inductiveCodeTrees$codes;

### If you want `rock` to be chatty, use:
parsedExample &lt;- rock::parse_source(exampleFile,
                                    silent=FALSE);

### Parse as selection of example sources in that directory
parsedExamples &lt;-
  rock::parse_sources(
    examplePath,
    regex = "(test|example)(.txt|.rock)"
  );

### Show combined inductive code tree for the codes
### extracted with the regular expression specified with
### the name 'codes':
parsedExamples$inductiveCodeTrees$codes;

### Show a souce coded with the Qualitative Network Approach
qnaExample &lt;-
  rock::parse_source(
    file.path(
      examplePath,
      "network-example-1.rock"
    )
  );

</code></pre>


</div>