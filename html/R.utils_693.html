<div class="container">

<table style="width: 100%;"><tr>
<td>readTable</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reads a file in table format</h2>

<h3>Description</h3>

<p>Reads a file in table format and creates a data frame from it, with cases corresponding
to lines and variables to fields in the file.
</p>
<p><em>WARNING: This method is very much in an alpha stage.
Expect it to change.</em>
</p>
<p>This method is an extension to the default <code>read.table</code>
function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>.  It is possible to specify a column name to column class
map such that the column classes are automatically assigned from the
column header in the file.
</p>
<p>In addition, it is possible to read any subset of rows.
The method is optimized such that only columns and rows that are of
interest are parsed and read into <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s memory.  This minimizes memory
usage at the same time as it speeds up the reading.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
readTable(file, colClasses=NULL, isPatterns=FALSE, defColClass=NA, header=FALSE, skip=0,
  nrows=-1, rows=NULL, col.names=NULL, check.names=FALSE, path=NULL, ...,
  stripQuotes=TRUE, method=c("readLines", "intervals"), verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>A <code>connection</code> or a filename.  If a filename, the path
specified by <code>path</code> is added to the front of the
filename.  Unopened files are opened and closed at the end.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colClasses</code></td>
<td>
<p>Either a named or an unnamed <code>character</code> <code>vector</code>.
If unnamed, it specified the column classes just as used by
<code>read.table</code>.
If it is a named vector, <code>names(colClasses)</code> are used to match
the column names read (this requires that <code>header=TRUE</code>) and
the column classes are set to the corresponding values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isPatterns</code></td>
<td>
<p>If <code>TRUE</code>, the matching of <code>names(colClasses)</code> to
the read column names is done by regular expressions matching.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defColClass</code></td>
<td>
<p>If the column class map specified by a named
<code>colClasses</code> argument does not match some of the read column
names, the column class is by default set to this class. The
default is to read the columns in an "as is" way.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header</code></td>
<td>
<p>If <code>TRUE</code>, column names are read from the file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip</code></td>
<td>
<p>The number of lines (commented or non-commented) to skip
before trying to read the header or alternatively the data table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrows</code></td>
<td>
<p>The number of rows to read of the data table.
Ignored if <code>rows</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>An row index <code>vector</code> specifying which rows of the table
to read, e.g. row one is the row following the header.
Non-existing rows are ignored.  Note that rows are returned in
the same order they are requested and duplicated rows are also
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.names</code></td>
<td>
<p>Same as in <code>read.table()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.names</code></td>
<td>
<p>Same as in <code>read.table()</code>, but default value
is <code>FALSE</code> here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>If <code>file</code> is a filename, this path is added to it,
otherwise ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>read.table</code> used internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stripQuotes</code></td>
<td>
<p>If <code>TRUE</code>, quotes are stripped from values before
being parse.
This argument is only effective when <code>method=="readLines"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>If <code>"readLines"</code>, <code>(readLines())</code> is used
internally to first only read rows of interest, which is then
passed to <code>read.table()</code>.
If <code>"intervals"</code>, contiguous intervals are first identified in
the rows of interest.  These intervals are the read one by one
using <code>read.table()</code>.
The latter methods is faster and especially more memory efficient
if the intervals are not too many, where as the former is preferred
if many "scattered" rows are to be read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A <code>logical</code> or a <code>Verbose</code> object.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>See Also</h3>

<p><code>readTableIndex</code>().
<code>read.table</code>.
<code>colClasses</code>().
</p>


</div>