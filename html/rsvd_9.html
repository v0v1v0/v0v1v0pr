<div class="container">

<table style="width: 100%;"><tr>
<td>rpca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Randomized principal component analysis (rpca).</h2>

<h3>Description</h3>

<p>Fast computation of the principal components analysis using the randomized singular value decomposition.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rpca(
  A,
  k = NULL,
  center = TRUE,
  scale = TRUE,
  retx = TRUE,
  p = 10,
  q = 2,
  rand = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>array_like; <br>
a numeric <code class="reqn">(m, n)</code> input matrix (or data frame) to be analyzed. <br>
If the data contain <code class="reqn">NA</code>s na.omit is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer; <br>
number of dominant principle components to be computed. It is required that <code class="reqn">k</code> is smaller or equal to
<code class="reqn">min(m,n)</code>, but it is recommended that <code class="reqn">k &lt;&lt; min(m,n)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>bool, optional; <br>
logical value which indicates whether the variables should be
shifted to be zero centered (<code class="reqn">TRUE</code> by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>bool, optional; <br>
logical value which indicates whether the variables should
be scaled to have unit variance (<code class="reqn">TRUE</code> by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retx</code></td>
<td>
<p>bool, optional; <br>
logical value indicating whether the rotated variables / scores
should be returned (<code class="reqn">TRUE</code> by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer, optional; <br>
oversampling parameter for <code class="reqn">rsvd</code> (default <code class="reqn">p=10</code>), see <code>rsvd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>integer, optional; <br>
number of additional power iterations for <code class="reqn">rsvd</code> (default <code class="reqn">q=1</code>), see <code>rsvd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand</code></td>
<td>
<p>bool, optional; <br>
if (<code class="reqn">TRUE</code>), the <code class="reqn">rsvd</code> routine is used, otherwise <code class="reqn">svd</code> is used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Principal component analysis is an important linear dimension reduction technique.
</p>
<p>Randomized PCA is computed via the randomized SVD algorithm (<code>rsvd</code>).
The computational gain is substantial, if the desired number of principal components
is relatively small, i.e. <code class="reqn">k &lt;&lt; min(m,n)</code>.
</p>
<p>The print and summary method can be used to present the results in a nice format.
A scree plot can be produced with <code>ggscreeplot</code>. 
The individuals factor map can be produced with <code>ggindplot</code>,
and a correlation plot with <code>ggcorplot</code>.
</p>
<p>The predict function can be used to compute the scores of new observations. The data
will automatically be centered (and scaled if requested). This is not fully supported for
complex input matrices.
</p>


<h3>Value</h3>

<p><code>rpca</code> returns a list with class <code class="reqn">rpca</code> containing the following components:
</p>

<dl>
<dt>rotation</dt>
<dd>
<p>  array_like; <br>
the rotation (eigenvectors); <code class="reqn">(n, k)</code> dimensional array.
</p>
</dd>
<dt>eigvals</dt>
<dd>
<p>  array_like; <br>
eigenvalues; <code class="reqn">k</code> dimensional vector.
</p>
</dd>
<dt>sdev</dt>
<dd>
<p>     array_like; <br>
standard deviations of the principal components; <code class="reqn">k</code> dimensional vector.
</p>
</dd>
<dt>x</dt>
<dd>
<p>        array_like; <br>
the scores / rotated data; <code class="reqn">(m, k)</code> dimensional array.
</p>
</dd>
<dt>center, scale</dt>
<dd>
<p>  array_like; <br>
the centering and scaling used.
</p>
</dd>
</dl>
<h3>Note</h3>

<p>The principal components are not unique and only defined up to sign
(a constant of modulus one in the complex case) and so may differ between different
PCA implementations.
</p>
<p>Similar to <code>prcomp</code> the variances are computed with the usual divisor N - 1.
</p>


<h3>Author(s)</h3>

<p>N. Benjamin Erichson, <a href="mailto:erichson@berkeley.edu">erichson@berkeley.edu</a>
</p>


<h3>References</h3>


<ul>
<li>
<p> [1] N. B. Erichson, S. Voronin, S. L. Brunton and J. N. Kutz. 2019.
Randomized Matrix Decompositions Using R. 
Journal of Statistical Software, 89(11), 1-48.
doi: <a href="https://doi.org/10.18637/jss.v089.i11">10.18637/jss.v089.i11</a>.
</p>
</li>
<li>
<p>  [2] N. Halko, P. Martinsson, and J. Tropp.
"Finding structure with randomness: probabilistic
algorithms for constructing approximate matrix
decompositions" (2009).
(available at arXiv <a href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a>).
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>ggscreeplot</code>, <code>ggindplot</code>,
<code>ggcorplot</code>, <code>plot.rpca</code>,
<code>predict</code>,   <code>rsvd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library('rsvd')
#
# Load Edgar Anderson's Iris Data
#
data('iris')

#
# log transform
#
log.iris &lt;- log( iris[ , 1:4] )
iris.species &lt;- iris[ , 5]

#
# Perform rPCA and compute only the first two PCs
#
iris.rpca &lt;- rpca(log.iris, k=2)
summary(iris.rpca) # Summary
print(iris.rpca) # Prints the rotations

#
# Use rPCA to compute all PCs, similar to \code{\link{prcomp}}
#
iris.rpca &lt;- rpca(log.iris)
summary(iris.rpca) # Summary
print(iris.rpca) # Prints the rotations
plot(iris.rpca) # Produce screeplot, variable and individuls factor maps.

</code></pre>


</div>