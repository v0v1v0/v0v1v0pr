<div class="container">

<table style="width: 100%;"><tr>
<td>R2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate R2_lik, R2_resid, and R2_pred</h2>

<h3>Description</h3>

<p>This is a wrapper for calculating three R2s – R2_lik, R2_resid, and R2_pred – for LMMs and GLMMs, and phylogenetic LMMs (PLMMs) and GLMMs (PGLMMs). Note that the individual functions <code>R2_lik()</code>, <code>R2_resid()</code>, and <code>R2_pred()</code> can be called separately. This is preferrable if you are only interested in one R2; for example, for <code>phylolm()</code> called from ‘R2' you need to specify ’phy' (phylo object for the phylogeny), while <code>R2_lik()</code> does not require this.
</p>


<h3>Usage</h3>

<pre><code class="language-R">R2(
  mod = NULL,
  mod.r = NULL,
  phy = NULL,
  sigma2_d = c("s2w", "NS", "rNS"),
  lik = TRUE,
  resid = TRUE,
  pred = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>A regression model with one of the following classes: 'lm', 'glm', lmerMod', glmerMod', 'phylolm', 'gls', 'pglmm', 'pglmm_compare', binaryPGLMM', or 'communityPGLMM'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.r</code></td>
<td>
<p>A reduced model; if not provided, the total R2 will be given by setting 'mod.r' to the model corresponding to 'mod' with the intercept as the only predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phy</code></td>
<td>
<p>The phylogeny for phylogenetic models (as a 'phylo' object), which is not required to be specified for <code>R2_lik()</code> or non-phylogenetic models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2_d</code></td>
<td>
<p>Distribution-specific variance <code class="reqn">\sigma^2_d</code> (see Details) used in <code>R2_resid()</code>. For binomial GLMs, GLMMs and PGLMMs with logit link functions, options are c('s2w', 'NS', 'rNS'). For binomial GLMs, GLMMs and PGLMMs with probit link functions, options are c('s2w', 'NS'). Other families use 's2w'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lik</code></td>
<td>
<p>Whether to calculate R2_lik; default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid</code></td>
<td>
<p>Whether to calculate R2_resid; default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>Whether to calculate R2_pred; default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for 'R2_pred()'. 'gaussian.pred = "tip_rm"' or 'gaussian.pred = "nearest_node"'.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Details about the methods are provided under the separate functions for <code>R2_lik()</code>, <code>R2_resid()</code>, and <code>R2_pred()</code>. There are also many worked examples.
</p>


<h3>Value</h3>

<p>A vector, with all three R2s by default.
</p>


<h3>Author(s)</h3>

<p>Daijiang Li and Anthony R. Ives
</p>


<h3>References</h3>

<p>Ives A.R. and Li D. 2018. rr2: An R package to calculate R2s for regression models. Journal of Open Source Software. DOI:10.21105/joss.01028
</p>
<p>Ives A.R. 2018. R2s for Correlated Data: Phylogenetic Models, LMMs, and GLMMs. Systematic Biology, Volume 68, Issue 2, March 2019, Pages 234-251. DOI:10.1093/sysbio/syy060
</p>


<h3>See Also</h3>

<p>MuMIn, lme4, ape, phylolm, phyr, pez
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ape)
library(phylolm)
library(lme4)
library(nlme)
library(phyr)

set.seed(12345)
p1 &lt;- 10
nsample &lt;- 10
n &lt;- p1 * nsample

d &lt;- data.frame(x1 = 0, x2 = 0, u1 = rep(1:p1, each = nsample),
                u2 = rep(1:p1, times = nsample))
d$u1 &lt;- as.factor(d$u1)
d$u2 &lt;- as.factor(d$u2)

b1 &lt;- 1
b2 &lt;- -1
sd1 &lt;- 1.5

d$x1 &lt;- rnorm(n = n)
d$x2 &lt;- rnorm(n = n)
d$y.lmm &lt;- b1 * d$x1 + b2 * d$x2 + 
  rep(rnorm(n = p1, sd = sd1), each = nsample) +
  rep(rnorm(n = p1, sd = sd1), times = nsample) + 
  rnorm(n = n)

prob &lt;- inv.logit(b1 * d$x1 + rep(rnorm(n = p1, sd = sd1), each = nsample))
d$y.glmm &lt;- rbinom(n = n, size = 1, prob = prob)

# LMM with two fixed and two random effects ----
z.f &lt;- lmer(y.lmm ~ x1 + x2 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.x &lt;- lmer(y.lmm ~ x1 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.v &lt;- lmer(y.lmm ~ 1 + (1 | u2), data = d, REML = FALSE)
z.0 &lt;- lm(y.lmm ~ 1, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# GLMM with one fixed and one random effect ----
z.f &lt;- glmer(y.glmm ~ x1 + (1 | u1), data = d, family = 'binomial')
z.x &lt;- glmer(y.glmm ~ 1 + (1 | u1), data = d, family = 'binomial')
z.v &lt;- glm(y.glmm ~ x1, data = d, family = 'binomial')

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# These give different results for R2_resid.
R2(z.f, sigma2_d = 's2w')
R2(z.f, sigma2_d = 'NS')
R2(z.f, sigma2_d = 'rNS')

# GLS {nlme} with one fixed effect and autocorrelated errors among 6 groups ----
nT &lt;- 10
nseries &lt;- 6
n &lt;- nT * nseries

d &lt;- data.frame(x = 0, y = 0, u = rep(1:nseries, each = nT), e = rnorm(1))
d$u &lt;- as.factor(d$u)
d$x &lt;- rnorm(n = n)
ar1 &lt;- .5
for(t in 2:n) d$e[t] &lt;- ar1*d$e[t-1] + rnorm(1)

b1 &lt;- 1
d$y &lt;- b1 * d$x + d$e

z.f &lt;- gls(y ~ x + u, correlation = corAR1(form = ~1 | u), data = d)
z.x &lt;- gls(y ~ 1, correlation = corAR1(form = ~1 | u), data = d)
z.ar &lt;- lm(y ~ x + u, data = d)

R2(z.f, z.x)
R2(z.f, z.ar)
R2(z.f)

# PGLS with a single fixed effect ----
n &lt;- 100
d &lt;- data.frame(x = rep(0, n), y = 0)

b1 &lt;- 1.5
signal &lt;- 0.7

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rTraitCont(phy.x, model = 'BM', sigma = 1)
e &lt;- signal ^ 0.5 * rTraitCont(phy, model = 'BM', sigma = 1) +
  (1 - signal) ^ 0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy$tip.label
d$sp &lt;- phy$tip.label

# Fit with phylolm() in {phylolm}
z.f &lt;- phylolm(y ~ x, phy = phy, data = d, model = 'lambda')
z.x &lt;- phylolm(y ~ 1, phy = phy, data = d, model = 'lambda')
z.v &lt;- lm(y ~ x, data = d)

R2(z.f, z.x, phy = phy)
R2(z.f, z.v, phy = phy)
R2(z.f, phy = phy)

# These data can also be fit with pglmm_compare in {phyr}
# Note that pglmm_compare will be renamed to pglmm_compare in the next version
z.f &lt;- pglmm_compare(y ~ x, data = d, phy = phy, REML=FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, phy = phy, REML=FALSE)
z.v &lt;- glm(y ~ x, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# This also works for models fit with gls() in {nlme}
z.f &lt;- gls(y ~ x, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.x &lt;- gls(y ~ 1, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.v &lt;- lm(y ~ x, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# But note that you need to define weights for gls() with non-ultrametric trees;
# if not, you will get a error from R2_resid,  "Matrix is not block-diagonal"

phy.nu &lt;- rtree(n = n)
# Generate random data
e &lt;- signal ^ 0.5 * rTraitCont(phy.nu, model = 'BM', sigma = 1) +
  (1 - signal) ^ 0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy.nu$tip.label
d$sp &lt;- phy.nu$tip.label

weights &lt;- diag(vcv.phylo(phy.nu))
z.f &lt;- gls(y ~ x, data = d,
           correlation = corPagel(1, phy.nu, form = ~sp),
           weights = varFixed(~weights), method = "ML")
z.x &lt;- gls(y ~ 1, data = d,
           correlation = corPagel(1, phy.nu, form = ~sp),
           weights = varFixed(~weights), method = "ML")
z.v &lt;- lm(y ~ x, weights = 1/weights, data = d)

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# PGLMM with one fixed effect ----
n &lt;- 100
b1 &lt;- 1.5
signal &lt;- 2

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rnorm(n)
d &lt;- data.frame(x = x, y = 0)

e &lt;- signal * rTraitCont(phy, model = 'BM', sigma = 1)
e &lt;- e[match(phy$tip.label, names(e))]

d$y &lt;- rbinom(n = n, size = 1, prob = inv.logit(b1 * d$x + e))
rownames(d) &lt;- phy$tip.label
# Use the function phyloglm() from the phylolm package.
z.f &lt;- phyloglm(y ~ x, data = d, start.alpha = 1, phy = phy)
z.x &lt;- phyloglm(y ~ 1, data = d, phy = phy, start.alpha = min(20, z.f$alpha))
z.v &lt;- glm(y ~ x, data = d, family = 'binomial')

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# Use the function pglmm_compare() from the phyr package. Note that this is a 
# different model from phyloglm()
z.f &lt;- pglmm_compare(y ~ x, data = d, family = 'binomial', phy = phy, REML = FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, family = 'binomial', phy = phy, REML = FALSE)
z.v &lt;- glm(y ~ x, data = d, family = 'binomial')

R2(z.f, z.x)
R2(z.f, z.v)
R2(z.f)

# A community example of pglmm {phyr} ----
library(mvtnorm)
nspp &lt;- 6
nsite &lt;- 4

# Simulate a phylogeny that has a lot of phylogenetic signal (power = 1.3)
phy &lt;- compute.brlen(rtree(n = nspp), method = "Grafen", power = 1.3)

# Simulate species means
sd.sp &lt;- 1
mean.sp &lt;- rTraitCont(phy, model = "BM", sigma=sd.sp ^ 2)

# Replicate values of mean.sp over sites
Y.sp &lt;- rep(mean.sp, times = nsite)

# Simulate site means
sd.site &lt;- 1
mean.site &lt;- rnorm(nsite, sd = sd.site)

# Replicate values of mean.site over sp
Y.site &lt;- rep(mean.site, each = nspp)

# Compute a covariance matrix for phylogenetic attraction
sd.attract &lt;- 1
Vphy &lt;- vcv(phy)

# Standardize the phylogenetic covariance matrix to have determinant = 1.
# (For an explanation of this standardization, see subsection 4.3.1 in Ives (2018))
Vphy &lt;- Vphy/(det(Vphy)^(1/nspp))

# Construct the overall covariance matrix for phylogenetic attraction.
# (For an explanation of Kronecker products, see subsection 4.3.1 in the book)
V &lt;- kronecker(diag(nrow = nsite, ncol = nsite), Vphy)
Y.attract &lt;- array(t(rmvnorm(n = 1, sigma = sd.attract^2*V)))

# Simulate residual errors
sd.e &lt;- 1
Y.e &lt;- rnorm(nspp * nsite, sd = sd.e)

# Construct the dataset
d &lt;- data.frame(sp = rep(phy$tip.label, times = nsite), site = rep(1:nsite, each = nspp))

# Simulate abundance data
d$Y &lt;- Y.sp + Y.site + Y.attract + Y.e

# Full and reduced models
z.f &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site) + (1|sp__@site),
             data = d, cov_ranef = list(sp = phy), REML = FALSE)
z.nested &lt;- pglmm(Y ~ 1 + (1|sp__) + (1|site),
                  data = d, cov_ranef = list(sp = phy), REML = FALSE)
z.sp &lt;- pglmm(Y ~ 1 + (1|sp) + (1|site),
              data = d, cov_ranef = list(sp = phy), REML = FALSE)

R2(z.f, z.nested)
R2(z.nested, z.sp)
R2(z.f)
</code></pre>


</div>