<div class="container">

<table style="width: 100%;"><tr>
<td>georamps</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian Geostatistical Model Fitting with RAMPS</h2>

<h3>Description</h3>

<p>General function for fitting Bayesian geostatistical models using the reparameterized and marginalized posterior sampling (RAMPS) algorithm of Yan et al. (2007).
</p>


<h3>Usage</h3>

<pre><code class="language-R">   georamps(fixed, random, correlation, data, subset, weights,
            variance = list(fixed = ~ 1, random = ~ 1, spatial = ~ 1),
            aggregate = list(grid = NULL, blockid = ""), kmat = NULL,
            control = ramps.control(...), contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>two-sided linear <code>"formula"</code> object describing the main effects in the mean structure of the model, with the response on the left of a <code>~</code> operator and the terms, separated by <code>+</code> operators, on the right.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random</code></td>
<td>
<p>optional one-sided formula of the form <code>~ 1 | g</code>, specifying random intercepts for groups defined by the factor <code>g</code>. Several grouping variables may be simultaneously specified, separated by the <code>*</code> operator, as in <code>~ 1 | g1 * g2 * g3</code>. In such cases, the levels of each variable are pasted together and the resulting factor used to group the observations.  Missing <code>NA</code> values may be given in the grouping variable to omit random effects for the associated measurements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correlation</code></td>
<td>
<p><code>'corRSpatial'</code> object describing the spatial correlation structure.  See the <code>corRClasses</code> documentation for a listing of the available structures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>optional data frame containing the variables named in <code>fixed</code>, <code>random</code>, <code>correlation</code>, <code>weights</code>, <code>variance</code>, and <code>subset</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>optional expression indicating the subset of rows in <code>data</code> that should be used in the fit. This can be a logical vector, or a numerical vector indicating which observation numbers are to be included, or a character vector of the row names to be included. All observations are included by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numerical vector of measurement error variance (inverse) weights to be used in the fitting process. Defaults to a value of 1 for point-source measurements and the number of grid points for areal measurements (see the <code>aggregate</code> argument below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance</code></td>
<td>
<p>optional list of one-sided formulas, each of the form <code>~ g</code> where <code>g</code> defines a grouping factor for the following elements: <code>fixed</code> for measurement error variances; <code>random</code> for random effects error variances; and <code>spatial</code> for spatial variances.  A single variance is assumed in each case by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p>optional list of elements: <code>grid</code> a data frame of coordinates to use for Monte Carlo integration over geographic blocks at which areal measurements are available; and <code>blockid</code> a character string specifying the column by which to merge the areal measurements in <code>data</code> with the grid coordinates in <code>grid</code>.  Merging is only performed for <code>blockid</code> values that are common to both datasets.  All observations in <code>data</code> are treated as point-source measurements by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmat</code></td>
<td>
<p>optional <code class="reqn">n \times s</code> design matrix for mapping spatial sites to outcome responses, where <code class="reqn">n</code> is the number of responses and <code class="reqn">s</code> the number of unique sites.  Unique sites are ordered first according to those supplied to the <code>data</code> argument and second to those supplied to the <code>aggregate</code> argument.  Defaults to <code>kmat[i,j] = 1 / N[i]</code> if site <code>j</code> is one of <code>N[i]</code> measurement sites contributing to response <code>i</code>; otherwise <code>kmat[i,j] = 0</code>.  Rows or columns of zeros are not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list of parameters for controlling the fitting process. See the <code>ramps.control</code> documentation for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>optional list. See the <code>contrasts.arg</code> of <code>model.matrix</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>'ramps'</code> containing the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p><code>'mcmc'</code> object of monitored model parameters with variable labels in the column names and MCMC iteration numbers in the row names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p><code>'mcmc'</code> object of monitored latent spatial parameters with variable labels in the column names and MCMC iteration numbers in the row names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>vector of data log-likelihood values at each MCMC iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evals</code></td>
<td>
<p>vector of slice sampler evaluations at each MCMC iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched function call to <code>georamps</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xmat</code></td>
<td>
<p>design matrix for the main effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>the <code>'terms'</code> object for <code>xmat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlevels</code></td>
<td>
<p>list of the factor levels for <code>xmat</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etype</code></td>
<td>
<p>grouping factor for the measurement error variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmat</code></td>
<td>
<p>matrix for mapping the spatial parameters to the observed data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correlation</code></td>
<td>
<p>specified <code>'corRSpatial'</code> object for the spatial correlation structure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>matrix of unique coordinates for the measurement and grid sites.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ztype</code></td>
<td>
<p>grouping factor for the spatial variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wmat</code></td>
<td>
<p>matrix for mapping the random effects to the observed data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retype</code></td>
<td>
<p>grouping factor for the random effects variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters used in the fitting process.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Brian Smith <a href="mailto:brian-j-smith@uiowa.edu">brian-j-smith@uiowa.edu</a>, Jun Yan <a href="mailto:jun.yan@uconn.edu">jun.yan@uconn.edu</a>, and Kate Cowles <a href="mailto:kate-cowles@uiowa.edu">kate-cowles@uiowa.edu</a></p>


<h3>References</h3>

<p>Yan, J., Cowles, M.K., Wang, S., and Armstrong, M. (2007) “Parallelizing MCMC for Bayesian Spatiotemporal Geostatistical Models”, <em>Statistics and Computing</em>, 17(4), 323-335.
</p>
<p>Smith, B. J., Yan, J., and Cowles, M. K. (2008) “Unified Geostatistical Modeling for Data Fusion and Spatial Heteroskedasticity with R Package ramps”, <em>Journal of Statistical Software</em>, 25(10), 1-21.
</p>


<h3>See Also</h3>

<p><code>corRClasses</code>,
<code>ramps.control</code>,
<code>mcmc</code>,
<code>DIC.ramps</code>,
<code>plot.ramps</code>,
<code>predict.ramps</code>,
<code>summary.ramps</code>,
<code>window.ramps</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## Load the included uranium datasets for use in this example
data(NURE)

## Geostatistical analysis of areal measurements
NURE.ctrl1 &lt;- ramps.control(
   iter = 25,
   beta = param(0, "flat"),
   sigma2.e = param(1, "invgamma", shape = 2.0, scale = 0.1, tuning = 0.75),
   phi = param(10, "uniform", min = 0, max = 35, tuning = 0.50),
   sigma2.z = param(1, "invgamma", shape = 2.0, scale = 0.1)
)

NURE.fit1 &lt;- georamps(log(ppm) ~ 1,
   correlation = corRExp(form = ~ lon + lat, metric = "haversine"),
   weights = area,
   data = NURE,
   subset = (measurement == 1),
   aggregate = list(grid = NURE.grid, blockid = "id"),
   control = NURE.ctrl1
)
print(NURE.fit1)
summary(NURE.fit1)


## Analysis of point-source measurements
NURE.ctrl2 &lt;- ramps.control(
   iter = 25,
   beta = param(0, "flat"),
   sigma2.e = param(1, "invgamma", shape = 2.0, scale = 0.1, tuning = 0.75),
   phi = param(10, "uniform", min = 0, max = 35, tuning = 0.5),
   sigma2.z = param(1, "invgamma", shape = 2.0, scale = 0.1)
)

NURE.fit2 &lt;- georamps(log(ppm) ~ 1,
   correlation = corRExp(form = ~ lon + lat, metric = "haversine"),
   data = NURE,
   subset = (measurement == 2),
   control = NURE.ctrl2
)
print(NURE.fit2)
summary(NURE.fit2)


## Joint analysis of areal and point-source measurements with
## prediction only at grid sites
NURE.ctrl &lt;- ramps.control(
   iter = 25,
   beta = param(rep(0, 2), "flat"),
   sigma2.e = param(rep(1, 2), "invgamma", shape = 2.0, scale = 0.1, tuning = 0.75),
   phi = param(10, "uniform", min = 0, max = 35, tuning = 0.5),
   sigma2.z = param(1, "invgamma", shape = 2.0, scale = 0.1),
   z.monitor = NURE.grid
)

NURE.fit &lt;- georamps(log(ppm) ~ factor(measurement) - 1,
   correlation = corRExp(form = ~ lon + lat, metric = "haversine"),
   variance = list(fixed = ~ measurement),
   weights = area * (measurement == 1) + (measurement == 2),
   data = NURE,
   aggregate = list(grid = NURE.grid, blockid = "id"),
   control = NURE.ctrl
)
print(NURE.fit)
summary(NURE.fit)


## Discard initial 5 MCMC samples as a burn-in sequence
fit &lt;- window(NURE.fit, iter = 6:25)
print(fit)
summary(fit)

## Deviance Information Criterion
DIC(fit)

## Prediction at unmeasured sites
ct &lt;- map("state", "connecticut", plot = FALSE)
lon &lt;- seq(min(ct$x, na.rm = TRUE), max(ct$x, na.rm = TRUE), length = 20)
lat &lt;- seq(min(ct$y, na.rm = TRUE), max(ct$y, na.rm = TRUE), length = 15)
grid &lt;- expand.grid(lon, lat)

newsites &lt;- data.frame(lon = grid[,1], lat = grid[,2],
                       measurement = 1)
pred &lt;- predict(fit, newsites)

plot(pred, func = function(x) exp(mean(x)),
     database = "state", regions = "connecticut",
     resolution = c(200, 150), bw = 5,
     main = "Posterior Mean",
     legend.args = list(text = "ppm", side = 3, line = 1))

plot(pred, func = function(x) exp(sd(x)),
     database = "state", regions = "connecticut",
     resolution = c(200, 150), bw = 5,
     main = "Posterior Standard Deviation",
     legend.args = list(text = "ppm", side = 3, line = 1))

## End(Not run)
</code></pre>


</div>