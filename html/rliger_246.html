<div class="container">

<table style="width: 100%;"><tr>
<td>runCluster</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SNN Graph Based Community Detection</h2>

<h3>Description</h3>

<p>After quantile normalization, users can additionally run the Leiden or
Louvain algorithm for community detection, which is widely used in
single-cell analysis and excels at merging small clusters into broad cell
classes.
</p>
<p>While using quantile normalized factor loadings (result from
<code>quantileNorm</code>) is recommended, this function looks for
unnormalized factor loadings (result from <code>runIntegration</code>) when
the former is not available.
</p>


<h3>Usage</h3>

<pre><code class="language-R">runCluster(
  object,
  resolution = 1,
  nNeighbors = 20,
  prune = 1/15,
  eps = 0.1,
  nRandomStarts = 10,
  nIterations = 5,
  method = c("leiden", "louvain"),
  useRaw = NULL,
  useDims = NULL,
  groupSingletons = TRUE,
  saveSNN = FALSE,
  clusterName = paste0(method, "_cluster"),
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A liger object. Should have valid factorization
result available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolution</code></td>
<td>
<p>Numeric, value of the resolution parameter, a larger value
results in a larger number of communities with smaller sizes. Default
<code>1.0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nNeighbors</code></td>
<td>
<p>Integer, the maximum number of nearest neighbors to
compute. Default <code>20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prune</code></td>
<td>
<p>Numeric. Sets the cutoff for acceptable Jaccard index when
computing the neighborhood overlap for the SNN construction. Any edges with
values less than or equal to this will be set to 0 and removed from the SNN
graph. Essentially sets the stringency of pruning. <code>0</code> for no pruning,
while <code>1</code> prunes everything. Default <code>1/15</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Numeric, the error bound of the nearest neighbor search. Default
<code>0.1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nRandomStarts</code></td>
<td>
<p>Integer number of random starts. Will pick the
membership with highest quality to return. Default <code>10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIterations</code></td>
<td>
<p>Integer, maximal number of iterations per random start.
Default <code>5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Community detection algorithm to use. Choose from
<code>"leiden"</code> or <code>"louvain"</code>. Default <code>"leiden"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useRaw</code></td>
<td>
<p>Whether to use un-aligned cell factor loadings (<code class="reqn">H</code>
matrices). Default <code>NULL</code> search for quantile-normalized loadings first
and un-aligned loadings then.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useDims</code></td>
<td>
<p>Indices of factors to use for clustering. Default <code>NULL</code>
uses all available factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupSingletons</code></td>
<td>
<p>Whether to group single cells that make up their own
cluster in with the cluster they are most connected to. Default <code>TRUE</code>,
if <code>FALSE</code>, assign all singletons to a <code>"singleton"</code> group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveSNN</code></td>
<td>
<p>Logical, whether to store the SNN graph, as a dgCMatrix
object, in the object. Default <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterName</code></td>
<td>
<p>Name of the variable that will store the clustering result
in <code>cellMeta</code> slot of <code>object</code>. Default <code>"leiden_cluster"</code> and
<code>"louvain_cluster"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Seed of the random number generator. Default <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>object</code> with cluster assignment updated in <code>clusterName</code>
variable in <code>cellMeta</code> slot. Can be fetched with
<code>object[[clusterName]]</code>. If <code>saveSNN = TRUE</code>, the SNN graph will
be stored at <code>object@uns$snn</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pbmcPlot &lt;- runCluster(pbmcPlot)
head(pbmcPlot$leiden_cluster)
pbmcPlot &lt;- runCluster(pbmcPlot, method = "louvain")
head(pbmcPlot$louvain_cluster)
</code></pre>


</div>