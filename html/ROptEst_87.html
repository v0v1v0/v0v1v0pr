<div class="container">

<table style="width: 100%;"><tr>
<td>getIneffDiff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Function for the Computation of Inefficiency Differences</h2>

<h3>Description</h3>

<p>Generic function for the computation of inefficiency differencies.
This function is rarely called directly. It is used to compute
the radius minimax IC and the least favorable radius.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getIneffDiff(radius, L2Fam, neighbor, risk, ...)

## S4 method for signature 'numeric,L2ParamFamily,UncondNeighborhood,asMSE'
getIneffDiff(
          radius, L2Fam, neighbor, risk, loRad, upRad, loRisk, upRisk, 
          z.start = NULL, A.start = NULL, upper.b = NULL, lower.b = NULL,
          OptOrIter = "iterate", MaxIter, eps, warn, loNorm = NULL, upNorm = NULL,
          verbose = NULL, ..., withRetIneff = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p> neighborhood radius. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRad</code></td>
<td>
<p> the lower end point of the interval to be searched. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upRad</code></td>
<td>
<p> the upper end point of the interval to be searched. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRisk</code></td>
<td>
<p> the risk at the lower end point of the interval. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upRisk</code></td>
<td>
<p> the risk at the upper end point of the interval. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper.b</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.b</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxIter</code></td>
<td>
<p> the maximum number of iterations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p> logical: print warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loNorm</code></td>
<td>
<p>object of class <code>"NormType"</code>; used in selfstandardization
to evaluate the bias of the current IC in the norm of the lower 
bound</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upNorm</code></td>
<td>
<p>object of class <code>"NormType"</code>; used in selfstandardization
to evaluate the bias of the current IC in the norm of the upper 
bound</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed on to <code>getInfRobIC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withRetIneff</code></td>
<td>
<p>logical: if <code>TRUE</code>, <code>getIneffDiff</code>  returns the
vector of lower and upper inefficiency (components named "lo" and "up"),
otherwise (default) the difference.
The latter was used in <code>radiusMinimaxIC</code> up to version 0.8
for a call to <code>uniroot</code> directly.  In order to speed up things
(i.e., not to call the expensive <code>getInfRobIC</code> once again at the zero,
up to version 0.8 we had some awkward <code>assign</code>-<code>sys.frame</code>
construction to modify the caller writing the upper inefficiency already
computed to the caller environment; having capsulated this into <code>try</code>
from version 0.9 on, this became even more awkward, so from version 0.9
onwards, we instead use the <code>TRUE</code>-alternative when calling it
from <code>radiusMinimaxIC</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The inefficieny difference between the left and
the right margin of a given radius interval is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>radius = "numeric", L2Fam = "L2ParamFamily", 
neighbor = "UncondNeighborhood", risk = "asMSE":</dt>
<dd> 
<p>computes difference of asymptotic MSEâ€“inefficiency for
the boundaries of a given radius interval.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code>radiusMinimaxIC</code>, <code>leastFavorableRadius</code></p>


</div>