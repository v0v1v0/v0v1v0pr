<div class="container">

<table style="width: 100%;"><tr>
<td>ggR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot RasterLayers in ggplot with greyscale</h2>

<h3>Description</h3>

<p>Plot single layer imagery in grey-scale. Can be used with a SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ggR(
  img,
  layer = 1,
  maxpixels = 5e+05,
  alpha = 1,
  hue = 1,
  sat = 0,
  stretch = "none",
  quantiles = c(0.02, 0.98),
  ext = NULL,
  coord_equal = TRUE,
  ggLayer = FALSE,
  ggObj = TRUE,
  geom_raster = FALSE,
  forceCat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>img</code></td>
<td>
<p>SpatRaster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layer</code></td>
<td>
<p>Character or numeric. Layername or number. Can be more than one layer, in which case each layer is plotted in a subplot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxpixels</code></td>
<td>
<p>Integer. Maximal number of pixels to sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Transparency (0-1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hue</code></td>
<td>
<p>Numeric. Hue value for color calculation [0,1] (see <code>hsv</code>). Change if you need anything else than greyscale. Only effective if <code>sat &gt; 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sat</code></td>
<td>
<p>Numeric. Saturation value for color calculation [0,1] (see <code>hsv</code>). Change if you need anything else than greyscale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stretch</code></td>
<td>
<p>Character. Either 'none', 'lin', 'hist', 'sqrt' or 'log' for no stretch, linear, histogram, square-root or logarithmic stretch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>Numeric vector with two elements. Min and max quantiles to stretch to. Defaults to 2% stretch, i.e. c(0.02,0.98).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ext</code></td>
<td>
<p>Extent object to crop the image</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord_equal</code></td>
<td>
<p>Logical. Force addition of coord_equal, i.e. aspect ratio of 1:1. Typically useful for remote sensing data (depending on your projection), hence it defaults to TRUE.
Note however, that this does not apply if (<code>ggLayer=FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ggLayer</code></td>
<td>
<p>Logical. Return only a ggplot layer which must be added to an existing ggplot. If <code>FALSE</code> s stand-alone ggplot will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ggObj</code></td>
<td>
<p>Logical. Return a stand-alone ggplot object (TRUE) or just the data.frame with values and colors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom_raster</code></td>
<td>
<p>Logical. If <code>FALSE</code> uses annotation_raster (good to keep aestetic mappings free). If <code>TRUE</code> uses <code>geom_raster</code> (and <code>aes(fill)</code>). See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceCat</code></td>
<td>
<p>Logical. If <code>TRUE</code> the raster values will be forced to be categorical (will be converted to factor if needed).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>img</code> contains factor values and <code>annotation=TRUE</code>, the raster values will automatically be converted
to numeric in order to proceed with the brightness calculation.
</p>
<p>The geom_raster argument switches from the default use of annotation_raster to geom_raster. The difference between the two is that geom_raster performs
a meaningful mapping from pixel values to fill colour, while annotation_raster is simply adding a picture to your plot. In practice this means that whenever you 
need a legend for your raster you should use <code>geom_raster = TRUE</code>. This also allows you to specify and modify the fill scale manually. 
The advantage of using annotation_raster (<code>geom_raster = TRUE</code>) is that you can still use the scale_fill* for another variable. For example you could add polygons and 
map a value to their fill colour. For more details on the theory behind aestetic mapping have a look at the <a href="https://CRAN.R-project.org/package=ggplot2/ggplot2.pdf">ggplot2</a> manuals.
</p>


<h3>Value</h3>


<table>
<tr>
<td style="text-align: left;">
 <code>ggObj = TRUE</code>:   </td>
<td style="text-align: left;"> ggplot2 plot </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>ggLayer = TRUE</code>: </td>
<td style="text-align: left;"> ggplot2 layer to be combined with an existing ggplot2 </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>ggObj = FALSE</code>:  </td>
<td style="text-align: left;"> data.frame in long format suitable for plotting with ggplot2, 
                         includes the pixel values and the calculated colors  </td>
</tr>
<tr>
<td style="text-align: left;">  
</td>
</tr>
</table>
<h3>See Also</h3>

<p>ggRGB, fortifySpatRaster
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ggplot2)
library(terra)

## Simple grey scale annotation
ggR(rlogo)

## With linear stretch contrast enhancement
ggR(rlogo, stretch = "lin", quantiles = c(0.1,0.9))

## ggplot with geom_raster instead of annotation_raster
## and default scale_fill*
ggR(rlogo, geom_raster = TRUE)

## with different scale
ggR(rlogo, geom_raster = TRUE) +
        scale_fill_gradientn(name = "mojo", colours = rainbow(10)) +
        ggtitle("**Funkadelic**")

## Plot multiple layers

ggR(lsat, 1:6, geom_raster=TRUE, stretch = "lin") +
    scale_fill_gradientn(colors=grey.colors(100), guide = "none") +
    theme(axis.text = element_text(size=5),
          axis.text.y = element_text(angle=90),
          axis.title=element_blank())

## Don't plot, just return a data.frame
df &lt;- ggR(rlogo, ggObj = FALSE)
head(df, n = 3)

## Layermode (ggLayer=TRUE)
data &lt;- data.frame(x = c(0, 0:100,100), y = c(0,sin(seq(0,2*pi,pi/50))*10+20, 0))
ggplot(data, aes(x, y)) +  ggR(rlogo, geom_raster= FALSE, ggLayer = TRUE) +
       geom_polygon(aes(x, y), fill = "blue", alpha = 0.4) +
       coord_equal(ylim=c(0,75))

## Categorical data 
## In this case you probably want to use geom_raster=TRUE 
## in order to perform aestetic mapping (i.e. a meaningful legend)
rc   &lt;- rlogo
rc[] &lt;- cut(rlogo[[1]][], seq(0,300, 50))
ggR(rc, geom_raster = TRUE)

## Legend cusomization etc. ...
ggR(rc, geom_raster = TRUE) + scale_fill_continuous(labels=paste("Class", 1:6))

## Creating a nicely looking DEM with hillshade background
terr &lt;- terrain(srtm, c("slope", "aspect"))
hill &lt;- shade(terr[["slope"]], terr[["aspect"]])
ggR(hill)

ggR(hill) + 
   ggR(srtm, geom_raster = TRUE, ggLayer = TRUE, alpha = 0.3) +
   scale_fill_gradientn(colours = terrain.colors(100), name = "elevation")
</code></pre>


</div>