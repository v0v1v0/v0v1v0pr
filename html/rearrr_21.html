<div class="container">

<table style="width: 100%;"><tr>
<td>extreme_pairing_rearranger_</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wrapper for running extreme pairing</h2>

<h3>Description</h3>

<p>Wrapper for running extreme pairing
</p>


<h3>Usage</h3>

<pre><code class="language-R">extreme_pairing_rearranger_(
  data,
  col = NULL,
  unequal_method = "middle",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_pairs = FALSE,
  num_pairings = 1,
  balance = "mean",
  factor_name = ".pair",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unequal_method</code></td>
<td>
<p>Method for dealing with an
unequal number of rows/elements in <code>`data`</code>.
</p>
<p>One of: <code>first</code>, <code>middle</code> or <code>last</code>
</p>


<h4>first</h4>

<p>The first group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 3, 3, 2)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 5, 3, 4)</code>
</p>



<h4>middle</h4>

<p>The middle group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(1, 3, </code><strong><code>2</code></strong><code>, 3, 1)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(1, 5, </code> <strong><code>3</code></strong><code>, 2, 4)</code>
</p>



<h4>last</h4>

<p>The last group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(1, 2, 2, 1, </code><strong><code>3</code></strong><code>)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(1, 4, 2, 3,</code> <strong><code>5</code></strong><code>)</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_by_aggregates</code></td>
<td>
<p>Whether to order the pairs from initial pairings (first <code>`num_pairings` - 1</code>)
by their aggregate values instead of their pair identifiers.
</p>
<p>N.B. Only used when <code>`num_pairings` &gt; 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle_members</code></td>
<td>
<p>Whether to shuffle the order of the group members within the groups. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle_pairs</code></td>
<td>
<p>Whether to shuffle the order of the pairs. Pair members remain together. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_pairings</code></td>
<td>
<p>Number of pairings to perform (recursively). At least <code>1</code>.
</p>
<p>Based on <code>`balance`</code>, the secondary pairings perform extreme pairing on either the
<em>sum</em>, <em>absolute difference</em>, <em>min</em>, or <em>max</em> of the pair elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance</code></td>
<td>
<p>What to balance pairs for in a given <em>secondary</em> pairing.
Either <code>"mean"</code>, <code>"spread"</code>, <code>"min"</code>, or <code>"max"</code>.
Can be a single string used for all secondary pairings
or one for each secondary pairing (<code>`num_pairings` - 1</code>).
</p>
<p>The first pairing always pairs the actual element values.
</p>


<h4>mean</h4>

<p>Pairs have similar means. The values in the pairs from the previous pairing
are aggregated with <code>`sum()`</code> and paired.
</p>



<h4>spread</h4>

<p>Pairs have similar spread (e.g. standard deviations).
The values in the pairs from the previous pairing
are aggregated with <code>`sum(abs(diff()))`</code> and paired.
</p>



<h4>min / max</h4>

<p>Pairs have similar minimum / maximum values. The values in the pairs from the previous pairing
are aggregated with <code>`min()`</code> / <code>`max()`</code> and paired.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor_name</code></td>
<td>
<p>Name of new column with the sorting factor.
If <code>`NULL`</code>, no column is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the sorting factor(s) added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`factor_name`</code> is <code>`NULL`</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>


</div>