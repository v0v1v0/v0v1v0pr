<div class="container">

<table style="width: 100%;"><tr>
<td>fastica</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast Fixed Point ICA
</h2>

<h3>Description</h3>

<p>The fast fixed point algorithm for independent component analysis and projection 
pursuit based on the direct translation to R of the FastICA program of the 
original authors at the Helsinki University of Technology.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fastica(X, approach = c("symmetric", "deflation"), n.comp = dim(X)[2], demean = TRUE, 
pca.cov = c("ML", "LW", "ROB", "EWMA"), gfun = c("pow3", "tanh", "gauss", "skew"), 
finetune = c("none", "pow3", "tanh", "gauss", "skew"), tanh.par = 1, gauss.par = 1, 
step.size = 1, stabilization = FALSE, epsilon = 1e-4, maxiter1 = 1000, maxiter2 = 5, 
A.init = NULL, pct.sample = 1, firstEig = NULL, lastEig = NULL, 
pcaE = NULL, pcaD = NULL, whiteSig = NULL, whiteMat = NULL, dewhiteMat = NULL, 
rseed = NULL, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p> The multidimensional signal matrix, where each column of matrix 
represents one observed signal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approach</code></td>
<td>
<p> The decorrelation approach to use, with “symmetric” 
estimating the components in parallel while “deflation” estimating 
one-by-one as in projection pursuit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.comp</code></td>
<td>
<p> Number of independent components to estimate, defaults to the 
dimension of the data (rows). Is overwritten by <code>firstEig</code> and <code>lastEig</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>demean</code></td>
<td>
<p> (Logical) Whether the data should be centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pca.cov</code></td>
<td>
<p> The method to use for the calculation of the covariance matrix 
during the PCA whitening phase. “ML” is the standard maximum likelihood 
method, “LW” is the Ledoit and Wolf method, “ROB” is the robust method 
from the MASS package and “EWMA” an exponentially weighted moving average
estimator. Optional parameters passed via the (...) argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gfun</code></td>
<td>
<p> The nonlinearity algorithm to use in the fixed-point algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finetune</code></td>
<td>
<p> The nonlinearity algorithm for fine-tuning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tanh.par</code></td>
<td>
<p> Control parameter used when nonlinearity algorithm 
equals “tanh”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gauss.par</code></td>
<td>
<p> Control parameter used when nonlinearity algorithm equals 
“gauss”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.size</code></td>
<td>
<p> Step size. If this is anything other than 1, the program will 
use the stabilized version of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stabilization</code></td>
<td>
<p> Controls whether the program uses the stabilized version 
of the algorithm. If the stabilization is on, then the value of <code>step.size</code> 
can momentarily be halved if the program estimates that the algorithm is stuck 
between two points (this is called a stroke). Also if there is no convergence 
before half of the maximum number of iterations has been reached then the 
<code>step.size</code> will be halved for the rest of the rounds.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p> Stopping criterion. Default is 0.0001.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter1</code></td>
<td>
<p> Maximum number of iterations for <code>gfun</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter2</code></td>
<td>
<p> Maximum number of iterations for <code>finetune</code> algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.init</code></td>
<td>
<p> Initial guess for the mixing matrix A. Defaults to a random 
(standard normal) filled matrix (no.signals by no.factors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pct.sample</code></td>
<td>
<p> Percentage [0-1] of samples used in one iteration. Samples are 
chosen at random.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>firstEig</code></td>
<td>
<p> This and <code>lastEig</code> specify the range for eigenvalues 
that are retained, <code>firstEig</code> is the index of largest eigenvalue to be 
retained. Making use of this option overwrites <code>n.comp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lastEig</code></td>
<td>
<p> This is the index of the last (smallest) eigenvalue to be 
retained and overwrites <code>n.comp</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcaE</code></td>
<td>
<p> Optionally provided eigenvector (must also supply <code>pcaD</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pcaD</code></td>
<td>
<p> Optionally provided eigenvalues (must also supply <code>pcaE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whiteSig</code></td>
<td>
<p>Optionally provided Whitened signal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whiteMat</code></td>
<td>
<p> Optionally provided Whitening matrix (no.factors by no.signals).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dewhiteMat</code></td>
<td>
<p>Optionally provided dewhitening matrix (no.signals by no.factors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rseed</code></td>
<td>
<p> Optionally provided seed to initialize the mixing matrix A 
(when <code>A.init</code> not provided).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>To report progress in the console, set this to ‘TRUE’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments passed to the pca.cov methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The fastica program is a direct translation into R of the FastICA Matlab program 
of Gaevert, Hurri, Saerelae, and Hyvaerinen with some extra features. All 
computations are currently implemented in R so for very large dimensional sets
alternative implementations may be faster. Porting part of the code to C++ may be
implemented in a future version.
</p>


<h3>Value</h3>

<p>A list containing the following values:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Estimated Mixing Matrix (no.signals by no.factors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Estimated UnMixing Matrix (no.factors by no.signals). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>Estimated rotation Matrix (no.factors by no.factors). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>The column vectors of estimated independent components (no.obs by no.factors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>Estimated Covariance Matrix (no.signals by no.signals).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whiteningMatrix</code></td>
<td>
<p>The Whitening matrix (no.factors by no.signals).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dewhiteningMatrix</code></td>
<td>
<p>The de-Whitening matrix  (no.signals by no.factors).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rseed</code></td>
<td>
<p>The random seed used (if any) for initializing the mixing matrix A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elapsed</code></td>
<td>
<p>The elapsed time.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Since version 1.0-3 the multidimensional signal matrix is now the usual row by 
column matrix, where the rows represent observations and columns the signals. 
Before this version, the reverse was true in keeping with the original version 
of the program.<br>
Dimensionality reduction can be achieved in the PCA stage by use of either 
<code>n.comp</code> in which case the n.comp largest eigenvalues are chosen, else by
selection of <code>firstEig</code> and <code>lastEig</code> which overwrites the choice of
<code>n.comp</code>.
</p>


<h3>Author(s)</h3>

<p>Hugo Gaevert, Jarmo Hurri, Jaakko Saerelae, and Aapo Hyvaerinen for the original 
FastICA package for matlab.<br> 
Alexios Galanos for this R-port.
</p>


<h3>References</h3>

<p>Hyvaerinen, A. and Oja,.E , 1997, A fast fixed-point algorithm for independent 
component analysis, <em>Neural Computation</em>, <b>9(7)</b>, 1483-1492. Reprinted in 
<em>Unsupervised Learning</em>, G. Hinton and T. J. Sejnowski, 1999, MIT Press.<br></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# create a set of independent signals S, glued together by a mixing matrix A
# (note the notation and matrix multiplication direction as we are dealing with
# row rather than column vectors)
set.seed(100)
S &lt;- matrix(runif(10000), 5000, 2)
A &lt;- matrix(c(1, 1, -1, 2), 2, 2, byrow = TRUE)
# the mixed signal X
X = S %*% t(A)
# The function centers and whitens (by the eigenvalue decomposition of the 
# unconditional covariance matrix)  the data before applying the theICA algorithm.
IC &lt;- fastica(X, n.comp = 2, approach = "symmetric", gfun = "tanh", trace  = TRUE, 
A.init = diag(2))

# demeaned data:
X_bar = scale(X, scale = FALSE)

# whitened data:
X_white = X_bar %*% t(IC$whiteningMatrix)

# check whitening:
# check correlations are zero
cor(X_white)
# check diagonals are 1 in covariance
cov(X_white)

# check that the estimated signals(S) multiplied by the
# estimated mxing matrix (A) are the same as the original dataset (X)
round(head(IC$S %*% t(IC$A)), 12) == round(head(X), 12)

# do some plots:
par(mfrow = c(1, 3))
plot(IC$S %*% t(IC$A), main = "Pre-processed data")
plot(X_white, main = "Whitened and Centered components")
plot(IC$S, main = "ICA components")

## End(Not run)</code></pre>


</div>