<div class="container">

<table style="width: 100%;"><tr>
<td>infer_notation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Infer the notation(s) for a row or column label</h2>

<h3>Description</h3>

<p>It is convenient to know which notation is applicable to row or column labels.
This function infers which <code>notations</code> are appropriate for <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">infer_notation(
  x,
  inf_notation = TRUE,
  notations = RCLabels::notations_list,
  allow_multiple = FALSE,
  retain_names = FALSE,
  choose_most_specific = TRUE,
  must_succeed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A row or column label (or vector of labels).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notations</code></td>
<td>
<p>A list of notations from which matches will be inferred.
This function might not work as expected if
<code>notation</code> is not a list.
If <code>notation</code> is not a list,
<code>notations</code> is returned in full.
Default is <code>RCLabels::notations_list</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_multiple</code></td>
<td>
<p>A boolean that tells whether multiple notation matches
are allowed.
If <code>FALSE</code> (the default), multiple matches give an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retain_names</code></td>
<td>
<p>A boolean that tells whether to retain names from <code>notations</code> on the
outgoing matches.
Default is <code>FALSE</code>.
If <code>TRUE</code>, the return value is <em>always</em> a named list.
If only one of <code>notations</code> is returned
(for example, because <code>choose_most_specific = TRUE</code>),
names are never supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choose_most_specific</code></td>
<td>
<p>A boolean that indicates whether the most-specific notation
will be returned when more than one of <code>notations</code> matches <code>x</code>
and <code>allow_multiple = FALSE</code>.
When <code>FALSE</code>, the first matching notation in <code>notations</code>
is returned when <code>allow_multiple = FALSE</code>.
Default is <code>TRUE</code>.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>must_succeed</code></td>
<td>
<p>A boolean that if <code>TRUE</code> (the default),
causes an error to be thrown if a matching notation is not found
for any label in <code>x</code>.
When <code>FALSE</code>, an unsuccessful notation inference will return <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is vectorized.
Thus, <code>x</code> can be a vector, in which case the output is a list of notations.
</p>
<p><code>notations</code> is treated as a store from which matches for each label in <code>x</code>
can be determined.
<code>notations</code> should be a named list of notations.
When <code>retain_names = TRUE</code>, the names on <code>notations</code> will be retained,
and the return value is <em>always</em> a list.
</p>
<p>By default (<code>allow_multiple = FALSE</code>),
a single notation object is returned for each item in <code>x</code>
if only one notation in <code>notations</code>
is appropriate for <code>x</code>.
If <code>allow_multiple = FALSE</code> (the default) and more than one <code>notation</code> is applicable to <code>x</code>,
an error is thrown.
Multiple matches can be returned when <code>allow_multiple = TRUE</code>.
</p>
<p>If multiple notations are matched, the return value is a list.
</p>
<p>When <code>choose_most_specific = TRUE</code> (the default),
the most specific notation in <code>notations</code> is returned.
"Most specific" is defined as the matching notation
whose sum of characters in the <code>pref_start</code>, <code>pref_end</code>,
<code>suff_start</code> and <code>suff_end</code> elements
is greatest.
If <code>choose_most_specific = TRUE</code> and
two matching notations in <code>notations</code> have the same number of characters,
only the first match is returned.
When <code>choose_most_specific = TRUE</code>,
the value of <code>allow_multiple</code> no longer matters.
<code>allow_multiple = FALSE</code> is implied and
at most one of the <code>notations</code> will be returned.
</p>
<p>When <code>inf_notation = FALSE</code> (default is <code>TRUE</code>),
<code>notations</code> are returned unmodified,
essentially disabling this function.
Although calling with <code>inf_notation = FALSE</code> seems daft,
this behavior enables cleaner code elsewhere.
</p>


<h3>Value</h3>

<p>A single notation object (if <code>x</code> is a single row or column label)
or a list of notation objects (if <code>x</code> is a vector or a list).
If no <code>notations</code> match <code>x</code>, <code>NULL</code> is returned,
either alone or in a list.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Does not match any notations in RCLabels::notations_list
# and throws an error, because the default value for `must_succeed`
# is `TRUE`.
## Not run: 
infer_notation("abc")

## End(Not run)
# This returns `NULL`, because `must_succeed = FALSE`.
infer_notation("abc", must_succeed = FALSE)
# This succeeds, because the label is in the form of a
# notation in `RCLabels::notation_list`,
# the default value of the `notation` argument.
infer_notation("a -&gt; b")
# Names of the notations can be retained, in which case
# the return value is always a list.
infer_notation("a -&gt; b", retain_names = TRUE)
# This function is vectorized.
# The list of labels matches
# all known notations in `RCLabels::notations_list`.
infer_notation(c("a -&gt; b", "a (b)", "a [b]", "a [from b]", "a [of b]",
                 "a [to b]", "a [in b]", "a [-&gt; b]", "a.b"),
                 retain_names = TRUE)
# By default, the most specific notation is returned.
# But when two or more matches are present,
# multiple notations can be returned, too.
infer_notation("a [from b]",
               allow_multiple = TRUE, retain_names = TRUE,
               choose_most_specific = FALSE)
infer_notation(c("a [from b]", "c [to d]"),
               allow_multiple = TRUE, retain_names = TRUE,
               choose_most_specific = FALSE)
# As shown above, "a \[from b\]" matches 2 notations:
# `RCLabels::bracket_notation` and `RCLabels::from_notation`.
# The default value for the notation argument is
# RCLabels::notations_list,
# which includes `RCLabels::bracket_notation`
# and `RCLabels::from_notation` in that order.
# Thus, there is some flexibility to how this function works
# if the value of the `notation` argument is a list of notations
# ordered from least specific to most specific,
# as `RCLabels::notations_list` is ordered.
# To review, the next call returns both `RCLabels::bracket_notation` and
# `RCLabels::from_notation`, because `allow_multiple = TRUE` and
# `choose_most_specific = FALSE`, neither of which are default.
infer_notation("a [from b]",
               allow_multiple = TRUE,
               choose_most_specific = FALSE,
               retain_names = TRUE)
# The next call returns `RCLabels::from_notation`, because
# the most specific notation is requested, and
# `RCLabels::from_notation` has more characters in its specification than
# `RCLabels::bracket_notation`.
infer_notation("a [from b]",
               choose_most_specific = TRUE,
               retain_names = TRUE)
# The next call returns the `RCLabels::bracket_notation`, because
# `choose_most_specific = FALSE`, and the first matching
# notation in `RCLabels::notations_list` is `RCLabels::bracket_notation`.
infer_notation("a [from b]",
               choose_most_specific = FALSE,
               retain_names = TRUE)
</code></pre>


</div>