<div class="container">

<table style="width: 100%;"><tr>
<td>SolrQuery-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SolrQuery</h2>

<h3>Description</h3>

<p>The <code>SolrQuery</code> object represents a query to be sent to a
<code>SolrCore</code>. This is a low-level interface to query
construction but will not be useful to most users. The typical reason
to directly manipulate a query would be to batch more operations than is
possible with the high-level <code>SolrFrame</code>, e.g., combining
multiple aggregations.
</p>


<h3>Details</h3>

<p>A <code>SolrQuery</code> API borrows many of the same verbs from the base R
API, including <code>subset</code>, <code>transform</code>,
<code>sort</code>, <code>xtabs</code>, <code>head</code>,
<code>tail</code>, <code>rev</code>, etc.
</p>
<p>The typical workflow is to construct a query, perform various
manipulations, and finally retrieve a result by passing the query to a
<code>SolrCore</code>, typically via the <code>docs</code> or <code>facets</code>
functions.
</p>


<h3>Accessors</h3>


<ul><li>
<p><code>params(x), params(x) &lt;- value</code>: Gets/sets the parameters of
the query, which roughly correspond to the parameters of a Solr
“select” request. The only reason to manipulate the
underlying query parameters is to either initiate a headache or to
do something really tricky with Solr, which implies the former.

</p>
</li></ul>
<h3>Querying</h3>


<ul>
<li>
<p><code>subset(x, subset, select, fields, select.from =
        character())</code>: Behaves like the base <code>subset</code>, with
some extensions. The <code>fields</code> argument is exclusive with
<code>select</code>, and should be a character vector of field names,
potentially with wildcards. The <code>select.from</code> argument
gives the names that are filtered by <code>select</code>, since
<code>SolrQuery</code> is not associated with any <code>SolrCore</code>, and
thus does not know the field set (in the future, we might use
laziness to avoid this problem).

</p>
</li>
<li>
<p><code>searchDocs(x, q)</code>: Performs a conventional document
search using the query string <code>q</code>. The main difference to
filtering (<code>subset</code>) is that (by default) Solr will order the
result by score, i.e., how well each document matches the query.

</p>
</li>
</ul>
<h3>Constructor</h3>


<ul><li>
<p><code>SolrQuery(expr)</code>:
Constructs a new <code>SolrQuery</code> instance. If <code>expr</code> is
non-missing, it is passed to <code>subset</code> and thus serves as an
initial restriction.

</p>
</li></ul>
<h3>Faceting</h3>

<p>The Solr facet component counts documents and calculates statistics on
a group-wise basis.
</p>

<ul><li>
<p><code>facet(x, by, ..., useNA=FALSE, sort=NULL,
        decreasing=FALSE, limit=NA_integer_)</code>: Returns a query that will
compute the number of documents in each group, where the
grouping is given as <code>by</code>, typically a formula, or
<code>NULL</code> for global aggregation. Arguments in ... are
quoted and should be expressions that summarize fields, or
mathematical combinations of fields. The names of the statistics
are taken from the argument names; if a name is omitted, a best
guess is made from the expression. If <code>useNA</code> is
<code>TRUE</code>, statistics and counts are computed for the bin
where documents have a missing value for one the grouping
variables. If <code>sort</code> is non-NULL, it should name a
statistic by which the results should be sorted. This is mostly
useful in conjunction if a <code>limit</code> is specified, so that
only the top-N statistics are returned.
</p>
<p>The formula should consist of Solr field names, or calls that
evaluate to logical and refer to one or more Solr fields. If the
latter, the results are grouped by <code>TRUE</code>, <code>FALSE</code> and
(optionally) <code>NA</code> for that term. As a special case, a term
can be a call to <code>cut</code> on any numeric or date field, which
will group by bin.

</p>
</li></ul>
<h3>Grouping</h3>

<p>The Solr grouping component causes results to be returned nested into
groups. The main use case would be to restrict to the first or last N
documents in each group. This functionality is <em>not</em> related to
aggregation; see <code>facet</code>.
</p>

<ul><li>
<p><code>group(x, by, limit = .Machine$integer.max, offset =
        0L, env = emptyenv())</code>: Returns the grouping of <code>x</code>
according to <code>by</code>, which might be a formula, or an
expression that evaluates (within <code>env</code>) to a factor. The
current sort specification applies within the groups, and any
subsequent sorting applies to the groups themselves, by using
the maximum value within the each group. Only the top
<code>limit</code> documents, starting after the first <code>offset</code>,
are returned from each group. Restricting that limit is probably
the main reason to use this functionality.

</p>
</li></ul>
<h3>Coercion</h3>

<p>These two functions are very low-level; users should almost never need
to call these.
</p>

<ul>
<li>
<p><code>translate(x, target, core)</code>: Translates the query <code>x</code>
into the language of Solr, where <code>core</code> specifies the
destination <code>SolrCore</code>. The <code>target</code> argument should be
missing.

</p>
</li>
<li>
<p><code>as.character(x)</code>:
Converts the query into a string to be sent to Solr. Remember to
translate first, if necessary.

</p>
</li>
</ul>
<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code>SolrFrame</code>, the recommended high-level interface
for interacting with Solr
</p>
<p><code>SolrCore</code>, which gives an example of constructing
and evaluating a query
</p>


</div>