<div class="container">

<table style="width: 100%;"><tr>
<td>search.conv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Searching for morphological convergence among species and clades</h2>

<h3>Description</h3>

<p>The function scans a phylogenetic tree looking for morphological
convergence between entire clades or species evolving under specific
states.
</p>


<h3>Usage</h3>

<pre><code class="language-R">search.conv(RR=NULL,tree=NULL,y,nodes=NULL,state=NULL,aceV=NULL,
  min.dim=NULL,max.dim=NULL,min.dist=NULL,declust=FALSE,nsim=1000,rsim=1000,
  clus=0.5,filename=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>RR</code></td>
<td>
<p>an object produced by <code>RRphylo</code>. This is not indicated
if convergence among states is tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric or
fully dichotomous. This is not indicated if convergence among clades is
tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a multivariate phenotype. The object <code>y</code> should be either a
matrix or dataframe with species names as rownames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>node pair to be tested. If unspecified, the function
automatically searches for convergence among clades. Notice the node number
must refer to the dichotomic version of the original tree, as produced by
<code>RRphylo</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>the named vector of tip states. The function tests for
convergence within a single state or among different states (this latter
case is especially meant to test for iterative evolution as for example the
appearance of repeated morphotypes into different clades). In both cases,
the state for non-focal species (i.e. not belonging to any convergent
group) must be indicated as "nostate".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aceV</code></td>
<td>
<p>phenotypic values at internal nodes. The object <code>aceV</code>
should be either a matrix or dataframe with nodes (referred to the
dichotomic version of the original tree, as produced by <code>RRphylo</code>) as
rownames. If <code>aceV</code> are not indicated, ancestral phenotypes are
estimated via <code>RRphylo</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.dim</code></td>
<td>
<p>the minimum size of the clades to be compared. When
<code>nodes</code> is indicated, it is the minimum size of the smallest clades in
<code>nodes</code>, otherwise it is set at one tenth of the tree size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.dim</code></td>
<td>
<p>the maximum size of the clades to be compared. When
<code>nodes</code> is indicated, it is <code>min.dim</code>*2 if the largest clade in
<code>nodes</code> is smaller than this value, otherwise it corresponds to the
size of the largest clade. Without <code>nodes</code> it is set at one third of
the tree size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.dist</code></td>
<td>
<p>the minimum distance between the clades to be compared. When
<code>nodes</code> is indicated, it is the distance between the pair. Under the
automatic mode, the user can choose whether time distance or node distance
(i.e. the number of nodes intervening between the pair) should be used. If
time distance has to be considered, <code>min.dist</code> should be a character
argument containing the word "time" and then the actual time distance to be
used. The same is true for node distance, but the word "node" must precede
the node distance to be used. For example, if the user want to test only
clades more distant than 10 time units, the argument should be "time10". If
clades separated by more than 8 nodes has to be tested, the argument
<code>min.dist</code> should be "node8". If left unspecified, it automatically
searches for convergence between clades separated by a number of nodes
bigger than one tenth of the tree size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>declust</code></td>
<td>
<p>if species under a given state (or a pair of states) to be
tested for convergence are phylogenetically closer than expected by chance,
trait similarity might depend on proximity rather than true convergence. In
this case, by setting <code>declust = TRUE</code>, tips under the focal state (or
states) are removed randomly until clustering disappears. A minimum of 3
species per state is enforced to remain anyway.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>number of simulations to perform sampling within the theta random
distribution. It is set at 1000 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rsim</code></td>
<td>
<p>number of simulations to be performed to produce the random
distribution of theta values. It is set at 1000 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing. To
run the single-threaded version of <code>search.conv</code> set <code>clus</code> = 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>is deprecated. <code>search.conv</code> does not return plots
anymore, check the function <code>plotConv</code> instead.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If convergence between clades is tested, the function returns a list
including:
</p>
<ul>
<li>
<p><strong>$node pairs</strong>: a dataframe containing for each
pair of nodes: </p>
<ul>
<li>
<p> ang.bydist.tip: the mean theta angle between
clades divided by the time distance. </p>
</li>
<li>
<p> ang.conv: the mean theta angle
between clades plus the angle between aces, divided by the time distance.
</p>
</li>
<li>
<p> ang.ace: the angle between aces. </p>
</li>
<li>
<p> ang.tip: the mean theta angle
between clades. </p>
</li>
<li>
<p> nod.dist: the distance intervening between clades in
terms of number of nodes. </p>
</li>
<li>
<p> time.dist: the time distance intervening
between the clades. </p>
</li>
<li>
<p> p.ang.bydist: the p-value computed for
ang.bydist.tip. </p>
</li>
<li>
<p> p.ang.conv: the p-value computed for ang.conv. </p>
</li>
<li>
<p>clade.size: the size of clades. </p>
</li>
</ul>
</li>
<li>
<p><strong>$node pairs comparison</strong>:
pairwise comparison between significantly convergent pairs (all pairs if no
instance of significance was found) performed on the distance from group
centroids (the mean phenotype per clade). </p>
</li>
<li>
<p><strong>$average distance
from group centroids</strong>: smaller average distances mean less variable
phenotypes within the pair. </p>
</li>
</ul>
<p>If convergence between (or within a single state) states is tested,
the function returns a list including: </p>
<ul><li>
<p><strong>state.res</strong> a
dataframe including for each pair of states (or single state): </p>

<ul>
<li>
<p> ang.state: the mean theta angle between species belonging to
different states (or within a single state). </p>
</li>
<li>
<p> ang.state.time: the mean
of theta angle between species belonging to different states (or within a
single state) divided by time distance. </p>
</li>
<li>
<p> p.ang.state: the p-value
computed for ang.state. </p>
</li>
<li>
<p> p.ang.state.time: the p-value computed for
ang.state.time.</p>
</li>
</ul>
</li></ul>
<ul><li>
<p><strong>plotData</strong> a dataframe including
data to plot the results via <code>plotConv</code></p>
</li></ul>
<p>.
</p>


<h3>Author(s)</h3>

<p>Silvia Castiglione, Carmela Serio, Pasquale Raia, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto, Paolo Piras, Davide Tamagnini
</p>


<h3>References</h3>

<p>Castiglione, S., Serio, C., Tamagnini, D., Melchionna, M.,
Mondanaro, A., Di Febbraro, M., Profico, A., Piras, P.,Barattolo, F., &amp;
Raia, P. (2019). A new, fast method to search for morphological convergence
with shape data. <em>PLoS ONE</em>, 14, e0226949.
https://doi.org/10.1371/journal.pone.0226949
</p>


<h3>See Also</h3>

<p><a href="../doc/search.conv.html"><code>search.conv</code> vignette</a>
</p>
<p><a href="../doc/Plotting-tools.html"><code>plotConv</code> vignette</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data("DataFelids")
DataFelids$PCscoresfel-&gt;PCscoresfel
DataFelids$treefel-&gt;treefel
DataFelids$statefel-&gt;statefel
cc&lt;- 2/parallel::detectCores()

RRphylo(treefel,PCscoresfel,clus=cc)-&gt;RRfel


## Case 1. searching convergence between clades
# by setting min.dist as node distance
search.conv(RR=RRfel, y=PCscoresfel, min.dim=5, min.dist="node9",clus=cc)
# by setting min.dist as time distance
search.conv(RR=RRfel, y=PCscoresfel, min.dim=5, min.dist="time38",clus=cc)

## Case 2. searching convergence within a single state
search.conv(tree=treefel, y=PCscoresfel, state=statefel,declust=TRUE,clus=cc)
  
## End(Not run)
</code></pre>


</div>