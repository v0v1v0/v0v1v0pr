<div class="container">

<table style="width: 100%;"><tr>
<td>svds</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find the Largest k Singular Values/Vectors of a Matrix</h2>

<h3>Description</h3>

<p>This function is a simple wrapper of the <code>svds()</code>
function in the <span class="pkg">RSpectra</span> package. Also see the documentation there.
</p>
<p>Given an <code class="reqn">m</code> by <code class="reqn">n</code> matrix <code class="reqn">A</code>,
function <code>svds()</code> can find its largest <code class="reqn">k</code>
singular values and the corresponding singular vectors.
It is also called the Truncated Singular Value Decomposition
since it only contains a subset of the whole singular triplets.
</p>
<p>Currently <code>svds()</code> supports matrices of the following classes:
</p>

<table>
<tr>
<td style="text-align: left;">
  <code>matrix</code>     </td>
<td style="text-align: left;"> The most commonly used matrix type,
                         defined in <strong>base</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dgeMatrix</code>  </td>
<td style="text-align: left;"> General matrix, equivalent to <code>matrix</code>,
                         defined in <strong>Matrix</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dgCMatrix</code>  </td>
<td style="text-align: left;"> Column oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dgRMatrix</code>  </td>
<td style="text-align: left;"> Row oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dsyMatrix</code>  </td>
<td style="text-align: left;"> Symmetrix matrix, defined in <strong>Matrix</strong>
                         package.
</td>
</tr>
</table>
<p>Note that when <code class="reqn">A</code> is symmetric,
SVD reduces to eigen decomposition, so you may consider using
<code>eigs()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">svds(A, k, nu = k, nv = k, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>The matrix whose truncated SVD is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of singular values requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Number of left singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nv</code></td>
<td>
<p>Number of right singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt>
<dd>
<p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. <code>ncv</code> must be satisfy
<code class="reqn">k &lt; ncv \le p</code> where
<code>p = min(m, n)</code>.
Default is <code>min(p, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt>
<dd>
<p>Maximum number of iterations. Default is 1000.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>A vector of the computed singular values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>An <code>m</code> by <code>nu</code> matrix whose columns contain
the left singular vectors. If <code>nu == 0</code>, <code>NULL</code>
will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>An <code>n</code> by <code>nv</code> matrix whose columns contain
the right singular vectors. If <code>nv == 0</code>, <code>NULL</code>
will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nconv</code></td>
<td>
<p>Number of converged singular values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>Number of iterations used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nops</code></td>
<td>
<p>Number of matrix-vector multiplications used.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yixuan Qiu &lt;<a href="http://statr.me">http://statr.me</a>&gt;
</p>


<h3>See Also</h3>

<p><code>eigen()</code>, <code>svd()</code>,
<code>eigs()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">m = 100
n = 20
k = 5
set.seed(111)
A = matrix(rnorm(m * n), m)

svds(A, k)
svds(t(A), k, nu = 0, nv = 3)

## Sparse matrices
library(Matrix)
A[sample(m * n, m * n / 2)] = 0
Asp1 = as(A, "dgCMatrix")
Asp2 = as(A, "dgRMatrix")

svds(Asp1, k)
svds(Asp2, k, nu = 0, nv = 0)

</code></pre>


</div>