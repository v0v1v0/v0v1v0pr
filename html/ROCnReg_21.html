<div class="container">

<table style="width: 100%;"><tr>
<td>pooledROC.dpm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Nonparametric Bayesian inference of the pooled ROC curve 
</h2>

<h3>Description</h3>

<p>This function estimates the pooled ROC curve using a Dirichlet process mixture of normals model as proposed by Erkanli et al. (2006).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pooledROC.dpm(marker, group, tag.h, data, 
  standardise = TRUE, p = seq(0, 1, l = 101), ci.level = 0.95, 
  compute.lpml = FALSE, compute.WAIC = FALSE, compute.DIC = FALSE, 
  pauc = pauccontrol(), density = densitycontrol(), 
  prior.h = priorcontrol.dpm(), prior.d = priorcontrol.dpm(),
  mcmc = mcmccontrol(),
  parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardise</code></td>
<td>
<p>A logical value. If TRUE the test outcomes are standardised (so that the resulting test outcomes have mean zero and standard deviation of one). The default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the pooled ROC curve. This set is also used to compute the area under the ROC curve (AUC) using Simpson's rule. Thus, the length of the set should be an odd number, and it should be rich enough for an accurate estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the level for the credible interval. The default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.lpml</code></td>
<td>
<p>A logical value. If TRUE, the log pseudo marginal likelihood (LPML, Geisser and Eddy, 1979) and the conditional predictive ordinates (CPO) are computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.WAIC</code></td>
<td>
<p>A logical value. If TRUE, the widely applicable information criterion (WAIC, Gelman et al., 2014; Watanabe, 2010) is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.DIC</code></td>
<td>
<p>A logical value. If TRUE, the deviance information criterion is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>pauccontrol</code>. This argument is used to indicate whether the partial area under the pooled ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>densitycontrol</code>. This argument is used to indicate whether the densities of the marker in the healthy and diseased population should be computed, and in case it is to be computed, at which grid of test outcomes in each of the populations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.h</code></td>
<td>
<p>Hyparameter specification for the healthy population. A list of control values to replace the default values returned by the function <code>priorcontrol.dpm</code>. See <code>priorcontrol.dpm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.d</code></td>
<td>
<p>Hyparameter specification for the diseased population. A list of control values to replace the default values returned by the function <code>priorcontrol.dpm</code>. See <code>priorcontrol.dpm</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>mcmccontrol</code>. See <code>mcmccontrol</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either "no" (default), "multicore" (not available on Windows) or "snow".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = "snow". If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates the pooled ROC curve (ROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The method implemented in this function estimates <code class="reqn">F_{D}(\cdot)</code> and <code class="reqn">F_{\bar{D}}(\cdot)</code> by means of a Dirichlet process mixture of normals model. More precisely, and letting <code class="reqn">\{y_{\bar{D}i}\}_{i=1}^{n_{\bar{D}}}</code>  and <code class="reqn">\{y_{Dj}\}_{j=1}^{n_{D}}</code> be two independent random samples from the nondiseased and diseased populations, respectively, the model postulated for the distribution function is as follows
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i}) = \sum_{l=1}^{L_{\bar{D}}}\omega_{l\bar{D}}\Phi(y_{\bar{D}i}\mid\mu_{l\bar{D}},\sigma_{l\bar{D}}^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{D}(y_{Dj}) = \sum_{l=1}^{L_{D}}\omega_{lD}\Phi(y_{Dj}\mid\mu_{lD},\sigma_{lD}^2),</code>
</p>

<p>where <code class="reqn">L_{d}</code> is pre-specified is a pre-specified upper bound on the number of mixture components (<code class="reqn">d \in \{D, \bar{D}\}</code>). The <code class="reqn">\omega_{ld}</code>'s result from a truncated version of the stick-breaking construction (<code class="reqn">\omega_{1d} = v_{1d}</code>; <code class="reqn">\omega_{ld} = v_{ld}\prod_{r&lt;l}(1-v_{dr})</code>, <code class="reqn">l=2,\ldots,L_{d}</code>; <code class="reqn">v_{d1},\ldots,v_{L_{d}-1}\sim</code> Beta <code class="reqn">(1,\alpha_{d})</code>; <code class="reqn">v_{Ld} = 1</code>, <code class="reqn">\alpha_d \sim \Gamma(a_{\alpha_d},b_{\alpha_d})</code>), <code class="reqn">\beta_{ld}\sim N(m_{0d},S_{0d})</code>, and <code class="reqn">\sigma_{ld}^{-2}\sim\Gamma(a_{d},b_{d})</code>.
</p>
<p>The area under the curve is 
</p>
<p style="text-align: center;"><code class="reqn">AUC=\int_{0}^{1}ROC(p)dp.</code>
</p>
 
<p>When the upper bound on the number of mixture components is 1, i.e., <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the AUC (binormal model), which is used in the package. In contrast, when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code>, the AUC is computed using results presented in Erkanli et al. (2006). With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is </p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1)=\int_0^{u_1} ROC(p)dp.</code>
</p>
 
<p>As for the AUC, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{FPF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as </p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp,</code>
</p>
<p> where <code class="reqn">ROC_{TNF}(p)</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p) = F_{\bar{D}}\{F_{D}^{-1}(1-p)\}.</code> Again, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{TNF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>
<p>It is worth referring that with respect to the computation of the DIC, when <code class="reqn">L=1</code>, it is computed as in Spiegelhalter et al. (2002), and when <code class="reqn">L&gt;1</code>, DIC3 as described in Celeux et al. (2006) is computed. Also, for the computation of the conditional predictive ordinates (CPO) we follow the stable version proposed by Gelman et al. (2014).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marker</code></td>
<td>
<p>A list with the diagnostic test outcomes in the healthy (h) and diseased (d) groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether missing values occur.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>A list returning the hyperparameter values in the healthy and diseased populations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding <code>ci.level</code>*100% pointwise credible band.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding <code>ci.level</code>*100% credible interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the pooled ROC curve (posterior mean) and <code>ci.level</code>*100% pointwise credible band. Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dens</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: <code>grid</code> (grid of test outcomes where the densities are evaluated) and <code>dens</code> (MCMC realisations of the corresponding densities).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpml</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: the log pseudo marginal likelihood (LPML) and the conditional predictive ordinates (CPO).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WAIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: widely applicable information criterion (WAIC) and associated complexity penalty (pW).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: deviance information criterion (DIC) and associated complexity penalty (pD).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with the following information: (1)<code>probs</code>: matrix of dimension nsave x L with the sampled components' weights; (2) <code>mu</code>: matrix of dimension nsave x L with the sampled means; and (3) <code>sd</code>: matrix of dimension nsave x L with the sampled standard deviations. Here, nsave is the number of Gibbs sampler iterates saved, and L is the upper bound on the number of mixture components.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Erkanli, A., Sung M., Jane Costello, E., and Angold, A. (2006). Bayesian semi-parametric ROC analysis. Statistics in Medicine, <b>25</b>, 3905–3928.
</p>
<p>Geisser, S. and Eddy, W.F. (1979) A Predictive Approach to Model Selection, Journal of the American Statistical Association, <b>74</b>, 153–160.
</p>
<p>Gelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A., and Rubin, D.B. (2014). Bayesian Data Analysis, 3rd ed. CRC Press: Boca Raton, FL.
</p>
<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. Statistics and Computing, <b>24</b>, 997–1010.
</p>
<p>Hillis, S. L. and Metz, C.E. (2012). An Analytic Expression for the Binormal Partial Area under the ROC Curve. Academic Radiology, <b>19</b>, 1491–1498.
</p>
<p>Watanabe, S. (2010). Asymptotic Equivalence of Bayes Cross Validation and Widely Applicable Information Criterion in Singular Learning Theory. Journal of Machine Learning Research, <b>11</b>, 3571–3594.
</p>


<h3>See Also</h3>

<p><code>AROC.bnp</code>, <code>AROC.sp</code>, <code>AROC.kernel</code>, <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code>, <code>pooledROC.dpm</code>, <code>cROC.bnp</code>, <code>cROC.sp</code> or <code>AROC.kernel</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_dpm &lt;- pooledROC.dpm(marker = "l_marker1", group = "status",
            tag.h = 0, data = newpsa, standardise = TRUE, 
            p = seq(0,1,l=101), compute.WAIC = TRUE, compute.lpml = TRUE, 
            compute.DIC = TRUE, 
            prior.h = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            prior.d = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            mcmc = mcmccontrol(nsave = 400, nburn = 100, nskip = 1))

summary(m0_dpm)

plot(m0_dpm)

  
</code></pre>


</div>