<div class="container">

<table style="width: 100%;"><tr>
<td>patternRepeat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Complex repetitions</h2>

<h3>Description</h3>

<p>Recreate patterns for collapsed arrays
</p>


<h3>Usage</h3>

<pre><code class="language-R">patternRepeat(x, which, n, careful = TRUE, keep.order = FALSE)

patternRepeat0(which, n, careful = TRUE, keep.order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector to be repeated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Which indices of the implicit array are given in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Dimensions of implicit array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>careful</code></td>
<td>
<p>logical indicating whether to check vailidty of arguments,
but therefore slow things down.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.order</code></td>
<td>
<p>logical indicating whether to respect the ordering of the
entries in the vector <code>which</code>, in which case data are permuted before
replication.  In other words, does <code>x</code> change fastest in
<code>which[1]</code>, or in the minimal entry for <code>which</code>?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions allow for the construction of complex repeating patterns
corresponding to those obtained by unwrapping arrays.  Consider an array
with dimensions <code>n</code>; then for each value of the dimensions in
<code>which</code>, this function returns a vector which places the corresponding
entry of <code>x</code> into every place which would match this pattern when the
full array is unwrapped.
</p>
<p>For example, if a full 4-way array has dimensions 2*2*2*2 and we consider
the margin of variables 2 and 4, then the function returns the pattern
c(1,1,2,2,1,1,2,2,3,3,4,4,3,3,4,4).  The entries 1,2,3,4 correspond to the
patterns (0,0), (1,0), (0,1) and (1,1) for the 2nd and 4th indices.
</p>
<p>In <code>patternRepeat()</code> the argument <code>x</code> is repeated according to the
pattern, while <code>patternRepeat0()</code> just returns the indexing pattern.
So <code>patternRepeat(x,which,n)</code> is effectively equivalent to
<code>x[patternRepeat0(which,n)]</code>.
</p>
<p>The length of <code>x</code> must be equal to <code>prod(n[which])</code>.
</p>


<h3>Value</h3>

<p>Both return a vector of length <code>prod(n)</code>;
<code>patternRepeat()</code> one containing suitably repeated and ordered elements
of <code>x</code>, for <code>patternRepeat0()</code> it is always the integers from 1 up
to <code>prod(n[which])</code>.
</p>


<h3>Functions</h3>


<ul><li> <p><code>patternRepeat0</code>: Stripped down version that just gives indices
</p>
</li></ul>
<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>See Also</h3>

<p><code>rep</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
patternRepeat(1:4, c(1,2), c(2,2,2))
c(array(1:4, c(2,2,2)))

patternRepeat0(c(1,3), c(2,2,2))
patternRepeat0(c(2,3), c(2,2,2))

patternRepeat0(c(3,1), c(2,2,2))
patternRepeat0(c(3,1), c(2,2,2), keep.order=TRUE)

patternRepeat(letters[1:4], c(1,3), c(2,2,2))

</code></pre>


</div>