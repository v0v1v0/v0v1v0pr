<div class="container">

<table style="width: 100%;"><tr>
<td>bicop_distributions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bivariate copula distributions</h2>

<h3>Description</h3>

<p>Density, distribution function, random generation and h-functions (with their
inverses) for the bivariate copula distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dbicop(u, family, rotation, parameters, var_types = c("c", "c"))

pbicop(u, family, rotation, parameters, var_types = c("c", "c"))

rbicop(n, family, rotation, parameters, qrng = FALSE)

hbicop(
  u,
  cond_var,
  family,
  rotation,
  parameters,
  inverse = FALSE,
  var_types = c("c", "c")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>
<p>evaluation points, a matrix with at least two columns, see
<em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>the copula family, a string containing the family name (see
<code>bicop</code> for all possible families).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotation</code></td>
<td>
<p>the rotation of the copula, one of <code>0</code>, <code>90</code>, <code>180</code>, <code>270</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>a vector or matrix of copula parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_types</code></td>
<td>
<p>variable types, a length 2 vector; e.g., <code>c("c", "c")</code> for
both continuous (default), or <code>c("c", "d")</code> for first variable continuous
and second discrete.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations. If 'length(n) &gt; 1â€œ, the length is taken to
be the number required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qrng</code></td>
<td>
<p>if <code>TRUE</code>, generates quasi-random numbers using the bivariate
Generalized Halton sequence (default <code>qrng = FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond_var</code></td>
<td>
<p>either <code>1</code> or <code>2</code>; <code>cond_var = 1</code> conditions on the first
variable, <code>cond_var = 2</code> on the second.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverse</code></td>
<td>
<p>whether to compute the h-function or its inverse.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See bicop for the various implemented copula families.
</p>
<p>The copula density is defined as joint density divided by marginal
densities, irrespective of variable types.
</p>
<p>H-functions (<code>hbicop()</code>) are conditional distributions derived
from a copula. If <code class="reqn">C(u, v) = P(U \le u, V \le v)</code> is a copula, then
</p>
<p style="text-align: center;"><code class="reqn">h_1(u, v) = P(V \le v | U = u) = \partial C(u, v) / \partial u,</code>
</p>

<p style="text-align: center;"><code class="reqn">h_2(u, v) = P(U \le u | V = v) = \partial C(u, v) / \partial v.</code>
</p>

<p>In other words, the H-function number refers to the conditioning variable.
When inverting H-functions, the inverse is then taken with respect to the
other variable, that is <code>v</code> when <code>cond_var = 1</code> and <code>u</code> when <code>cond_var = 2</code>.
</p>


<h4>Discrete variables</h4>

<p>When at least one variable is discrete, more than two columns are required
for <code>u</code>: the first <code class="reqn">n \times 2</code> block contains realizations of
<code class="reqn">F_{X_1}(x_1), F_{X_2}(x_2)</code>. The second <code class="reqn">n \times 2</code> block contains
realizations of <code class="reqn">F_{X_1}(x_1^-), F_{X_1}(x_1^-)</code>. The minus indicates a
left-sided limit of the cdf. For, e.g., an integer-valued variable, it holds
<code class="reqn">F_{X_1}(x_1^-) = F_{X_1}(x_1 - 1)</code>. For continuous variables the left
limit and the cdf itself coincide. Respective columns can be omitted in the
second block.
</p>



<h3>Value</h3>

<p><code>dbicop()</code> gives the density, <code>pbicop()</code> gives the distribution function,
<code>rbicop()</code> generates random deviates, and <code>hbicop()</code> gives the h-functions
(and their inverses).
</p>
<p>The length of the result is determined by <code>n</code> for <code>rbicop()</code>, and
the number of rows in <code>u</code> for the other functions.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length of the
result.
</p>


<h3>Note</h3>

<p>The functions can optionally be used with a bicop_dist object, e.g.,
<code>dbicop(c(0.1, 0.5), bicop_dist("indep"))</code>.
</p>


<h3>See Also</h3>

<p><code>bicop_dist()</code>, <code>bicop()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## evaluate the copula density
dbicop(c(0.1, 0.2), "clay", 90, 3)
dbicop(c(0.1, 0.2), bicop_dist("clay", 90, 3))

## evaluate the copula cdf
pbicop(c(0.1, 0.2), "clay", 90, 3)

## simulate data
plot(rbicop(500, "clay", 90, 3))

## h-functions
joe_cop &lt;- bicop_dist("joe", 0, 3)
# h_1(0.1, 0.2)
hbicop(c(0.1, 0.2), 1, "bb8", 0, c(2, 0.5))
# h_2^{-1}(0.1, 0.2)
hbicop(c(0.1, 0.2), 2, joe_cop, inverse = TRUE)

## mixed discrete and continuous data
x &lt;- cbind(rpois(10, 1), rnorm(10, 1))
u &lt;- cbind(ppois(x[, 1], 1), pnorm(x[, 2]), ppois(x[, 1] - 1, 1))
pbicop(u, "clay", 90, 3, var_types = c("d", "c"))

</code></pre>


</div>