<div class="container">

<table style="width: 100%;"><tr>
<td>isPrimeRcpp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Vectorized Primality Test
</h2>

<h3>Description</h3>

<p>Implementation of the <a href="https://en.wikipedia.org/wiki/Miller-Rabin_primality_test">Miller-Rabin primality test</a>. Based on the "mp_prime_p" function from the "factorize.c" source file found in the gmp library: <a href="https://gmplib.org">https://gmplib.org</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">isPrimeRcpp(v, namedVector = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Vector of integers or numeric values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namedVector</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named vector is returned. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Miller-Rabin primality test is a probabilistic algorithm that makes heavy use of <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">modular exponentiation</a>. At the heart of modular exponentiation is the ability to accurately obtain the remainder of the product of two numbers <code class="reqn">\pmod p</code>.
</p>
<p>With the gmp library, producing accurate calculations for problems like this is trivial because of the nature of the multiple precision data type. However, standard C++ does not afford this luxury and simply relying on a strict translation would have limited this algorithm to numbers less than <code class="reqn">\sqrt 2^{63} - 1</code> (N.B. We are taking advantage of the signed 64-bit fixed width integer from the stdint library in C++. If we were confined to base R, the limit would have been <code class="reqn">\sqrt 2^{53} - 1</code>). RcppAlgos::isPrimeRcpp gets around this limitation with a <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide and conquer</a> approach taking advantage of properties of arithmetic.
</p>
<p>The problem we are trying to solve can be summarized as follows:
</p>
<p style="text-align: center;"><code class="reqn">(x_1 * x_2) \pmod p</code>
</p>

<p>Now, we rewrite <code class="reqn">x_2</code> as <code class="reqn">x_2 = y_1 + y_2 + \dots + y_n</code>, so that we obtain:
</p>
<p style="text-align: center;"><code class="reqn">(x_1 * y_1) \pmod p + (x_1 * y_2) \pmod p + \dots + (x_1 * y_n) \pmod p</code>
</p>

<p>Where each product <code class="reqn">(x_1 * y_j)</code> for <code class="reqn">j &lt;= n</code> is smaller than the original <code class="reqn">x_1 * x_2</code>. With this approach, we are now capable of handling much larger numbers. Many details have been omitted for clarity.
</p>
<p>For a more in depth examination of this topic see <a href="https://codereview.stackexchange.com/questions/186751/accurate-modular-arithmetic-with-double-precision">Accurate Modular Arithmetic with Double Precision</a>.
</p>


<h3>Value</h3>

<p>Returns a named/unnamed logical vector. If an index is <code>TRUE</code>, the number at that index is prime, otherwise the number is composite.
</p>


<h3>Note</h3>

<p>The maximum value for each element in <code class="reqn">v</code> is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://www.math.uconn.edu/~kconrad/blurbs/ugradnumthy/millerrabin.pdf">THE MILLER-RABIN TEST</a></p>
<ul><li>
<p>Conrad, Keith. "THE MILLER-RABIN TEST." https://www.math.uconn.edu/~kconrad/blurbs/ugradnumthy/millerrabin.pdf.</p>
</li></ul>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a></p>
</li>
</ul>
<h3>See Also</h3>

<p><code>primeFactorize</code>, <code>isprime</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## check the primality of a single number
isPrimeRcpp(100)

## check the primality of every number in a vector
isPrimeRcpp(1:100)

set.seed(42)
mySamp &lt;- sample(10^13, 10)

## return named vector for easy identification
isPrimeRcpp(mySamp, namedVector = TRUE)

## Using nThreads
system.time(isPrimeRcpp(mySamp, nThreads = 2))
</code></pre>


</div>