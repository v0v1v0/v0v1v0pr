<div class="container">

<table style="width: 100%;"><tr>
<td>fit_cie_sky_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit CIE sky model</h2>

<h3>Description</h3>

<p>Use maximum likelihood to estimate the coefficients of the CIE sky model that
best fit to data sampled from a canopy photograph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_cie_sky_model(
  r,
  z,
  a,
  sky_points,
  zenith_dn,
  sun_coord,
  custom_sky_coef = NULL,
  std_sky_no = NULL,
  general_sky_type = NULL,
  twilight = TRUE,
  rmse = FALSE,
  method = "BFGS"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>SpatRaster. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code>read_caim()</code>
and <code>normalize()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>SpatRaster built with <code>zenith_image()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>SpatRaster built with <code>azimuth_image()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sky_points</code></td>
<td>
<p>The <em>data.frame</em> returned by <code>extract_rl()</code> or a
<em>data.frame</em> with same structure and names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zenith_dn</code></td>
<td>
<p>Numeric vector of length one. Zenith digital number, see
<code>extract_rl()</code> for how to obtain it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sun_coord</code></td>
<td>
<p>An object of class <em>list</em>. The result of a call to
<code>extract_sun_coord()</code> or an object with same structure and names. See also
<code>row_col_from_zenith_azimuth()</code> in case you want to provide values based on
date and time of acquisition and the <code>suncalc</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>custom_sky_coef</code></td>
<td>
<p>Numeric vector of length five. Custom starting
coefficients of the sky model. By default, they are drawn from standard
skies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std_sky_no</code></td>
<td>
<p>Numeric vector. Standard sky number from
Li et al. (2016)'s Table 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>general_sky_type</code></td>
<td>
<p>Character vector of length one. It could be any of
these: "Overcast", "Clear", or "Partly cloudy". See Table 1 from
Li et al. (2016) for additional details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twilight</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code> and the initial
standard parameters belong to the "Clear" general sky type, sun zenith
angles from 90 to 96 degrees will be tested (civic twilight). This is
necessary since <code>extract_sun_coord()</code> would mistakenly recognize the center
of what can be seen of the solar corona as the solar disk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmse</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code>, the criteria for
selecting the best sky model is to choose the one with the lowest <strong>root
mean square error (RMSE)</strong> calculated by using the <code>sky_points</code> argument as
the source of reference values. Otherwise, the criteria is to evaluate the
whole image by calculating the <strong>out-of-range index</strong> as <code class="reqn">\sum_{i =
  1}^{N}(r_i/sky_i)^2</code>, where <code class="reqn">r</code> is the <code>r</code> argument, <code class="reqn">sky</code> is the
raster obtained from the fitted model with <code>cie_sky_model_raster()</code> and
<code>zenith_dn</code>, <code class="reqn">i</code> is the index that represents the position of a given
pixel on the raster grid, and <code class="reqn">N</code> is the total number of pixels that
satisfy either of these inequalities: <code class="reqn">r_i/sky_i&lt;0</code> and
<code class="reqn">r_i/sky_i&gt;1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Optimization method to use. See <code>optim</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is based on Lang et al. (2010). In theory,
the best result would be obtained with data showing a linear relation between
digital numbers and the amount of light reaching the sensor. See
<code>extract_radiometry()</code> and <code>read_caim_raw()</code> for further details. As a
compromise solution, <code>gbc()</code> can be used.
</p>
<p>The following code exemplifies how this package can be used to compare the
manually-guided fitting provided by HSP (Lang et al. 2013)
against the automatic fitting provided by this package. The code assumes that
the user is working within an RStudio project located in the HSP project
folder.
</p>
<div class="sourceCode"><pre>r &lt;- read_caim("manipulate/IMG_1013.pgm") %&gt;% normalize()
z &lt;- zenith_image(ncol(r), lens())
a &lt;- azimuth_image(z)
manual_input &lt;- read_manual_input(".", "IMG_1013" )
sun_coord &lt;- manual_input$sun_coord$row_col
sun_coord &lt;- zenith_azimuth_from_row_col(z, sun_coord, lens())
sky_points &lt;- manual_input$sky_points
rl &lt;- extract_rl(r, z, a, sky_points)
model &lt;- fit_cie_sky_model(r, z, a, rl$sky_points, rl$zenith_dn, sun_coord)
cie_sky &lt;- model$relative_luminance * model$zenith_dn
plot(r/cie_sky)

r &lt;- read_caim("manipulate/IMG_1013.pgm")
sky_coef &lt;- read_opt_sky_coef(".", "IMG_1013")
cie_sky_manual &lt;- cie_sky_model_raster(z, a, sun_coord$zenith_azimuth, sky_coef)
cie_sky_manual &lt;- cie_sky_manual * manual_input$zenith_dn
plot(r/cie_sky_manual)
</pre></div>


<h3>Value</h3>

<p>object from the class <em>list</em>. The result includes the following: (1)
the output produced by <code>bbmle::mle2()</code>, (2) the 5 coefficients, (3 and 4)
observed and predicted values, (5) the digital number at the zenith, (6)
the sun coordinates –zenith and azimuth angle in degrees–, and (7) the
description of the standard sky from which the initial coefficients were
drawn. See Li et al. (2016) to know more about these
coefficients.
</p>


<h3>Note</h3>

<p>If you use this function in your research, please cite
Lang et al. (2010) in addition to this package
(<code style="white-space: pre;">⁠citation("rcaiman"⁠</code>).
</p>


<h3>References</h3>

<p>Lang M, Kodar A, Arumäe T (2013).
“Restoration of above canopy reference hemispherical image from below canopy measurements for plant area index estimation in forests.”
<em>Forestry Studies</em>, <b>59</b>(1), 13–27.
<a href="https://doi.org/10.2478/fsmu-2013-0008">doi:10.2478/fsmu-2013-0008</a>.<br><br> Lang M, Kuusk A, M~ottus M, Rautiainen M, Nilson T (2010).
“Canopy gap fraction estimation from digital hemispherical images using sky radiance models and a linear conversion method.”
<em>Agricultural and Forest Meteorology</em>, <b>150</b>(1), 20–29.
<a href="https://doi.org/10.1016/j.agrformet.2009.08.001">doi:10.1016/j.agrformet.2009.08.001</a>.<br><br> Li DH, Lou S, Lam JC, Wu RH (2016).
“Determining solar irradiance on inclined planes from classified CIE (International Commission on Illumination) standard skies.”
<em>Energy</em>, <b>101</b>, 462–470.
<a href="https://doi.org/10.1016/j.energy.2016.02.054">doi:10.1016/j.energy.2016.02.054</a>.
</p>


<h3>See Also</h3>

<p>Other Sky Reconstruction Functions: 
<code>cie_sky_model_raster()</code>,
<code>fit_coneshaped_model()</code>,
<code>fit_trend_surface()</code>,
<code>fix_reconstructed_sky()</code>,
<code>interpolate_sky_points()</code>,
<code>ootb_sky_reconstruction()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
caim &lt;- read_caim() %&gt;% normalize()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)

# Manual method after Lang et al. (2010)
# ImageJ can be used to digitize points
path &lt;- system.file("external/sky_points.csv",
                    package = "rcaiman")
sky_points &lt;- read.csv(path)
sky_points &lt;- sky_points[c("Y", "X")]
colnames(sky_points) &lt;- c("row", "col")
head(sky_points)
plot(caim$Blue)
points(sky_points$col, nrow(caim) - sky_points$row, col = 2, pch = 10)

xy &lt;- c(210, 451) #originally captured with click() after x11()
sun_coord &lt;- zenith_azimuth_from_row_col(z, z, c(nrow(z) - xy[2],xy[1]))
points(sun_coord$row_col[2], nrow(caim) - sun_coord$row_col[1],
       col = 3, pch = 1)

rl &lt;- extract_rl(caim$Blue, z, a, sky_points)

set.seed(7)
model &lt;- fit_cie_sky_model(caim$Blue, z, a, rl$sky_points,
                           rl$zenith_dn, sun_coord,
                           general_sky_type = "Clear",
                           rmse = FALSE,
                           twilight = FALSE,
                           method = "SANN")
summary(model$mle2_output)
plot(model$obs, model$pred)
abline(0,1)
r2 &lt;- lm(model$pred~model$obs) %&gt;% summary(.) %&gt;% .$r.squared
r2
sky_cie &lt;- cie_sky_model_raster(z, a,
                                model$sun_coord$zenith_azimuth,
                                model$coef) * model$zenith_dn
plot(sky_cie)
plot(caim$Blue/sky_cie)

# A quick demonstration of how to use interpolation to improve sky modelling
# after Lang et al. (2010)
sky &lt;- interpolate_sky_points(rl$sky_points, caim$Blue, rmax = ncol(caim)/7)
plot(sky)
sky &lt;- sky * rl$zenith_dn * (1 - r2) + sky_cie * r2
sky &lt;- terra::cover(sky, sky_cie)
plot(sky)
plot(caim$Blue/sky)

# how to provide a custom starting coefficient
model &lt;- fit_cie_sky_model(caim$Blue, z, a, rl$sky_points,
                           rl$zenith_dn, sun_coord,
                           custom_sky_coef = model$coef,
                           method = "SANN")
plot(model$obs, model$pred, ylim = range(model$obs))
abline(0,1)

## End(Not run)
</code></pre>


</div>