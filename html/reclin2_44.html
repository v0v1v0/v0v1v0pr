<div class="container">

<table style="width: 100%;"><tr>
<td>select_greedy.cluster_pairs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Select matching pairs enforcing one-to-one linkage</h2>

<h3>Description</h3>

<p>Select matching pairs enforcing one-to-one linkage
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'cluster_pairs'
select_greedy(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

## S3 method for class 'cluster_pairs'
select_n_to_m(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

select_greedy(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

## S3 method for class 'pairs'
select_greedy(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  include_ties = FALSE,
  n = 1L,
  m = 1L,
  ...
)

select_n_to_m(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  ...
)

## S3 method for class 'pairs'
select_n_to_m(
  pairs,
  variable,
  score,
  threshold,
  preselect = NULL,
  id_x = NULL,
  id_y = NULL,
  x = attr(pairs, "x"),
  y = attr(pairs, "y"),
  inplace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pairs</code></td>
<td>
<p>a <code>pairs</code> object, such as generated by 
<code>pair_blocking</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variable</code></td>
<td>
<p>the name of the new variable to create in pairs. This will be a
logical variable with a value of <code>TRUE</code> for the selected pairs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>name of the score/weight variable of the pairs. When not given
and <code>attr(pairs, "score")</code> is defined, that is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>the threshold to apply. Pairs with a score above the 
threshold are selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preselect</code></td>
<td>
<p>a logical variable with the same length as <code>pairs</code> has
rows, or the name of such a variable in <code>pairs</code>. Pairs are only 
selected when <code>preselect</code> is <code>TRUE</code>. This interacts with 
<code>threshold</code> (pairs have to be selected with both conditions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_x</code></td>
<td>
<p>a integer vector with the same length as the number of rows in 
<code>pairs</code>, or the name of a column in <code>x</code>. This vector should 
identify unique objects in <code>x</code>. When not specified it is assumed that
each element in <code>x</code> is unique.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_y</code></td>
<td>
<p>a integer vector with the same length as the number of rows in 
<code>pairs</code>, or the name of a column in <code>y</code>. This vector should 
identify unique objects in <code>y</code>. When not specified it is assumed that
each element in <code>y</code> is unique.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Used to pass additional arguments to methods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>data.table</code> with one half of the pairs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p><code>data.table</code> with the other half of the pairs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inplace</code></td>
<td>
<p>logical indicating whether <code>pairs</code> should be modified in place. When
pairs is large this can be more efficient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_ties</code></td>
<td>
<p>when pairs for a given record have an equal weight, should
all pairs be included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>an integer. Each element of x can be linked to at most n elements of
y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>an integer. Each element of y can be linked to at most m elements of
x.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Both methods force one-to-one matching. <code>select_greedy</code> uses a greedy 
algorithm that selects the first pair with the highest weight. 
<code>select_n_to_m</code> tries to optimise the total weight of all of the 
selected pairs. In general this will result in a better selection. However,
<code>select_n_to_m</code> uses much more memory and is much slower and, therefore,
can only be used when the number of possible pairs is not too large. 
</p>
<p>Note that when <code>include_ties = TRUE</code> the same record can still be 
selected more than once. In that case the pairs will have an equal weight.
</p>


<h3>Value</h3>

<p>Returns the <code>pairs</code> with the variable given by <code>variable</code> added. This
is a logical variable indicating which pairs are selected as matches.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("linkexample1", "linkexample2")
pairs &lt;- pair_blocking(linkexample1, linkexample2, "postcode")
pairs &lt;- compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
pairs &lt;- predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)

# Select pairs with a mpost &gt; 0.5 and force one-to-one linkage
pairs &lt;- select_n_to_m(pairs, "ntom", "mpost", 0.5)
pairs &lt;- select_greedy(pairs, "greedy", "mpost", 0.5)
table(pairs$ntom, pairs$greedy)

# The same example as above using a cluster;
library(parallel)
cl &lt;- makeCluster(2)

pairs &lt;- cluster_pair_blocking(cl, linkexample1, linkexample2, "postcode")
compare_pairs(pairs, c("lastname", "firstname", "address", "sex"))
model &lt;- problink_em(~ lastname + firstname + address + sex, data = pairs)
predict(model, pairs, type = "mpost", add = TRUE, binary = TRUE)
# Select pairs with a mpost &gt; 0.5 and force one-to-one linkage
# select_n_to_m and select_greedy only work on pairs that are local; 
# therefore we first collect the pairs
select_threshold(pairs, "selected", "mpost", 0.5)
local_pairs &lt;- cluster_collect(pairs, "selected")
local_pairs &lt;- select_n_to_m(local_pairs, "ntom", "mpost", 0.5)
local_pairs &lt;- select_greedy(local_pairs, "greedy", "mpost", 0.5)
table(local_pairs$ntom, local_pairs$greedy)

stopCluster(cl)

</code></pre>


</div>