<div class="container">

<table style="width: 100%;"><tr>
<td>residuals.seqModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract residuals from a sequence of regression models</h2>

<h3>Description</h3>

<p>Extract residuals from a sequence of regression models, such as submodels
along a robust or groupwise least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'seqModel'
residuals(object, s = NA, standardized = FALSE, drop = !is.null(s), ...)

## S3 method for class 'tslars'
residuals(object, p, ...)

## S3 method for class 'perrySeqModel'
residuals(object, ...)

## S3 method for class 'sparseLTS'
residuals(
  object,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  standardized = FALSE,
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>the model fit from which to extract residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels for which to extract the residuals (the default is to
use the optimal submodel).  For the <code>"sparseLTS"</code> method, an integer
vector giving the indices of the models for which to extract residuals.  If
<code>fit</code> is <code>"both"</code>, this can be a list with two components, with
the first component giving the indices of the reweighted fits and the second
the indices of the raw fits.  The default is to use the optimal model for
each of the requested estimators.  Note that the optimal models may not
correspond to the same value of the penalty parameter for the reweighted and
the raw estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>a logical indicating whether the residuals should be
standardized (the default is <code>FALSE</code>). Note that this argument is
<b>deprecated</b> and may be removed as soon as the next version. Use
<code>rstandard</code> instead to extract standardized
residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"seqModel"</code> method.  For the other methods,
additional arguments are currently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an integer giving the lag length for which to extract residuals
(the default is to use the optimal lag length).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>a character string specifying which residuals to extract.
Possible values are <code>"reweighted"</code> (the default) for the residuals
from the reweighted estimator, <code>"raw"</code> for the residuals from the raw
estimator, or <code>"both"</code> for the residuals from both estimators.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector or matrix containing the requested residuals.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code>residuals</code>, <code>rstandard</code>
</p>
<p><code>rlars</code>, <code>grplars</code>, <code>rgrplars</code>,
<code>tslarsP</code>, <code>rtslarsP</code>, <code>tslars</code>,
<code>rtslars</code>, <code>sparseLTS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract residuals
residuals(fitRlars)
head(residuals(fitRlars, s = 1:5))


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract residuals
residuals(fitSparseLTS)
head(residuals(fitSparseLTS, fit = "both"))
head(residuals(fitSparseLTS, s = NULL))
head(residuals(fitSparseLTS, fit = "both", s = NULL))
</code></pre>


</div>