<div class="container">

<table style="width: 100%;"><tr>
<td>sid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A function for computing the spectral information divergence between
spectra (sid)</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><a href="https://www.tidyverse.org/lifecycle/#experimental"><img src="figures/lifecycle-experimental.svg" alt="Experimental lifecycle"></a>
<p>This function computes the spectral information divergence/dissimilarity between
spectra based on the kullback-leibler divergence algorithm (see details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sid(Xr, Xu = NULL,
    mode = "density",
    center = FALSE, scale = FALSE,
    kernel = "gaussian",
    n = if(mode == "density") round(0.5 * ncol(Xr)),
    bw = "nrd0",
    reg = 1e-04,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xr</code></td>
<td>
<p>a matrix containing the spectral (reference) data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xu</code></td>
<td>
<p>an optional matrix containing the spectral data of a second set of
observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>the method to be used for computing the spectral information
divergence. Options are <code>"density"</code> (default) for computing the divergence
values on the density distributions of the spectral observations, and
<code>"feature"</code> for computing the divergence vales on the spectral variables.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>a logical indicating if the computations must be carried out on
the centred <code>X</code> and <code>Xu</code> (if specified) matrices. If
<code>mode = "feature"</code> centring is not carried out since this option does
not accept negative values which are generated after centring the matrices.
Default is FALSE. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical indicating if the computations must be carried out on
the variance scaled <code>X</code> and <code>Xu</code> (if specified) matrices. Default
is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>if <code>mode = "density"</code> a character string indicating the
smoothing kernel to be used. It must be one of <code>"gaussian"</code> (default),
<code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code> or <code>"optcosine"</code>. See the
<code>density</code> function of the <code>stats</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>if <code>mode = "density"</code> a numerical value indicating the number
of equally spaced points at which the density is to be estimated. See the
<code>density</code> function of the <code>stats</code> package for further
details. Default is <code>round(0.5 * ncol(X))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>if <code>mode = "density"</code> a numerical value indicating the
smoothing kernel bandwidth to be used. Optionally the character string
<code>"nrd0"</code> can be used, it computes the bandwidth using the <code>bw.nrd0</code>
function of the <code>stats</code> package (see <code>bw.nrd0</code>). See the
<code>density</code> and the <code>bw.nrd0</code> functions for more
details. By default <code>"nrd0"</code> is used, in this case the bandwidth is
computed as <code>bw.nrd0(as.vector(X))</code>, if <code>Xu</code> is specified the
bandwidth is computed as <code>bw.nrd0(as.vector(rbind(X, Xu)))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reg</code></td>
<td>
<p>a numerical value larger than 0 which indicates a regularization
parameter. Values (probabilities) below this threshold are replaced by this
value for numerical stability. Default is 1e-4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to the
<code>density</code> function of the base package.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes the spectral information divergence (distance)
between spectra.
When <code>mode = "density"</code>, the function first computes the probability
distribution of each spectrum which result in a matrix of density
distribution estimates. The density distributions of all the observations in
the datasets are compared based on the kullback-leibler divergence algorithm.
When <code>mode = "feature"</code>, the kullback-leibler divergence between all
the observations is computed directly on the spectral variables.
The spectral information divergence (SID) algorithm (Chang, 2000) uses the
Kullback-Leibler divergence (\(KL\)) or relative entropy
(Kullback and Leibler, 1951) to account for the vis-NIR information provided
by each spectrum. The SID between two spectra (\(x_{i}\) and
\(x_{j}\)) is computed as follows:
</p>
\[sid(x_{i},x_{j}) = KL(x_{i} \left |\right | x_{j}) + KL(x_{j} \left |\right | x_{i})\]
\[sid(x_{i},x_{j}) = \sum_{l=1}^{k} p_l \ log(\frac{p_l}{q_l}) + \sum_{l=1}^{k} q_l \ log(\frac{q_l}{p_l})\]
<p>where \(k\) represents the number of variables or spectral features,
\(p\) and \(q\) are the probability vectors of \(x_{i}\) and
\(x_{i}\) respectively which are calculated as:
</p>
\[p = \frac{x_i}{\sum_{l=1}^{k} x_{i,l}}\]
\[q = \frac{x_j}{\sum_{l=1}^{k} x_{j,l}}\]
<p>From the above equations it can be seen that the original SID algorithm
assumes that all the components in the data matrices are nonnegative.
Therefore centering cannot be applied when <code>mode = "feature"</code>. If a
data matrix with negative values is provided and <code>mode = "feature"</code>,
the <code>sid</code> function automatically scales the matrix as follows:
</p>
\[X_s = \frac{X-min(X)}{max(X)-min(X)}\]
<p>or
</p>
\[X_{s} = \frac{X-min(X, Xu)}{max(X, Xu)-min(X, Xu)}\]
\[Xu_{s} = \frac{Xu-min(X, Xu)}{max(X, Xu)-min(X, Xu)}\]
<p>if <code>Xu</code> is specified. The 0 values are replaced by a regularization
parameter (<code>reg</code> argument) for numerical stability.
The default of the <code>sid</code> function is to compute the SID based on the
density distributions of the spectra (<code>mode = "density"</code>). For each
spectrum in <code>X</code> the density distribution is computed using the
<code>density</code> function of the <code>stats</code> package.
The 0 values of the estimated density distributions of the spectra are
replaced by a regularization parameter (<code>"reg"</code> argument) for numerical
stability. Finally the divergence between the computed spectral histogramas
is computed using the SID algorithm. Note that if <code>mode = "density"</code>,
the <code>sid</code> function will accept negative values and matrix centering
will be possible.
</p>


<h3>Value</h3>

<p>a <code>list</code> with the following components:
</p>

<ul>
<li>
<p><code>sid</code>: if only <code>"X"</code> is specified (i.e. <code>Xu = NULL</code>),
a square symmetric matrix of SID distances between all the components in
<code>"X"</code>. If both <code>"X"</code> and <code>"Xu"</code> are specified, a matrix
of SID distances between the components in <code>"X"</code> and the components
in <code>"Xu"</code>) where the rows represent the objects in <code>"X"</code> and the
columns represent the objects in <code>"Xu"</code>
</p>
</li>
<li>
<p><code>Xr</code>: the (centered and/or scaled if specified) spectral
<code>X</code> matrix
</p>
</li>
<li>
<p><code>Xu</code>: the (centered and/or scaled if specified) spectral
<code>Xu</code> matrix
</p>
</li>
<li>
<p><code>densityDisXr</code>: if <code>mode = "density"</code>, the computed
density distributions of <code>Xr</code>
</p>
</li>
<li>
<p><code>densityDisXu</code>: if <code>mode = "density"</code>, the computed
density distributions of <code>Xu</code>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>


<h3>References</h3>

<p>Chang, C.I. 2000. An information theoretic-based approach to
spectral variability, similarity and discriminability for hyperspectral
image analysis. IEEE Transactions on Information Theory 46, 1927-1932.
</p>


<h3>See Also</h3>

<p><code>density</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(prospectr)

data(NIRsoil)

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Yu &lt;- NIRsoil$CEC[!as.logical(NIRsoil$train)]
Yr &lt;- NIRsoil$CEC[as.logical(NIRsoil$train)]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

Xu &lt;- Xu[!is.na(Yu), ]
Xr &lt;- Xr[!is.na(Yr), ]

# Example 1
# Compute the SID distance between all the observations in Xr
xr_sid &lt;- sid(Xr)
xr_sid

# Example 2
# Compute the SID distance between the observations in Xr and the observations
# in Xu
xr_xu_sid &lt;- sid(Xr, Xu)
xr_xu_sid

</code></pre>


</div>