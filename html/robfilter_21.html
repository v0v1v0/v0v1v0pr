<div class="container">

<table style="width: 100%;"><tr>
<td>robust.filter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Robust Filtering Methods for Univariate Time Series</h2>

<h3>Description</h3>

 
<p>Procedure for robust (online) extraction of low frequency
components (the <em>signal</em>) from a univariate time series with
optional rules for outlier replacement and shift detection.
</p>


<h3>Usage</h3>

<pre><code class="language-R">robust.filter(y, width, trend = "RM", scale = "QN", outlier = "T", 
                        shiftd = 2, wshift = floor(width/2), lbound = 0.1, p = 0.9,
                        adapt = 0, max.width = width, 
                        online = FALSE, extrapolate = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector or (univariate) time series object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>a positive integer defining the window width used for fitting.
If <code>online=FALSE</code> (default) this needs to be an odd number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trend</code></td>
<td>
<p>a character string defining the method to be used for robust approximation of the signal 
within one time window. Possible values are:<br></p>

<dl>
<dt>
<code>"MED"</code>:</dt>
<dd>
<p>Median</p>
</dd>
<dt>
<code>"RM"</code>:</dt>
<dd>
<p>Repeated Median regression (default)</p>
</dd>
<dt>
<code>"LTS"</code>:</dt>
<dd>
<p>Least Trimmed Squares regression</p>
</dd>
<dt>
<code>"LMS"</code>:</dt>
<dd>
<p>Least Median of Squares regression</p>
</dd> 
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a character string defining the method to be used for robust estimation of the local 
variability (within one time window). 
Possible values are:<br></p>

<dl>
<dt>
<code>"MAD"</code>:</dt>
<dd>
<p>Median absolute deviation about the median</p>
</dd>
<dt>
<code>"QN"</code>:</dt>
<dd>
<p>Rousseeuw's and Croux' (1993) <code class="reqn">Q_n</code> scale estimator (default)</p>
</dd>
<dt>
<code>"SN"</code>:</dt>
<dd>
<p>Rousseeuw's and Croux' (1993) <code class="reqn">S_n</code> scale estimator</p>
</dd>
<dt>
<code>"LSH"</code>:</dt>
<dd>
<p>Length of the shortest half</p>
</dd>   
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outlier</code></td>
<td>
<p>a single character defining the rule to be used for outlier detection and outlier treatment. 
Observations deviating more than <code class="reqn">d\cdot \hat{\sigma}_t</code> 
from the current level approximation <code class="reqn">\hat{\mu}_t</code> 
are replaced by <code class="reqn">\hat{\mu}_t\pm k\hat{\sigma}_t</code>
where <code class="reqn">\hat{\sigma}_t</code> denotes the current scale estimate. <br>
Possible values are:<br></p>

<dl>
<dt>
<code>"T"</code>:</dt>
<dd>
<p>Replace ('trim') large outliers detected by a <code class="reqn">3\sigma</code>-rule 
(<code class="reqn">d=3</code>) by the current level estimate (<code class="reqn">k=0</code>). (default)</p>
</dd>
<dt>
<code>"L"</code>:</dt>
<dd>
<p>Shrink large outliers (<code class="reqn">d=3</code>) strongly 
towards the current level estimate (<code class="reqn">k=1</code>).</p>
</dd>
<dt>
<code>"M"</code>:</dt>
<dd>
<p>Shrink large and moderatly sized outliers (<code class="reqn">d=2</code>) strongly 
towards the current level estimate (<code class="reqn">k=1</code>).</p>
</dd>
<dt>
<code>"W"</code>:</dt>
<dd>
<p>Shrink large and moderatly sized outliers (<code class="reqn">d=2</code>) 
towards the current level estimate (<code class="reqn">k=2</code>).</p>
</dd>
</dl>
<p><code>W</code> is the most efficient, <code>T</code> the most robust method (which should ideally 
be combined with a suitable value of <code>lbound</code>).  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shiftd</code></td>
<td>
<p>a positive numeric value defining the factor the current scale estimate is multiplied 
with for shift detection. Default is <code>shiftd</code>=2 
corresponding to a <code class="reqn">2\sigma</code> rule for shift detection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wshift</code></td>
<td>
<p>a positive integer specifying the number of the most recent observations used for shift detection
(regulates therefore also the delay of shift detection). Only used
in the <code>online</code> mode; should be less than half the (minimal)
window width then. In the offline mode (<code>online=FALSE</code>, default), shift
detection is based on the right half of the time window, i.e. <code>wshift=floor(width/2)</code> (default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbound</code></td>
<td>
<p>a positive real value specifying an optional lower bound for the scale to prevent 
the scale estimate from reaching zero (implosion). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a fraction <code class="reqn">\in [2/3,1]</code> of observations 
for additional rules in case of only two or three different values 
within one window.<br>
If 100 percent of the observations within one window take on 
only two different values, the current level is estimated by the 
mean of these values regardless of the <code>trend</code> 
specification. In case of three differing values the median is 
taken as the current level estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>a numeric value  defining the fraction which regulates the adaption of the
moving window width. <code>adapt</code> can be either 0 or a value <code class="reqn">\in [0.6,1]</code> . 
<code>adapt = 0</code> means that a fixed window width is used. 
Otherwise, the window width is reduced whenever more than a fraction of 
<code>adapt</code> <code class="reqn">\in [0.6,1]</code> of the residuals in a
certain part of the current time window are all positive or all
negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.width</code></td>
<td>
<p>a positive integer (<code>&gt;= width</code>) specifying the maximal width of the time window.<br><code>width</code> specifies the minimal (and also the initial) width.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>online</code></td>
<td>
<p>a logical indicating whether the current level and 
scale estimates are evaluated at the most recent time 
within each window (<code>TRUE</code>) or centered within the window 
(<code>FALSE</code>). <code>online=FALSE</code> (default) requires an odd 
<code>width</code> for the window and means a time delay of 
(<code>width</code>+1)/2 time units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrapolate</code></td>
<td>
<p>a logical indicating whether the level 
estimations should be extrapolated to the edges of the time series. <br>
If <code>online=FALSE</code> the extrapolation consists of the 
fitted values within the first half of the first window and the 
last half of the last window; if <code>online=TRUE</code> the 
extrapolation consists of all fitted values within the first 
time window. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>robust.filter</code> works by applying the methods 
specified by <code>trend</code> and <code>scale</code> to a moving time 
window of length <code>width</code>.
</p>
<p>Before moving the time window, it is checked whether the next 
(incoming) observation is considered an 'outlier' by applying the 
rule specified by <code>outlier</code>. Therefore, the trend in the 
current time window is extrapolated to the next point in time and 
the residual of the incoming observation is standardised by the 
current scale estimate.
</p>
<p>After moving the time window, it can be tested whether a level 
shift has occurred within the window: If more than half of the 
residuals in the right part of the window are larger than 
<code>shiftd</code><code class="reqn">\cdot\sigma_t</code>, a shift is detected and 
appropriate actions are taken. In
the <code>online</code> mode, the number of the rightmost residuals can be
chosen by <code>wshift</code> to regulate the resistance of the detection
rule against outliers, its power and the time delay of detection.
</p>
<p>A more detailed description of the filter can be found in Fried 
(2004). The adaption of the window width is described by Gather and
Fried (2004). For more explanations on shift detection, see Fried
and Gather (2007).</p>


<h3>Value</h3>

 
<p><code>robust.filter</code> returns an object of class <code>robust.filter</code>.  
An object of class <code>robust.filter</code> is a list containing the 
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>a numeric vector containing the signal level extracted by the (regression) filter specified by <code>trend</code>, <code>scale</code> and <code>outlier</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slope</code></td>
<td>
<p>a numeric vector containing the corresponding slope within each time window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>a numeric vector containing the corresponding scale within each time window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ol</code></td>
<td>
<p>an outlier indicator. 
0: no outlier, +1: positive outlier, -1: negative outlier</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level.shift</code></td>
<td>
<p>a level shift indicator.
0: no level shift, t: positive level shift detected at processing
time t, -t: negative level shift detected at processing time t (the
position in the vector gives an estimate of the point in time before
which the shift has occurred).
</p>
</td>
</tr>
</table>
<p>In addition, the original input time series is returned as list 
member <code>y</code>, and the settings used for the analysis are 
returned as the list members <code>width</code>, <code>trend</code>, 
<code>scale</code>, <code>outlier</code>, <code>shiftd</code>, 
<code>wshift</code>, <code>lbound</code>, 
<code>p</code>, <code>adapt</code>, <code>max.width</code>, <code>online</code> and <code>extrapolate</code>. 
</p>
<p>Application of the function <code>plot</code> to an object of class
<code>robust.filter</code> returns a plot showing the original time series 
with the filtered output. 
</p>


<h3>Note</h3>

<p>Missing values have to be replaced or removed from the time series 
before applying <code>robust.filter</code>.
</p>


<h3>Author(s)</h3>

<p>Roland Fried and Karen Schettlinger</p>


<h3>References</h3>

 
<p>Fried, R. (2004), Robust Filtering of Time Series with 
Trends, <em>Journal of Nonparametric Statistics</em> <b>16</b>, 
313-328.<br>
(earlier version: <a href="http://hdl.handle.net/2003/4992">http://hdl.handle.net/2003/4992</a>)
</p>
<p>Fried, R., Gather, U. (2007), On Rank Tests for Shift Detection in Time Series, 
<em>Computational Statistics and Data Analysis, Special Issue on Machine Learning and Robust Data Mining</em> <b>52</b>, 221-233.<br>
(earlier version: <a href="http://hdl.handle.net/2003/23301">http://hdl.handle.net/2003/23301</a>) 
</p>
<p>Gather, U., Fried, R. (2004), Methods and Algorithms for Robust Filtering, 
<em>COMPSTAT 2004: Proceedings in Computational Statistics</em>, J. Antoch (eds.), Physika-Verlag, Heidelberg, 159-170. <br></p>
<p>Schettlinger, K., Fried, R., Gather, U. (2006) Robust Filters
for Intensive Care Monitoring: Beyond the Running Median,
<em>Biomedizinische Technik</em> <b>51</b>(2), 49-56.
</p>


<h3>See Also</h3>

<p><code>robreg.filter</code>, <code>hybrid.filter</code>, <code>dw.filter</code>, <code>wrm.filter</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate random time series:
y &lt;- cumsum(runif(500)) - .5*(1:500)
# Add jumps:
y[200:500] &lt;- y[200:500] + 5
y[400:500] &lt;- y[400:500] - 7
# Add noise:
n &lt;- sample(1:500, 30)
y[n] &lt;- y[n] + rnorm(30)

# Delayed Filtering of the time series with window width 23:
y.rf &lt;- robust.filter(y, width=23)
# Plot:
plot(y.rf)

# Delayed Filtering with different settings and fixed window width 31:
y.rf2 &lt;- robust.filter(y, width=31, trend="LMS", scale="QN", outlier="W")
plot(y.rf2)

# Online Filtering with fixed window width 24:
y.rf3 &lt;- robust.filter(y, width=24, online=TRUE)
plot(y.rf3)

# Delayed Filtering with adaptive window width (minimal width 11, maximal width 51):
y.rf4 &lt;- robust.filter(y, width=11, adapt=0.7, max.width=51)
plot(y.rf4)
</code></pre>


</div>