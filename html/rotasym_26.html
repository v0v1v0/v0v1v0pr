<div class="container">

<table style="width: 100%;"><tr>
<td>estimators</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimators for the axis of rotational symmetry
<code class="reqn">\boldsymbol\theta</code>
</h2>

<h3>Description</h3>

<p>Estimation of the axis of rotational symmetry
<code class="reqn">\boldsymbol{\theta}</code> of a rotational symmetric unit-norm
random vector <code class="reqn">\mathbf{X}</code> in
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p \ge 2</code>, from a
hyperspherical sample <code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n\in S^{p-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">spherical_mean(data)

spherical_loc_PCA(data)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>hyperspherical data, a matrix of size <code>c(n, p)</code> with unit
norm rows. Normalized internally if any row does not have unit norm
(with a <code>warning</code> message). <code>NA</code>s are ignored.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The <code>spherical_mean</code> estimator computes the sample mean of
<code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n</code> and normalizes it
by its norm (if the norm is different from zero). It estimates consistently
<code class="reqn">\boldsymbol{\theta}</code> for rotational symmetric models based on
angular functions <code class="reqn">g</code> that are
monotone increasing.
</p>
<p>The estimator in <code>spherical_loc_PCA</code> is based on the fact that, under
rotational symmetry, the expectation of
<code class="reqn">\mathbf{X}\mathbf{X}'</code> is
<code class="reqn">a\boldsymbol{\theta}\boldsymbol{\theta}' +
b(\mathbf{I}_p - \boldsymbol{\theta}\boldsymbol{\theta}')</code>
for certain constants <code class="reqn">a,b \ge 0</code>. Therefore,
<code class="reqn">\boldsymbol{\theta}</code> is the eigenvector with unique
multiplicity of the expectation of <code class="reqn">\mathbf{X}\mathbf{X}'</code>. Its
use is recommended if the rotationally symmetric data is not unimodal.
</p>


<h3>Value</h3>

<p>A vector of length <code>p</code> with an estimate for
<code class="reqn">\boldsymbol{\theta}</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873–1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Sample from a vMF
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
set.seed(123456789)
data &lt;- r_vMF(n = n, mu = theta, kappa = 3)
theta_mean &lt;- spherical_mean(data)
theta_PCA &lt;- spherical_loc_PCA(data)
sqrt(sum((theta - theta_mean)^2)) # More efficient
sqrt(sum((theta - theta_PCA)^2))

# Sample from a mixture of antipodal vMF's
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
set.seed(123456789)
data &lt;- rbind(r_vMF(n = n, mu = theta, kappa = 3),
              r_vMF(n = n, mu = -theta, kappa = 3))
theta_mean &lt;- spherical_mean(data)
theta_PCA &lt;- spherical_loc_PCA(data)
sqrt(sum((theta - theta_mean)^2))
sqrt(sum((theta - theta_PCA)^2)) # Better suited in this case
</code></pre>


</div>