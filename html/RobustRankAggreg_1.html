<div class="container">

<table style="width: 100%;"><tr>
<td>aggregateRanks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate ranked lists</h2>

<h3>Description</h3>

<p>Method implementing various gene list aggregation methods, most notably Robust Rank 
Aggregation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">aggregateRanks(
  glist,
  rmat = rankMatrix(glist, N, full = full),
  N = NA,
  method = "RRA",
  full = FALSE,
  exact = FALSE,
  topCutoff = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>glist</code></td>
<td>
<p>list of element vectors, the order of the vectors is used as the ranking.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmat</code></td>
<td>
<p>the rankings in matrix format. The glist is by default converted to this 
format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>the number of ranked elements, important when using only top-k ranks, by 
default it is calculated as the number of unique elements in the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>rank aggregation method, by default <code>'RRA'</code>, other options are 
<code>'min'</code>, <code>'geom.mean'</code>, <code>'mean'</code>, <code>'median'</code> and <code>'stuart'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>indicates if the full rankings are given, used if the the sets of ranked 
elements do not match perfectly</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>indicator showing if exact p-value will be calculated based on rho score (Default: if number of lists smaller than 10, exact is used)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topCutoff</code></td>
<td>
<p>a vector of cutoff values used to limit the number of elements in the 
input lists
elements do not match perfectly</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All the methods implemented in this function make an assumtion that the number of
ranked items is known. This assumption is satisfied for example in the case of 
gene lists (number of all genes known to certain extent), but not when aggregating 
results from google searches (there are too many web pages). This parameter N can be 
set manually and has strong influence on the end result. The p-values from RRA 
algorithm can be trusted only if N is close to the real value.
</p>
<p>The rankings can be either full or partial. Tests with the RRA algorithm show that one 
does not lose too much information if only top-k rankings are used. The missing values 
are assumed to be equal to maximal value and that way taken into account 
appropriately. 
</p>
<p>The function can handle also the case when elements of the different rankings do not 
overlap perfectly. For example if we combine results from different microarray 
platforms with varying coverage. In this case these structurally missing values are 
substituted with NA-s and handled differently than omitted parts of the rankings. 
The function accepts as an input either list of rankings or rank matrix based on them. 
It converts the list to rank matrix automatically using the function 
<code>rankMatrix</code>. For most cases the ranking list is more convenient. Only 
in complicated cases, for example with top-k lists and structural missing values one 
would like to construct the rank matrix manually.  
</p>
<p>When the number of top elements included into input is specified in advance, for 
example some lists are limited to 100 elements, and the lengths of these lists differ 
significantly, we can use more sensitive and accurate algorithm for the score 
calculation. Then one has to specify in the input also the parameter topCutoff, which 
is a vector defining an cutoff value for each input list. For example if we have three 
lists of 1000 elements but first is limited to 100, second 200 and third to 900 
elements, then the topCutoff parameter should be c(0.1, 0.2, 0.9).
</p>


<h3>Value</h3>

<p>Returns a two column dataframe with the element names and associated scores 
or p-values.
</p>


<h3>Author(s)</h3>

<p>Raivo Kolde &lt;rkolde@gmail.com&gt;
</p>


<h3>References</h3>

<p>Raivo Kolde, Sven Laur, Priit Adler, Jaak Vilo, Robust rank aggregation for gene list integration and meta-analysis, Bioinformatics, 2012,, https://doi.org/10.1093/bioinformatics/btr709
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Make sample input data
glist &lt;- list(sample(letters, 4), sample(letters, 10), sample(letters, 12))

# Aggregate the inputs
aggregateRanks(glist = glist, N = length(letters))
aggregateRanks(glist = glist, N = length(letters), method = "stuart")

# Since we know the cutoffs for the lists in advance (4, 10, 12) we can use
# the more accurate algorithm with parameter topCutoff

# Use the rank matrix instead of the gene lists as the input
r = rankMatrix(glist)

aggregateRanks(rmat = r)

# Example, when the input lists represent full rankings but the domains do not match 
glist &lt;- list(sample(letters[4:24]), sample(letters[2:22]), sample(letters[1:20]))
r = rankMatrix(glist, full = TRUE) 
head(r)

aggregateRanks(rmat = r, method = "RRA")

# Dataset representing significantly changed genes after knockouts 
# of cell cycle specific trancription factors
data(cellCycleKO)
r = rankMatrix(cellCycleKO$gl, N = cellCycleKO$N)
ar = aggregateRanks(rmat = r)
head(ar)

</code></pre>


</div>