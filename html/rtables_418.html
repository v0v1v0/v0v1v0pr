<div class="container">

<table style="width: 100%;"><tr>
<td>pag_tt_indices</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pagination of a <code>TableTree</code>
</h2>

<h3>Description</h3>

<p>Paginate an <code>rtables</code> table in the vertical and/or horizontal direction, as required for the specified page size.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pag_tt_indices(
  tt,
  lpp = 15,
  min_siblings = 2,
  nosplitin = character(),
  colwidths = NULL,
  max_width = NULL,
  fontspec = NULL,
  col_gap = 3,
  verbose = FALSE
)

paginate_table(
  tt,
  page_type = "letter",
  font_family = "Courier",
  font_size = 8,
  lineheight = 1,
  landscape = FALSE,
  pg_width = NULL,
  pg_height = NULL,
  margins = c(top = 0.5, bottom = 0.5, left = 0.75, right = 0.75),
  lpp = NA_integer_,
  cpp = NA_integer_,
  min_siblings = 2,
  nosplitin = character(),
  colwidths = NULL,
  tf_wrap = FALSE,
  max_width = NULL,
  fontspec = font_spec(font_family, font_size, lineheight),
  col_gap = 3,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tt</code></td>
<td>
<p>(<code>TableTree</code> or related class)<br> a <code>TableTree</code> object representing a populated table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpp</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> maximum lines per page including (re)printed header and context rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_siblings</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> minimum sibling rows which must appear on either side of pagination row for a
mid-subtable split to be valid. Defaults to 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nosplitin</code></td>
<td>
<p>(<code>character</code>)<br> names of sub-tables where page-breaks are not allowed, regardless of other
considerations. Defaults to none.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colwidths</code></td>
<td>
<p>(<code>numeric</code>)<br> a vector of column widths for use in vertical pagination.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_width</code></td>
<td>
<p>(<code>integer(1)</code>, <code>string</code> or <code>NULL</code>)<br> width that title and footer (including
footnotes) materials should be word-wrapped to. If <code>NULL</code>, it is set to the current print width of the
session (<code>getOption("width")</code>). If set to <code>"auto"</code>, the width of the table (plus any table inset) is
used. Parameter is ignored if <code>tf_wrap = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fontspec</code></td>
<td>
<p>(<code>font_spec</code>)<br> a font_spec object specifying the font information to use for
calculating string widths and heights, as returned by <code>font_spec()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_gap</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> space (in characters) between columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>(<code>flag</code>)<br> whether additional information should be displayed to the user. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>page_type</code></td>
<td>
<p>(<code>string</code>)<br> name of a page type. See <code>page_types</code>. Ignored
when <code>pg_width</code> and <code>pg_height</code> are set directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font_family</code></td>
<td>
<p>(<code>string</code>)<br> name of a font family. An error will be thrown
if the family named is not monospaced. Defaults to <code>"Courier"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>font_size</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> font size. Defaults to <code>12</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lineheight</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> line height. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>landscape</code></td>
<td>
<p>(<code>flag</code>)<br> whether the dimensions of <code>page_type</code> should be
inverted for landscape orientation. Defaults to <code>FALSE</code>, ignored when <code>pg_width</code> and
<code>pg_height</code> are set directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pg_width</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> page width in inches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pg_height</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> page height in inches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margins</code></td>
<td>
<p>(<code>numeric(4)</code>)<br> named numeric vector containing <code>"bottom"</code>, <code>"left"</code>,
<code>"top"</code>, and <code>"right"</code> margins in inches. Defaults to <code>.5</code> inches for both vertical
margins and <code>.75</code> for both horizontal margins.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpp</code></td>
<td>
<p>(<code>numeric(1)</code> or <code>NULL</code>)<br> width (in characters) of the pages for horizontal pagination.
<code>NA</code> (the default) indicates <code>cpp</code> should be inferred from the page size; <code>NULL</code> indicates no horizontal
pagination should be done regardless of page size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tf_wrap</code></td>
<td>
<p>(<code>flag</code>)<br> whether the text for title, subtitles, and footnotes should be wrapped.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>rtables</code> pagination is context aware, meaning that label rows and row-group summaries (content rows) are repeated
after (vertical) pagination, as appropriate. This allows the reader to immediately understand where they are in the
table after turning to a new page, but does also mean that a rendered, paginated table will take up more lines of
text than rendering the table without pagination would.
</p>
<p>Pagination also takes into account word-wrapping of title, footer, column-label, and formatted cell value content.
</p>
<p>Vertical pagination information (pagination <code>data.frame</code>) is created using (<code>make_row_df</code>).
</p>
<p>Horizontal pagination is performed by creating a pagination data frame for the columns, and then applying the same
algorithm used for vertical pagination to it.
</p>
<p>If physical page size and font information are specified, these are used to derive lines-per-page (<code>lpp</code>) and
characters-per-page (<code>cpp</code>) values.
</p>
<p>The full multi-direction pagination algorithm then is as follows:
</p>

<ol><li>
<p> Adjust <code>lpp</code> and <code>cpp</code> to account for rendered elements that are not rows (columns):
</p>
</li></ol>
<ul>
<li>
<p> titles/footers/column labels, and horizontal dividers in the vertical pagination case
</p>
</li>
<li>
<p> row-labels, table_inset, and top-left materials in the horizontal case
</p>
</li>
</ul>
<ol>
<li>
<p> Perform 'forced pagination' representing page-by row splits, generating 1 or more tables.
</p>
</li>
<li>
<p> Perform vertical pagination separately on each table generated in (1).
</p>
</li>
<li>
<p> Perform horizontal pagination <strong>on the entire table</strong> and apply the results to each table
page generated in (1)-(2).
</p>
</li>
<li>
<p> Return a list of subtables representing full bi-directional pagination.
</p>
</li>
</ol>
<p>Pagination in both directions is done using the <em>Core Pagination Algorithm</em> implemented in the <code>formatters</code> package:
</p>


<h3>Value</h3>


<ul>
<li> <p><code>pag_tt_indices</code> returns a list of paginated-groups of row-indices of <code>tt</code>.
</p>
</li>
<li> <p><code>paginate_table</code> returns the subtables defined by subsetting by the indices defined by <code>pag_tt_indices</code>.
</p>
</li>
</ul>
<h3>Pagination Algorithm</h3>

<p>Pagination is performed independently in the vertical and horizontal
directions based solely on a <em>pagination data frame</em>, which includes the
following information for each row/column:
</p>

<ul>
<li>
<p> Number of lines/characters rendering the row will take <strong>after
word-wrapping</strong> (<code>self_extent</code>)
</p>
</li>
<li>
<p> The indices (<code>reprint_inds</code>) and number of lines (<code>par_extent</code>)
of the rows which act as <strong>context</strong> for the row
</p>
</li>
<li>
<p> The row's number of siblings and position within its siblings
</p>
</li>
</ul>
<p>Given <code>lpp</code> (<code>cpp</code>) is already adjusted for rendered elements which
are not rows/columns and a data frame of pagination information,
pagination is performed via the following algorithm with <code>start = 1</code>.
</p>
<p>Core Pagination Algorithm:
</p>

<ol>
<li>
<p> Initial guess for pagination position is <code>start + lpp</code> (<code>start + cpp</code>)
</p>
</li>
<li>
<p> While the guess is not a valid pagination position, and <code>guess &gt; start</code>,
decrement guess and repeat.
</p>

<ul><li>
<p> An error is thrown if all possible pagination positions between
<code>start</code> and <code>start + lpp</code> (<code>start + cpp</code>) would be <code style="white-space: pre;">⁠&lt; start⁠</code>
after decrementing
</p>
</li></ul>
</li>
<li>
<p> Retain pagination index
</p>
</li>
<li>
<p> If pagination point was less than <code>NROW(tt)</code> (<code>ncol(tt)</code>), set
<code>start</code> to <code>pos + 1</code>, and repeat steps (1) - (4).
</p>
</li>
</ol>
<p>Validating Pagination Position:
</p>
<p>Given an (already adjusted) <code>lpp</code> or <code>cpp</code> value, a pagination is invalid if:
</p>

<ul>
<li>
<p> The rows/columns on the page would take more than (adjusted) <code>lpp</code> lines/<code>cpp</code>
characters to render <strong>including</strong>:
</p>

<ul>
<li>
<p> word-wrapping
</p>
</li>
<li>
<p> (vertical only) context repetition
</p>
</li>
</ul>
</li>
<li>
<p> (vertical only) footnote messages and/or section divider lines
take up too many lines after rendering rows
</p>
</li>
<li>
<p> (vertical only) row is a label or content (row-group summary) row
</p>
</li>
<li>
<p> (vertical only) row at the pagination point has siblings, and
it has less than <code>min_siblings</code> preceding or following siblings
</p>
</li>
<li>
<p> pagination would occur within a sub-table listed in <code>nosplitin</code>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">s_summary &lt;- function(x) {
  if (is.numeric(x)) {
    in_rows(
      "n" = rcell(sum(!is.na(x)), format = "xx"),
      "Mean (sd)" = rcell(c(mean(x, na.rm = TRUE), sd(x, na.rm = TRUE)),
        format = "xx.xx (xx.xx)"
      ),
      "IQR" = rcell(IQR(x, na.rm = TRUE), format = "xx.xx"),
      "min - max" = rcell(range(x, na.rm = TRUE), format = "xx.xx - xx.xx")
    )
  } else if (is.factor(x)) {
    vs &lt;- as.list(table(x))
    do.call(in_rows, lapply(vs, rcell, format = "xx"))
  } else {
    (
      stop("type not supported")
    )
  }
}

lyt &lt;- basic_table() %&gt;%
  split_cols_by(var = "ARM") %&gt;%
  analyze(c("AGE", "SEX", "BEP01FL", "BMRKR1", "BMRKR2", "COUNTRY"), afun = s_summary)

tbl &lt;- build_table(lyt, ex_adsl)
tbl

nrow(tbl)

row_paths_summary(tbl)

tbls &lt;- paginate_table(tbl, lpp = 15)
mf &lt;- matrix_form(tbl, indent_rownames = TRUE)
w_tbls &lt;- propose_column_widths(mf) # so that we have the same column widths


tmp &lt;- lapply(tbls, function(tbli) {
  cat(toString(tbli, widths = w_tbls))
  cat("\n\n")
  cat("~~~~ PAGE BREAK ~~~~")
  cat("\n\n")
})

</code></pre>


</div>