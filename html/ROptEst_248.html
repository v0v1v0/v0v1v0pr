<div class="container">

<table style="width: 100%;"><tr>
<td>radiusMinimaxIC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic function for the computation of the radius minimax IC</h2>

<h3>Description</h3>

<p>Generic function for the computation of the radius minimax IC.
</p>


<h3>Usage</h3>

<pre><code class="language-R">radiusMinimaxIC(L2Fam, neighbor, risk, ...)

## S4 method for signature 'L2ParamFamily,UncondNeighborhood,asGRisk'
radiusMinimaxIC(
        L2Fam, neighbor, risk, loRad = 0, upRad = Inf, z.start = NULL, A.start = NULL, 
        upper = NULL, lower = NULL, OptOrIter = "iterate",
        maxiter = 50, tol = .Machine$double.eps^0.4,
        warn = FALSE, verbose = NULL, loRad0 = 1e-3, ...,
        returnNAifProblem = FALSE, loRad.s = NULL, upRad.s = NULL,
        modifyICwarn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRad</code></td>
<td>
<p> the lower end point of the interval to be searched
in the inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upRad</code></td>
<td>
<p> the upper end point of the interval to be searched in the
inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> the maximum number of iterations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p> logical: print warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRad0</code></td>
<td>
<p> for numerical reasons: the effective lower bound for the zero search;
internally set to <code>max(loRad,loRad0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed on to <code>getInfRobIC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnNAifProblem</code></td>
<td>
<p>logical (of length 1):
if <code>TRUE</code> (not the default), in case of convergence problems in
the algorithm, returns <code>NA</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRad.s</code></td>
<td>
<p> the lower end point of the interval
to be searched in the outer optimization
(for the user-guessed radius); if <code>NULL</code> (default)
set to <code>loRad</code> in the algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upRad.s</code></td>
<td>
<p> the upper end point of the interval to be searched in the
outer optimization (for the user-guessed radius); if
<code>NULL</code> (default) set to <code>upRad</code> in the algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In case the neighborhood radius is unknown, Rieder et al. (2001, 2008)
and Kohl (2005) show that there is nevertheless a way to compute an
optimally robust IC - the so-called radius-minimax IC - which is 
optimal for some radius interval.
</p>


<h3>Value</h3>

<p>The radius minimax IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>L2Fam = "L2ParamFamily", neighbor = "UncondNeighborhood", risk = "asGRisk":</dt>
<dd> 
<p>computation of the radius minimax IC for an L2 differentiable parametric family. </p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code>radiusMinimaxIC</code></p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- NormLocationFamily(mean=0, sd=1) 
radIC &lt;- radiusMinimaxIC(L2Fam=N, neighbor=ContNeighborhood(), 
                         risk=asMSE(), loRad=0.1, upRad=0.5)
checkIC(radIC)
</code></pre>


</div>