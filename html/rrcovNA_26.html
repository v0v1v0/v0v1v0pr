<div class="container">

<table style="width: 100%;"><tr>
<td>PcaNA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Classical or robust Principal Components for incomplete data</h2>

<h3>Description</h3>

<p>Computes classical and robust principal components for incomplete data using an EM algorithm as descibed by Serneels and Verdonck (2008)
</p>


<h3>Usage</h3>

<pre><code class="language-R">PcaNA(x, ...)
## Default S3 method:
PcaNA(x, k = ncol(x), kmax = ncol(x), conv=1e-10, maxiter=100, 
    method=c("cov", "locantore", "hubert", "grid", "proj", "class"), cov.control=NULL,
    scale = FALSE, signflip = TRUE, crit.pca.distances = 0.975, trace=FALSE, ...)
## S3 method for class 'formula'
PcaNA(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame (or similar: see
<code>model.frame</code>) containing the variables in the
formula <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code>options</code>, and is
<code>na.fail</code> if that is unset. The default is <code>na.omit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, the algorithm itself will determine the number of 
components by finding such <code>k</code> that <code class="reqn">l_k/l_1 &gt;= 10.E-3</code> and 
<code class="reqn">\Sigma_{j=1}^k l_j/\Sigma_{j=1}^r l_j &gt;= 0.8</code>. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=ncol(x)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code> 
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>convergence criterion for the EM algorithm.
Default is <code>conv=1e-10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximal number of iterations for the EM algorithm.
Default is <code>maxiter=100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>which PC method to use (classical or robust) - "class" means classical PCA 
and one of the following "locantore", "hubert", "grid", "proj", "cov" specifies a 
robust PCA method. If the method is "cov" - i.e. PCA based on a robust covariance matrix - 
the argument <code>cov.control</code> can specify which method for computing the 
(robust) covariance matrix will be used. 
Default is <code>method="locantore"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.control</code></td>
<td>
<p>control object in case of robust PCA based on a robust covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical value indicating whether the variables should be 
scaled to have unit variance (only possible if there are no constant 
variables). As a scale function <code>mad</code> is used but alternatively, a vector of length equal 
the number of columns of x can be supplied. The value is passed to 
scale and the result of the scaling is stored in the <code>scale</code> slot. 
Default is <code>scale = FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signflip</code></td>
<td>
<p>a logical value indicating wheather to try to solve the sign indeterminancy of the loadings -   
ad hoc approach setting the maximum element in a singular vector to be positive. Default is <code>signflip = FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit.pca.distances</code></td>
<td>
<p>criterion to use for computing the cutoff values for the orthogonal and score distances. Default is 0.975.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>PcaNA</code>, serving as a constructor for objects of class <code>PcaNA</code> 
is a generic function with "formula" and "default" methods. For details see the relevant references.
</p>


<h3>Value</h3>

<p>An S4 object of class <code>PcaNA</code> which is a subclass of the 
virtual class <code>Pca-class</code>. 
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>Serneels S &amp; Verdonck T (2008),
Principal component analysis for data containing outliers and missing elements.
<em>Computational Statistics and Data Analisys</em>, <b>52</b>(3), 1712–1727 .
</p>
<p>Todorov V &amp; Filzmoser P (2009),
An Object Oriented Framework for Robust Multivariate Analysis.
<em>Journal of Statistical Software</em>, <b>32</b>(3), 1–47.
&lt;doi:10.18637/jss.v032.i03&gt;.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## 1. With complete data
## PCA of the bushfire data
    data(bushfire)
    pca &lt;- PcaNA(bushfire)
    pca

## Compare with the classical PCA
    prcomp(bushfire)

## or  
    PcaNA(bushfire, method="class")
    
## If you want to print the scores too, use
    print(pca, print.x=TRUE)

## Using the formula interface
    PcaNA(~., data=bushfire)

## To plot the results:

    plot(pca)                    # distance plot
    pca2 &lt;- PcaNA(bushfire, k=2)  
    plot(pca2)                   # PCA diagnostic plot (or outlier map)
    
## Use the standard plots available for for prcomp and princomp
    screeplot(pca)    
    biplot(pca)  

################################################################      
## 2. Now the same wit incomplete data - bush10
    data(bush10)
    pca &lt;- PcaNA(bush10)
    pca

## Compare with the classical PCA
    PcaNA(bush10, method="class")
    
## If you want to print the scores too, use
    print(pca, print.x=TRUE)

## Using the formula interface
    PcaNA(~., data=as.data.frame(bush10))

## To plot the results:

    plot(pca)                    # distance plot
    pca2 &lt;- PcaNA(bush10, k=2)  
    plot(pca2)                   # PCA diagnostic plot (or outlier map)
    
## Use the standard plots available for for prcomp and princomp
    screeplot(pca)    
    biplot(pca)    
    
</code></pre>


</div>