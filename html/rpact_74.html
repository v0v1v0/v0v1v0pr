<div class="container">

<table style="width: 100%;"><tr>
<td>getGroupSequentialProbabilities</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get Group Sequential Probabilities</h2>

<h3>Description</h3>

<p>Calculates probabilities in the group sequential setting.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getGroupSequentialProbabilities(decisionMatrix, informationRates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decisionMatrix</code></td>
<td>
<p>A matrix with either 2 or 4 rows and kMax = length(informationRates) columns, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>informationRates</code></td>
<td>
<p>The information rates t_1, ..., t_kMax (that must be fixed prior to the trial),
default is <code>(1:kMax) / kMax</code>. For the weighted inverse normal design, the weights are derived
through w_1 = sqrt(t_1), and w_k = sqrt(t_k - t_(k-1)). For the weighted Fisher's combination test, the
weights (scales) are w_k = sqrt((t_k - t_(k-1)) / t_1) (see the documentation).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given a sequence of information rates (fixing the correlation structure), and
decisionMatrix with either 2 or 4 rows and kMax = length(informationRates) columns,
this function calculates a probability matrix containing, for two rows, the probabilities:<br>
P(Z_1 &lt; l_1), P(l_1 &lt; Z_1 &lt; u_1, Z_2 &lt; l_2),..., P(l_kMax-1 &lt; Z_kMax-1 &lt; u_kMax-1, Z_kMax &lt; l_l_kMax)<br>
P(Z_1 &lt; u_1), P(l_1 &lt; Z_1 &lt; u_1, Z_2 &lt; u_2),..., P(l_kMax-1 &lt; Z_kMax-1 &lt; u_kMax-1, Z_kMax &lt; u_l_kMax)<br>
P(Z_1 &lt; Inf), P(l_1 &lt; Z_1 &lt; u_1, Z_2 &lt; Inf),..., P(l_kMax-1 &lt; Z_kMax-1 &lt; u_kMax-1, Z_kMax &lt; Inf)<br>
with continuation matrix<br>
l_1,...,l_kMax<br>
u_1,...,u_kMax<br>
That is, the output matrix of the function provides per stage (column) the cumulative probabilities
for values specified in decisionMatrix and Inf, and reaching the stage, i.e., the test
statistics is in the continuation region for the preceding stages.
For 4 rows, the continuation region contains of two regions and the probability matrix is
obtained analogously (cf., Wassmer and Brannath, 2016).
</p>


<h3>Value</h3>

<p>Returns a numeric matrix containing the probabilities described in the details section.
</p>


<h3>See Also</h3>

<p>Other design functions: 
<code>getDesignCharacteristics()</code>,
<code>getDesignConditionalDunnett()</code>,
<code>getDesignFisher()</code>,
<code>getDesignGroupSequential()</code>,
<code>getDesignInverseNormal()</code>,
<code>getPowerAndAverageSampleNumber()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Calculate Type I error rates in the two-sided group sequential setting when
# performing kMax stages with constant critical boundaries at level alpha:
alpha &lt;- 0.05
kMax &lt;- 10
decisionMatrix &lt;- matrix(c(
    rep(-qnorm(1 - alpha / 2), kMax),
    rep(qnorm(1 - alpha / 2), kMax)
), nrow = 2, byrow = TRUE)
informationRates &lt;- (1:kMax) / kMax
probs &lt;- getGroupSequentialProbabilities(decisionMatrix, informationRates)
cumsum(probs[3, ] - probs[2, ] + probs[1, ])

# Do the same for a one-sided design without futility boundaries:
decisionMatrix &lt;- matrix(c(
    rep(-Inf, kMax),
    rep(qnorm(1 - alpha), kMax)
), nrow = 2, byrow = TRUE)
informationRates &lt;- (1:kMax) / kMax
probs &lt;- getGroupSequentialProbabilities(decisionMatrix, informationRates)
cumsum(probs[3, ] - probs[2, ])

# Check that two-sided Pampallona and Tsiatis boundaries with binding 
# futility bounds obtain Type I error probabilities equal to alpha:
x &lt;- getDesignGroupSequential(
    alpha = 0.05, beta = 0.1, kMax = 3, typeOfDesign = "PT",
    deltaPT0 = 0, deltaPT1 = 0.4, sided = 2, bindingFutility = TRUE
)
dm &lt;- matrix(c(
    -x$criticalValues, -x$futilityBounds, 0,
    x$futilityBounds, 0, x$criticalValues
), nrow = 4, byrow = TRUE)
dm[is.na(dm)] &lt;- 0
probs &lt;- getGroupSequentialProbabilities(
    decisionMatrix = dm, informationRates = (1:3) / 3
)
sum(probs[5, ] - probs[4, ] + probs[1, ])

# Check the Type I error rate decrease when using non-binding futility bounds:
x &lt;- getDesignGroupSequential(
    alpha = 0.05, beta = 0.1, kMax = 3, typeOfDesign = "PT",
    deltaPT0 = 0, deltaPT1 = 0.4, sided = 2, bindingFutility = FALSE
)
dm &lt;- matrix(c(
    -x$criticalValues, -x$futilityBounds, 0,
    x$futilityBounds, 0, x$criticalValues
), nrow = 4, byrow = TRUE)
dm[is.na(dm)] &lt;- 0
probs &lt;- getGroupSequentialProbabilities(
    decisionMatrix = dm, informationRates = (1:3) / 3
)
sum(probs[5, ] - probs[4, ] + probs[1, ])

## End(Not run)

</code></pre>


</div>