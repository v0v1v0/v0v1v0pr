<div class="container">

<table style="width: 100%;"><tr>
<td>niftyreg.nonlinear</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two and three dimensional nonlinear image registration</h2>

<h3>Description</h3>

<p>The <code>niftyreg.nonlinear</code> function performs nonlinear registration for
two and three dimensional images. 4D images may also be registered
volumewise to a 3D image, or 3D images slicewise to a 2D image. The warping
is based on free-form deformations, parameterised using an image of control
points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">niftyreg.nonlinear(source, target, init = NULL, sourceMask = NULL,
  targetMask = NULL, symmetric = TRUE, nLevels = 3L,
  maxIterations = 150L, nBins = 64L, bendingEnergyWeight = 0.001,
  linearEnergyWeight = 0.01, jacobianWeight = 0, finalSpacing = c(5, 5,
  5), spacingUnit = c("voxel", "world"), interpolation = 3L,
  verbose = FALSE, estimateOnly = FALSE, sequentialInit = FALSE,
  internal = NA, precision = c("double", "single"),
  threads = getOption("RNiftyReg.threads"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>source</code></td>
<td>
<p>The source image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2, 3 or 4 dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>The target image, an object of class <code>"nifti"</code> or
<code>"internalImage"</code>, or a plain array, or a NIfTI-1 filename. Must have
2 or 3 dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Transformation(s) to be used for initialisation, which may be
<code>NULL</code>, for no initialisation, or an affine matrix or control point
image (nonlinear only). For multiple registration, where the source image
has one more dimension than the target, this may also be a list whose
components are likewise <code>NULL</code> or a suitable initial transform.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sourceMask</code></td>
<td>
<p>An optional mask image in source space, whose nonzero
region will be taken as the region of interest for the registration.
Ignored when <code>symmetric</code> is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targetMask</code></td>
<td>
<p>An optional mask image in target space, whose nonzero
region will be taken as the region of interest for the registration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>Logical value. Should forward and reverse transformations
be estimated simultaneously?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nLevels</code></td>
<td>
<p>A single integer specifying the number of levels of the
algorithm that should be applied. If zero, no optimisation will be
performed, and the final control-point image will be the same as its
initialisation value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIterations</code></td>
<td>
<p>A single integer specifying the maximum number of
iterations to be used within each level. Fewer iterations may be used if a
convergence test deems the process to have completed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nBins</code></td>
<td>
<p>A single integer giving the number of bins to use for the joint
histogram created by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bendingEnergyWeight</code></td>
<td>
<p>A numeric value giving the weight of the bending
energy term in the cost function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linearEnergyWeight</code></td>
<td>
<p>A numeric value giving the weight of the linear
energy term in the cost function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jacobianWeight</code></td>
<td>
<p>A numeric value giving the weight of the Jacobian
determinant term in the cost function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finalSpacing</code></td>
<td>
<p>A numeric vector giving the spacing of control points in
the final grid, along the X, Y and Z directions respectively. This is set
from the initial control point image, if one is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spacingUnit</code></td>
<td>
<p>A character string giving the units in which the
<code>finalSpacing</code> is specified: either <code>"voxel"</code> for pixels/voxels,
or <code>"world"</code> for real-world units (see <code>pixunits</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolation</code></td>
<td>
<p>A single integer specifying the type of interpolation
to be applied to the final resampled image. May be 0 (nearest neighbour),
1 (trilinear) or 3 (cubic spline). No other values are valid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A single logical value: if <code>TRUE</code>, the code will give
some feedback on its progress; otherwise, nothing will be output while the
algorithm runs. Run time can be seconds or more, depending on the size and
dimensionality of the images.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimateOnly</code></td>
<td>
<p>Logical value: if <code>TRUE</code>, transformations will be
estimated, but images will not be resampled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sequentialInit</code></td>
<td>
<p>If <code>TRUE</code> and <code>source</code> has higher
dimensionality than <code>target</code>, transformations which are not
explicitly initialised will begin from the result of the previous
registration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>internal</code></td>
<td>
<p>If <code>NA</code>, the default, the final resampled image will be
returned as a standard R array, but control point maps will be objects of
class <code>"internalImage"</code>, containing only basic metadata and a C-level
pointer to the full image. (See also <code>readNifti</code>.) If
<code>TRUE</code>, all image-type objects in the result will be internal images;
if <code>FALSE</code>, they will all be R arrays. The default is fine for most
purposes, but using <code>TRUE</code> may save memory, while using <code>FALSE</code>
can be necessary if there is a chance that external pointers will be
invalidated, for example when returning from worker threads.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p>Working precision for the registration. Using single-
precision may be desirable to save memory when coregistering large images.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>For OpenMP-capable builds of the package, the maximum number
of threads to use.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function performs the dual operations of finding a transformation to
optimise image alignment, and resampling the source image into the space of
the target image (and vice-versa, if <code>symmetric</code> is <code>TRUE</code>).
Unlike <code>niftyreg.linear</code>, this transformation is nonlinear, and
the degree of deformation may vary across the image.
</p>
<p>The nonlinear warping is based on free-form deformations. A lattice of
equally-spaced control points is defined over the target image, each of
which can be moved to locally modify the mapping to the source image. In
order to assess the quality of the warping between the two images, an
objective function based on the normalised mutual information is used, with
penalty terms based on the bending energy or the squared log of the Jacobian
determinant. The objective function value is optimised using a conjugate
gradient scheme.
</p>
<p>The source image may have 2, 3 or 4 dimensions, and the target 2 or 3. The
dimensionality of the target image determines whether 2D or 3D registration
is applied, and source images with one more dimension than the target (i.e.
4D to 3D, or 3D to 2D) will be registered volumewise or slicewise, as
appropriate. In the latter case the last dimension of the resulting image is
taken from the source image, while all other dimensions come from the
target. One image of control points is returned for each registration
performed.
</p>


<h3>Value</h3>

<p>See <code>niftyreg</code>.
</p>


<h3>Note</h3>

<p>Performing a linear registration first, and then initialising the
nonlinear transformation with the result (via the <code>init</code> parameter),
is highly recommended in most circumstances.
</p>


<h3>Author(s)</h3>

<p>Jon Clayden &lt;code@clayden.org&gt;
</p>


<h3>References</h3>

<p>The algorithm used by this function is described in the
following publication.
</p>
<p>M. Modat, G.R. Ridgway, Z.A. Taylor, M. Lehmann, J. Barnes, D.J. Hawkes,
N.C. Fox &amp; S. Ourselin (2010). Fast free-form deformation using graphics
processing units. Computer Methods and Programs in Biomedicine
98(3):278-284.
</p>


<h3>See Also</h3>

<p><code>niftyreg</code>, which can be used as an interface to this
function, and <code>niftyreg.linear</code> for linear registration. Also,
<code>forward</code> and <code>reverse</code> to extract
transformations, and <code>applyTransform</code> to apply them to new
images or points.
</p>


</div>