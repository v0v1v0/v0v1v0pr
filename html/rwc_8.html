<div class="container">

<table style="width: 100%;"><tr>
<td>mcmc.wish.icar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Markov chain Monte Carlo sampler for Generalized Wishart distance
matrix data arising from an ICAR spatial model.

</h2>

<h3>Description</h3>

<p>Constructs and runs an MCMC sampler to estimate resistance
parameters of different landscape features.

</p>


<h3>Usage</h3>

<pre><code class="language-R">mcmc.wish.icar(Dobs, TL, obs.idx, df=1,
               beta.start = rep(0, length(TL)),
               beta.prior.mean = rep(0, length(TL)),
               beta.prior.cov = diag(10, length(TL)),
               tau.start = 0.1, tau.prior.var = 1,
               theta.tune = diag(10^-4,length(TL)+1),
               n.mcmc=100, adapt.max=10000, adapt.int=100,
               print.iter=FALSE, output.trace.plot=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Dobs</code></td>
<td>
<p>A square symmetric matrix of observed pairwise distances.
For example, a genetic distance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TL</code></td>
<td>
<p>A list of transition matrices for different covariate raster
layers, created by get.TL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.idx</code></td>
<td>
<p>A vector of unique indices of observed nodes in the
graph defined by the raster grid. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>An integer specifying the degrees of freedom of Dobs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.start</code></td>
<td>
<p>Vector of initial values for conductance parameters
beta.  Default is a vector of zeros.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.prior.mean</code></td>
<td>
<p>Vector of prior mean values for conductance parameters
beta.  Default is a vector of zeros.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.prior.cov</code></td>
<td>
<p>Matrix of the prior covariance matrix for conductance parameters
beta.  Default is a diagonal matrix with diagonal entries equal to
10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.start</code></td>
<td>
<p>Numeric starting value for the nugget variance tau.
Default is 0.1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau.prior.var</code></td>
<td>
<p>Variance of the half-normal prior for tau.
Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.tune</code></td>
<td>
<p>Covariance matrix for the random walk MH sampler
for all parameters.  Default is a diagonal matrix with variance
10^-4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.mcmc</code></td>
<td>
<p>Integer number of iterations of the MCMC sampler to
run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt.max</code></td>
<td>
<p>Integer number (or INF) specifying the last iteration
at which the covariance matrix of the proposal distribution will be
adapted.  Default is 10^5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt.int</code></td>
<td>
<p>Interval at which the covariance matrix of the proposal
distribution is adapted.  Default is every 100 iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.iter</code></td>
<td>
<p>Logical.  If TRUE, then the current state of the
system will be printed to the console every 100 iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output.trace.plot</code></td>
<td>
<p>Logical.  If TRUE, then the trace plots of the
sampler will be saved to "traceOut.pdf" every 100 iterations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Runs an MCMC sampler to draw samples from the posterior distribution
of model parameters (beta,tau) from the following model for an
observed squared distance matrix Dobs:
</p>
<p>-Dobs ~ GenWish(2*Sigma,df)
</p>
<p>Sigma = K(Psi)K'+tau*I
</p>
<p>where Psi is the covariance matrix of the observed nodes of a graph
described by the transition list TL.  That is, the total graph has
Laplacian (precision) matrix Q, with off-diagonal entries of Q given
by
</p>
<p>Q_ij = exp( b0 + b1 x_1ij + ... + bp x_pij ), where beta=(b1,b2,...,bp) is
a vector of log-conductance values of the covariates x_kij.  Each
x_kij is equal to (x_ki+x_kj)/2.
</p>
<p>The prior on beta is N(beta.prior.mean,beta.prior.cov), and the prior
on tau is tau~Half_Normal(0,tau.prior.var).
</p>


<h3>Value</h3>

<p> A list containing output from the MCMC sampler.
</p>
<table><tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Posterior samples for conductance parameters beta.</p>
</td>
</tr></table>
<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>Hanks and Hooten 2013.  Circuit theory and model-based inference for
landscape connectivity.  Journal of the American Statistical
Association.  108(501), 22-33.

</p>


<h3>Examples</h3>

<pre><code class="language-R">

## Not run: 
## The following code conducts a simulation example by
## first simulating a heterogeneous landscape, then
## simulating pairwise distance data on the landscape
## and finally making inference on model parameters.

library(rwc)
library(MASS)

## source("GenWishFunctions_20170901.r")

##
## specify 2-d raster
##


ras=raster(nrow=30,ncol=30)
extent(ras) &lt;- c(0,30,0,30)
values(ras) &lt;- 1
plot(ras,asp=1)
ras

int=ras
cov.ras=ras



## simulate "resistance" raster
TL.int=get.TL(int)
Q.int=get.Q(TL.int,1)
set.seed(1248)
## values(cov.ras) &lt;- as.numeric(rnorm.Q(Q.int
values(cov.ras) &lt;- as.numeric(rnorm.Q(Q.int,zero.constraint=TRUE))
plot(cov.ras)


stack=stack(int,cov.ras)
plot(stack)
TL=get.TL(stack)


## Create "barrier" raster which has no effect, to test model selection

barrier=int
values(barrier) &lt;- 0
barrier[,10:11] &lt;- 1

plot(barrier)

TL.all=get.TL(stack(int,cov.ras,barrier))


##
## sampling locations
##

nsamps=150
set.seed(4567)
samp.xy=cbind(runif(nsamps,0,30),runif(nsamps,0,30))
## samp.xy=samp.xy[rep(1:nsamps,times=5),]
samp.locs=cellFromXY(int,samp.xy)
samp.cells=unique(samp.locs)
nsamps=nrow(samp.xy)

plot(cov.ras)
points(samp.xy)

K=matrix(0,nrow=nsamps,ncol=length(samp.cells))
for(i in 1:nsamps){
    K[i,which(samp.cells==samp.locs[i])]=1
}
image(K)

##
## beta values
##


betas=c(-2,-1)
tau=.01


Q=get.Q(TL,betas)
Phi=get.Phi(Q,samp.cells)



## simulate from ibr model
D.rand.ibr=rGenWish(df=20,Sigma=K%*%ginv(as.matrix(Phi))%*%t(K) + diag(nsamps)*tau)
image(D.rand.ibr)


## crude plot of geographic distance vs genetic distance

plot(as.numeric(as.matrix(dist(xyFromCell(ras,samp.locs)))),as.numeric(D.rand.ibr))

##
## fitting using MCMC
## 

fit=mcmc.wish.icar(D.rand.ibr,TL,samp.locs,df=20,output.trace.plot=TRUE,
                   adapt.int=100,adapt.max=100000,n.mcmc=10000)

str(fit)


## End(Not run)
</code></pre>


</div>