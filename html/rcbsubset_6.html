<div class="container">

<table style="width: 100%;"><tr>
<td>dist2net</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Building and Manipulating Network Flow Problems
</h2>

<h3>Description</h3>

<p>These are internal rcbsubset methods not meant to be called directly by users.  They are used to construct a network flow problem from the information about a matching problem that is passed to the <code>rcbsubset</code> method.</p>


<h3>Usage</h3>

<pre><code class="language-R">dist2net(dist.struct, k, exclude.treated = FALSE, exclude.penalty = NULL, ncontrol = NULL,
	tol = 1e-3)

dist2net.matrix(dist.struct, k, exclude.treated = FALSE, exclude.penalty = NULL, 
	tol = 1e-3)

add.layer(net.layers, new.layer)

penalty.update(net.layers, newtheta, newp = NA)

penalize.near.exact(net.layers, near.exact)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dist.struct</code></td>
<td>

<p>an object specifying the sparsity structure of the match.  For the dist2net method it is a list of vectors, and for the dist2net.matrix method it is a matrix or InfinitySparseMatrix.   See rcbalance documentation for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>a nonnegative integer. The number of control units to which each treated unit will be matched.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.treated</code></td>
<td>

<p>if <code>TRUE</code>, then when there is no feasible match using all treated units, a minimal number of treated units may be dropped so that a match can be formed.  Specifying this argument adds penalized edges to the network so that such a match can be computed. NOTE: this argument is incompatible with values of <code>k</code> greater than 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.penalty</code></td>
<td>

<p>a parameter that gives the cost of excluding a treated unit.  If left NULL it will be set to a very large value designed to ensure treated units are never excluded if they can be matched.  Lower values may result in subsets of treated units being excluded.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncontrol</code></td>
<td>

<p>the total number of controls in the matching problem.  If left <code>NULL</code> the function will attempt to compute it by counting controls referenced in the distance object provided.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>edge cost tolerance.  This is the smallest tolerated difference between matching costs.  It is used in these functions only when exclude.penalty is NULL, to choose a default penalty that is small enough not to cause integer overflows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>net.layers</code></td>
<td>

<p>a layered network object of the type produced by the dist2net function.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.layer</code></td>
<td>

<p>a vector equal in length to the number of treated and control units in the matching problem.  Each coordinate contains the value of a new fine balance variable for the corresponding unit.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newtheta</code></td>
<td>
<p>optional argument giving a new value for the theta field of the net.layers object (see value section for description of this field).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newp</code></td>
<td>
<p>optional argument giving a new value for the p field of the net.layers object (see value section for description of this field).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>near.exact</code></td>
<td>
<p>a vector equal in length to the number of treated and control units in the matching problem.  Edges between units with different values of this variable will be penalized.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>dist2net</code> and <code>dist2net.matrix</code> take the distance structure given to <code>rcbalance</code> encoding information about the matching problem and converts it into a network flow problem.  <code>add.layer</code> adds network structure to handle an individual fine balance variable (it can be called iteratively to add many such variables).  <code>penalty.update</code> is used to change the penalties for each layer (and the penalties for edges used to exclude treated units if they are present) and <code>penalize.near.exact</code> is used to add penalties to the treated-control edges to allow near-exact matching. See the references for a detailed description of how the matching problem is transformed into a network.
</p>


<h3>Value</h3>

<p>A layered network object, formatted as a list with the following arguments (where narcs is the number of arcs and nnodes is the number of nodes in the network):
</p>
<table>
<tr style="vertical-align: top;">
<td><code>startn</code></td>
<td>
<p>a vector of length narc containing the node numbers of the start nodes of each arc in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endn</code></td>
<td>
<p> a vector of length narc containing the node numbers of the end nodes of each arc in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ucap</code></td>
<td>
<p> a vector of length narc containing the (integer) upper capacity of each arc in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p> a vector of length narc containing the (integer) cost of each arc in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p> a vector of length nnode containing the (integer) supply or demand of each node in the network.  Supplies are given as positive numbers and demands as negative numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tcarcs</code></td>
<td>
<p>an integer giving the total number of arcs between the treated and control nodes in the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layers</code></td>
<td>
<p>a list object containing information about the refined covariate balance layers of the network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>a vector of treatment indicators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fb.structure</code></td>
<td>
<p>a matrix containing information about the membership of the treated and control units in the different classes of refined balance covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalties</code></td>
<td>
<p>a vector of integer penalties, one for each fine balance layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>a value no less than 1 giving the ratio by which the penalty is increased with each additional layer of fine balance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a nonnegative value giving the penalty for the finest level of fine balance.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>


</div>