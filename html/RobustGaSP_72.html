<div class="container">

<table style="width: 100%;"><tr>
<td>predict.ppgasp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

Prediction for PP GaSP model
</h2>

<h3>Description</h3>


<p>Function to make prediction on the PP GaSP model after the PP GaSP model has been constructed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'ppgasp'
predict(object, testing_input, 
testing_trend= matrix(1,dim(testing_input)[1],1),r0=NA, 
interval_data=T,
outasS3 = T,loc_index=NA, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> an object of  class <code>ppgasp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testing_input</code></td>
<td>
<p>a matrix containing the inputs where the <code>rgasp</code> is to perform prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testing_trend</code></td>
<td>
<p>a matrix of mean/trend for prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r0</code></td>
<td>

<p>the distance between input and testing input. If the value 
is <code>NA</code>, it will be calculated later. It can also be 
specified by the user. If specified by user, it is either a 
<code>matrix</code> or <code>list</code>. The default value is <code>NA</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval_data</code></td>
<td>

<p>a boolean value. If <code>T</code>, the interval of the data will be   
calculated. Otherwise, the interval of the mean of the data will 
be calculted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outasS3</code></td>
<td>
<p>a boolean parameter indicating whether the output of the function should be as an <code>S3 object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc_index</code></td>
<td>
<p>specified coodinate index of the prediction. The default value is <code>NA</code> and prediction will be computed for all coordinates. If e.g. <code>loc_index=c(3,5)</code>, it means the prediction will be computed on only the third and fifth coordinates, corresponding the coordinates of the third and fifth columns of the output matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Extra arguments to be passed to the function (not implemented yet).</p>
</td>
</tr>
</table>
<h3>Value</h3>






<p>If the parameter <code>outasS3=F</code>, then the returned value is a <code>S4 object</code> of class <code>predppgasp-class</code> with 
</p>

<table>
<tr style="vertical-align: top;">
<td>
<code>call</code>:</td>
<td>
 <p><code>call</code> to <code>predict.ppgasp</code> function where the returned object has been created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td>
<code>mean</code>:</td>
<td>
<p> predictive mean for the testing inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td>
<code>lower95</code>:</td>
<td>
<p>lower bound of the 95% posterior credible interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td>
<code>upper95</code>:</td>
<td>
<p>upper bound of the 95% posterior credible interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td>
<code>sd</code>:</td>
<td>
<p>standard deviation of each <code>testing_input</code>.</p>
</td>
</tr>
</table>
<p>If the parameter <code>outasS3=T</code>, then the returned value is a <code>list</code> with 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mean </code></td>
<td>
<p> predictive mean for the testing inputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower95 </code></td>
<td>
<p>lower bound of the 95% posterior credible interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper95 </code></td>
<td>
<p>upper bound of the 95% posterior credible interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd </code></td>
<td>
<p>standard deviation of each <code>testing_input</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>


<p>Mengyang Gu [aut, cre],
  Jesus Palomo [aut],
  James Berger [aut]
</p>
<p>Maintainer: Mengyang Gu &lt;mengyang@pstat.ucsb.edu&gt;
</p>


<h3>References</h3>

<p>M. Gu. and J.O. Berger (2016). Parallel partial Gaussian process emulation for computer models with massive output. <em>Annals of Applied Statistics</em>, 10(3), 1317-1347.
</p>
<p>M. Gu. (2016). Robust Uncertainty Quantification and Scalable Computation for Computer Models with Massive Output. Ph.D. thesis. Duke University.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  library(RobustGaSP)
  #----------------------------------
  # an example of environmental model
  #----------------------------------
  
  set.seed(1)
  #Here the sample size is very small. Consider to use more observations 
  n=80
  p=4
  ##using the latin hypercube will be better
  #library(lhs)
  #input_samples=maximinLHS(n,p)
  input_samples=matrix(runif(n*p),n,p)
  input=matrix(0,n,p)
  input[,1]=7+input_samples[,1]*6
  input[,2]=0.02+input_samples[,2]*1
  input[,3]=0.01+input_samples[,3]*2.99
  input[,4]=30.01+input_samples[,4]*0.285
  
  k=300
  output=matrix(0,n,k)
  ##environ.4.data is an environmental model on a spatial-time vector
  ##? environ.4.data
  for(i in 1:n){
    output[i,]=environ.4.data(input[i,],s=seq(0.15,3,0.15),t=seq(4,60,4)  )
  }
  
  ##samples some test inputs
  n_star=1000
  sample_unif=matrix(runif(n_star*p),n_star,p)
  
  testing_input=matrix(0,n_star,p)
  testing_input[,1]=7+sample_unif[,1]*6
  testing_input[,2]=0.02+sample_unif[,2]*1
  testing_input[,3]=0.01+sample_unif[,3]*2.99
  testing_input[,4]=30.01+sample_unif[,4]*0.285
  
  
  testing_output=matrix(0,n_star,k)
  
  s=seq(0.15,3,0.15)
  t=seq(4,60,4) 
  
  for(i in 1:n_star){
    testing_output[i,]=environ.4.data(testing_input[i,],s=s,t=t )
  }
  
  ##we do a transformation of the output 
  ##one can change the number of initial values to test
  log_output_1=log(output+1)
  #since we have lots of output, we use 'nelder-mead' for optimization
  m.ppgasp=ppgasp(design=input,response=log_output_1,kernel_type
                  ='pow_exp',num_initial_values=2,optimization='nelder-mead')
  
  m_pred.ppgasp=predict(m.ppgasp,testing_input)
  ##we transform back for the prediction
  m_pred_ppgasp_median=exp(m_pred.ppgasp$mean)-1
  ##mean squared error
  mean( (m_pred_ppgasp_median-testing_output)^2)
  ##variance of the testing outputs
  var(as.numeric(testing_output))
  
  ##makes plots for the testing 
  par(mfrow=c(1,2))
  testing_plot_1=matrix(testing_output[1,],  length(t), length(s) )
  
  max_testing_plot_1=max(testing_plot_1)
  min_testing_plot_1=min(testing_plot_1)
  
  image(x=t,y=s,testing_plot_1,  col = hcl.colors(100, "terrain"),main='test outputs')
  contour(x=t,y=s,testing_plot_1, levels = seq(min_testing_plot_1, max_testing_plot_1,
                                               by = (max_testing_plot_1-min_testing_plot_1)/5),
          add = TRUE, col = "brown")
  
  ppgasp_plot_1=matrix(m_pred_ppgasp_median[1,],  length(t), length(s) )
  max_ppgasp_plot_1=max(ppgasp_plot_1)
  min_ppgasp_plot_1=min(ppgasp_plot_1)
  
  image(x=t,y=s,ppgasp_plot_1,  col = hcl.colors(100, "terrain"),main='prediction')
  contour(x=t,y=s,ppgasp_plot_1, levels = seq(min_testing_plot_1, max_ppgasp_plot_1,
                                              by = (max_ppgasp_plot_1-min_ppgasp_plot_1)/5),
          add = TRUE, col = "brown")
  dev.off()
  

</code></pre>


</div>