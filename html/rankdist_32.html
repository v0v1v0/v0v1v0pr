<div class="container">

<table style="width: 100%;"><tr>
<td>RankData-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>RankData Class</h2>

<h3>Description</h3>

<p>A S4 class to represent ranking data
</p>
<p>It is well understood that the ranking representation and ordering representation of ranking data can easily be confused.
I thus use a S4 class to store all the information about the ranking data. This can avoid unnecessary confusion.
</p>


<h3>Details</h3>

<p>It is possible to store both complete and top-q rankings in the same RankData object. Three slots <code>topq</code>, <code>subobs</code>, and
<code>q_ind</code> are introduced for this purpose. Note that there is generally no need to specify these slots if your data set only contains
a single "q" level (for example all data are top-10 rankings). The "q" level for complete ranking should be <code>nobj-1</code>.
Moreover, if the rankings are organized in chunks of increasing "q" levels (for
example, top-2 rankings followed by top-3 rankings followed by top-5 rankings etc.), then slots <code>subobs</code>, and <code>q_ind</code> can also be inferred
correctly by the initializer. Therefore it is highly recommender that you organise the ranking matrix in this way and utilize the initializer.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nobj</code></dt>
<dd>
<p>The number of ranked objects. If not provided, it will be inferred as the maximum ranking in the data set. As a result, it must be provided if the data is top-q ranking.</p>
</dd>
<dt><code>nobs</code></dt>
<dd>
<p>the number of observations. No need to be provided during initialization since it must be equal to the sum of slot <code>count</code>.</p>
</dd>
<dt><code>ndistinct</code></dt>
<dd>
<p>the number of distinct rankings. No need to be provided during initialization since it must be equal to the number of rows of slot <code>ranking</code>.</p>
</dd>
<dt><code>ranking</code></dt>
<dd>
<p>a matrix that stores the ranking representation of distinct rankings. Each row contains one ranking. For top-q ranking, all unobserved objects have ranking <code>q+1</code>.</p>
</dd>
<dt><code>count</code></dt>
<dd>
<p>the number of observations for each distinct ranking corresponding to each row of <code>ranking</code>.</p>
</dd>
<dt><code>topq</code></dt>
<dd>
<p>a numeric vector to store top-q ranking information. More information in details section.</p>
</dd>
<dt><code>subobs</code></dt>
<dd>
<p>a numeric vector to store number of observations for each chunk of top-q rankings.</p>
</dd>
<dt><code>q_ind</code></dt>
<dd>
<p>a numeric vector to store the beginning and ending of each chunk of top-q rankings. The last element has to be <code>ndistinct+1</code>.</p>
</dd>
</dl>
<h3>References</h3>

<p>Qian Z,  Yu L. H. P (2019) "Weighted Distance-Based Models for Ranking Data Using the R Package rankdist." <em>Journal of Statistical Software</em>, <strong>90</strong>(5), 1-31. doi: 10.18637/jss.v090.i05
</p>


<h3>See Also</h3>

<p><code>RankInit</code>, <code>RankControl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># creating a data set with only complete rankings
rankmat &lt;- replicate(10,sample(1:52,52), simplify = "array")
countvec &lt;- sample(1:52,52,replace=TRUE)
rankdat &lt;- new("RankData",ranking=rankmat,count=countvec)
# creating a data set with both complete and top-10 rankings
rankmat_in &lt;- replicate(10,sample(1:52,52), simplify = "array")
rankmat_in[rankmat_in&gt;11] &lt;- 11
rankmat_total &lt;- cbind(rankmat_in, rankmat)
countvec_total &lt;- c(countvec,countvec)
rankdat2 &lt;- new("RankData",ranking=rankmat_total,count=countvec_total, nobj=52, topq=c(10,51))
</code></pre>


</div>