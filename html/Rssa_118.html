<div class="container">

<table style="width: 100%;"><tr>
<td>rforecast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform recurrent SSA forecasting of the series</h2>

<h3>Description</h3>

<p>Perform recurrent SSA forecasting of the series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class '1d.ssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'mssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          direction = c("row", "column"), only.new = TRUE, ..., drop = TRUE,
          drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'cssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'pssa.1d.ssa'
rforecast(x, groups, len = 1, base = c("reconstructed", "original"),
          only.new = TRUE, reverse = FALSE, ...,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p>integer, the desired length of the forecasted series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>series used as a 'seed' of forecast: original or
reconstructed according to the value of <code>groups</code> argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>direction of forecast in multichannel SSA case, "column"
stands for so-called L-forecast and "row" stands for K-forecast</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.new</code></td>
<td>
<p>logical, if 'TRUE' then only forecasted values are returned,
whole series otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p>logical, direction of forecast in 1D SSA case, 'FALSE'
(default) means that the forecast moves forward in the time and
'TRUE' means the opposite</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>reconstruct</code>
routines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The routines applies the recurrent SSA forecasting algorithm to
produce the new series which is expected to 'continue' the current
series on the basis of a given decomposition. The algorithm
sequentialy projects the incomplete embedding vectors (from either the original
or the reconstructed series) onto the subspace spanned by the
selected eigentriples of the decomposition to derive the missed
(last) values of the such vectors. Then the filled value 
In such a way the forecasting elements are produced on
one-by-one basis.
</p>
<p>It is shown in Golyandina et al (2001) that this approach corresponds
to application of a linear recurrence formula (the same formula as 
described in <code>lrr</code>) to initial data taken from either the original
or the reconstructed series.
</p>
<p>In particular, the <code class="reqn">m</code>-th step of the forecast is calculated by
means of linear recurrence relation (see <code>lrr</code>) as
<code class="reqn">y_{n+m}=\sum_{k=1}^{L-1} a_k y_{n+m-k}</code> where the starting points
<code class="reqn">y_{n-(L-2)}</code>, ..., <code class="reqn">y_{n}</code> are taken from the reconstructed
time series (<code>base="reconstructed"</code>) or from the initial
(<code>base="initial"</code>) time series.
</p>
<p>For multichannel SSA the column forecast is obtained via applying the
LRR to each series separately. The row forecast is more complicated
and is based on a multivariate LRR. Forecast uses the formulae from
Golyandina and Stepanov (2005) and Golyandina et.al (2015).
</p>
<p>For details of 1D-SSA recurrent forecasting, see Section 3.2.1.2 and 
Algorithm 3.5 in Golyandina et al (2018).
For details of MSSA recurrent forecasting, see Section 4.3.1.2  and 
Algorithm 4.4 (column forecasting).
</p>


<h3>Value</h3>

<p>List of forecasted objects. Elements of the list have the same names
as elements of <code>groups</code>. If group is unnamed, corresponding
component gets name ‘Fn’, where ‘n’ is its index in <code>groups</code>
list.
</p>
<p>Or, the forecasted object itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>References</h3>

<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and
Hall/CRC. ISBN 1584881941
</p>
<p>Golyandina, N., Korobeynikov, A., Shlemov, A. and Usevich, K. (2015):
<em>Multivariate and 2D Extensions of Singular Spectrum Analysis
with the Rssa Package</em>. Journal of Statistical Software, Vol. 67, Issue 2.
<a href="https://doi.org/10.18637/jss.v067.i02">doi:10.18637/jss.v067.i02</a>
</p>
<p>Golyandina, N. and Stepanov, D. (2005): <em>SSA-based approaches to
analysis and forecast of multidimensional time series</em>. In
Proceedings of the 5th St.Petersburg Workshop on Simulation, June
26-July 2, 2005, St. Petersburg State University, St. Petersburg,
293–298. <a href="https://www.gistatgroup.com/gus/mssa2.pdf">https://www.gistatgroup.com/gus/mssa2.pdf</a>
</p>


<h3>See Also</h3>

<p><code>Rssa</code> for an overview of the package, as well as,
<code>forecast</code>,
<code>vforecast</code>,
<code>bforecast</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Produce 24 forecasted values of the series using different sets of eigentriples
# as a base space for the forecast.
rfor &lt;- rforecast(s, groups = list(c(1,4), 1:4), len = 24, only.new=FALSE)
matplot(data.frame(c(co2, rep(NA, 24)), rfor), type = "l")

# Forecast `co2' trend by SSA with projections
s &lt;- ssa(co2, column.projector = 2, row.projector = 2)
len &lt;- 100
rfor &lt;- rforecast(s, groups = list(trend = seq_len(nspecial(s))), len = len, only.new = FALSE)
matplot(data.frame(c(co2, rep(NA, len)), rfor), type = "l")

# Forecast finite rank series with polynomial component by SSA with projections
v &lt;- 5000 * sin(2*pi / 13 * (1:100)) +  (1:100)^2 + 10000
s &lt;- ssa(v, row.projector = 2, column.projector = 2)
plot(rforecast(s, groups = list(all = 1:6), len = 100, only.new = FALSE), type = "l")
</code></pre>


</div>