<div class="container">

<table style="width: 100%;"><tr>
<td>multi_optim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multiple starts for Regularized Structural Equation Modeling</h2>

<h3>Description</h3>

<p>Multiple starts for Regularized Structural Equation Modeling
</p>


<h3>Usage</h3>

<pre><code class="language-R">multi_optim(
  model,
  max.try = 10,
  lambda = 0,
  alpha = 0.5,
  gamma = 3.7,
  random.alpha = 0.5,
  LB = -Inf,
  UB = Inf,
  par.lim = c(-Inf, Inf),
  block = TRUE,
  full = TRUE,
  type = "lasso",
  optMethod = "rsolnp",
  gradFun = "ram",
  pars_pen = "regressions",
  diff_par = NULL,
  hessFun = "none",
  tol = 1e-05,
  round = 3,
  solver = FALSE,
  quasi = FALSE,
  solver.maxit = 50000,
  alpha.inc = FALSE,
  line.search = FALSE,
  prerun = FALSE,
  step = 0.1,
  momentum = FALSE,
  step.ratio = FALSE,
  verbose = FALSE,
  warm.start = FALSE,
  Start2 = NULL,
  nlminb.control = NULL,
  max.iter = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Lavaan output object. This is a model that was previously
run with any of the lavaan main functions: cfa(), lavaan(), sem(),
or growth(). It also can be from the efaUnrotate() function from
the semTools package. Currently, the parts of the model which cannot
be handled in regsem is the use of multiple group models, missing
other than listwise, thresholds from categorical variable models,
the use of additional estimators other than
ML, most notably WLSMV for categorical variables. Note: the model
does not have to actually run (use do.fit=FALSE), converge etc...
regsem() uses the lavaan object as more of a parser and to get
sample covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.try</code></td>
<td>
<p>number of starts to try before convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Penalty value. Note: higher values will result in additional
convergence issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Mixture for elastic net.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Additional penalty for MCP and SCAD</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.alpha</code></td>
<td>
<p>Alpha parameter for randomised lasso. Has to be between
0 and 1, with a default of 0.5. Note this is only used for
"rlasso", which pairs with stability selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LB</code></td>
<td>
<p>lower bound vector. Note: This is very important to specify
when using regularization. It greatly increases the chances of
converging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>UB</code></td>
<td>
<p>Upper bound vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.lim</code></td>
<td>
<p>Vector of minimum and maximum parameter estimates. Used to
stop optimization and move to new starting values if violated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p>Whether to use block coordinate descent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>Whether to do full gradient descent or block</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Penalty type. Options include "none", "lasso",
"enet" for the elastic net,
"alasso" for the adaptive lasso
and "diff_lasso". If ridge penalties are desired, use type="enet" and
alpha=1. diff_lasso penalizes the discrepency between
parameter estimates and some pre-specified values. The values
to take the deviation from are specified in diff_par. Two methods for
sparser results than lasso are the smooth clipped absolute deviation,
"scad", and the minimum concave penalty, "mcp". Last option is "rlasso"
which is the randomised lasso to be used for stability selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optMethod</code></td>
<td>
<p>Solver to use. Two main options for use: rsoolnp and coord_desc.
Although slightly slower, rsolnp works much better for complex models.
coord_desc uses gradient descent with soft thresholding for the type of
of penalty. Rsolnp is a nonlinear solver that doesn't rely on gradient
information. There is a similar type of solver also available for use,
slsqp from the nloptr package. coord_desc can also be used with hessian
information, either through the use of quasi=TRUE, or specifying a hess_fun.
However, this option is not recommended at this time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradFun</code></td>
<td>
<p>Gradient function to use. Recommended to use "ram",
which refers to the method specified in von Oertzen &amp; Brick (2014).
Only for use with optMethod="coord_desc".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars_pen</code></td>
<td>
<p>Parameter indicators to penalize. There are multiple ways to specify.
The default is to penalize all regression parameters ("regressions"). Additionally,
one can specify all loadings ("loadings"), or both c("regressions","loadings").
Next, parameter labels can be assigned in the lavaan syntax and passed to pars_pen.
See the example.Finally, one can take the parameter numbers from the A or S matrices and pass these
directly. See extractMatrices(lav.object)$A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff_par</code></td>
<td>
<p>Parameter values to deviate from. Only used when
type="diff_lasso".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessFun</code></td>
<td>
<p>Hessian function to use. Currently not recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance for coordinate descent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round</code></td>
<td>
<p>Number of digits to round results to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>Whether to use solver for coord_desc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quasi</code></td>
<td>
<p>Whether to use quasi-Newton. Currently not recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.maxit</code></td>
<td>
<p>Max iterations for solver in coord_desc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.inc</code></td>
<td>
<p>Whether alpha should increase for coord_desc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line.search</code></td>
<td>
<p>Use line search for optimization. Default is no, use fixed step size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prerun</code></td>
<td>
<p>Logical. Use rsolnp to first optimize before passing to
gradient descent? Only for use with coord_desc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>Step size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momentum</code></td>
<td>
<p>Momentum for step sizes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.ratio</code></td>
<td>
<p>Ratio of step size between A and S. Logical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print iteration number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm.start</code></td>
<td>
<p>Whether start values are based on previous iteration.
This is not recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Start2</code></td>
<td>
<p>Provided starting values. Not required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.control</code></td>
<td>
<p>list of control values to pass to nlminb</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Number of iterations for coordinate descent</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>fit Full set of output from regsem()
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Note that this is not currently recommended. Use cv_regsem() instead
library(regsem)
# put variables on same scale for regsem
HS &lt;- data.frame(scale(HolzingerSwineford1939[ ,7:15]))
mod &lt;- '
f =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9
'
outt = cfa(mod, HS, meanstructure=TRUE)

fit1 &lt;- multi_optim(outt, max.try=40,
                   lambda=0.1, type="lasso")


# growth model
model &lt;- ' i =~ 1*t1 + 1*t2 + 1*t3 + 1*t4
          s =~ 0*t1 + s1*t2 + s2*t3 + 3*t4 '
fit &lt;- growth(model, data=Demo.growth)
summary(fit)
fitmeasures(fit)
fit3 &lt;- multi_optim(fit, lambda=0.2, type="lasso")
summary(fit3)

## End(Not run)
</code></pre>


</div>