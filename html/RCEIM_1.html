<div class="container">

<table style="width: 100%;"><tr>
<td>RCEIM-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
An R Cross Entropy Inspired Method for Optimization
RCEIM
</h2>

<h3>Description</h3>

<p>RCEIM is a package implementing a stochastic heuristic method for performing multidimensional function optimization. The method is inspired in the Cross-Entropy Method.
</p>


<h3>Details</h3>


<table>
<tr>
<td style="text-align: left;">
Package: </td>
<td style="text-align: left;"> RCEIM</td>
</tr>
<tr>
<td style="text-align: left;">
Type: </td>
<td style="text-align: left;"> Package</td>
</tr>
<tr>
<td style="text-align: left;">
Version: </td>
<td style="text-align: left;"> 0.3</td>
</tr>
<tr>
<td style="text-align: left;">
Date: </td>
<td style="text-align: left;"> 2015-02-19</td>
</tr>
<tr>
<td style="text-align: left;">
License: </td>
<td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>RCEIM implements a simple stochastic heuristic method for optimization in the function <code>ceimOpt</code>. This method starts from a random population of solutions, computes the values of the function and selects a fraction of these solutions - the elite members. Afterwards, based on the elite members it creates a gaussian distribution, samples new random solutions from it, and iterates until convergence is reached (this is controlled by an epsilon parameter) or other stopping criteria is fulfilled (such as the maximum number of iterations).
</p>
<p>One advantage of this method is that it does not impose strong conditions on the function to be optimized. The function must written as an R function, but it does not need to be continuous, differentiable, neither analytic. Moreover, the method is ready for multicore processing, enabling the optimization of time-consuming functions.
</p>
<p><img src="../help/figures/RCEIM-Problems.jpg" alt="RCEIM-Problems"></p>
<p>Two examples of 1D and 2D functions that can be used as test problems for RCEIM (defined in <code>testFunOptimization</code> and <code>testFunOptimization2d</code>) are represented in the above figures.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Laurent Gallucio
</p>
<p>Maintainer: Alberto Krone-Martins &lt;algol@sim.ul.pt&gt;
</p>


<h3>See Also</h3>

<p><code>ceimOpt</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Solve a simple optimization problem and shows the results
po &lt;- ceimOpt(OptimFunction=function(x){(x[1]+1)^2+(x[2]+2)^2}, maxIter=100, epsilon=0.3, 
      nParams=2)
plotEliteDistrib(po$EliteMembers)
rm(po)

# A harder problem in 1D
po &lt;- ceimOpt(OptimFunction="testFunOptimization", maxIter=10, epsilon=0.3, 
      nParams=1, verbose=TRUE)
dev.new()
xx &lt;- seq(-10,10,by=0.01)
plot(xx, testFunOptimization(xx), type="l", xlab="x", ylab="Value")
points(po$BestMember[1], po$BestMember[2], col="red")
rm(list=c('xx','po'))

# A harder problem in 2D
po &lt;- ceimOpt(OptimFunction="testFunOptimization2d", maxIter=20, epsilon=0.3, 
      nParams=2, verbose=TRUE)
dev.new()
xx &lt;- seq(-10,10,by=0.1)
yy &lt;- seq(-10,10,by=0.1)
zz &lt;- matrix(nrow=length(yy), ncol=length(xx))
for(i in 1:length(xx)){
    for(j in 1:length(yy)){
        zz[i,j] &lt;- testFunOptimization2d( c(xx[i],yy[j]) )
    }
}
image(xx,yy,zz, col=gray((50:100)/100), xlab="x", ylab="y")
contour(xx,yy,zz, add=TRUE)
points(po$BestMember[1], po$BestMember[2], col="red", pch=19, cex=0.5)
rm(list=c('xx','yy','zz'))

# Example of multicore processing
slowFunction &lt;- function(x) { 
  p&lt;-runif(50000)
  return((x+3)^2)
} 
system.time(po &lt;- ceimOpt(OptimFunction="slowFunction", maxIter=10,
    Ntot=100, epsilon=0.3, nParams=1, verbose=FALSE, parallel=FALSE))
print(po$BestMember)
system.time(po &lt;- ceimOpt(OptimFunction="slowFunction", maxIter=10,
    Ntot=100, epsilon=0.3, nParams=1, verbose=FALSE, parallel=TRUE))
print(po$BestMember)
rm(po)
</code></pre>


</div>