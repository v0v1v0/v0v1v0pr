<div class="container">

<table style="width: 100%;"><tr>
<td>read_html</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Static web scraping (with xml2)</h2>

<h3>Description</h3>

<p><code>read_html()</code> works by performing a HTTP request then parsing the HTML
received using the xml2 package. This is "static" scraping because it
operates only on the raw HTML file. While this works for most sites,
in some cases you will need to use <code>read_html_live()</code> if the parts of
the page you want to scrape are dynamically generated with javascript.
</p>
<p>Generally, we recommend using <code>read_html()</code> if it works, as it will be
faster and more robust, as it has fewer external dependencies (i.e. it
doesn't rely on the Chrome web browser installed on your computer.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">read_html(x, encoding = "", ..., options = c("RECOVER", "NOERROR", "NOBLANKS"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Usually a string representing a URL. See <code>xml2::read_html()</code> for
other options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>Specify a default encoding for the document. Unless
otherwise specified XML documents are assumed to be in UTF-8 or
UTF-16. If the document is not UTF-8/16, and lacks an explicit
encoding directive, this allows you to supply a default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>Set parsing options for the libxml2 parser. Zero or more of
</p>

<dl>
<dt>RECOVER</dt>
<dd>
<p>recover on errors</p>
</dd>
<dt>NOENT</dt>
<dd>
<p>substitute entities</p>
</dd>
<dt>DTDLOAD</dt>
<dd>
<p>load the external subset</p>
</dd>
<dt>DTDATTR</dt>
<dd>
<p>default DTD attributes</p>
</dd>
<dt>DTDVALID</dt>
<dd>
<p>validate with the DTD</p>
</dd>
<dt>NOERROR</dt>
<dd>
<p>suppress error reports</p>
</dd>
<dt>NOWARNING</dt>
<dd>
<p>suppress warning reports</p>
</dd>
<dt>PEDANTIC</dt>
<dd>
<p>pedantic error reporting</p>
</dd>
<dt>NOBLANKS</dt>
<dd>
<p>remove blank nodes</p>
</dd>
<dt>SAX1</dt>
<dd>
<p>use the SAX1 interface internally</p>
</dd>
<dt>XINCLUDE</dt>
<dd>
<p>Implement XInclude substitition</p>
</dd>
<dt>NONET</dt>
<dd>
<p>Forbid network access</p>
</dd>
<dt>NODICT</dt>
<dd>
<p>Do not reuse the context dictionary</p>
</dd>
<dt>NSCLEAN</dt>
<dd>
<p>remove redundant namespaces declarations</p>
</dd>
<dt>NOCDATA</dt>
<dd>
<p>merge CDATA as text nodes</p>
</dd>
<dt>NOXINCNODE</dt>
<dd>
<p>do not generate XINCLUDE START/END nodes</p>
</dd>
<dt>COMPACT</dt>
<dd>
<p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p>
</dd>
<dt>OLD10</dt>
<dd>
<p>parse using XML-1.0 before update 5</p>
</dd>
<dt>NOBASEFIX</dt>
<dd>
<p>do not fixup XINCLUDE xml:base uris</p>
</dd>
<dt>HUGE</dt>
<dd>
<p>relax any hardcoded limit from the parser</p>
</dd>
<dt>OLDSAX</dt>
<dd>
<p>parse using SAX2 interface before 2.7.0</p>
</dd>
<dt>IGNORE_ENC</dt>
<dd>
<p>ignore internal document encoding hint</p>
</dd>
<dt>BIG_LINES</dt>
<dd>
<p>Store big lines numbers in text PSVI field</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># Start by reading a HTML page with read_html():
starwars &lt;- read_html("https://rvest.tidyverse.org/articles/starwars.html")

# Then find elements that match a css selector or XPath expression
# using html_elements(). In this example, each &lt;section&gt; corresponds
# to a different film
films &lt;- starwars %&gt;% html_elements("section")
films

# Then use html_element() to extract one element per film. Here
# we the title is given by the text inside &lt;h2&gt;
title &lt;- films %&gt;%
  html_element("h2") %&gt;%
  html_text2()
title

# Or use html_attr() to get data out of attributes. html_attr() always
# returns a string so we convert it to an integer using a readr function
episode &lt;- films %&gt;%
  html_element("h2") %&gt;%
  html_attr("data-id") %&gt;%
  readr::parse_integer()
episode
</code></pre>


</div>