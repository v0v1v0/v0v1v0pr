<div class="container">

<table style="width: 100%;"><tr>
<td>RKHSMetMod</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to produce a sequence of meta models that are the solutions of the RKHS Ridge Group Sparse or RKHS Group Lasso optimization problems.
</h2>

<h3>Description</h3>

<p>Calculates the Gram matrices <code class="reqn">K_v</code> for a chosen reproducing kernel and fits the solution of an RKHS ridge group sparse or an RKHS group lasso problem for each pair of penalty parameters <code class="reqn">(\mu,\gamma)</code>, for the Gaussian regression model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RKHSMetMod(Y, X, kernel, Dmax, gamma, frc, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Vector of response observations of size <code class="reqn">n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Matrix of observations with <code class="reqn">n</code> rows and <code class="reqn">d</code> columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>Character, indicates the type of the reproducing kernel: matern <code class="reqn">(</code>matern kernel<code class="reqn">)</code>, brownian <code class="reqn">(</code>brownian kernel<code class="reqn">)</code>, gaussian <code class="reqn">(</code>gaussian kernel<code class="reqn">)</code>, linear <code class="reqn">(</code>linear kernel<code class="reqn">)</code>, quad <code class="reqn">(</code>quadratic kernel<code class="reqn">)</code>. See the function <code>calc_Kv</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dmax</code></td>
<td>
<p>Integer, between <code class="reqn">1</code> and <code class="reqn">d</code>, indicates the order of interactions considered in the meta model: Dmax<code class="reqn">=1</code> is used to consider only the main effects, Dmax<code class="reqn">=2</code> to include the main effects and the interactions of order <code class="reqn">2,\ldots</code>. See the function <code>calc_Kv</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Vector of non negative scalars, values of the penalty parameter <code class="reqn">\gamma</code> in decreasing order. If <code class="reqn">\gamma=0</code> the function solves an RKHS Group Lasso problem and for <code class="reqn">\gamma&gt;0</code> it solves an RKHS Ridge Group Sparse problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frc</code></td>
<td>
<p>Vector of positive scalars. Each element of the vector sets a value to the penalty parameter <code class="reqn">\mu</code>, <code class="reqn">\mu=\mu_{max}/(\sqrt{n}\times frc)</code>. The value <code class="reqn">\mu_{max}</code> is calculated by the program. See the function <code>mu_max</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, if TRUE, prints: the group <code class="reqn">v</code> for which the correction of Gram matrix <code class="reqn">K_v</code> is done, and for each pair of the penalty parameters <code class="reqn">(\mu,\gamma)</code>: the number of current iteration, active groups and convergence criterias. Set as FALSE by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Details.
</p>


<h3>Value</h3>

<p>List of l components, with l equals to the number of pairs of the penalty parameters <code class="reqn">(\mu,\gamma)</code>. Each component of the list is a list of <code class="reqn">3</code> components "mu", "gamma" and "Meta-Model":
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Positive scalar, penalty parameter <code class="reqn">\mu</code> associated with the estimated Meta-Model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Positive scalar, an element of the input vector gamma associated with the estimated Meta-Model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Meta-Model</code></td>
<td>
<p>An RKHS Ridge Group Sparse or RKHS Group Lasso object associated with the penalty parameters mu and gamma:</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Scalar, estimated value of intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teta</code></td>
<td>
<p>Matrix with vMax rows and <code class="reqn">n</code> columns. Each row of the matrix is the estimated vector <code class="reqn">\theta_{v}</code> for <code class="reqn">v=1,...,</code>vMax.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.v</code></td>
<td>
<p>Matrix with <code class="reqn">n</code> rows and vMax columns. Each row of the matrix is the estimated value of <code class="reqn">f_{v}=K_{v}\theta_{v}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>Vector of size <code class="reqn">n</code>, indicates the estimator of <code class="reqn">m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Norm.n</code></td>
<td>
<p>Vector of size vMax, estimated values for the Ridge penalty norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Norm.H</code></td>
<td>
<p>Vector of size vMax, estimated values of the Sparse Group penalty norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>supp</code></td>
<td>
<p>Vector of active groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsupp</code></td>
<td>
<p>Vector of the names of the active groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SCR</code></td>
<td>
<p>Scalar, equals to <code class="reqn">\Vert Y-f_{0}-\sum_{v}K_{v}\theta_{v}\Vert ^{2}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>Scalar, indicates the value of the penalized criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.v</code></td>
<td>
<p>Vector of size vMax, coefficients of the Ridge penalty norm, <code class="reqn">\sqrt{n}\gamma\times</code>gama_v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.v</code></td>
<td>
<p>Vector of size vMax, coefficients of the Group Sparse penalty norm, <code class="reqn">n\mu\times</code>mu_v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>List of two components: maxIter, and the number of iterations until the convergence is achieved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>TRUE or FALSE. Indicates whether the algorithm has converged or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RelDiffCrit</code></td>
<td>
<p>Scalar, value of the first convergence criteria at the last iteration, <code class="reqn">\Vert\frac{\theta_{lastIter}-\theta_{lastIter-1}}{\theta_{lastIter-1}}\Vert ^{2}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RelDiffPar</code></td>
<td>
<p>Scalar, value of the second convergence criteria at the last iteration, <code class="reqn">\frac{crit_{lastIter}-crit_{lastIter-1}}{crit_{lastIter-1}}</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For the case <code class="reqn">\gamma=0</code> the outputs "mu"<code class="reqn">=\mu_g</code> and "Meta-Model" is the same as the one returned by the function <code>RKHSgrplasso</code>.
</p>


<h3>Author(s)</h3>

<p>Halaleh Kamari
</p>


<h3>References</h3>

<p>Kamari, H., Huet, S. and Taupin, M.-L. (2019) RKHSMetaMod : An R package to estimate the Hoeffding decomposition of an unknown function by solving RKHS Ridge Group Sparse optimization problem. &lt;arXiv:1905.13695&gt;
</p>


<h3>See Also</h3>

<p><code>calc_Kv</code>, <code>mu_max</code>, <code>RKHSgrplasso</code>, <code>pen_MetMod</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">d &lt;- 3
n &lt;- 50
library(lhs)
X &lt;- maximinLHS(n, d)
c &lt;- c(0.2,0.6,0.8)
F &lt;- 1;for (a in 1:d) F &lt;- F*(abs(4*X[,a]-2)+c[a])/(1+c[a])
epsilon &lt;- rnorm(n,0,1);sigma &lt;- 0.2
Y &lt;- F + sigma*epsilon
Dmax &lt;- 3
kernel &lt;- "matern"
frc &lt;- c(10,100)
gamma &lt;- c(.5,.01,.001,0)
result &lt;- RKHSMetMod(Y,X,kernel,Dmax,gamma,frc,FALSE)
l &lt;- length(result)
for(i in 1:l){print(result[[i]]$mu)}
for(i in 1:l){print(result[[i]]$gamma)}
for(i in 1:l){print(result[[i]]$`Meta-Model`$Nsupp)}
</code></pre>


</div>