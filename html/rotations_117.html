<div class="container">

<table style="width: 100%;"><tr>
<td>weighted.mean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighted mean rotation</h2>

<h3>Description</h3>

<p>Compute the weighted geometric or projected mean of a sample of rotations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'SO3'
weighted.mean(
  x,
  w = NULL,
  type = "projected",
  epsilon = 1e-05,
  maxIter = 2000,
  ...
)

## S3 method for class 'Q4'
weighted.mean(
  x,
  w = NULL,
  type = "projected",
  epsilon = 1e-05,
  maxIter = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix form (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>vector of weights the same length as the number of rows in x giving
the weights to use for elements of x. Default is <code>NULL</code>, which falls
back to the usual <code>mean</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>string indicating "projected" or "geometric" type mean estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>stopping rule for the geometric method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>maximum number of iterations allowed before returning most
recent estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>only used for consistency with mean.default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function takes a sample of 3D rotations (in matrix or quaternion form)
and returns the weighted projected arithmetic mean <code class="reqn">\widehat{\bm
S}_P</code> or geometric mean <code class="reqn">\widehat{\bm S}_G</code> according to the
<code>type</code> option. For a sample of <code class="reqn">n</code> rotations in matrix form
<code class="reqn">\bm{R}_i\in SO(3), i=1,2,\dots,n</code>, the
weighted mean is defined as </p>
<p style="text-align: center;"><code class="reqn">\widehat{\bm{S}}=argmin_{\bm{S}\in
SO(3)}\sum_{i=1}^nw_id^2(\bm{R}_i,\bm{S})</code>
</p>
<p> where
<code class="reqn">d</code> is the Riemannian or Euclidean distance.  For more on the projected
mean see <cite>moakher02</cite> and for the geometric mean see <cite>manton04</cite>.
</p>
<p>moakher02
</p>


<h3>Value</h3>

<p>Weighted mean of the sample in the same parametrization.
</p>


<h3>See Also</h3>

<p><code>median.SO3</code>, <code>mean.SO3</code>, <code>bayes.mean</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">Rs &lt;- ruars(20, rvmises, kappa = 0.01)

# Find the equal-weight projected mean
mean(Rs)

# Use the rotation misorientation angle as weight
wt &lt;- abs(1 / mis.angle(Rs))
weighted.mean(Rs, wt)

rot.dist(mean(Rs))

# Usually much smaller than unweighted mean
rot.dist(weighted.mean(Rs, wt))

# Can do the same thing with quaternions
Qs &lt;- as.Q4(Rs)
mean(Qs)
wt &lt;- abs(1 / mis.angle(Qs))
weighted.mean(Qs, wt)
rot.dist(mean(Qs))
rot.dist(weighted.mean(Qs, wt))
</code></pre>


</div>