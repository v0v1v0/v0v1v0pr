<div class="container">

<table style="width: 100%;"><tr>
<td>optimizeNewLambda</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform factorization for new lambda value</h2>

<h3>Description</h3>

<p>Uses an efficient strategy for updating that takes advantage of
the information in the existing factorization; always uses previous k.
Recommended mainly when re-optimizing for higher lambda and when new lambda
value is significantly different; otherwise may not return optimal results.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optimizeNewLambda(
  object,
  lambdaNew,
  nIteration = 30,
  seed = 1,
  verbose = getOption("ligerVerbose"),
  new.lambda = lambdaNew,
  max.iters = nIteration,
  rand.seed = seed,
  thresh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>liger object. Should have integrative
factorization (e.g. <code>runINMF</code>) performed in advance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaNew</code></td>
<td>
<p>Numeric regularization parameter. Larger values penalize
dataset-specific effects more strongly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIteration</code></td>
<td>
<p>Number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>. Used
by <code>runINMF</code> factorization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> which is <code>TRUE</code> if users have not set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.lambda, max.iters, rand.seed</code></td>
<td>
<p>These arguments are now replaced by
others and will be removed in the future. Please see usage for replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p><b>Deprecated</b>. New implementation of iNMF does not require
a threshold for convergence detection. Setting a large enough
<code>nIteration</code> will bring it to convergence.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Input <code>object</code> with optimized factorization values updated.
including the <code>W</code> matrix in liger object, and <code>H</code> and
<code>V</code> matrices in each ligerDataset object in the
<code>datasets</code> slot.
</p>


<h3>See Also</h3>

<p><code>runINMF</code>, <code>optimizeNewK</code>,
<code>optimizeNewData</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    # Only running a few iterations for fast examples
    pbmc &lt;- runINMF(pbmc, k = 20, nIteration = 2)
    pbmc &lt;- optimizeNewLambda(pbmc, lambdaNew = 5.5, nIteration = 2)
}
</code></pre>


</div>