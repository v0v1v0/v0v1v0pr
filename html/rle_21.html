<div class="container">

<table style="width: 100%;"><tr>
<td>Summary.rle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summary methods for <code>rle</code> objects.</h2>

<h3>Description</h3>

<p>Summarisation functions for vectors described in Summary are implemented for <code>rle</code> objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'rle'
Summary(..., na.rm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><code>rle</code> objects or objects that can be coerced to <code>rle</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Whether the missing values should be ignored (<code>TRUE</code>) or propagated (<code>FALSE</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Supported functions include all elements of the S3
Summary group. As of this writing, functions supported include
(from R help) <code>all</code>, <code>any</code>, <code>max</code>, <code>min</code>, <code>prod</code>, <code>range</code>, and
<code>sum</code>.
</p>


<h3>Value</h3>

<p>In every supported case, the call should produce the same
result as what would have resulted had the call been applied to
the original (uncompressed) vector. (At no point in the
calculation is the uncompressed vector actually constructed, of
course.) The exception is that if <code>values</code> are of class
<code>integer</code>, the result will nonetheless always be upcast to
<code>numeric</code> to avert overflows. This behaviour may change in the
future.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- rle(as.logical(rbinom(20,1,.7)))
y &lt;- rle(as.logical(rbinom(20,1,.3)))

stopifnot(isTRUE(all.equal(any(x, y),any(inverse.rle(x), inverse.rle(y)))))
stopifnot(isTRUE(all.equal(any(y),any(inverse.rle(y)))))

stopifnot(isTRUE(all.equal(sum(inverse.rle(x),inverse.rle(y)),sum(x,y))))
stopifnot(isTRUE(all.equal(sum(inverse.rle(y)),sum(y))))

y$values[2:3] &lt;- NA
stopifnot(isTRUE(all.equal(sum(inverse.rle(y), na.rm=TRUE),sum(y, na.rm=TRUE))))
stopifnot(isTRUE(all.equal(sum(inverse.rle(y), na.rm=FALSE),sum(y, na.rm=FALSE))))

</code></pre>


</div>