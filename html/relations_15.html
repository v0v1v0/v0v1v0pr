<div class="container">

<table style="width: 100%;"><tr>
<td>relation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Relations</h2>

<h3>Description</h3>

<p>Creation and manipulation of relations.</p>


<h3>Usage</h3>

<pre><code class="language-R">relation(domain = NULL, incidence = NULL, graph = NULL,
         charfun = NULL)
endorelation(domain = NULL, incidence = NULL, graph = NULL,
             charfun = NULL)
homorelation(domain = NULL, incidence = NULL, graph = NULL,
             charfun = NULL)
as.relation(x, ...)
is.relation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p>List (or tuple) of (possibly named) sets (or vectors)
used as the domain, recycled as needed to fit the arity of the relation.
If <code>domain</code> is not a list or tuple, it is converted to a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incidence</code></td>
<td>
<p>A numeric array with values in the unit interval, or
a logical array.  Note that one-dimensional incidences are also
accepted.  The <code>names</code>/<code>dimnames</code> attribute of
<code>incidence</code> is used as domain if this is not explicitly given
using the <code>domain</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>Either a set of equally sized tuples, or a list of
(possibly, generic) vectors of same length where each component
specifies one relation element, or a data frame where each row
specifies one relation element.  For the latter, the columns
correspond to the domain sets, and the colnames are used as their
labels if specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>charfun</code></td>
<td>
<p>A characteristic function of the relation, i.e., a
predicate function taking <code class="reqn">k</code> arguments, with <code class="reqn">k</code> equal to
the arity of the relation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>as.relation()</code>
methods (currently not used for those defined in the relations
package).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given <code class="reqn">k</code> sets of objects <code class="reqn">X_1</code>, ..., <code class="reqn">X_k</code>, a
<code class="reqn">k</code>-ary relation <code class="reqn">R</code> on <code class="reqn">D(R) = (X_1, \ldots, X_k)</code> is a
(possibly fuzzy) subset <code class="reqn">G(R)</code> of the Cartesian product <code class="reqn">X_1
    \times \cdots \times X_k</code>.  We refer to <code class="reqn">D(R)</code>
and <code class="reqn">G(R)</code> as the <em>domain</em> and the <em>graph</em> of the
relation, respectively (alternative notions are that of <em>ground</em>
and <em>figure</em>, respectively).  We also refer to <code class="reqn">s = (s_1,
    \ldots, s_k)</code>, where each <code class="reqn">s_i</code> gives the cardinality of
<code class="reqn">X_i</code>, as the <em>size</em> of the relation.
</p>
<p>Strictly speaking, the relation is the <em>pair</em> <code class="reqn">(D(R), G(R))</code>;
often, relations are identified with their graph.  If <code class="reqn">G(R)</code> is a
crisp subset of <code class="reqn">D(R)</code>, <code class="reqn">R</code> is a <em>crisp relation</em>.  In
this case, we say that a <code class="reqn">k</code>-tuple <code class="reqn">t</code> is <em>contained</em> in
the relation <code class="reqn">R</code> iff it is an element of <code class="reqn">G(R)</code>.
</p>
<p>The <em>characteristic function</em> <code class="reqn">f_R</code> of a relation <code class="reqn">R</code> is
the membership function of <code class="reqn">G(R)</code>, giving for each <code class="reqn">k</code>-tuple
<code class="reqn">t</code> in <code class="reqn">D(R)</code> the membership (amount of belongingness) of
<code class="reqn">t</code> to <code class="reqn">G(R)</code>.  In the crisp case, <code class="reqn">f_R</code> is also referred
to as the indicator function of the relation, and is a binary (0/1)
function such that <code class="reqn">f_R(t)</code> is one iff <code class="reqn">t</code> is in <code class="reqn">G(R)</code>.
</p>
<p>Relations with arity 2, 3, and 4 are typically referred to as
<em>binary</em>, <em>ternary</em>, and <em>quaternary</em> relations,
respectively.  A <em>homorelation</em> on <code class="reqn">X</code> is a relation with
homogeneous domain, i.e. <code class="reqn">(X, X, \dots, X)</code>.
An <em>endorelation</em> on <code class="reqn">X</code> (or binary relation
<em>over</em> <code class="reqn">X</code>) is a binary homorelation.
See predicates for the most important
types of endorelations.
</p>
<p>Relations with the same domain can naturally be ordered according to
their graphs.  I.e., <code class="reqn">R \le S</code> iff <code class="reqn">G(R)</code> is a subset of
<code class="reqn">G(S)</code>, or equivalently, iff <code class="reqn">f_R(t) \le f_S(t)</code> for every
<code class="reqn">k</code>-tuple <code class="reqn">t</code> (in the crisp case, iff every tuple contained in
<code class="reqn">R</code> is also contained in <code class="reqn">S</code>).  This induces a lattice
structure, with meet (greatest lower bound) and join (least upper
bound) the intersection and union of the graphs, respectively, also
known as the <em>intersection</em> and <em>union</em> of the relations.
The least element moves metric on this lattice is the
<em>symmetric difference metric</em>, i.e., the Manhattan distance
between the collections of membership values (incidences).  In the
crisp case, this gives the cardinality of the symmetric difference of
the graphs (the number of tuples in exactly one of the relation
graphs).
</p>
<p>The <em>complement</em> (or <em>negation</em>) <code class="reqn">R^c</code> of a relation
<code class="reqn">R</code> is the relation with domain <code class="reqn">D(R)</code> whose graph is the
complement of <code class="reqn">G(R)</code> (in the crisp case, containing exactly the
tuples not contained in <code class="reqn">R</code>).
</p>
<p>For binary crisp relations <code class="reqn">R</code>, it is customary to write
<code class="reqn">x R y</code> iff <code class="reqn">(x, y)</code> is contained in <code class="reqn">R</code>.  For binary
crisp relations <code class="reqn">R_1</code> and <code class="reqn">R_2</code> with domains <code class="reqn">(X, Y)</code> and 
<code class="reqn">(Y, Z)</code>, the <em>composition</em> <code class="reqn">T = R_1 * R_2</code> of <code class="reqn">R_1</code>
and <code class="reqn">R_2</code> is defined by taking <code class="reqn">x S z</code> iff there is an <code class="reqn">y</code>
such that <code class="reqn">x R_1 y</code> and <code class="reqn">y R_2 z</code>.  The <em>transpose</em> (or
<em>inverse</em>) <code class="reqn">R^{t}</code> of the relation <code class="reqn">R</code> with domain
<code class="reqn">(X, Y)</code> is the relation with domain <code class="reqn">(Y, X)</code> such that
<code class="reqn">y R^{t} x</code> iff <code class="reqn">x R y</code>.  The 
<em>codual</em> (Clark (1990), also known as the ‘dual’ in the
fuzzy preference literature, e.g., Ovchinnikov (1991)) is the
complement of the transpose (equivalently, the transpose of the
complement).
</p>
<p>For binary fuzzy relations <code class="reqn">R</code>, one often writes <code class="reqn">R(x, y)</code> for
the membership of the pair <code class="reqn">(x, y)</code> in the relation.  The above
notions need to take the fuzzy logic employed (as described by the
fuzzy t-norm (intersection) <code class="reqn">T</code>, t-conorm (disjunction) <code class="reqn">S</code>,
and negation <code class="reqn">N</code>) into account.  Let <code class="reqn">R</code>, <code class="reqn">R_1</code> and
<code class="reqn">R_2</code> be binary relations with appropriate domains.  Then the
memberships for <code class="reqn">(x, y)</code> of the complement, transpose and codual of
<code class="reqn">R</code> are <code class="reqn">N(R(x, y))</code>, <code class="reqn">R(y, x)</code> and <code class="reqn">N(R(y, x))</code>,
respectively.  The membership of <code class="reqn">(x, y)</code> for the composition of
<code class="reqn">R_1</code> and <code class="reqn">R_2</code> is <code class="reqn">\max_z T(R_1(x, z), R_2(z, y))</code>.
</p>
<p>Package <span class="pkg">relations</span> implements finite relations as an S3 class
which allows for a variety of representations (even though currently,
typically dense array representations of the incidences are employed).
Other than by the generator,
relations can be obtained by coercion via the generic function
<code>as.relation()</code>, which has methods for at least logical and numeric
vectors, unordered and ordered factors, arrays including matrices, and
data frames.  Unordered factors are coerced to equivalence relations;
ordered factors and numeric vectors are coerced to order relations.
Logical vectors give unary relations (predicates).  A (feasible)
<code class="reqn">k</code>-dimensional array is taken as the incidence of a <code class="reqn">k</code>-ary
relation.  Finally, a data frame is taken as a relation table.  Note
that missing values will be propagated in the coercion.
</p>
<p><code>endorelation()</code> is a wrapper for <code>relation()</code>, trying to
guess a suitable domain from its arguments to create an
endorelation.  If a domain is given, all labels are combined and the
result (as a list) recycled as needed.
</p>
<p>Basic relation operations are available as group methods: <code>min()</code>
and <code>max()</code> give the meet and join, and <code>range()</code> a
relation ensemble with these two.
Comparison operators implement the natural ordering in the relation
lattice.  Where applicable, <code>!</code> gives the complement (negation),
<code>&amp;</code> and <code>|</code> intersection and union, and <code>*</code>
composition, respectively.  Finally, <code>t()</code> gives the transpose
and <code>codual()</code> the codual.
</p>
<p>There is a <code>plot()</code> method for certain
crisp endorelations provided that package <span class="pkg">Rgraphviz</span> is
available.
</p>
<p>For crisp endorelations <code class="reqn">R</code>, <code>sym()</code> and <code>asy()</code> give
the symmetric and asymmetric parts of <code class="reqn">R</code>, defined as the
intersection of <code class="reqn">R</code> with its transpose, or, respectively, with its
codual (the complement of its transpose).
</p>
<p>The <code>summary()</code> method applies all predicates available
and returns a logical vector with the corresponding results.
</p>


<h3>References</h3>

<p>S. A. Clark (1990),
A folk meta-theorem in the foundations of utility theory.
<em>Mathematical Social Sciences</em>, <b>19</b>/3, 253–267.
<a href="https://doi.org/10.1016/0165-4896%2890%2990065-F">doi:10.1016/0165-4896(90)90065-F</a>.
</p>
<p>S. Ovchinnikov (1991),
Similarity relations, fuzzy partitions, and fuzzy orderings.
<em>Fuzzy Sets and Systems</em>, <b>40</b>/1, 107–126.
<a href="https://doi.org/10.1016/0165-0114%2891%2990048-U">doi:10.1016/0165-0114(91)90048-U</a>.
</p>


<h3>See Also</h3>

<p><code>relation_incidence()</code> for obtaining incidences;
<code>relation_domain()</code> for determining domain, arity, and
size;
<code>relation_graph()</code> for determining the graph of a relation;
<code>relation_charfun()</code> for determining the characteristic
function;
predicates for available predicate functions; and
algebra for further operations defined on relations.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require("sets")				# set(), tuple() etc.

## A relation created by specifying the graph:
R &lt;- relation(graph = data.frame(A = c(1, 1:3), B = c(2:4, 4)))
relation_incidence(R)
## extract domain
relation_domain(R)
## extract graph
relation_graph(R)
## both ("a pair of domain and graph" ...)
as.tuple(R)

## (Almost) the same using the set specification
## (the domain labels are missing).
R &lt;- relation(graph = set(tuple(1,2), tuple(1,3),
                          tuple(2,4), tuple(3,4)))
## equivalent to:
## relation(graph = list(c(1,2), c(1,3), c(2,4), c(3,4)))
relation_incidence(R)

## Explicitly specifying the domain:
R &lt;- relation(domain = list(A = letters[1:3], B = LETTERS[1:4]),
              graph = set(tuple("a","B"), tuple("a","C"),
                          tuple("b","D"), tuple("c","D")))
relation_incidence(R)

## Domains can be composed of arbitrary R objects:
R &lt;- relation(domain = set(c, "test"),
              graph = set(tuple(c, c), tuple(c, "test")))
relation_incidence(R)

## Characteristic function ("a divides b"):
R &lt;- relation(domain = list(1 : 10, 1 : 10),
              charfun = function(a, b) b %% a == 0)
relation_incidence(R)
## R is a partial order: plot the Hasse diagram provided that
## Rgraphviz is available:
if(require("Rgraphviz")) plot(R)

## conversions and operators
x &lt;- matrix(0, 3, 3)
R1 &lt;- as.relation(row(x) &gt;= col(x))
R2 &lt;- as.relation(row(x) &lt;= col(x))
R3 &lt;- as.relation(row(x) &lt;  col(x))
relation_incidence(max(R1, R2))
relation_incidence(min(R1, R2))
R3 &lt; R2
relation_incidence(R1 * R2)
relation_incidence(! R1)
relation_incidence(t(R2))

### endorelation
s &lt;- set(pair("a","b"), pair("c","d"))
relation_incidence(relation(graph = s))
relation_incidence(endorelation(graph = s))
</code></pre>


</div>