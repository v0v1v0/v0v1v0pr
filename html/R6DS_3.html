<div class="container">

<table style="width: 100%;"><tr>
<td>RBST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The RBST reference class</h2>

<h3>Description</h3>

<p>The RBST reference class implements the data structure binary search tree (BST).
</p>


<h3>Usage</h3>

<pre><code class="language-R">RBST
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A BST is a particular type of container storing elements in nodes by following a binary tree structure.
So the element is the value of the corresponding node in the tree.
</p>
<p>The BST has one root on top, which is the first node of the tree,
and each node in the BST has at most two sub-nodes (left sub-node and right sub-node) which can be the roots of their sub-trees.
</p>
<p>The BST should be equipped with the "&lt;" and "=" operations such that any two nodes in the tree can be compared.
Note that, by the definitions of the "&lt;" and "=" operations, the operation "&gt;" is also defined.
</p>
<p>The BST structure follows strictly the rules that, for a certain node in the tree,
any nodes in its left sub-tree must be strictly smaller ("&lt;") than it,
any nodes in its right sub-tree must be strictly larger ("&gt;") than it,
and any two nodes in the tree must not be equal (no "=").
</p>
<p>Therefore, the BST is a special set or dictionary equipped with "&lt;", "&gt;" operations.
</p>
<p>When you create a new RBST instance, you have to input two functions which defines
the bodies of the two private methods <code>lessthan</code> and <code>equal</code>.
The RBST instance then will use them to make comparison and decide where to put new nodes (build the BST).
</p>
<p>Each time a new node is inserted, the BST algorithm finds its location on the tree.
Then you can imagine, the BST is efficient in maintaining (inserting and deleting), searching and traversing the tree.
An average O(log n) time complexity can be achieved by applying the BST algorithm.
</p>
<p>A very important fact is that, the RBST only compares the nodes by using
the function <code>equal</code>.
So it will regard any two nodes identical if <code>equal</code> returns <code>TRUE</code>,
even though they are different.
</p>
<p>We see that the BST can also be regarded as a dictionary,
as the key of the dictionary is actually the value input into <code>insert</code>, <code>delete</code> and <code>search_for</code>.
</p>
<p>The traversals of the BST (in-order, pre-order, and post-order) are implemented as well.
A <code>callback</code> function can be input into the <code>traverse</code> function
to specify how to treat the traversed nodes.
By default (if you do not input anything here) the <code>traverse</code> function
prints the traversed nodes.
But of course you can, for example, store them by changing the <code>callback</code> function,
see the examples below.
</p>
<p>The elements in the BST are not necessarily to be of the same type,
and they can even contain functions.
</p>


<h3>References</h3>

<p>For the details about the BST data structure, see <a href="https://en.wikipedia.org/wiki/Binary_search_tree">BST at Wikipedia</a>.
</p>


<h3>Class Method</h3>

<p>The class method belongs to the class.
</p>

<dl>
<dt><code>new(lessthan, equal, ..., collapse=NULL)</code></dt>
<dd>
<p>The <code>new</code> method creates a new instance of the RBST class
containing the values in <code>...</code> and <code>collapse</code> as its nodes.
</p>
<p>The argument <code>lessthan</code> takes a function defining the "&lt;" operation,
and the argument <code>equal</code> takes a function defining the "=" operation.
Both of the functions takes two values of the nodes in the tree and return
a boolean.
</p>
<p><code>lessthan</code> can take, for example, the form
</p>
<p><code>lessthan &lt;- function(x, y) return(x$num &lt; y$num)</code>
</p>
<p>where <code>x</code> and <code>y</code> are values of two nodes in the tree
with the attribute <code>num</code>.
</p>
<p><code>equal</code> can take, for example, the form
</p>
<p><code>equal &lt;- function(x, y) return(x$num == y$num)</code>
</p>
<p>where <code>x</code> and <code>y</code> are values of two nodes in the tree
with the attribute <code>num</code>.
</p>
</dd>
</dl>
<h3>Immutable Methods</h3>

<p>The immutable methods do not change the nodes of the instance.
</p>

<dl>
<dt>
<code>toList</code>, <code>toList_pre</code>, and <code>toList_post</code>
</dt>
<dd>
<p>The active method <code>toList</code> returns a list containing its elements (a copy).
</p>
<p>The order of the list can be "traverse-in-order" by using <code>toList</code>,
"traverse-pre-order" by using <code>toList_pre</code>,
or "traverse-post-order" by using <code>toList_post</code>
</p>
</dd>
<dt><code>traverse(mode, callback=function(item){print(item)}, ...)</code></dt>
<dd>
<p>The <code>traverse</code> method takes at least two arguments which are <code>mode</code> and <code>callback</code>.
</p>
<p>The <code>mode</code> takes a value in one of the three strings
<code>"in"</code>, <code>"pre"</code>, and <code>"post"</code> which indicate
<em>traverse-in-order</em>, <em>traverse-pre-order</em>, and <em>traverse-post-order</em>, respectively.
</p>
<p>The <code>callback</code> takes a function
specifying how to handle the value of each node in the tree.
By default, <code>callback</code> prints the nodes by using the <code>print</code> function.
</p>
<p>Note that the first argument of the <code>callback</code> function must be the value of the node
but not the node itself!
</p>
<p><code>callback</code> can have two or more arguments.
The method also takes <code>...</code> as the additional arguments for the <code>callback</code> function if any.
</p>
</dd>
<dt><code>search_for(val)</code></dt>
<dd>
<p>The method <code>search_for</code> uses the <code>equal</code> function
to compare <code>val</code> with the nodes in BST.
It returns the value of the node if the node is <code>equal</code> to the given value, and <code>NULL</code> otherwise.
</p>
<p>As the tree has been structured strictly by following the rules introduced above,
there is no need to search the whole tree in most cases, and the maintaining and searching are efficient.
</p>
</dd>
<dt><code>min</code></dt>
<dd>
<p>The active method <code>min</code> returns the smallest node in the tree,
and <code>NULL</code> if the tree is empty.
</p>
</dd>
<dt><code>max</code></dt>
<dd>
<p>The active method <code>min</code> returns the largest node in the tree,
and <code>NULL</code> if the tree is empty.
</p>
</dd>
</dl>
<h3>Mutable Methods</h3>

<p>The mutable methods changes the nodes of the instance.
</p>

<dl>
<dt><code>insert(..., collapse=NULL)</code></dt>
<dd>
<p>The method <code>insert</code> inserts new nodes into the tree.
If some nodes are <code>equal</code> to the nodes in the tree,
they will not be inserted.
</p>
</dd>
<dt><code>delete(val)</code></dt>
<dd>
<p>The method <code>delete</code> removes the node which is <code>equal</code> to <code>val</code>.
If the node is found, then it will be removed and the function returns a <code>TRUE</code>,
and if the node is not found, then it will do nothing and returns a <code>FALSE</code>,
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p>R6DS for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### create a new instance

# you have to define two functions for "&lt;" and "="
lessthan &lt;- function(x, y) return(x$key &lt; y$key)
equal &lt;- function(x, y) return(x$key == y$key)
# remember that the nodes in the BST have the "key" variable
# and it is numeric

# to create a new instance of the class
bst &lt;- RBST$new(lessthan=lessthan, equal=equal)

# of course you can start to push elements when creating the instance
bst &lt;- RBST$new(lessthan=lessthan, equal=equal,
    list(key=5, val="5"), collapse=list(list(key=3,val="3"), list(key=9,val="9")))
# the following sentence is equivalent to the above
bst &lt;- RBST$new(lessthan=lessthan, equal=equal,
    list(key=5, val="5"), list(key=3,val="3"), list(key=9,val="9"))
# where the three lists are inserted into the BST

### maintaining

bst$insert(list(key=5, val="6"))
bst$insert(list(key=6, val="5"))

bst$delete(list(key=7, val="7"))
# FALSE
bst$delete(list(key=6, val="7"))
# TRUE and delete list(key=6, val="5")
# though val are different

### searching

bst$search_for(list(key=0, val="0"))
# NULL
bst$search_for(list(key=5, val="0"))
# the BST has a node whose key is 5

### min and max

# min and max are two active functions
# so the parenthesis is not needed
bst$min
bst$max

### toList

bst$toList
bst$toList_pre
bst$toList_post

### traversing

# by default, the callback function prints the nodes
# but you can re-define the callback function
queue &lt;- RQueue$new()
callback &lt;- function(item)queue$enqueue(item)
# remember that RQueue is a reference class
# so the new callback will store the traversed nodes

bst$traverse(mode = "in", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}
bst$traverse(mode = "in", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}

# pre-order traversing
bst$traverse(mode = "pre", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}

# post-order traversing
bst$traverse(mode = "post", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}

</code></pre>


</div>