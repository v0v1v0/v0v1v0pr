<div class="container">

<table style="width: 100%;"><tr>
<td>Require-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Require: Installing and Loading R Packages for Reproducible Workflows</h2>

<h3>Description</h3>

<p>A single key function, 'Require' that makes rerun-tolerant versions of 'install.packages' and 'require' for CRAN packages, packages no longer on CRAN (i.e., archived), specific versions of packages, and GitHub packages. This approach is developed to create reproducible workflows that are flexible and fast enough to use while in development stages, while able to build snapshots once a stable package collection is found. As with other functions in a reproducible workflow, this package emphasizes functions that return the same result whether it is the first or subsequent times running the function, with subsequent times being sufficiently fast that they can be run every time without undue waiting burden on the user or developer.
</p>
<p>This is an "all in one" function that will run <code>install.packages</code> for CRAN
and GitHub <a href="https://github.com/">https://github.com/</a> packages and will install specific versions
of each package if versions are specified either via an (in)equality (e.g.,
<code>"glue (&gt;=1.6.2)"</code> or <code>"glue (==1.6.2)"</code> for an exact version) or with a
<code>packageVersionFile</code>. If <code>require = TRUE</code>, the default, the function will
then run <code>require</code> on all named packages that satisfy their version
requirements. If packages are already installed (<code>packages</code> supplied), and
their optional version numbers are satisfied, then the "install" component
will be skipped.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Require(
  packages,
  packageVersionFile,
  libPaths,
  install_githubArgs = list(),
  install.packagesArgs = list(INSTALL_opts = "--no-multiarch"),
  standAlone = getOption("Require.standAlone", FALSE),
  install = getOption("Require.install", TRUE),
  require = getOption("Require.require", TRUE),
  repos = getOption("repos"),
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose", FALSE),
  type = getOption("pkgType"),
  upgrade = FALSE,
  returnDetails = FALSE,
  ...
)

Install(
  packages,
  packageVersionFile,
  libPaths,
  install_githubArgs = list(),
  install.packagesArgs = list(INSTALL_opts = "--no-multiarch"),
  standAlone = getOption("Require.standAlone", FALSE),
  install = TRUE,
  repos = getOption("repos"),
  purge = getOption("Require.purge", FALSE),
  verbose = getOption("Require.verbose", FALSE),
  type = getOption("pkgType"),
  upgrade = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>packages</code></td>
<td>
<p>Either a character vector of packages to install via
<code>install.packages</code>, then load (i.e., with <code>library</code>), or, for convenience,
a vector or list (using <code>c</code> or <code>list</code>) of unquoted package names to install
and/or load (as in <code>require</code>, but vectorized). Passing vectors of names may
not work in all cases, so user should confirm before relying on this behaviour
in operational code.
In the case of a GitHub package, it
will be assumed that the name of the repository is the name of the package.
If this is not the case, then pass a <em>named</em> character vector here, where the
names are the package names that could be different than the GitHub
repository name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>packageVersionFile</code></td>
<td>
<p>Character string of a file name or logical. If
<code>TRUE</code>, then this function will load the default file,
<code>getOption("Require.packageVersionFile")</code>. If this argument is provided,
then this will override any packages passed to <code>packages</code>. By default,
<code>Require</code> will attempt to resolve dependency violations (i.e., if this
<code>packageVersionFile</code> specifies a version of a package that violates
the dependency specification of another package). If a user wishes to attempt
to install the <code>packageVersionFile</code> without assessing the dependencies,
set <code>dependencies = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>libPaths</code></td>
<td>
<p>The library path (or libraries) where all packages should be
installed, and looked for to load (i.e., call <code>library</code>). This can be used
to create isolated, stand alone package installations, if used with
<code>standAlone = TRUE</code>. Currently, the path supplied here will be prepended to
<code>.libPaths()</code> (temporarily during this call) to <code>Require</code> if
<code>standAlone = FALSE</code> or will set (temporarily) <code>.libPaths()</code> to
<code style="white-space: pre;">⁠c(libPaths, tail(libPaths(), 1)⁠</code> to keep base packages.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>install_githubArgs</code></td>
<td>
<p>Deprecated. Values passed here are merged with
<code>install.packagesArgs</code>, with the <code>install.packagesArgs</code> taking precedence
if conflicting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>install.packagesArgs</code></td>
<td>
<p>List of optional named arguments, passed to
<code>install.packages</code>. Default is only <code>--no-multi-arch</code>, meaning that only
the current architecture will be built and installed (e.g., 64 bit, not 32 bit,
in many cases).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standAlone</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all packages will be installed to and
loaded from the <code>libPaths</code> only. NOTE: If <code>TRUE</code>, THIS WILL CHANGE THE
USER'S <code>.libPaths()</code>, similar to e.g., the <code>checkpoint</code> package. If
<code>FALSE</code>, then <code>libPath</code> will be prepended to <code>.libPaths()</code> during the
<code>Require</code> call, resulting in shared packages, i.e., it will include the
user's default package folder(s). This can be create dramatically faster
installs if the user has a substantial number of the packages already in
their personal library. Default <code>FALSE</code> to minimize package installing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>install</code></td>
<td>
<p>Logical or "force". If <code>FALSE</code>, this will not try to install
anything. If <code>"force"</code>, then it will force installation of requested
packages, mimicking a call to e.g., <code>install.packages</code>. If <code>TRUE</code>, the
default, then this function will try to install any missing packages or
dependencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>require</code></td>
<td>
<p>Logical or character string. If <code>TRUE</code>, the default, then the
function will attempt to call <code>require</code> on all requested <code>packages</code>,
possibly after they are installed. If a character string, then it will only
call <code>require</code> on those specific packages (i.e., it will install the ones
listed in <code>packages</code>, but load the packages listed in <code>require</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repos</code></td>
<td>
<p>The remote repository (e.g., a CRAN mirror), passed to either
<code>install.packages</code>, <code>install_github</code> or <code>installVersions</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>purge</code></td>
<td>
<p>Logical. Should all caches be purged? Default is
<code>getOption("Require.purge", FALSE)</code>. There is a lot of internal caching of
results throughout the <code>Require</code> package. These help with speed and reduce
calls to internet sources. However, sometimes these caches must be purged.
The cached values are renewed when found to be too old, with the age limit.
This maximum age can be set in seconds with the environment variable
<code>R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE</code>, or if unset, defaults to 3600
(one hour – see <code>utils::available.packages</code>).
</p>
<p>Internally, there are calls to <code>available.packages</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Numeric or logical indicating how verbose should the function
be. If -1 or -2, then as little verbosity as possible. If 0 or FALSE,
then minimal outputs; if <code>1</code> or TRUE, more outputs; <code>2</code> even more. NOTE: in
<code>Require</code> function, when <code>verbose &gt;= 2</code>, also returns details as if
<code>returnDetails = TRUE</code> (for backwards compatibility).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>See <code>utils::install.packages</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upgrade</code></td>
<td>
<p>When <code>FALSE</code>, the default, will only upgrade a package when the
version on in the local library is not adequate for the version requirements
of the <code>packages</code>. Note: for convenience, <code>update</code>
can be used for this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnDetails</code></td>
<td>
<p>Logical. If <code>TRUE</code> the return object will have an
attribute: <code>attr(.., "Require")</code> which has lots of information about the
processes of the installs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Passed to <code>install.packages</code>. Good candidates are e.g., <code>type</code> or
<code>dependencies</code>. This can be used with <code>install_githubArgs</code> or
<code>install.packageArgs</code> which give individual options for those 2 internal
function calls.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>Install</code> is the same as <code>Require(..., require = FALSE)</code>, for convenience.
</p>


<h3>Value</h3>

<p><code>Require</code> is intended to replace <code>base::require</code>, thus it returns a
logical, named vector indicating whether the named packages have been loaded.
Because <code>Require</code> also has the ability to install packages, a return value of
<code>FALSE</code> does not mean that it did not install correctly; rather, it means it
did not attach with <code>require</code>, which could be because it did not install
correctly, or also because e.g., <code>require = FALSE</code>.
</p>
<p><code>standAlone</code> will either put the <code>Require</code>d packages and their dependencies
<em>all</em> within the <code>libPaths</code> (if <code>TRUE</code>) or if <code>FALSE</code> will only install
packages and their dependencies that are otherwise not installed in
<code>.libPaths()[1]</code>, i.e., the current active R package directory. Any packages
or dependencies that are not yet installed will be installed in <code>libPaths</code>.
</p>


<h3>GitHub Package</h3>

<p>Follows <code>remotes::install_github</code> standard. As with
<code>remotes::install_github</code>, it is not possible to specify a past version of
a GitHub package unless that version is a tag or the user passes the SHA
that had that package version. Similarly, if a developer does a local
install e.g., via <code>pkgload::install</code>, of an active project, this package
will not be able know of the GitHub state, and thus <code>pkgSnapshot</code> will not
be able to recover this state as there is no SHA associated with a local
installation. Use <code>Require</code> (or <code>remotes::install_github</code>) to create a
record of the GitHub state.
</p>


<h3>Package Snapshots</h3>

<p>To build a snapshot of the desired packages and
their versions, first run <code>Require</code> with all packages, then <code>pkgSnapshot</code>.
If a <code>libPaths</code> is used, it must be used in both functions.
</p>


<h3>Mutual Dependencies</h3>

<p>This function works best if all required
packages are called within one <code>Require</code> call, as all dependencies can be
identified together, and all package versions will be addressed (if there
are no conflicts), allowing a call to <code>pkgSnapshot()</code> to take a snapshot or
"record" of the current collection of packages and versions.
</p>


<h3>Local Cache of Packages</h3>

<p>When installing new packages, <code>Require</code>
will put all source and binary files in an R-version specific subfolder of
<code>getOption("Require.cachePkgDir")</code> whose default is <code>RPackageCache()</code>,
meaning <em>cache packages locally in a project-independent location</em>, and
will reuse them if needed. To turn off this feature, set
<code>options("Require.cachePkgDir" = FALSE)</code>.
</p>


<h3>Note</h3>

<p>For advanced use and diagnosis, the user can set <code>verbose = TRUE</code> or
<code>1</code> or <code>2</code> (or via <code>options("Require.verbose")</code>). This will attach an
attribute <code>attr(obj, "Require")</code> to the output of this function.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eliot J B McIntire <a href="mailto:eliot.mcintire@canada.ca">eliot.mcintire@canada.ca</a> (<a href="https://orcid.org/0000-0002-6914-8316">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li>
<p> Alex M Chubaty <a href="mailto:achubaty@for-cast.ca">achubaty@for-cast.ca</a> (<a href="https://orcid.org/0000-0001-7146-8135">ORCID</a>) [contributor]
</p>
</li>
<li>
<p> Her Majesty the Queen in Right of Canada, as represented by the Minister of Natural Resources Canada [copyright holder]
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://Require.predictiveecology.org">https://Require.predictiveecology.org</a>
</p>
</li>
<li> <p><a href="https://github.com/PredictiveEcology/Require">https://github.com/PredictiveEcology/Require</a>
</p>
</li>
<li>
<p> Report bugs at <a href="https://github.com/PredictiveEcology/Require/issues">https://github.com/PredictiveEcology/Require/issues</a>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
opts &lt;- Require:::.setupExample()

library(Require)
getCRANrepos(ind = 1)
Require("utils") # analogous to require(stats), but it checks for
#   pkg dependencies, and installs them, if missing

# unquoted version
Require(c(tools, utils))

if (Require:::.runLongExamples()) {
  # Install in a new local library (libPaths)
  tempPkgFolder &lt;- file.path(tempdir(), "Require/Packages")
  # use standAlone, means it will put it in libPaths, even if it already exists
  #   in another local library (e.g., personal library)
  Install("crayon", libPaths = tempPkgFolder, standAlone = TRUE)

  # Mutual dependencies, only installs once -- e.g., cli
  tempPkgFolder &lt;- file.path(tempdir(), "Require/Packages")
  Install(c("cli", "R6"), libPaths = tempPkgFolder, standAlone = TRUE)

  # Mutual dependencies, only installs once -- e.g., rlang
  tempPkgFolder &lt;- file.path(tempdir(), "Require/Packages")
  Install(c("rlang", "ellipsis"), libPaths = tempPkgFolder, standAlone = TRUE)

  #####################################################################################
  # Isolated projects -- Use a project folder and pass to libPaths or set .libPaths() #
  #####################################################################################
  # GitHub packages
  if (requireNamespace("gitcreds", quietly = TRUE)) {
    #if (is(try(gitcreds::gitcreds_get(), silent = TRUE), "gitcreds")) {
      ProjectPackageFolder &lt;- file.path(tempdir(), "Require/ProjectA")
      if (requireNamespace("curl")) {
        Require("PredictiveEcology/fpCompare@development",
          libPaths = ProjectPackageFolder,
        )
      }

      # No install because it is there already
      Install("PredictiveEcology/fpCompare@development",
        libPaths = ProjectPackageFolder,
      ) # the latest version on GitHub

      ############################################################################
      # Mixing and matching GitHub, CRAN, with and without version numbering
      ############################################################################
      pkgs &lt;- c(
        "remotes (&lt;=2.4.1)", # old version
        "digest (&gt;= 0.6.28)", # recent version
        "PredictiveEcology/fpCompare@a0260b8476b06628bba0ae73af3430cce9620ca0" # exact version
      )
      Require::Require(pkgs, libPaths = ProjectPackageFolder)
    #}
  }
  Require:::.cleanup(opts)
}

## End(Not run)

</code></pre>


</div>