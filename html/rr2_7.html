<div class="container">

<table style="width: 100%;"><tr>
<td>R2_lik</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate R2_lik</h2>

<h3>Description</h3>

<p>Calculate partial and total R2s for LMM, GLMM, PGLS, and PGLMM using R2_lik, 
an R2 based on the likelihood of the fitted model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">R2_lik(mod = NULL, mod.r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mod</code></td>
<td>
<p>A regression model with one of the following classes: 'lm', 'glm', 
'lmerMod', 'glmerMod', 'phylolm', 'phyloglm', 'gls', 'pglmm', pglmm_compare' 
or 'communityPGLMM'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mod.r</code></td>
<td>
<p>A reduced model; if not provided, the total R2 will be given by 
setting 'mod.r' to the model corresponding to 'mod' with the intercept as 
the only predictor.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>R2_lik()</code> is implemented as
</p>
<p style="text-align: center;"><code class="reqn">partial R2 = 1 - exp(-2/n * (logLik(mod.f) - logLik(mod.r)))</code>
</p>

<p>where 'mod.f' and 'mod.r' are the full and reduced models, respectively. The total 
R2 is given when 'mod.r' is the model corresponding to mod.f that contains only 
the intercept. For GLMMs and PGLMMs, <code>R2_lik()</code> is standardized to have a 
maximum of one following Nagelkerke (1991). Although you can use R2_lik with 
models fit with REML, you really shouldn't, because this makes it impossible 
to compare values when reduced models differ in independent variables (fixed effects).
</p>
<p><code>R2_lik()</code> is also computed for LMMs and GLMMs in the MuMIn package.
</p>


<h3>Value</h3>

<p>R2_lik value.
</p>


<h3>Author(s)</h3>

<p>Anthony R. Ives
</p>


<h3>References</h3>

<p>Ives A.R. and Li D. 2018. rr2: An R package to calculate R2s for regression models. Journal of Open Source Software. DOI:10.21105/joss.01028
</p>
<p>Ives A.R. 2018. R2s for Correlated Data: Phylogenetic Models, LMMs, and GLMMs. Systematic Biology, Volume 68, Issue 2, March 2019, Pages 234-251. DOI:10.1093/sysbio/syy060
</p>
<p>Nagelkerke 1991. A note on a general definition of the coefficient of determination. Biometrika 78:691â€“692.
</p>


<h3>See Also</h3>

<p>MuMIn, lme4, ape, phylolm, phyr, pez
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ape)
library(phylolm)
library(lme4)
library(nlme)
library(phyr)

set.seed(12345)
p1 &lt;- 10
nsample &lt;- 10
n &lt;- p1 * nsample

d &lt;- data.frame(x1 = 0, x2 = 0, u1 = rep(1:p1, each = nsample),
                u2 = rep(1:p1, times = nsample))
d$u1 &lt;- as.factor(d$u1)
d$u2 &lt;- as.factor(d$u2)

b1 &lt;- 1
b2 &lt;- -1
sd1 &lt;- 1.5

d$x1 &lt;- rnorm(n = n)
d$x2 &lt;- rnorm(n = n)
d$y.lmm &lt;- b1 * d$x1 + b2 * d$x2 + 
  rep(rnorm(n = p1, sd = sd1), each = nsample) +
  rep(rnorm(n = p1, sd = sd1), times = nsample) + 
  rnorm(n = n)

prob &lt;- inv.logit(b1 * d$x1 + rep(rnorm(n = p1, sd = sd1), each = nsample))
d$y.glmm &lt;- rbinom(n = n, size = 1, prob = prob)

# LMM with two fixed and two random effects ----
z.f &lt;- lmer(y.lmm ~ x1 + x2 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.x &lt;- lmer(y.lmm ~ x1 + (1 | u1) + (1 | u2), data = d, REML = FALSE)
z.v &lt;- lmer(y.lmm ~ 1 + (1 | u2), data = d, REML = FALSE)
z.0 &lt;- lm(y.lmm ~ 1, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# GLMM with one fixed and one random effect ----
z.f &lt;- glmer(y.glmm ~ x1 + (1 | u1), data = d, family = 'binomial')
z.x &lt;- glmer(y.glmm ~ 1 + (1 | u1), data = d, family = 'binomial')
z.v &lt;- glm(y.glmm ~ x1, data = d, family = 'binomial')

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# PGLS with a single fixed effect ----
n &lt;- 100
d &lt;- data.frame(x = array(0, dim = n), y = 0)

b1 &lt;- 1.5
signal &lt;- 0.5

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rTraitCont(phy.x, model = 'BM', sigma = 1)
e &lt;- signal^0.5 * rTraitCont(phy, model = 'BM', sigma = 1) + (1-signal)^0.5 * rnorm(n = n)
d$x &lt;- x[match(names(e), names(x))]
d$y &lt;- b1 * x + e
rownames(d) &lt;- phy$tip.label
d$sp &lt;- phy$tip.label

z.f &lt;- pglmm_compare(y ~ x, data = d, phy = phy, REML=FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, phy = phy, REML=FALSE)
z.v &lt;- glm(y ~ x, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# These data can also be fit with phylolm() in {phylolm}
z.f &lt;- phylolm(y ~ x, phy = phy, data = d, model = 'lambda')
z.x &lt;- phylolm(y ~ 1, phy = phy, data = d, model = 'lambda')
z.v &lt;- lm(y ~ x, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# This also works for models fit with gls() in {nlme}
z.f &lt;- gls(y ~ x, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.x &lt;- gls(y ~ 1, data = d, correlation = corPagel(1, phy, form = ~sp), method = "ML")
z.v &lt;- lm(y ~ x, data = d)

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# PGLMM with one fixed effect ----
n &lt;- 100
b1 &lt;- 1.5
signal &lt;- 2

phy &lt;- compute.brlen(rtree(n = n), method = 'Grafen', power = 1)
phy.x &lt;- compute.brlen(phy, method = 'Grafen', power = .0001)

# Generate random data
x &lt;- rnorm(n)
d &lt;- data.frame(x = x, y = 0)

e &lt;- signal * rTraitCont(phy, model = 'BM', sigma = 1)
e &lt;- e[match(phy$tip.label, names(e))]

d$y &lt;- rbinom(n = n, size = 1, prob = inv.logit(b1 * d$x + e))
rownames(d) &lt;- phy$tip.label

z.f &lt;- phyloglm(y ~ x, data = d, start.alpha = 1, phy = phy)
z.x &lt;- phyloglm(y ~ 1, data = d, phy = phy, start.alpha = min(20, z.f$alpha))
z.v &lt;- glm(y ~ x, data = d, family = 'binomial')

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)

# These data can also be fit with pglmm_compare(), although note that 
# this is a different model from phyloglm()

z.f &lt;- pglmm_compare(y ~ x, data = d, family = "binomial", phy = phy, REML=FALSE)
z.x &lt;- pglmm_compare(y ~ 1, data = d, family = "binomial", phy = phy, REML=FALSE)
z.v &lt;- glm(y ~ x, data = d, family = "binomial")

R2_lik(z.f, z.x)
R2_lik(z.f, z.v)
R2_lik(z.f)
</code></pre>


</div>