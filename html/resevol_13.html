<div class="container">

<table style="width: 100%;"><tr>
<td>mine_gmatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mine G-matrices</h2>

<h3>Description</h3>

<p>Mine networks for establishing the link between genome and g-matrix. The 
output from this function is required to run individual-based simulations
in the rest of the package. The key input to this function, 'gmatrix', is a
(square) covariance matrix, with each row and column representing a trait for
the individual-based model. This function will run an evolutionary algorithm
to try to find a network that produces traits with the covariance structure
of gmatrix from a set of random standard normal values. The network from loci
values to trait values goes through a number of linked nodes to achieve this, 
and each generation tests the stress of the resulting network in terms of 
expected squared deviation of trait covariances from the input gmatrix. 
Simulations can take minutes to hours or longer, depending on parameters 
chosen and the number of traits. See vignettes for a more comprehensive
explanation for what this function is doing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mine_gmatrix(
  loci = 18,
  layers = 6,
  indivs = 1000,
  npsize = 2000,
  mu_pr = 0.05,
  mu_sd = 0.01,
  max_gen = 1000,
  pr_cross = 0.05,
  sampleK = 40,
  chooseK = 4,
  term_cri = -5.3,
  sd_ini = 0.1,
  use_cor = FALSE,
  prnt_out = TRUE,
  gmatrix
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>loci</code></td>
<td>
<p>The number of loci for an individual. Simulations can allow for 
both haploid and diploid individuals. Allele values at each loci affect trait
values through a network of intermediary nodes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layers</code></td>
<td>
<p>The number of hidden layers in the network linking loci to 
traits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indivs</code></td>
<td>
<p>The number of individuals initialised in each generation of the 
evolutionary algorithm to test among-individual trait correlations. 
Individuals are initialised with allele values drawn from a standard normal 
distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npsize</code></td>
<td>
<p>The size of the population of networks in each generation of the
evolutionary algorithm. Each network is a discrete individual in the 
population.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_pr</code></td>
<td>
<p>The probability that a value in the network will mutate in a 
generation. Mutation events change the existing value by adding a new value 
drawn from a normal distribution with a mean of 0 and standard deviation of
mu_sd.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_sd</code></td>
<td>
<p>The standard deviation of the random normal value mean centered 
at 0 that is added to the existing value of the network when a mutation event
occurs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_gen</code></td>
<td>
<p>The maximum number of generations that the evolutionary 
algorithm is allowed to run before terminating (regardless of how well the 
evolved covariance structure matches the pre-specified gmatrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pr_cross</code></td>
<td>
<p>The probability that a focal network in the population will 
initiate a crossover of a subset of its values with a randomly selected 
second network (note that any given network might therefore be included in 
more than one crossover event in a generation). The size of the subset is 
determined randomly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleK</code></td>
<td>
<p>During a round of selection, the number of random networks 
chosen to compete in a tournament. A single generation will include as many 
tournaments as necessary to create a new network population of size npsize.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chooseK</code></td>
<td>
<p>During a round of selection tournament, the number of networks 
within the sampleK random subset of the tournament that have the highest 
fitness will be selected to populate the next generation of networks</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term_cri</code></td>
<td>
<p>The criteria for terminating the evolutionary algorithm. The 
algorithm will terminate if a network is found in which the mean squared 
deviation of the covariance matrix elements from gmatrix is less than 
exp(term_crit).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_ini</code></td>
<td>
<p>The standard deviation of initialised network values at the 
start of the evolutionary algorithm. All network values are initialised by 
randomly sampling from a normal distribution with a mean of 0 and a 
standard deviation of sd_ini</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_cor</code></td>
<td>
<p>Should the gmatrix be treated as a correlation matrix rather 
than a covariance matrix when calculating fitness?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prnt_out</code></td>
<td>
<p>Should the function print out progress showing the stress for 
each generation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gmatrix</code></td>
<td>
<p>The pre-specified trait covariance matrix. This will define
what the covariance will be between each trait when allele values are drawn 
from a standard normal distribution.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of eight elements that includes the following: (1) A vector of
input parameters, (2) the pre-specified covariance matrix, (3) matrix defining
the effects of loci values on the first layer of the network, (4) a three
dimensional array link the first network layer to trait values, (5) a matrix
of the marginal effect of each locus on each trait, (6) the mined covariance
structure, (7) all network values to be inserted into individual genomes, and
(8) the log stress of the mined matrix against the pre-specified matrix.
</p>


<h3>Examples</h3>

<pre><code class="language-R">gmt       &lt;- matrix(data = 0, nrow = 4, ncol = 4);
diag(gmt) &lt;- 1;
mg        &lt;- mine_gmatrix(gmatrix = gmt, loci = 4, layers = 3, indivs = 100, 
                         npsize = 100, max_gen = 2, prnt_out = FALSE);
</code></pre>


</div>