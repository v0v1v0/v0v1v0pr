<div class="container">

<table style="width: 100%;"><tr>
<td>graph_knn_query</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Query a search graph for nearest neighbors</h2>

<h3>Description</h3>

<p>Run queries against a search graph, to return nearest neighbors taken from
the reference data used to build that graph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">graph_knn_query(
  query,
  reference,
  reference_graph,
  k = NULL,
  metric = "euclidean",
  init = NULL,
  epsilon = 0.1,
  max_search_fraction = 1,
  use_alt_metric = TRUE,
  n_threads = 0,
  verbose = FALSE,
  obs = "R"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>Matrix of <code>n</code> query items, with observations in the rows and
features in the columns. Optionally, the data may be passed with the
observations in the columns, by setting <code>obs = "C"</code>, which should be more
efficient. The <code>reference</code> data must be passed in the same orientation as
<code>query</code>. Possible formats are <code>base::data.frame()</code>, <code>base::matrix()</code>
or <code>Matrix::sparseMatrix()</code>. Sparse matrices should be in <code>dgCMatrix</code>
format. Dataframes will be converted to <code>numerical</code> matrix format
internally, so if your data columns are <code>logical</code> and intended to be used
with the specialized binary <code>metric</code>s, you should convert it to a logical
matrix first (otherwise you will get the slower dense numerical version).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>Matrix of <code>m</code> reference items, with observations in the rows
and features in the columns. The nearest neighbors to the queries are
calculated from this data. Optionally, the data may be passed with the
observations in the columns, by setting <code>obs = "C"</code>, which should be more
efficient. The <code>query</code> data must be passed in the same format and
orientation as <code>reference</code>. Possible formats are <code>base::data.frame()</code>,
<code>base::matrix()</code> or <code>Matrix::sparseMatrix()</code>. Sparse matrices should be in
<code>dgCMatrix</code> format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference_graph</code></td>
<td>
<p>Search graph of the <code>reference</code> data. A neighbor
graph, such as that output from <code>nnd_knn()</code> can be used, but
preferably a suitably prepared sparse search graph should be used, such as
that output by <code>prepare_search_graph()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of nearest neighbors to return. Optional if <code>init</code> is
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>Type of distance calculation to use. One of:
</p>

<ul>
<li> <p><code>"braycurtis"</code>
</p>
</li>
<li> <p><code>"canberra"</code>
</p>
</li>
<li> <p><code>"chebyshev"</code>
</p>
</li>
<li> <p><code>"correlation"</code> (1 minus the Pearson correlation)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"euclidean"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"hellinger"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"jensenshannon"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"sqeuclidean"</code> (squared Euclidean)
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"spearmanr"</code> (1 minus the Spearman rank correlation)
</p>
</li>
<li> <p><code>"symmetrickl"</code> (symmetric Kullback-Leibler divergence)
</p>
</li>
<li> <p><code>"tsss"</code> (Triangle Area Similarity-Sector Area Similarity or TS-SS
metric)
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li>
</ul>
<p>For non-sparse data, the following variants are available with
preprocessing: this trades memory for a potential speed up during the
distance calculation. Some minor numerical differences should be expected
compared to the non-preprocessed versions:
</p>

<ul>
<li> <p><code>"cosine-preprocess"</code>: <code>cosine</code> with preprocessing.
</p>
</li>
<li> <p><code>"correlation-preprocess"</code>: <code>correlation</code> with preprocessing.
</p>
</li>
</ul>
<p>For non-sparse binary data passed as a <code>logical</code> matrix, the following
metrics have specialized variants which should be substantially faster than
the non-binary variants (in other cases the logical data will be treated as
a dense numeric vector of 0s and 1s):
</p>

<ul>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"matching"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Initial <code>query</code> neighbor graph to optimize. If not provided, <code>k</code>
random neighbors are created. If provided, the input format must be one of:
</p>

<ol>
<li>
<p> A list containing:
</p>

<ul>
<li> <p><code>idx</code> an <code>n</code> by <code>k</code> matrix containing the nearest neighbor indices.
</p>
</li>
<li> <p><code>dist</code> (optional) an <code>n</code> by <code>k</code> matrix containing the nearest neighbor
distances.
</p>
</li>
</ul>
<p>If <code>k</code> and <code>init</code> are specified as arguments to this function, and the
number of neighbors provided in <code>init</code> is not equal to <code>k</code> then:
</p>

<ul>
<li>
<p> if <code>k</code> is smaller, only the <code>k</code> closest values in <code>init</code> are retained.
</p>
</li>
<li>
<p> if <code>k</code> is larger, then random neighbors will be chosen to fill <code>init</code> to
the size of <code>k</code>. Note that there is no checking if any of the random
neighbors are duplicates of what is already in <code>init</code> so effectively fewer
than <code>k</code> neighbors may be chosen for some observations under these
circumstances.
</p>
</li>
</ul>
<p>If the input distances are omitted, they will be calculated for you.
</p>
</li>
<li>
<p> A random projection forest, such as that returned from <code>rpf_build()</code> or
<code>rpf_knn()</code> with <code>ret_forest = TRUE</code>.
</p>
</li>
</ol>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Controls trade-off between accuracy and search cost, as
described by Iwasaki and Miyazaki (2018), by specifying a distance
tolerance on whether to explore the neighbors of candidate points. The
larger the value, the more neighbors will be searched. A value of 0.1
allows query-candidate distances to be 10% larger than the current
most-distant neighbor of the query point, 0.2 means 20%, and so on.
Suggested values are between 0-0.5, although this value is highly dependent
on the distribution of distances in the dataset (higher dimensional data
should choose a smaller cutoff). Too large a value of <code>epsilon</code> will result
in the query search approaching brute force comparison. Use this parameter
in conjunction with <code>max_search_fraction</code> and <code>prepare_search_graph()</code> to
prevent excessive run time. Default is 0.1. If you set <code>verbose = TRUE</code>,
statistics of the number of distance calculations will be logged which
can help you tune <code>epsilon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_search_fraction</code></td>
<td>
<p>Maximum fraction of the reference data to search.
This is a value between 0 (search none of the reference data) and 1 (search
all of the data if necessary). This works in conjunction with <code>epsilon</code> and
will terminate the search early if the specified fraction of the reference
data has been searched. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_alt_metric</code></td>
<td>
<p>If <code>TRUE</code>, use faster metrics that maintain the
ordering of distances internally (e.g. squared Euclidean distances if using
<code>metric = "euclidean"</code>), then apply a correction at the end. Probably the
only reason to set this to <code>FALSE</code> is if you suspect that some sort of
numeric issue is occurring with your data in the alternative code path. If
a search forest is used for initialization via the <code>init</code> parameter, then
the metric is fetched from there and this setting is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>
<p>Number of threads to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, log information to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>
<p>set to <code>"C"</code> to indicate that the input <code>query</code> and <code>reference</code>
orientation stores each observation as a column (the orientation must be
consistent). The default <code>"R"</code> means that observations are stored in each
row. Storing the data by row is usually more convenient, but internally
your data will be converted to column storage. Passing it already
column-oriented will save some memory and (a small amount of) CPU usage.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A greedy beam search is used to query the graph, combining two search pruning
strategies. The first, due to Iwasaki and Miyazaki (2018), only considers
new candidates within a relative distance of the current furthest neighbor
in the query's graph. The second, due to Harwood and Drummond (2016), puts a
limit on the absolute number of distance calculations to carry out. See the
<code>epsilon</code> and <code>max_search_fraction</code> parameters respectively.
</p>


<h3>Value</h3>

<p>the approximate nearest neighbor graph as a list containing:
</p>

<ul>
<li> <p><code>idx</code> a <code>n</code> by <code>k</code> matrix containing the nearest neighbor indices
specifying the row of the neighbor in <code>reference</code>.
</p>
</li>
<li> <p><code>dist</code> a <code>n</code> by <code>k</code> matrix containing the nearest neighbor distances.
</p>
</li>
</ul>
<h3>References</h3>

<p>Harwood, B., &amp; Drummond, T. (2016).
Fanng: Fast approximate nearest neighbour graphs.
In <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>
(pp. 5713-5722).
</p>
<p>Iwasaki, M., &amp; Miyazaki, D. (2018).
Optimization of indexing based on k-nearest neighbor graph for proximity
search in high-dimensional data.
<em>arXiv preprint arXiv:1810.07355</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># 100 reference iris items
iris_ref &lt;- iris[iris$Species %in% c("setosa", "versicolor"), ]

# 50 query items
iris_query &lt;- iris[iris$Species == "versicolor", ]

# First, find the approximate 4-nearest neighbor graph for the references:
iris_ref_graph &lt;- nnd_knn(iris_ref, k = 4)

# For each item in iris_query find the 4 nearest neighbors in iris_ref.
# You need to pass both the reference data and the reference graph.
# If you pass a data frame, non-numeric columns are removed.
# set verbose = TRUE to get details on the progress being made
iris_query_nn &lt;- graph_knn_query(iris_query, iris_ref, iris_ref_graph,
  k = 4, metric = "euclidean", verbose = TRUE
)

# A more complete example, converting the initial knn into a search graph
# and using a filtered random projection forest to initialize the search
# create initial knn and forest
iris_ref_graph &lt;- nnd_knn(iris_ref, k = 4, init = "tree", ret_forest = TRUE)
# keep the best tree in the forest
forest &lt;- rpf_filter(iris_ref_graph, n_trees = 1)
# expand the knn into a search graph
iris_ref_search_graph &lt;- prepare_search_graph(iris_ref, iris_ref_graph)
# run the query with the improved graph and initialization
iris_query_nn &lt;- graph_knn_query(iris_query, iris_ref, iris_ref_search_graph,
  init = forest, k = 4
)

</code></pre>


</div>