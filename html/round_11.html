<div class="container">

<table style="width: 100%;"><tr>
<td>roundX</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rounding Numbers to Decimal Digits – Variants</h2>

<h3>Description</h3>

<p>Provide several <code>version</code>s of algorithms for <code>round(x,
    digits)</code>, i.e., rounding to decimal digits.  In particular, provides
previous and current implementations of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s <code>round()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">roundX  (x, digits, version = roundVersions, trace = 0)

roundAll(x, digits, versions = roundVersions)

round_r3(x, d, info=FALSE, check=TRUE)

roundVersions # "sprintf" "r0.C" "r1.C" "r1a.C" "r2.C"  "r3.C" "r3d.C"  "r3"
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits, d</code></td>
<td>
<p>integer number (for <code>d</code>) or numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>version</code></td>
<td>
<p>a <code>character</code> string specifying the version of
rounding.  Must match <code>roundVersions</code> (via
<code>match.arg</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>integer; if positive, the corresponding computations should
be “traced” (possibly proportionally to the value of
<code>trace</code>); currently only implemented for <code>version = "r3.C"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>versions</code></td>
<td>
<p>a <code>character</code> vector, a subset of
<code>roundVersions</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p><code>logical</code> specifying if <code>round_r3(*)</code> should
result in a <code>list</code> with components
</p>

<dl>
<dt>
<code>"r"</code>:</dt>
<dd>
<p>the rounded <code>x</code>,</p>
</dd>
<dt>
<code>"D"</code>:</dt>
<dd>
<p>the difference <code>(xu - x) - (x - xd)</code>, where
<code>xd</code> and <code>xu</code> are the round <b>d</b>own and <b>u</b>p
versions of <code>x</code>,</p>
</dd>
<dt>
<code>"e"</code>:</dt>
<dd>
<p>the modulo-2 remainder of <code>floor(x * 10^d)</code>,
which determines rounding to even (only) in case <code>D = 0</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p><code>logical</code> indicating if <code>x</code> and
<code>digits</code> should be checked for validity.  Is set to <code>FALSE</code>
when used in <code>roundX()</code> (or <code>roundAll</code>), as the checks happen
before <code>round_r3()</code> is called.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Rounding to decimal digits is non-trivial in binary arithmetic.  ISO
standard “round to even”, see <code>round()</code>'s (help page),
is more rare than typically assumed as most decimal fractions
are not exactly representable in binary <code>double</code> precision
numbers.
</p>
<p>Decimal rounding is well defined when <code>digits = 0</code>, and calls the
(C99 standard) C library function <code>nearbyint()</code> (which
provide in this package as well, for completeness):
<code>round(x)</code> is (<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> level) equivalent to <code>round(x, digits
  = 0)</code> and is also equivalent to (<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and C level) <code>nearbyint(x)</code>
which is defined to return the closest integer number (as
<code>double</code>) and in the case of “doubt”, where both
integer number neighbours are of the same distance, i.e., distance
<code>0.5</code> the famous “round to even” strategy is used, such that,
e.g., <code>round(0:7 + 0.5) == c(0, 2, 2, 4, 4, 6, 6, 8)</code>.
</p>
<p>The following strategy / algorithms are used for the different
<code>roundVersions</code>; note that we <em>only</em> consider the crucial case
<code>digits &gt; 0</code> in the following description:

</p>

<dl>
<dt>
<code>"sprintf"</code>:</dt>
<dd>
<p>diverts the operation to
<code>sprintf("%.*f", digits, x)</code> which in turn diverts to the
corresponding C library function <code>sprintf()</code>; consequently may
be platform dependent (though we have not yet seen differences from
what we get by the most widely used GNU ‘<span class="file">glibc</span>’ library,
<a href="https://www.gnu.org/software/libc/">https://www.gnu.org/software/libc/</a>).  This version does <em>not</em>
work with negative digits, returning <code>NA</code> with a
<code>warning</code> there.</p>
</dd>
<dt>
<code>"r0.C"</code>:</dt>
<dd>
<p>a (too much) simplified version of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s
<code>"r1.C"</code>, just skipping the whole integer part computations;
this was the first patch proposal in R-bugs' report <a href="https://bugs.R-project.org/show_bug.cgi?id=17668">PR#17668</a>.

However, this completely breaks down in extreme cases.</p>
</dd>
</dl>
<dl>
<dt>
<code>"r1.C"</code>:</dt>
<dd>
<p>the version of <code>round()</code> as in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
3.6.2 and earlier.  It first removes the integer part(s) of <code>x</code>,
then rounds and re-adds the integer part.</p>
</dd>
<dt>
<code>"r1a.C"</code>:</dt>
<dd>
<p>a slightly improved version of <code>"r1.C"</code>,
notably for |digits| &gt; 308.</p>
</dd>
<dt>
<code>"r2.C"</code>:</dt>
<dd>
<p>the version of <code>round()</code> as added to
‘R-devel’ (the development version of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>) with ‘<span class="file">svn</span>’ revision
<code>.....</code>.  It does <em>not</em> remove and re-add the integer part(s)
of <code>x</code> but ensures that no unnecessary overflow to <code>+/-Inf</code> or
underflow to <code>0</code> happens when numbers are multiplied and divided
by <code class="reqn">10^d</code>.</p>
</dd>
<dt>
<code>"r2a.C"</code>:</dt>
<dd>
<p>a slightly improved version of <code>"r2.C"</code>,
notably for large negative digits.</p>
</dd>
<dt>
<code>"r3"</code>:</dt>
<dd>
<p>(<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> level) implementation of “correct”
rounding, rounding to the nearest double precision number (with
“round to even” in case of equal distance) as seen in the
function definition of <code>round_r3()</code>.  Note that
<code>info=TRUE</code> is only applied when when the <code>digits</code> <code class="reqn">d</code>
fulfill <code class="reqn">|d| &lt;= 308</code>.</p>
</dd>
<dt>
<code>"r3.C"</code>:</dt>
<dd>
<p>a C translation of <code>"r3"</code>, using <code>long
	double</code> for intermediate computations which is particularly
convenient for <code>digits</code> <code class="reqn">308 &lt; d &lt; ~324</code> as overflow is not
a possible then.</p>
</dd>
<dt>
<code>"r3d.C"</code>:</dt>
<dd>
<p>a version of <code>"r3.C"</code>, only using
<code>double</code> precision, and hence typically fast and less platform
dependent, and also more often identical to <code>"r3"</code>.</p>
</dd>
</dl>
<h3>Value</h3>

<p><code>roundX()</code> returns a numeric vector (of length of recycled <code>x</code>
and <code>digits</code>, i.e., typically (when <code>digits</code> is of
length one) of <code>length(x)</code>.
</p>
<p><code>round_r3()</code> is the workhorse of <code>roundX(.., version = "r3")</code>;
it vectorizes in <code>x</code> but needs <code>length(d) == 1</code>.
</p>
<p><code>roundVersions</code> is a <code>character</code> vector of the versions
available for <code>roundX()</code>.
</p>
<p><code>roundAll()</code> applies <code>roundX()</code> for all <code>versions</code>,
returning a matrix if one of <code>x</code> or <code>digits</code> is not of length one.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler (R Core for version "r1.C")</p>


<h3>References</h3>

<p>Wikipedia, Rounding, notably "Round half to even":
<a href="https://en.wikipedia.org/wiki/Rounding#Round_half_to_even">https://en.wikipedia.org/wiki/Rounding#Round_half_to_even</a>
</p>


<h3>See Also</h3>

<p><code>round</code>, also <code>signif</code> which is relatively
sophisticated (also by code from M.M.).</p>


<h3>Examples</h3>

<pre><code class="language-R">roundVersions

round (55.55, 1)
roundX(55.55, 1, "r3")

## round() with all  roundVersions; quite simple (w/ recycling!)
roundAll # shows the function's definition

roundAll(55.55, 1)
roundAll(55.555, 2)
roundAll(55.5555, 3)
roundAll(55.55555, 4)
roundAll(55.555555, 5)
roundAll(55.5555555, 6)

## other "controversial" cases
rEx &lt;- cbind( x =  c(10.7775, 12.345, 9.18665),
         digits =  c(   3  ,    2   ,    4   ))

resEx &lt;- matrix(, length(roundVersions), nrow(rEx),
                dimnames = list(roundVersions, as.character(rEx[,"x"])))
for(i in 1:nrow(rEx))
  resEx[,i] &lt;-  roundAll(rEx[[i,"x"]], digits = rEx[[i,"digits"]])

resEx  # r0.C &amp; r2* agree and differ from the r1*;
       # "r3*" is close to "r2*" but not for 12.345
## The parts of "r3" :
r3rE &lt;- sapply(1:nrow(rEx), function(i)
               round_r3(rEx[[i,"x"]], rEx[[i,"digits"]], info=TRUE))
colnames(r3rE) &lt;- sapply(rEx[,"x"], format)
r3rE # rounding to even when D=0, but not when D &lt; 0

## "Deterministic" Simulation - few digits only:
long &lt;- interactive() # save time/memory e.g. when checking
I &lt;- if(long) 0:9999 else 0:999
Ix &lt;- I + 0.5
ndI &lt;- 1L + as.integer(log10(pmax(1,I))) # number of (decimal) digits of I
nd2 &lt;- outer(ndI, if(long) -3:4 else -2:3, `+`)
x   &lt;- c(t( Ix / (10^nd2) ))
nd2 &lt;- c(t( nd2 ))
 x  &lt;-  x [nd2 &gt; 0]
nd2 &lt;- nd2[nd2 &gt; 0]
rx &lt;- roundAll(x, digits = nd2)

formatF &lt;- function(.) format(., scientific=FALSE, drop0trailing=TRUE)
rownames(rx) &lt;- formatF(x)
options(width = 123)
noquote(cbind(d = nd2, formatF(rx))[1:140,])
## -&gt; The first cases already show a diverse picture; sprintf() a bit as outlier

## Error, assuming "r3" to be best, as it *does* really go to nearest:
Err &lt;- rx - rx[, "r3"]
## careful : allowing small "noise" differences:
tErr &lt;- abs(Err) &gt; 1e-3* 10^-nd2 # "truly" differing from "r3"
colSums(tErr)  ## --&gt; old R "r1*" is best here, then sprintf (among non-r3):
## For F30 Linux 64-bit (gcc),  and this selection of cases, r0+r2 are worst; r1 is best
## sprintf   r0.C   r1.C  r1a.C    r2.C  r2a.C   r3.C r3d.C  r3
##   15559  19778  14078  14078   19778  19778      8     0   0  {  long }
##    1167   1457   1290   1290    1457   1457      0     0   0  { !long }
if(long) { ## Q: where does  "r3.C"  differ from "r3" == "r3d.C" ?    A: in 10 cases; 8 "real"
  i3D &lt;- which(Err[,"r3.C"] != 0)
  print(cbind(d = nd2[i3D], formatF(rx[i3D,])), quote=FALSE)
  print.table(zapsmall(Err[i3D,]), zero.print = ".")# differences (not very small ones!)
}

## Visualization of error happening (FIXME: do zapsmall()-like not count "noise")
cumErr &lt;- apply(tErr[,colnames(rx) != "r3"], 2L, cumsum)
matPm &lt;- function(y) {
   matplot(y=y, type = "l", lwd = 2, xlab = "i", ylab = deparse(substitute(y)))
   abline(h = 0, lty=2, col="gray")
   legend("topleft", legend = setdiff(roundVersions, "r3"),
          col = 1:6, lty = 1:5, lwd = 2, bty = "n")
}
matPm(head(cumErr,  100)) # sprintf seems worst
matPm(head(cumErr,  250)) # now r0+2 is worst, sprintf best
matPm(head(cumErr, 1000)) # now sprintf clearly worst again
matPm(head(cumErr, 2000)) # 0r/r2 best sprintf catching up
if(long) {
matPm(head(cumErr, 5000)) # now sprintf clearly worst again
matPm(head(cumErr,10000)) # now r0+2 is worst,  r1 best
}
matPm( cumErr )

same_cols &lt;- function(m) all(m == m[,1])
stopifnot(same_cols(Err[, c("r0.C", "r2.C", "r2a.C")]))
stopifnot(same_cols(Err[, c("r1.C", "r1a.C")]))
if(FALSE) ## *not* in 'long' case, see above
stopifnot(same_cols(Err[, c("r3", "r3.C", "r3d.C")]))

sp &lt;- search()
if(long &amp;&amp; require("Matrix")) {
  showSp &lt;- function(m) print(image(as(m, "sparseMatrix"), aspect = 4,
         ## fails, bug in lattice?  useRaster = !dev.interactive(TRUE) &amp;&amp; (nrow(m) &gt;= 2^12),
                                border.col = if(nrow(m) &lt; 1e3) adjustcolor(1, 1/2) else NA))
  showSp(head(Err, 100))
  showSp(head(Err, 1000))
  showSp(Err)
  showSp(Err != 0) # B&amp;W version ..
  if(!any(sp == "package:Matrix")) detach("package:Matrix")
}

## More digits random sample simulation tend go against "sprintf";
## see ../tests/  and also the vignette
</code></pre>


</div>