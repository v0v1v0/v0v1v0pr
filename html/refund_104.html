<div class="container">

<table style="width: 100%;"><tr>
<td>smooth.construct.dt.smooth.spec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Domain Transformation basis constructor</h2>

<h3>Description</h3>

<p>The <code>dt</code> basis allows for any of the standard <code>mgcv</code> (or
user-defined) bases to be aplied to a transformed version of the
original terms. Smooths may be of any number of terms. Transformations
are specified by supplying a function of any or all of the original terms.
"<code>by</code>" variables are not transformed.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'dt.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a smooth specification object, generated by <code>s()</code>,
<code>te()</code>, <code>ti()</code>, or <code>t2()</code>, with <code>bs="dt"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list containing just the data (including any by variable)
required by this term, with names corresponding to <code>object$term</code>
(and <code>object$by</code>). The <code>by</code> variable is the last element.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knots</code></td>
<td>
<p>a list containing any knots supplied for basis setup - in same
order and with same names as <code>data</code>. Can be <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>object</code> should be creaated with an <code>xt</code> argument. For
non-tensor-product smooths, this will be a list with the following elements:
</p>

<ol>
<li> <p><code>tf</code> (required): a function or character string (or list of functions
and/or character strings) defining the coordinate transformations; see
further details below.
</p>
</li>
<li> <p><code>bs</code> (optional): character string indicating the <code>bs</code> for
the basis applied to the transformed coordinates; if empty, the appropriate
defaults are used.
</p>
</li>
<li> <p><code>basistype</code> (optional): character string indicating type of
bivariate basis used. Options include <code>"s"</code> (the default), <code>"te"</code>,
<code>"ti"</code>, and <code>"t2"</code>, which correspond to <code>s</code>,
<code>te</code>, <code>ti</code>, and <code>t2</code>.
</p>
</li>
<li> <p><code>...</code> (optional): for tensor product smooths, additional arguments
to the function specified by <code>basistype</code> that are not available in
<code>s()</code> can be included here, e.g. <code>d</code>, <code>np</code>, etc.
</p>
</li>
</ol>
<p>For tensor product smooths, we recommend using <code>s()</code> to set up the basis,
and specifying the tensor product using <code>xt$basistype</code> as described
above. If the basis is set up using <code>te()</code>, then the variables in
<code>object$term</code> will be split up, meaning all transformation functions
would have to be univariate.
</p>


<h3>Value</h3>

<p>An object of class "dt.smooth". This will contain all the elements
associated with the <code>smooth.construct</code> object from the
inner smooth (defined by <code>xt$bs</code>), in addition to an <code>xt</code>
element used by the <code>Predict.matrix</code> method.
</p>


<h3>Transformation Functions</h3>

<p>Let <code>nterms = length(object$term)</code>. The <code>tf</code> element can take one
of the following forms:
</p>

<ol>
<li>
<p> a function of <code>nargs</code> arguments, where <code>nargs &lt;= nterms</code>.
If <code>nterms &gt; 1</code>, it is assumed that this function will be applied to
the first term of <code>object$term</code>. If all argument names of the
function are term names, then those arguments will correspond to those
terms; otherwise, they will correspond to the first <code>nargs</code> terms in
<code>object$term</code>.
</p>
</li>
<li>
<p> a character string corresponding to one of the built-in
transformations (listed below).
</p>
</li>
<li>
<p> A list of length <code>ntfuncs</code>, where <code>ntfuncs&lt;=nterms</code>,
containing either the functions or character strings described above. If
this list is named with term names, then the transformation functions
will be applied to those terms; otherwise, they will be applied to the
first <code>ntfuncs</code> terms in <code>object$term</code>.
</p>
</li>
</ol>
<p>The following character strings are recognized as built-in transformations:
</p>

<ul>
<li> <p><code>"log"</code>: log transformation (univariate)
</p>
</li>
<li> <p><code>"ecdf"</code>: empirical cumulative distribution function (univariate)
</p>
</li>
<li> <p><code>"linear01"</code>: linearly rescale from 0 to 1 (univariate)
</p>
</li>
<li> <p><code>"s-t"</code>: first term ("s") minus the second term ("t") (bivariate)
</p>
</li>
<li> <p><code>"s/t"</code>: first term ("s") divided by the second term ("t") (bivariate)
</p>
</li>
<li> <p><code>"QTransform"</code>: performs a time-specific ecdf transformation for
a bivariate smooth, where time is indicated by the first term, and
<code class="reqn">x</code> by the second term. Primarily for use with <code>refund::af</code>.
</p>
</li>
</ul>
<p>Some transformations rely on a fixed "pivot point" based on the data used to
fit the model, e.g. quantiles (such as the min or max) of this data.
When making predictions based on these transformations, the transformation
function will need to know what the pivot points are, based on the original
(not prediction) data. In order to accomplish this, we allow the user to
specify that they want their transformation function to refer to the original
data (as opposed to whatever the "current" data is). This is done by appending
a zero ("0") to the argument name.
</p>
<p>For example, suppose you want to scale
the term linearly so that the data used to define the basis ranges from
0 to 1. The wrong way to define this transformation function:
<code>function(x) {(x - min(x))/(max(x) - min(x))}</code>.
This function will result in incorrect predictions if the range of data for
which preditions are being made is not the same as the range of data that was
used to define the basis. The proper way to define this function:
<code>function(x) {(x - min(x0))/(max(x0) - min(x0))}</code>.
By refering to <code>x0</code> instead of <code>x</code>, you are indicating that you
want to use the original data instead of the current data. This may seem
strange to refer to a variable that is not one of the arguments, but the
<code>"dt"</code> constructor explicitly places these variables in the environment
of the transformation function to make them available.
</p>


<h3>Author(s)</h3>

<p>Jonathan Gellar
</p>


<h3>See Also</h3>

<p><code>smooth.construct</code>
</p>


</div>