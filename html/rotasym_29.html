<div class="container">

<table style="width: 100%;"><tr>
<td>tang-norm-decomp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distributions based on the tangent-normal decomposition</h2>

<h3>Description</h3>

<p>Density and simulation of a distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 2</code>, obtained by the
tangent-normal decomposition. The <em>tangent-normal decomposition</em> of
the random vector <code class="reqn">\mathbf{X}\in S^{p-1}</code> is
</p>
<p style="text-align: center;"><code class="reqn">V\boldsymbol{\theta} +
\sqrt{1 - V^2}\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{U}</code>
</p>

<p>where <code class="reqn">V := \mathbf{X}'\boldsymbol{\theta}</code> is a
random variable in <code class="reqn">[-1, 1]</code> (the <em>cosines</em> of
<code class="reqn">\mathbf{X}</code>) and
<code class="reqn">\mathbf{U} := \boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}/
||\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}||</code> is a random vector in
<code class="reqn">S^{p-2}</code> (the <em>multivariate signs</em> of <code class="reqn">\mathbf{X}</code>)
and <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is the
<code class="reqn">p\times(p-1)</code> matrix computed by <code>Gamma_theta</code>.
</p>
<p>The tangent-normal decomposition can be employed for constructing
distributions for <code class="reqn">\mathbf{X}</code> that arise for certain choices of
<code class="reqn">V</code> and <code class="reqn">\mathbf{U}</code>. If <code class="reqn">V</code> and
<code class="reqn">\mathbf{U}</code> are <em>independent</em>, then simulation from
<code class="reqn">\mathbf{X}</code> is straightforward using the tangent-normal
decomposition. Also, the density of <code class="reqn">\mathbf{X}</code> at
<code class="reqn">\mathbf{x}\in S^{p-1}</code>,
<code class="reqn">f_\mathbf{X}(\mathbf{x})</code>, is readily computed as
</p>
<p style="text-align: center;"><code class="reqn">f_\mathbf{X}(\mathbf{x})=
\omega_{p-1}c_g g(t)(1-t^2)^{(p-3)/2}f_\mathbf{U}(\mathbf{u})</code>
</p>

<p>where <code class="reqn">t:=\mathbf{x}'\boldsymbol{\theta}</code>,
<code class="reqn">\mathbf{u}:=\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{x}/
||\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{x}||</code>,
<code class="reqn">f_\mathbf{U}</code> is the density of <code class="reqn">\mathbf{U}</code>,
and <code class="reqn">f_V(v) := \omega_{p-1} c_g g(v) (1 - v^2)^{(p-3)/2}</code> is the density
of <code class="reqn">V</code> for an angular function <code class="reqn">g</code> with normalizing constant
<code class="reqn">c_g</code>. <code class="reqn">\omega_{p-1}</code> is the surface area of <code class="reqn">S^{p-2}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">d_tang_norm(x, theta, g_scaled, d_V, d_U, log = FALSE)

r_tang_norm(n, theta, r_U, r_V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>a unit norm vector of size <code>p</code> giving the axis of
rotational symmetry.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g_scaled</code></td>
<td>
<p>the <em>scaled</em> angular density <code class="reqn">c_g g</code>. In the
form <br><code>g_scaled &lt;- function(t, log = TRUE) {...}</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_V</code></td>
<td>
<p>the density <code class="reqn">f_V</code>. In the form
<code>d_V &lt;- function(v, log = TRUE) {...}</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d_U</code></td>
<td>
<p>the density <code class="reqn">f_\mathbf{U}</code>. In the form
<code>d_U &lt;- function(u, log = TRUE) {...}</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_U</code></td>
<td>
<p>a function for simulating <code class="reqn">\mathbf{U}</code>. Its first argument
must be the sample size. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_V</code></td>
<td>
<p>a function for simulating <code class="reqn">V</code>. Its first argument must be
the sample size. See examples.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Either <code>g_scaled</code> or <code>d_V</code> can be supplied to <code>d_tang_norm</code>
(the rest of the arguments are compulsory). One possible choice for
<code>g_scaled</code> is <code>g_vMF</code> with <code>scaled = TRUE</code>. Another
possible choice is the angular function <code class="reqn">g(t) = 1 - t^2</code>, normalized by
its normalizing constant
<code class="reqn">c_g = (\Gamma(p/2) p) / (2\pi^{p/2} (p - 1))</code> (see examples).
This angular function makes <code class="reqn">V^2</code> to be distributed as a
<code class="reqn">\mathrm{Beta}(1/2,(p+1)/2)</code>.
</p>
<p>The normalizing constants and densities are computed through log-scales for
numerical accuracy.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_tang_norm</code>: a vector of length <code>nx</code> or <code>1</code>
with the evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_tang_norm</code>: a matrix of size <code>c(n, p)</code> with the
random sample.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873–1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>See Also</h3>

<p><code>Gamma_theta</code>, <code>signs</code>,
<code>tangent-elliptical</code>, <code>tangent-vMF</code>,
<code>vMF</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Simulation and density evaluation for p = 2

# Parameters
n &lt;- 1e3
p &lt;- 2
theta &lt;- c(rep(0, p - 1), 1)
mu &lt;- c(rep(0, p - 2), 1)
kappa_V &lt;- 2
kappa_U &lt;- 0.1

# The vMF scaled angular function
g_scaled &lt;- function(t, log) {
  g_vMF(t, p = p - 1, kappa = kappa_V, scaled = TRUE, log = log)
}

# Cosine density for the vMF distribution
d_V &lt;- function(v, log) {
 log_dens &lt;- g_scaled(v, log = log) + (p - 3)/2 * log(1 - v^2)
 switch(log + 1, exp(log_dens), log_dens)
}

# Multivariate signs density based on a vMF
d_U &lt;- function(x, log) d_vMF(x = x, mu = mu, kappa = kappa_U, log = log)

# Simulation functions
r_V &lt;- function(n) r_g_vMF(n = n, p = p, kappa = kappa_V)
r_U &lt;- function(n) r_vMF(n = n, mu = mu, kappa = kappa_U)

# Sample and color according to density
x &lt;- r_tang_norm(n = n, theta = theta, r_V = r_V, r_U = r_U)
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
col &lt;- viridisLite::viridis(n)
dens &lt;- d_tang_norm(x = x, theta = theta, g_scaled = g_scaled, d_U = d_U)
# dens &lt;- d_tang_norm(x = x, theta = theta, d_V = d_V, d_U = d_U) # The same
plot(r * x, pch = 16, col = col[rank(dens)])

## Simulation and density evaluation for p = 3

# Parameters
p &lt;- 3
n &lt;- 5e3
theta &lt;- c(rep(0, p - 1), 1)
mu &lt;- c(rep(0, p - 2), 1)
kappa_V &lt;- 2
kappa_U &lt;- 2

# Sample and color according to density
x &lt;- r_tang_norm(n = n, theta = theta, r_V = r_V, r_U = r_U)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_tang_norm(x = x, theta = theta, g_scaled = g_scaled, d_U = d_U)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}

## A non-vMF angular function: g(t) = 1 - t^2. It is sssociated to the
## Beta(1/2, (p + 1)/2) distribution.

# Scaled angular function
g_scaled &lt;- function(t, log) {
  log_c_g &lt;- lgamma(0.5 * p) + log(0.5 * p / (p - 1)) - 0.5 * p * log(pi)
  log_g &lt;- log_c_g + log(1 - t^2)
  switch(log + 1, exp(log_g), log_g)
}

# Cosine density
d_V &lt;- function(v, log) {
  log_dens &lt;- w_p(p = p - 1, log = TRUE) + g_scaled(t = v, log = TRUE) +
    (0.5 * (p - 3)) * log(1 - v^2)
  switch(log + 1, exp(log_dens), log_dens)
}

# Simulation
r_V &lt;- function(n) {
  sample(x = c(-1, 1), size = n, replace = TRUE) *
    sqrt(rbeta(n = n, shape1 = 0.5, shape2 = 0.5 * (p + 1)))
}

# Sample and color according to density
r_U &lt;- function(n) r_unif_sphere(n = n, p = p - 1)
x &lt;- r_tang_norm(n = n, theta = theta, r_V = r_V, r_U = r_U)
col &lt;- viridisLite::viridis(n)
dens &lt;- d_tang_norm(x = x, theta = theta, d_V = d_V, d_U = d_unif_sphere)
# dens &lt;- d_tang_norm(x = x, theta = theta, g_scaled = g_scaled,
#                     d_U = d_unif_sphere) # The same
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(dens)], size = 5)
}
</code></pre>


</div>