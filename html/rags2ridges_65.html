<div class="container">

<table style="width: 100%;"><tr>
<td>ridgeP.fused</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fused ridge estimation</h2>

<h3>Description</h3>

<p>Performs fused ridge estimation of multiple precision matrices in cases
where multiple classes of data is present for given a penalty matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ridgeP.fused(
  Slist,
  ns,
  Tlist = default.target.fused(Slist, ns),
  lambda,
  Plist,
  maxit = 100L,
  verbose = TRUE,
  relative = TRUE,
  eps = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Slist</code></td>
<td>
<p>A <code>list</code> of length <code class="reqn">G</code> of covariance matrices, i.e.
square, symmetric <code>numeric</code> matrices of the same size.  The <code class="reqn">g</code>th
matrix should correspond to the <code class="reqn">g</code>th class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ns</code></td>
<td>
<p>A <code>numeric</code> vector of sample sizes on which the matrices in
<code>Slist</code> are based.  I.e. <code>ns[g]</code> correspond to <code>Slist[[g]]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tlist</code></td>
<td>
<p>A <code>list</code> of length <code class="reqn">G</code> of <code>numeric</code> p.d. target
matrices corresponding to the matrices in <code>Slist</code>.  If not supplied,
the default is given by <code>default.target</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The <code class="reqn">G</code> by <code class="reqn">G</code> penalty matrix.  That is, a symmetric,
non-negative <code>numeric</code> <code>matrix</code> of size <code class="reqn">G</code> times <code class="reqn">G</code>
giving the class- and pair-specific penalties.  The diagonal entries are the
class specific ridge penalties.  I.e. <code>lambda[i, i]</code> is the ridge
penalty for class <code class="reqn">i</code>.  The off-diagonal entries are the pair-specific
fusion penalties.  I.e. <code>lambda[i, j]</code> is the fusion penalty applied on
the pair of classes <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
<p>Alternatively, can be supplied as a <code>numeric</code> of length 1 or 2.  If a
single number, a diagonal penalty with lambda in the diagonal is used If
supplied as a <code>numeric</code> vector of two numbers, the first is used as a
common ridge penalty and the second as a common fusion penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Plist</code></td>
<td>
<p>An optional <code>list</code> of initial precision matrices for the
fused ridge algorithm the same size as <code>Slist</code>.  Can be omitted.
Default is the nonfused ridge precision estimate using the pooled
covariance matrix corresponding to setting all fusion penalties to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>A single <code>integer</code> giving the maximum number of allowed
iterations.  Can be set to <code>Inf</code>.  If <code>maxit</code> is hit, a warning
is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>logical</code>. Set to <code>TRUE</code> for extra output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative</code></td>
<td>
<p><code>logical</code> indicating if the convergence criterion should
be on a relative scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>A single positive <code>numeric</code> giving the convergence threshold.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Performs a coordinate ascent to find the maximum likelihood of the fused
likelihood problem for a given ridge penalty <code class="reqn">lambda</code> and fused penalty
matrix <code class="reqn">Lambda_f</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> as <code>Slist</code> with precision estimates of the
corresponding classes.
</p>


<h3>Note</h3>

<p>For extreme fusion penalties in <code>lambda</code> the algorithm is quite
sensitive to the initial values given in <code>Plist</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau, Carel F.W. Peeters &lt;carel.peeters@wur.nl&gt;,
Wessel N. van Wieringen
</p>


<h3>References</h3>

<p>Bilgrau, A.E., Peeters, C.F.W., Eriksen, P.S., Boegsted, M., and
van Wieringen, W.N. (2020).  Targeted Fused Ridge Estimation of Inverse
Covariance Matrices from Multiple High-Dimensional Data Classes.  Journal
of Machine Learning Research, 21(26): 1-52.
</p>


<h3>See Also</h3>

<p><code>default.penalty</code> <br><code>ridgeP</code> for the
regular ridge estimate
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create some (not at all high-dimensional) data on three classes
p &lt;- 5  # Dimension
ns &lt;- c(4, 6, 8)  # Sample sizes (K = 3 classes)
Slist &lt;- createS(ns, p = p)
str(Slist, max.level = 2)  # The structure of Slist

#
# Estimate the precisions (using the complete penalty graph)
#

res1 &lt;- ridgeP.fused(Slist, ns, lambda = c(1.3, 2.1))
print(res1)

# The same using the penalty matrix (the diagnal is ignored)
mylambda  &lt;- matrix(c(1.3, 2.1, 2.1,
                      2.1, 1.3, 2.1,
                      2.1, 2.1, 1.3), 3, 3, byrow = TRUE)
res2 &lt;- ridgeP.fused(Slist, ns, lambda = mylambda)
stopifnot(all.equal(res1, res2))


#
# Estimate the precisions (using a non-complete penalty graph)
#

# Say we only want to shrink pairs (1,2) and (2,3) and not (1,3)
mylambda[1,3] &lt;- mylambda[3,1] &lt;- 0
print(mylambda)
res3 &lt;- ridgeP.fused(Slist, ns, lambda = mylambda)
# which similar to, but not the same as res1 and res2.


#
# Using other custom target matrices
#

# Construct a custom target list
myTlist &lt;- list(diag(p), matrix(1, p, p), matrix(0, p, p))
res4 &lt;- ridgeP.fused(Slist, ns, Tlist = myTlist, lambda = c(1.3, 2.1))
print(res4)

# Alternative, see ?default.target.fused
myTlist2 &lt;- default.target.fused(Slist, ns, type = "Null")  # For the null target
res5 &lt;- ridgeP.fused(Slist, ns, Tlist = myTlist2, lambda = c(1.3, 2.1))
print(res5)

</code></pre>


</div>