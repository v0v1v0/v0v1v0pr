<div class="container">

<table style="width: 100%;"><tr>
<td>getRNG</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Getting/Setting RNGs</h2>

<h3>Description</h3>

<p><code>getRNG</code> returns the Random Number Generator (RNG) settings used for
computing an object, using a suitable <code>.getRNG</code> S4 method to extract
these settings.
For example, in the case of objects that result from multiple model fits,
it would return the RNG settings used to compute the best fit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getRNG(object, ..., num.ok = FALSE, extract = TRUE, recursive = TRUE)

hasRNG(object)

nextRNG(object, ..., ndraw = 0L)

setRNG(object, ..., verbose = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an R object from which RNG settings can be extracted, e.g. an
integer vector containing a suitable value for <code>.Random.seed</code> or embedded
RNG data, e.g., in S3/S4 slot <code>rng</code> or <code>rng$noise</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra arguments to allow extension and passed to a suitable S4 method
<code>.getRNG</code> or <code>.setRNG</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.ok</code></td>
<td>
<p>logical that indicates if single numeric (not integer) RNG data should be
considered as a valid RNG seed (<code>TRUE</code>) or passed to <code>set.seed</code>
into a proper RNG seed (<code>FALSE</code>) (See details and examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extract</code></td>
<td>
<p>logical that indicates if embedded RNG data should be looked for and
extracted (<code>TRUE</code>) or if the object itself should be considered as an
RNG specification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>logical that indicates if embedded RNG data should be extracted
recursively (<code>TRUE</code>) or only once (<code>FASE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndraw</code></td>
<td>
<p>number of draws to perform before returning the RNG seed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a logical that indicates if the new RNG settings should
be displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>logical that indicates if only valid RNG kinds should be
accepted, or if invalid values should just throw a warning.
Note that this argument is used only on R &gt;= 3.0.2.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function handles single number RNG specifications in the following way:
</p>

<dl>
<dt>integers</dt>
<dd>
<p>Return them unchanged, considering them as encoded RNG kind
specification (see <code>RNG</code>). No validity check is performed.</p>
</dd>
<dt>real numbers</dt>
<dd>
<p>If <code>num.ok=TRUE</code> return them unchanged.
Otherwise, consider them as (pre-)seeds and pass them to <code>set.seed</code>
to get a proper RNG seed.
Hence calling <code>getRNG(1234)</code> is equivalent to <code>set.seed(1234); getRNG()</code>
(See examples).
</p>
</dd>
</dl>
<h3>Value</h3>

<p><code>getRNG</code>, <code>getRNG1</code>, <code>nextRNG</code> and <code>setRNG</code>
usually return an integer vector of length &gt; 2L, like <code>.Random.seed</code>.
</p>
<p><code>getRNG</code> and <code>getRNG1</code> return <code>NULL</code> if no RNG data was found.
</p>
<p><code>setRNG</code> invisibly returns the old RNG settings as
they were before changing them.
</p>


<h3>See Also</h3>

<p><code>.Random.seed</code>, <code>showRNG</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#--- getRNG ---
# get current RNG settings
s &lt;- getRNG()
head(s)
showRNG(s)

# get RNG from a given single numeric seed
s1234 &lt;- getRNG(1234)
head(s1234)
showRNG(s1234)
# this is identical to the RNG seed as after set.seed()
set.seed(1234)
identical(s1234, .Random.seed)
# but if num.ok=TRUE the object is returned unchanged
getRNG(1234, num.ok=TRUE)

# single integer RNG data = encoded kind 
head(getRNG(1L))

# embedded RNG data
s &lt;- getRNG(list(1L, rng=1234))
identical(s, s1234)
 

#--- hasRNG ---
# test for embedded RNG data
hasRNG(1)
hasRNG( structure(1, rng=1:3) )
hasRNG( list(1, 2, 3) )
hasRNG( list(1, 2, 3, rng=1:3) )
hasRNG( list(1, 2, 3, noise=list(1:3, rng=1)) )


#--- nextRNG ---
head(nextRNG())
head(nextRNG(1234))
head(nextRNG(1234, ndraw=10))


#--- setRNG ---

obj &lt;- list(x=1000, rng=123)
setRNG(obj)
rng &lt;- getRNG()
runif(10)
set.seed(123)
rng.equal(rng)


</code></pre>


</div>