<div class="container">

<table style="width: 100%;"><tr>
<td>AnnoyIndex</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximate Nearest Neighbors with Annoy</h2>

<h3>Description</h3>

<p>Annoy is a small library written to provide fast and memory-efficient
nearest neighbor lookup from a possibly static index which can be
shared across processes.
</p>


<h3>Usage</h3>

<pre>
a &lt;- new(AnnoyEuclidean, vectorsz)

a$setSeed(0)
a$setVerbose(0)

a$addItem(i, dv)

a$getNItems()

a$getItemsVector(i)
a$getDistance(i, j)

a$build(n_trees)

a$getNNsByItem(i, n)
a$getNNsByItemList(i, n, search_k, include_distances)

a$getNNsByVector(v, n)
a$getNNsByVectorList(v, n, search_k, include_distances)

a$save(fn)
a$load(fn)
a$unload()
</pre>


<h3>Details</h3>

<p><code>new(Class, vectorsz)</code>
Create a new Annoy instance of type <code>Class</code> where <code>Class</code>
is on of the following:
<code>AnnoyEuclidean</code>,
<code>AnnoyAngular</code>,
<code>AnnoyManhattan</code>,
<code>AnnoyHamming</code>.
<code>vectorsz</code> denotes the length of the vectors that the Annoy instance
will be indexing.
</p>
<p><code>$addItem(i, v)</code>
Adds item <code>i</code> (any nonnegative integer) with vector <code>v</code>.
Note that it will allocate memory for <code>max(i) + 1</code> items.
</p>
<p><code>$build(n_trees)</code>
Builds a forest of <code>n_trees</code> trees.
More trees gives higher precision when querying.
After calling <code>build</code>, no more items can be added.
</p>
<p><code>$save(fn)</code>
Saves the index to disk as filename <code>fn</code>.
After saving, no more items can be added.
</p>
<p><code>$load(fn)</code>
Loads (mmaps) an index from filename <code>fn</code> on disk.
</p>
<p><code>$unload()</code>
Unloads index.
</p>
<p><code>$getDistance(i, j)</code>
Returns the distance between items <code>i</code> and <code>j</code>
</p>
<p><code>$getNNsByItem(i, n)</code>
Returns the <code>n</code> closest items as an integer vector of indices.
</p>
<p><code>$getNNsByVector(v, n)</code>
Same as <code>$getNNsByItem</code>, but queries by vector <code>v</code> rather than
index <code>i</code>.
</p>
<p><code>$getNNsByItemList(i, n, search_k = -1, include_distances = FALSE)</code>
Returns the n closest items to item <code>i</code> as a list.
During the query it will inspect up to <code>search_k</code> nodes which
defaults to <code>n_trees * n</code> if not provided.
<code>search_k</code> gives you a run-time tradeoff between better accuracy and
speed.
If you set <code>include_distances</code> to <code>TRUE</code>,
it will return a length 2 list with elements <code>"item"</code> &amp;
<code>"distance"</code>.
The <code>"item"</code> element contains the <code>n</code> closest items as an integer
vector of indices.
The optional <code>"distance"</code> element contains the corresponding distances
to <code>"item"</code> as a numeric vector.
</p>
<p><code>$getNNsByVectorList(i, n, search_k = -1, include_distances = FALSE)</code>
Same as <code>$getNNsByItemList</code>, but queries by vector <code>v</code> rather than
index <code>i</code>
</p>
<p><code>$getItemsVector(i)</code>
Returns the vector for item <code>i</code> that was previously added.
</p>
<p><code>$getNItems()</code>
Returns the number of items in the index.
</p>
<p><code>$setVerbose()</code>
If <code>1</code> then messages will be printed during processing.
If <code>0</code> then messages will be suppressed during processing.
</p>
<p><code>$setSeed()</code>
Set random seed for annoy (integer).
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(RcppAnnoy)

# BUILDING ANNOY INDEX ---------------------------------------------------------
vector_size &lt;- 10
a &lt;- new(AnnoyEuclidean, vector_size)

a$setSeed(42)

# Turn on verbose status messages (0 to turn off)
a$setVerbose(1)

# Load 100 random vectors into index
for (i in 1:100) a$addItem(i - 1, runif(vector_size)) # Annoy uses zero indexing

# Display number of items in index
a$getNItems()

# Retrieve item at postition 0 in index
a$getItemsVector(0)

# Calculate distance between items at postitions 0 &amp; 1 in index
a$getDistance(0, 1)

# Build forest with 50 trees
a$build(50)


# PERFORMING ANNOY SEARCH ------------------------------------------------------

# Retrieve 5 nearest neighbors to item 0
# Returned as integer vector of indices
a$getNNsByItem(0, 5)

# Retrieve 5 nearest neighbors to item 0
# search_k = -1 will invoke default search_k value of n_trees * n
# Return results as list with an element for distance
a$getNNsByItemList(0, 5, -1, TRUE)

# Retrieve 5 nearest neighbors to item 0
# search_k = -1 will invoke default search_k value of n_trees * n
# Return results as list without an element for distance
a$getNNsByItemList(0, 5, -1, FALSE)


v &lt;- runif(vector_size)
# Retrieve 5 nearest neighbors to vector v
# Returned as integer vector of indices
a$getNNsByVector(v, 5)

# Retrieve 5 nearest neighbors to vector v
# search_k = -1 will invoke default search_k value of n_trees * n
# Return results as list with an element for distance
a$getNNsByVectorList(v, 5, -1, TRUE)

# Retrieve 5 nearest neighbors to vector v
# search_k = -1 will invoke default search_k value of n_trees * n
# Return results as list with an element for distance
a$getNNsByVectorList(v, 5, -1, TRUE)


# SAVING/LOADING ANNOY INDEX ---------------------------------------------------

# Create a tempfile, replace with a local file to keep
treefile &lt;- tempfile(pattern="annoy", fileext="tree")

# Save annoy tree to disk
a$save(treefile)

# Load annoy tree from disk
a$load(treefile)

# Unload index from memory
a$unload()
</code></pre>


</div>