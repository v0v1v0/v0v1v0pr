<div class="container">

<table style="width: 100%;"><tr>
<td>tran.polar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Diffusive Transport in polar (r, theta) coordinates.
</h2>

<h3>Description</h3>

<p>Estimates the transport term (i.e. the rate of change of a concentration
due to diffusion) in a polar (r, theta)  coordinate system
</p>


<h3>Usage</h3>

<pre><code class="language-R">tran.polar (C, C.r.up = NULL, C.r.down = NULL, 
            C.theta.up = NULL, C.theta.down = NULL, 
            flux.r.up = NULL, flux.r.down = NULL, 
            flux.theta.up = NULL, flux.theta.down = NULL, 
            cyclicBnd = NULL, D.r = 1, D.theta = D.r, 
            r = NULL, theta = NULL, full.output = FALSE)

polar2cart (out, r, theta, x = NULL, y = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>C </code></td>
<td>
<p>concentration, expressed per unit volume, defined at the centre
of each grid cell; Nr*Nteta matrix [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.r.up </code></td>
<td>
<p>concentration at upstream boundary in r(x)-direction;
vector of length Nteta [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.r.down </code></td>
<td>
<p>concentration at downstream boundary in r(x)-direction;
vector of length Nteta [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.theta.up </code></td>
<td>
<p>concentration at upstream boundary in theta-direction;
vector of length Nr [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.theta.down </code></td>
<td>
<p>concentration at downstream boundary in theta-direction;
vector of length Nr [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.r.up </code></td>
<td>
<p>flux across the upstream boundary in r-direction,
positive = INTO model domain; vector of length Ntheta [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.r.down </code></td>
<td>
<p>flux across the downstream boundary in r-direction,
positive = OUT of model domain; vector of length Ntheta [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.theta.up </code></td>
<td>
<p>flux across the upstream boundary in theta-direction,
positive = INTO model domain; vector of length Nr [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.theta.down </code></td>
<td>
<p>flux across the downstream boundary in theta-direction,
positive = OUT of model domain; vector of length Nr [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cyclicBnd </code></td>
<td>
<p>If not <code>NULL</code>, the direction in which a cyclic 
boundary is defined, i.e. <code>cyclicBnd = 1</code> for the <code>r</code> direction, 
<code>cyclicBnd = 2</code> for the <code>theta</code> direction and 
<code>cyclicBnd = c(1,2)</code> for both the <code>r</code> and <code>theta</code> direction.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.r </code></td>
<td>
<p>diffusion coefficient in r-direction, defined on grid cell
interfaces. One value, a vector of length (Nr+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a (Nr+1)* Nteta matrix [L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.theta </code></td>
<td>
<p>diffusion coefficient in theta-direction, defined on grid cell
interfaces. One value, a vector of length (Ntheta+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a Nr*(Ntheta+1) matrix [L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r </code></td>
<td>
<p>position of adjacent cell interfaces in the r-direction. 
A vector of length Nr+1 [L].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta </code></td>
<td>
<p>position of adjacent cell interfaces in the theta-direction.
A vector of length Ntheta+1 [L].  Theta should be within [0,2 pi]
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.output </code></td>
<td>
<p>logical flag enabling a full return of the output
(default = <code>FALSE</code>; <code>TRUE</code> slows down execution by 20 percent).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out </code></td>
<td>
<p>output as returned by <code>tran.polar</code>, and which is to be
mapped from polar to cartesian coordinates
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x </code></td>
<td>
<p>The cartesian x-coordinates to whicht the polar coordinates are
to be mapped
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y </code></td>
<td>
<p>The cartesian y-coordinates to whicht the polar coordinates are
to be mapped
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>tran.polar</code> performs (simplified) transport in polar coordinates
</p>
<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li>
<p> (1) zero gradient
</p>
</li>
<li>
<p> (2) fixed concentration
</p>
</li>
<li>
<p> (3) fixed flux
</p>
</li>
<li>
<p> (4) cyclic boundary
</p>
</li>
</ul>
<p>This is also the order of priority. The cyclic boundary overrules the other.
If fixed concentration, fixed flux, and cyclicBnd are <code>NULL</code> then
the boundary is zero-gradient
</p>
<p>A cyclic boundary condition has concentration and flux at upstream and 
downstream boundary the same.
</p>
<p><code>polar2cart</code> maps the polar coordinates to cartesian coordinates
</p>
<p>If <code>x</code> and <code>y</code> is not provided, then it will create an (x,y)
grid based on <code>r</code> : <code>seq(-maxr, maxr, length.out=Nr)</code>, where
<code>maxr</code> is the maximum value of <code>r</code>, and <code>Nr</code> is the number
of elements in <code>r</code>.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dC </code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell, a Nr*Nteta matrix. [M/L3/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.r.up </code></td>
<td>
<p>concentration at the upstream interface in r-direction.
A vector of length Nteta [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.r.down </code></td>
<td>
<p>concentration at the downstream interface in r-direction.
A vector of length Nteta [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.theta.up </code></td>
<td>
<p>concentration at the the upstream interface in theta-direction.
A vector of length Nr [M/L3].  Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.theta.down </code></td>
<td>
<p>concentration at the downstream interface in theta-direction.
A vector of length Nr [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.flux </code></td>
<td>
<p>flux across the interfaces in x-direction of the grid cells.
A (Nr+1)*Nteta matrix  [M/L2/T]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.flux </code></td>
<td>
<p>flux across the interfaces in y-direction of the grid cells.
A Nr*(Nteta+1) matrix [M/L2/T].  Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.r.up </code></td>
<td>
<p>flux across the upstream boundary in r-direction,
positive = INTO model domain. A vector of length Nteta [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.r.down </code></td>
<td>
<p>flux across the downstream boundary in r-direction,
positive = OUT of model domain. A vector of length Nteta [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.theta.up </code></td>
<td>
<p>flux across the upstream boundary in theta-direction,
positive = INTO model domain. A vector of length Nr [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.theta.down </code></td>
<td>
<p>flux across the downstream boundary in theta-direction,
positive = OUT of model domain. A vector of length Nr [M/L2/T].
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Soetaert and Herman, 2009. a practical guide to ecological modelling -
using R as a simulation platform. Springer
</p>


<h3>See Also</h3>

<p><code>tran.cylindrical</code>, <code>tran.spherical</code> 
for a discretisation of 3-D transport equations in cylindrical and 
spherical coordinates
</p>
<p><code>tran.1D</code>,   <code>tran.2D</code>,  <code>tran.3D</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## =============================================================================
## Testing the functions
## =============================================================================
# Parameters
F        &lt;- 100             # input flux [micromol cm-2 yr-1]
D        &lt;- 400             # mixing coefficient [cm2 yr-1]

# Grid definition
r.N   &lt;- 4     # number of cells in r-direction
theta.N &lt;- 6   # number of cells in theta-direction
r.L &lt;- 8       # domain size r-direction [cm]
r      &lt;- seq(0, r.L,len = r.N+1)      # cell size r-direction [cm]
theta  &lt;- seq(0, 2*pi,len = theta.N+1) # theta-direction - theta: from 0, 2pi
 
# Intial conditions 
C &lt;- matrix(nrow = r.N, ncol = theta.N, data = 0)

# Boundary conditions: fixed concentration  
C.r.up       &lt;- rep(1, times = theta.N)
C.r.down     &lt;- rep(0, times = theta.N)
C.theta.up   &lt;- rep(1, times = r.N)
C.theta.down &lt;- rep(0, times = r.N)

# Concentration boundary conditions
tran.polar(C = C, D.r = D, D.theta = D, 
  r = r, theta = theta,
  C.r.up = C.r.up, C.r.down = C.r.down, 
  C.theta.up = C.theta.up, C.theta.down = C.theta.down)

# Flux boundary conditions
flux.r.up &lt;- rep(200, times = theta.N)
flux.r.down &lt;- rep(-200, times = theta.N)
flux.theta.up &lt;- rep(200, times = r.N)
flux.theta.down &lt;- rep(-200, times = r.N)

tran.polar(C = C, D.r = D, r = r, theta = theta,
  flux.r.up = flux.r.up, flux.r.down = flux.r.down,
  flux.theta.up = flux.theta.up, flux.theta.down = flux.theta.down,
  full.output = TRUE)


## =============================================================================
## A model with diffusion and first-order consumption
## =============================================================================
N     &lt;- 50          # number of grid cells
XX    &lt;- 4           # total size
rr    &lt;- 0.005       # consumption rate
ini   &lt;- 1           # initial value at x=0
D     &lt;- 400

r     &lt;- seq (2, 4, len = N+1)
theta   &lt;- seq(0, 2*pi, len = N+1)
theta.m &lt;- 0.5*(theta[-1]+theta[-(N+1)])

# The model equations

Diffpolar &lt;- function (t, y, parms)  {
  CONC  &lt;- matrix(nrow = N, ncol = N, data = y)
  tran  &lt;- tran.polar(CONC, D.r = D, D.theta = D, r = r, theta = theta,
        C.r.up = 0, C.r.down = 1*sin(5*theta.m), 
        cyclicBnd = 2, full.output=TRUE )
  dCONC &lt;- tran$dC  - rr * CONC
  return (list(dCONC))
}

# solve to steady-state; cyclicBnd = 2, because of C.theta.up, C.theta.down
out &lt;- steady.2D (y = rep(0, N*N), func = Diffpolar, parms = NULL,
                  dim = c(N, N), lrw = 1e6, cyclicBnd = 2)

image(out)

cart &lt;- polar2cart(out, r = r, theta = theta, 
                        x = seq(-4, 4, len = 100), 
                        y = seq(-4, 4, len = 100))
image(cart)
          
</code></pre>


</div>