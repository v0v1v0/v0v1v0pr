<div class="container">

<table style="width: 100%;"><tr>
<td>ORRRR</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Online Robust Reduced-Rank Regression</h2>

<h3>Description</h3>

<p>Online robust reduced-rank regression with two major estimation methods:
</p>

<dl>
<dt>SMM</dt>
<dd>
<p>Stochastic Majorisation-Minimisation</p>
</dd>
<dt>SAA</dt>
<dd>
<p>Sample Average Approximation</p>
</dd>
</dl>
<h3>Usage</h3>

<pre><code class="language-R">ORRRR(
  y,
  x,
  z = NULL,
  mu = TRUE,
  r = 1,
  initial_size = 100,
  addon = 10,
  method = c("SMM", "SAA"),
  SAAmethod = c("optim", "MM"),
  ...,
  initial_A = matrix(rnorm(P * r), ncol = r),
  initial_B = matrix(rnorm(Q * r), ncol = r),
  initial_D = matrix(rnorm(P * R), ncol = R),
  initial_mu = matrix(rnorm(P)),
  initial_Sigma = diag(P),
  ProgressBar = requireNamespace("lazybar"),
  return_data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Matrix of dimension N*P. The matrix for the response variables. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Matrix of dimension N*Q. The matrix for the explanatory variables to be projected. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Matrix of dimension N*R. The matrix for the explanatory variables not to be projected. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Logical. Indicating if a constant term is included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Integer. The rank for the reduced-rank matrix <code class="reqn">AB'</code>. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_size</code></td>
<td>
<p>Integer. The number of data points to be used in the first iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addon</code></td>
<td>
<p>Integer. The number of data points to be added in the algorithm in each iteration after the first.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character. The estimation method. Either "SMM" or "SAA". See <code>Description</code> and <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SAAmethod</code></td>
<td>
<p>Character. The sub solver used in each iteration when the <code>method</code> is chosen to be "SAA". See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to function
</p>

<dl>
<dt><code>optim</code></dt>
<dd>
<p>when the <code>method</code> is "SAA" and the <code>SAAmethod</code> is "optim"</p>
</dd>
<dt><code>RRRR</code></dt>
<dd>
<p>when the <code>method</code> is "SAA" and the <code>SAAmethod</code> is "MM"</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_A</code></td>
<td>
<p>Matrix of dimension P*r. The initial value for matrix <code class="reqn">A</code>. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_B</code></td>
<td>
<p>Matrix of dimension Q*r. The initial value for matrix <code class="reqn">B</code>. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_D</code></td>
<td>
<p>Matrix of dimension P*R. The initial value for matrix <code class="reqn">D</code>. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_mu</code></td>
<td>
<p>Matrix of dimension P*1. The initial value for the constant <code class="reqn">mu</code>. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_Sigma</code></td>
<td>
<p>Matrix of dimension P*P. The initial value for matrix Sigma. See <code>Detail</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ProgressBar</code></td>
<td>
<p>Logical. Indicating if a progress bar is shown during the estimation process.
The progress bar requires package <code>lazybar</code> to work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_data</code></td>
<td>
<p>Logical. Indicating if the data used is return in the output.
If set to <code>TRUE</code>, <code>update.RRRR</code> can update the model by simply provide new data.
Set to <code>FALSE</code> to save output size.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The formulation of the reduced-rank regression is as follow:
</p>
<p style="text-align: center;"><code class="reqn">y = \mu +AB'  x + D z+innov,</code>
</p>

<p>where for each realization <code class="reqn">y</code> is a vector of dimension <code class="reqn">P</code> for the <code class="reqn">P</code> response variables,
<code class="reqn">x</code> is a vector of dimension <code class="reqn">Q</code> for the <code class="reqn">Q</code> explanatory variables that will be projected to
reduce the rank,
<code class="reqn">z</code> is a vector of dimension <code class="reqn">R</code> for the <code class="reqn">R</code> explanatory variables
that will not be projected,
<code class="reqn">\mu</code> is the constant vector of dimension <code class="reqn">P</code>,
<code class="reqn">innov</code> is the innovation vector of dimension <code class="reqn">P</code>,
<code class="reqn">D</code> is a coefficient matrix for <code class="reqn">z</code> with dimension <code class="reqn">P*R</code>,
<code class="reqn">A</code> is the so called exposure matrix with dimension <code class="reqn">P*r</code>, and
<code class="reqn">B</code> is the so called factor matrix with dimension <code class="reqn">Q*r</code>.
The matrix resulted from <code class="reqn">AB'</code> will be a reduced rank coefficient matrix with rank of <code class="reqn">r</code>.
The function estimates parameters <code class="reqn">\mu</code>, <code class="reqn">A</code>, <code class="reqn">B</code>, <code class="reqn">D</code>, and <code class="reqn">Sigma</code>, the covariance matrix of
the innovation's distribution.
</p>
<p>The algorithm is online in the sense that the data is continuously incorporated
and the algorithm can update the parameters accordingly. See <code>?update.RRRR</code> for more details.
</p>
<p>At each iteration of SAA, a new realisation of the parameters is achieved by
solving the minimisation problem of the sample average of
the desired objective function using the data currently incorporated.
This can be computationally expensive when the objective function is highly nonconvex.
The SMM method overcomes this difficulty by replacing the objective function
by a well-chosen majorising surrogate function which can be much easier to optimise.
</p>
<p>SMM method is robust in the sense that it assumes a heavy-tailed Cauchy distribution
for the innovations.
</p>


<h3>Value</h3>

<p>A list of the estimated parameters of class <code>ORRRR</code>.
</p>

<dl>
<dt>method</dt>
<dd>
<p>The estimation method being used</p>
</dd>
<dt>SAAmethod</dt>
<dd>
<p>If SAA is the major estimation method, what is the sub solver in each iteration.</p>
</dd>
<dt>spec</dt>
<dd>
<p>The input specifications. <code class="reqn">N</code> is the sample size.</p>
</dd>
<dt>history</dt>
<dd>
<p>The path of all the parameters during optimization and the path of the objective value.</p>
</dd>
<dt>mu</dt>
<dd>
<p>The estimated constant vector. Can be <code>NULL</code>.</p>
</dd>
<dt>A</dt>
<dd>
<p>The estimated exposure matrix.</p>
</dd>
<dt>B</dt>
<dd>
<p>The estimated factor matrix.</p>
</dd>
<dt>D</dt>
<dd>
<p>The estimated coefficient matrix of <code>z</code>.</p>
</dd>
<dt>Sigma</dt>
<dd>
<p>The estimated covariance matrix of the innovation distribution.</p>
</dd>
<dt>obj</dt>
<dd>
<p>The final objective value.</p>
</dd>
<dt>data</dt>
<dd>
<p>The data used in estimation if <code>return_data</code> is set to <code>TRUE</code>. <code>NULL</code> otherwise.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Yangzhuoran Yang
</p>


<h3>See Also</h3>

<p><code>update.RRRR</code>, <code>RRRR</code>, <code>RRR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(2222)
data &lt;- RRR_sim()
res &lt;- ORRRR(y=data$y, x=data$x, z = data$z)
res

</code></pre>


</div>