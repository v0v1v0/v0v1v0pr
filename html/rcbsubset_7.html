<div class="container">

<table style="width: 100%;"><tr>
<td>rcbsubset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Optimal Matching with Refined Covariate Balance
</h2>

<h3>Description</h3>

<p>This function computes an optimal match with refined covariate balance.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rcbsubset(distance.structure, near.exact = NULL, fb.list = NULL, 
treated.info = NULL, control.info = NULL, exclude.penalty = NULL, 
penalty = 2, tol = 1e-3, solver = 'rlemon')
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>distance.structure</code></td>
<td>

<p>A distance matrix, a sparse distance matrix of class InfinitySparseMatrix (produced by various functions in the <code>optmatch</code> package), or a
a list of vectors that encodes information about covariate distances between treated and control units (produced by the <code>build.dist.struct</code> function in the <code>rcbalance</code> package).  If a matrix is given, rows should correspond to treated units and columns to control units.  Distances of <code>Inf</code> should be used to indicate that the units in question must never be matched to each other.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>near.exact</code></td>
<td>
 
<p>an optional character vector specifying names of covariates for near-exact matching.  This argument takes precedence over any refined covariate balance constraints, so the match will produce the best refined covariate balance subject to matching exactly on this variable wherever possible.  If multiple covariates are named, near-exact matching will be done on their interaction.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fb.list</code></td>
<td>

<p>an optional list of character vectors specifying covariates to be used for refined balance.  Each element of the list corresponds to a level of refined covariate balance, and the levels are assumed to be in decreasing order of priority.  Each character vector should contain one or more names of categorical covariates on which the user would like to enforce near fine balance.  If multiple covariates are specified, an interaction is created between the categories of the covariates and near fine balance is enforced on the interaction.  IMPORTANT: covariates or interactions coming later in the list must be nested within covariates coming earlier in the list; if this is not the case the function will stop with an error.  An easy way to ensure that this occurs is to include in each character vector all the variables named in earlier list elements.  If the <code>fb.list</code> argument is specified, the <code>treated.info</code> and <code>control.info</code> arguments must also be specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treated.info</code></td>
<td>

<p>an optional data frame containing covariate information for the treated units in the problem.  The row count of this data frame must be equal to the length of the <code>distance.structure</code> argument, and it is assumed that row <code>i</code> contains covariate information for the treated unit described by element <code>i</code> of <code>distance.structure</code>.  In addition, the column count and column names must be identical to those of the <code>control.info</code> argument, and the column names must include all of the covariate names mentioned in the <code>near.exact</code> and <code>fb.list</code> arguments.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control.info</code></td>
<td>

<p>an optional data frame containing covariate information for the control units in the problem.  The row count of this data frame must be no smaller than the maximum control index in the <code>distance.structure</code> argument, and it is assumed that row <code>i</code> contains the covariate information for the control indexed by <code>i</code> in distance.structure.  In addition, the column count and column names must be identical to those of the <code>treated.info</code> argument.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.penalty</code></td>
<td>

<p>A parameter that gives the cost of excluding a treated unit.  If left NULL it will be set to a very large value designed to ensure treated units are never excluded if they can be matched.  Lower values may result in subsets of treated units being excluded.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>

<p>a nonnegative value.  This is a tuning parameter that helps ensure the different levels of refined covariate balance are prioritized correctly.   Setting the penalty higher tends to improve the guarantee of match optimality up to a point, but penalties above a certain level cause integer overflows and throw errors.  It is not recommended that the user change this parameter from its default value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>

<p>edge cost tolerance.  This is the smallest tolerated difference between matching costs; cost differences smaller than this will be considered zero.  Match distances will be scaled by inverse tolerance, so when matching with large edge costs or penalties the tolerance may need to be increased.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>

<p>the name of the package used to solve the network flow optimization problem underlying the match, one of 'rlemon' (which uses the Lemon Optimization Library) and 'rrelaxiv' (which uses the RELAX-IV algorithm). 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To use the option <code>solver = 'rrelaxiv'</code>, the user must install the
<code>rrelaxiv</code> manually; it is not hosted on CRAN because it carries an academic
license.  
</p>


<h3>Value</h3>

<p>A list with the following components:

</p>
<table>
<tr style="vertical-align: top;">
<td><code>matches</code></td>
<td>
<p>a nt by k matrix containing the matched sets produced by the algorithm (where nt is the number of treated units).  The rownames of this matrix are the numbers of the treated units (indexed by their position in distance.structure), and the elements of each row contain the indices of the control units to which this treated unit has been matched.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fb.tables</code></td>
<td>
<p>a list of matrices, equal in length to the fb.list argument.  Each matrix is a contingency table giving the counts among treated units and matched controls for each level of the categorical variable specified by the corresponding element of fb.list. </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>


<h3>References</h3>

<p>Pimentel, S.D., Kelz, R.R., Silber, J.H., and Rosenbaum, P.R. (2015) Large, sparse optimal matching with refined covariate balance in an observational study of the health outcomes produced by new surgeons, JASA 110 (510), 515-527.	
</p>
<p>Pimentel, S.D., and Kelz, R.R. (2020). Optimal tradeoffs in matched designs comparing US-trained and internationally trained surgeons. JASA 115 (532), 1675-1688.
</p>
<p>Rosenbaum, P.R. (2012) Optimal matching of an optimally chosen subset in observational studies, JCGS 21.1: 57-71.  
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
library(optmatch)	
data(nuclearplants)

#match exactly on 3 binaries
exact.mask &lt;- exactMatch(pr ~ pt + ct + bw, data = nuclearplants)
my.dist.matrix &lt;- match_on(pr ~ date + t1 + t2 + cap + ne + cum.n,
	within = exact.mask, data = nuclearplants)

#one treated unit out of 10 is excluded
rcbsubset(my.dist.matrix)

#repeat under a refined balance constraint
rcbsubset(my.dist.matrix, fb.list = list('ne'), 
 treated.info = nuclearplants[which(nuclearplants$pr ==1),],
 control.info = nuclearplants[which(nuclearplants$pr == 0),])

#specifying a low exclude.penalty leads to more individuals excluded
rcbsubset(my.dist.matrix, fb.list = list('ne'), 
 treated.info = nuclearplants[which(nuclearplants$pr ==1),],
 control.info = nuclearplants[which(nuclearplants$pr == 0),], exclude.penalty = 1.5)


#match using distance objects created by rcbalance package
library(rcbalance)

my.dist.struct &lt;- build.dist.struct(z = nuclearplants$pr, 
	X = subset(nuclearplants[c('date','t1','t2','cap','ne','cum.n')]),
	exact = paste(nuclearplants$pt, nuclearplants$ct, nuclearplants$bw, sep = '.'))
	
rcbsubset(my.dist.struct, fb.list = list('ne'), 
 treated.info = nuclearplants[which(nuclearplants$pr ==1),],
 control.info = nuclearplants[which(nuclearplants$pr == 0),], exclude.penalty = 15)	


## End(Not run)
</code></pre>


</div>