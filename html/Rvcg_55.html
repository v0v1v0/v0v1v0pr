<div class="container">

<table style="width: 100%;"><tr>
<td>vcgRaySearch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>check if a mesh is intersected by a set of rays</h2>

<h3>Description</h3>

<p>check if a mesh is intersected by a set of rays (stored as normals)
</p>


<h3>Usage</h3>

<pre><code class="language-R">vcgRaySearch(x, mesh, mintol = 0, maxtol = 1e+15, mindist = FALSE, threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a triangular mesh of class 'mesh3d' or a list containing vertices and vertex normals (fitting the naming conventions of 'mesh3d'). In the second case x must contain x$vb = 3 x n matrix containing 3D-coordinates and x$normals = 3 x n matrix containing normals associated with x$vb.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>triangular mesh to be intersected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mintol</code></td>
<td>
<p>minimum distance to target mesh</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxtol</code></td>
<td>
<p>maximum distance to search along ray</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mindist</code></td>
<td>
<p>search both ways (ray and -ray) and select closest point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>number of threads used during search.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>vcgRaySearch</code> projects a mesh (or set of 3D-coordinates) along a set of given rays (stored as normals) onto a target and return the hit points as well as information if the target mesh was hit at all. If nothing is hit along the ray(within the given thresholds), the ordinary closest point's value will be returned and the corresponding entry in <code>quality</code> will be zero.
</p>


<h3>Value</h3>

<p>list with following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>vb </code></td>
<td>
<p>4 x n matrix containing intersection points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normals </code></td>
<td>
<p>4 x n matrix containing homogenous coordinates of normals at intersection points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quality </code></td>
<td>
<p>integer vector containing a value for each vertex of <code>x</code>: 1 indicates that a ray has intersected 'mesh' , while 0 means not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance </code></td>
<td>
<p>numeric vector: distances to intersection</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">data(humface)
#get normals of landmarks
lms &lt;- vcgClost(humface.lm, humface)
# offset landmarks along their normals for a negative amount of -5mm
lms$vb[1:3,] &lt;- lms$vb[1:3,]+lms$normals[1:3,]*-5
intersect &lt;- vcgRaySearch(lms, humface)
## Not run: 
require(Morpho)
require(rgl)
spheres3d(vert2points(lms),radius=0.5,col=3)
plotNormals(lms,long=5)
spheres3d(vert2points(intersect),col=2) #plot intersections
wire3d(humface,col="white")#'

## End(Not run)

</code></pre>


</div>