<div class="container">

<table style="width: 100%;"><tr>
<td>SolrCore-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SolrCore</h2>

<h3>Description</h3>

<p>The <code>SolrCore</code> object represents a core hosted by a Solr
instance. A core is essentially a queryable collection of documents
that share the same schema. It is usually not necessary to interact
with a <code>SolrCore</code> directly.
</p>


<h3>Details</h3>

<p>The typical usage (by advanced users) would be to construct a custom
<code>SolrQuery</code> and execute it via the <code>docs</code>,
<code>facets</code> or (the very low-level) <code>eval</code> methods.
</p>


<h3>Accessor methods</h3>

<p>In the code snippets below, <code>x</code> is a <code>SolrCore</code> object.
</p>

<ul>
<li>
<p><code>name(x)</code>: Gets the name of the core (specified by the
schema).

</p>
</li>
<li>
<p><code>ndoc(x, query = SolrQuery())</code>: Gets the number of
documents in the core, given the <code>query</code> restriction.

</p>
</li>
<li>
<p><code>schema(x)</code>: Gets the <code>SolrSchema</code>
satisfied by all documents in the core.

</p>
</li>
<li>
<p><code>fieldNames(x, query = NULL, onlyStored = FALSE,
        onlyIndexed = FALSE, includeStatic = FALSE)</code>: Gets the field
names, given any restriction and/or transformation in
<code>query</code>, which is a <code>SolrQuery</code> or a character vector of
field patterns. The <code>onlyIndexed</code> and <code>onlyStored</code>
arguments restrict the fields to those indexed and stored,
respectively (see <code>FieldInfo</code> for more
details). Setting <code>includeStatic</code> to <code>TRUE</code> ensures
that all of the static fields in the schema are returned.

</p>
</li>
<li>
<p><code>version(x)</code>: Gets the version of the Solr instance
hosting the core.

</p>
</li>
</ul>
<h3>Constructor</h3>


<ul><li>
<p><code>SolrCore(uri, ...)</code>:
Constructs a new <code>SolrCore</code> instance, representing a Solr
core located at <code>uri</code>, which should be a string or a
<code>RestUri</code> object. If a string, then the
... are passed to the <code>RestUri</code> constructor.

</p>
</li></ul>
<h3>Reading</h3>


<ul>
<li>
<p><code>docs(x, query = SolrQuery(), as=c("list", "data.frame"))</code>:
Get the documents selected by <code>query</code>, in the form indicated
by <code>as</code>, i.e., either a list or a data frame.

</p>
</li>
<li>
<p><code>read(x, ...)</code>: Just an alias for <code>docs</code>.

</p>
</li>
</ul>
<h3>Summarizing</h3>


<ul>
<li>
<p><code>facets(x, by, ...)</code>:
Gets the <code>Facets</code> results as requested by
<code>by</code>, a <code>SolrQuery</code>. The ... are passed
down to <code>facets</code> on <code>ListSolrResult</code>.

</p>
</li>
<li>
<p><code>groupings(x, by, ...)</code>:
Gets the list of <code>Grouping</code> objects as requested by
the grouped query <code>by</code>. The ... are passed
down to <code>groupings</code> on <code>ListSolrResult</code>.

</p>
</li>
<li>
<p><code>ngroup(x)</code>: Gets the number of groupings that would be
returned by <code>groupings</code>.

</p>
</li>
</ul>
<h3>Updating</h3>


<ul>
<li>
<p><code>update(object, value, commit = TRUE, atomic = FALSE, ...)</code>:
Load the documents in <code>value</code> (typically a list or data
frame) into the SolrCore given by <code>object</code>. If <code>commit</code>
is <code>TRUE</code>, we request that Solr commit the changes to its
index on disk, with arguments in <code>...</code> fine-tuning the commit
(see <code>commit</code>). If <code>atomic</code> is <code>TRUE</code>, then the
existing documents are modified, rather than replaced, by the
documents in <code>value</code>.

</p>
</li>
<li>
<p><code>delete(x, which = SolrQuery(), ...)</code>:
Deletes the documents specified by <code>which</code> (all by default),
where the ... are passed down to <code>update</code>.

</p>
</li>
<li>
<p><code>commit(x, waitSearcher=TRUE, softCommit=FALSE,
        expungeDeletes=FALSE, optimize=TRUE, maxSegments=if (optimize) 1L)</code>:
Commits the changes to the Solr index; see the Solr documentation
for the meaning of the parameters.

</p>
</li>
<li>
<p><code>purgeCache(x)</code>: Purges the client-side HTTP cache, which is
useful if the Solr instance is using expiration-based HTTP caching
and one needs to see the result of an update immediately.

</p>
</li>
</ul>
<h3>Evaluation</h3>


<ul><li>
<p><code>eval(expr, envir, enclos)</code>:
Evaluates the query <code>expr</code> in the core <code>envir</code>,
ignoring <code>enclos</code>. Unless otherwise requested by the query
response type, the result should be returned as a
<code>ListSolrResult</code>. 

</p>
</li></ul>
<h3>Coercion</h3>


<ul><li>
<p><code>as.data.frame(x, row.names=NULL, optional=FALSE, ...)</code>:

</p>
</li></ul>
<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code>SolrFrame</code>, the typical way to interact with a
Solr core.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
     solr &lt;- TestSolr()
     sc &lt;- SolrCore(solr$uri)
     name(sc)
     ndoc(sc)

     delete(sc)
     
     docs &lt;- list(
        list(id="2", inStock=TRUE, price=2, timestamp_dt=Sys.time()),
        list(id="3", inStock=FALSE, price=3, timestamp_dt=Sys.time()),
        list(id="4", price=4, timestamp_dt=Sys.time()),
        list(id="5", inStock=FALSE, price=5, timestamp_dt=Sys.time())
     )
     update(sc, docs)

     q &lt;- SolrQuery(id %in% as.character(2:4))
     read(sc, q)

     solr$kill()

</code></pre>


</div>