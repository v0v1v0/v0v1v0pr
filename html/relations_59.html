<div class="container">

<table style="width: 100%;"><tr>
<td>impute</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Impute relations</h2>

<h3>Description</h3>

<p>Impute missing incidences in relations by averaging all possible
completions within a specified family.
</p>


<h3>Usage</h3>

<pre><code class="language-R">relation_impute(x, method = NULL, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an endorelation or an ensemble of endorelations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string specifying the method to be used (see
<b>Details</b>).  If <code>NULL</code>, it is guessed from the
relation with missing <em>objects</em> removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>named list of control arguments. Currently, only
<code>n</code> is accepted by the <code>any/<var>F</var></code> methods, indicating
the number of solutions to be returned. Default is 1; <code>"all"</code>
or <code>NA</code> will generate all possible completions. Note that
<code>n</code> is currently ignored if <code>x</code> is a relation ensemble.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>named list of control arguments, overriding the ones
in <code>control</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Endorelations with missing elements (i.e., whose incidence is
<code>NA</code>) are imputed using one of the methods described as follows.
</p>

<dl>
<dt><code>"omit"</code></dt>
<dd>
<p>Missing incidences are replaced by zeros, i.e.,
the corresponding elements are removed from the graph.</p>
</dd>
<dt><code>"any/<var>F</var>"</code></dt>
<dd>
<p>The incidences are replaced by
arbitrary values suitable for family <var>F</var>, with possible values:
</p>

<dl>
<dt><code>G</code></dt>
<dd>
<p>General (unrestricted) relations.</p>
</dd>
<dt><code>L</code></dt>
<dd>
<p>Linear orders.</p>
</dd>
<dt><code>W</code></dt>
<dd>
<p>Weak orders.</p>
</dd>
<dt><code>O</code></dt>
<dd>
<p>Partial orders.</p>
</dd>
</dl>
<p><code>L</code>, <code>W</code>, and <code>O</code> can optionally be complemented by
<code>/first</code> or <code>/last</code> to further restrict imputed elements
to be placed on top or bottom of the given ordering.
</p>
</dd>
<dt><code>"average/<var>F</var>"</code></dt>
<dd>
<p>Computes the relation with average
incidences, based on all possible completions as indicated for the
<code>any/<var>F</var></code> methods. Note that these completions are not
explicitly generated to compute the averages, and that the
resulting relation will typically be fuzzy.</p>
</dd>
</dl>
<h3>Value</h3>

<p>If <code>x</code> is an ensemble or more than one solution is requested
using the <code>n</code> control argument: an ensemble
of endorelations.  An endorelation otherwise.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## create a relation with a missing object
R &lt;- ranking(1:2, 1:3)
print(R)
R &lt;- as.relation(R)

## find all suitable completions within L
ens &lt;- relation_impute(R, method = "any/L", n = "all")
lapply(ens, as.ranking)
if(require("Rgraphviz")) plot(ens)

## find 3 suitable partial orders
ens &lt;- relation_impute(R, method = "any/O", n = 3)
lapply(ens, relation_incidence)
if(require("Rgraphviz")) plot(ens)

## compute average completion
R1 &lt;- relation_impute(R, method = "average/O")
relation_incidence(R1)

## check correctness of averaging
R2 &lt;- mean(relation_impute(R, "any/O", n = "all"))
stopifnot(all.equal(R1, R2))
</code></pre>


</div>