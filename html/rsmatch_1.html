<div class="container">

<table style="width: 100%;"><tr>
<td>brsmatch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Balanced Risk Set Matching</h2>

<h3>Description</h3>

<p>Perform balanced risk set matching as described in Li et al. (2001) "Balanced
Risk Set Matching".  Given a longitudinal data frame with covariate
information, along with treatment time, build a MIP problem that matches
treated individuals to those that haven't been treated yet (or are never
treated) based on minimizing the Mahalanobis distance between covariates. If
balancing is desired, the model will try to minimize the imbalance in terms
of specified balancing covariates in the final pair output.  Each treated
individual is matched to one other individual.
</p>


<h3>Usage</h3>

<pre><code class="language-R">brsmatch(
  n_pairs,
  data,
  id = "id",
  time = "time",
  trt_time = "trt_time",
  covariates = NULL,
  balance = TRUE,
  balance_covariates = NULL,
  exact_match = NULL,
  options = list(time_lag = FALSE, verbose = FALSE, optimizer = c("glpk", "gurobi"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n_pairs</code></td>
<td>
<p>The number of pairs desired from matching.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame or similar containing columns matching the <code style="white-space: pre;">⁠id, time, trt_time⁠</code> arguments, and covariates. This data frame is expected to
be in tidy, long format, so that <code>id</code>, <code>trt_time</code>, and other variables may
be repeated for different values of <code>time</code>. The data.frame should be unique
at <code>id</code> and <code>time</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>A character specifying the id column name (default <code>'id'</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>A character specifying the time column name (default <code>'time'</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trt_time</code></td>
<td>
<p>A character specifying the treatment time column name
(default <code>'trt_time'</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>A character vector specifying the covariates to use for
matching (default <code>NULL</code>). If <code>NULL</code>, this will default to all columns
except those named by the <code>id</code>, <code>time</code>, and <code>trt_time</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance</code></td>
<td>
<p>A logical value indicating whether to include balancing
constraints in the matching process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance_covariates</code></td>
<td>
<p>A character vector specifying the covariates to use
for balancing (default <code>NULL</code>).  If <code>NULL</code>, this will default to all
columns except those named by the <code>id</code>, <code>time</code>, and <code>trt_time</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact_match</code></td>
<td>
<p>A vector of optional covariates to perform exact matching
on. If <code>NULL</code>, no exact matching is done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>A list of additional parameters with the following components:
</p>

<ul>
<li> <p><code>time_lag</code> A logical value indicating whether the matches should be made
on the time period preceding treatment.  This can help avoid confounding if
treatment happens between two periods.
</p>
</li>
<li> <p><code>verbose</code> A logical value
indicating whether to print information to the console during a potentially
long matching process.
</p>
</li>
<li> <p><code>optimizer</code> The optimizer to use (default
<code>'glpk'</code>). The option <code>'gurobi'</code> requires an external license and package,
but offers speed improvements.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that when using exact matching, the <code>n_pairs</code> are split roughly in
proportion to the number of treated subjects in each exact matching group.
If you would like to control <code>n_pairs</code> exactly, we suggest manually
performing exact matching, for example with <code>split()</code>, and selecting
<code>n_pairs</code> for each group interactively.
</p>


<h3>Value</h3>

<p>A data frame containing the pair information.  The data frame has
columns <code>id</code>, <code>pair_id</code>, and <code>type</code>. <code>id</code> matches the input parameter and
will contain all ids from the input data frame.  <code>pair_id</code> refers to the id
of the computed pairs; <code>NA</code> values indicate unmatched individuals.  <code>type</code>
indicates whether the individual in the pair is considered as treatment
("trt") or control ("all") in that pair.
</p>


<h3>Author(s)</h3>

<p>Sean Kent
</p>


<h3>References</h3>

<p>Li, Yunfei Paul, Kathleen J Propert, and Paul R Rosenbaum. 2001.
"Balanced Risk Set Matching." Journal of the American Statistical
Association 96 (455): 870-82.
<a href="https://doi.org/10.1198/016214501753208573">doi:10.1198/016214501753208573</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("Rglpk", quietly = TRUE)) {
  library(dplyr, quietly = TRUE)
  pairs &lt;- brsmatch(
    n_pairs = 13,
    data = oasis,
    id = "subject_id",
    time = "visit",
    trt_time = "time_of_ad",
    balance = FALSE
  )

  na.omit(pairs)

  # evaluate the first match
  first_match &lt;- pairs$subject_id[which(pairs$pair_id == 1)]
  oasis %&gt;% dplyr::filter(subject_id %in% first_match)
}

</code></pre>


</div>