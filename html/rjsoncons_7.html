<div class="container">

<table style="width: 100%;"><tr>
<td>j_data_type</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Detect JSON and NDJSON data and path types</h2>

<h3>Description</h3>

<p><code>j_data_type()</code> uses simple rules to determine whether
'data' is JSON, NDJSON, file, url, or R.
</p>
<p><code>j_path_type()</code> uses simple rules to identify
whether <code>path</code> is a JSONpointer, JSONpath, or JMESpath
expression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">j_data_type(data)

j_path_type(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>character(1) JSONpointer, JSONpath or JMESpath query
string.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>j_data_type()</code> without any arguments reports possible return
values: <code>"json"</code>, <code>"ndjson"</code>, <code>"file"</code>, <code>"url"</code>, <code>"R"</code>.  When
provided an argument, <code>j_data_type()</code> infers (but does not
validate) the type of <code>data</code> based on the following rules:
</p>

<ul>
<li>
<p> For a scalar (length 1) character <code>data</code>, either <code>"url"</code>
(matching regular expression <code>"^https?://"</code>, <code>"file"</code>
(<code>file.exists(data)</code> returns <code>TRUE</code>), or <code>"json"</code>. When <code>"file"</code>
or <code>"url"</code> is inferred, the return value is a length 2 vector,
with the first element the inferred type of data (<code>"json"</code> or
<code>"ndjson"</code>) obtained from the first 2 lines of the file.
</p>
</li>
<li>
<p> For character data with <code>length(data) &gt; 1</code>, <code>"ndjson"</code> if all
elements start a square bracket or curly brace, consistently
(i.e., agreeing with the start of the first record), otherwise
<code>"json"</code>.
</p>
</li>
<li> <p><code>"R"</code> for all non-character data.
</p>
</li>
</ul>
<p><code>j_path_type()</code> without any argument reports possible values:
<code>"JSONpointer"</code>, <code>"JSONpath"</code>, or <code>"JMESpath"</code>. When provided an
argument, <code>j_path_type()</code> infers the type of <code>path</code> using a simple
but incomplete classification:
</p>

<ul>
<li> <p><code>"JSONpointer"</code> is inferred if the the path is <code>""</code> or starts with <code>"/"</code>.
</p>
</li>
<li> <p><code>"JSONpath"</code> expressions start with <code>"$"</code>.
</p>
</li>
<li> <p><code>"JMESpath"</code> expressions satisfy neither the <code>JSONpointer</code> nor
<code>JSONpath</code> criteria.
</p>
</li>
</ul>
<p>Because of these rules, the valid JSONpointer path <code>"@"</code> is
interpreted as JMESpath; use <code>jsonpointer()</code> if JSONpointer
behavior is required.
</p>


<h3>Examples</h3>

<pre><code class="language-R">j_data_type()                            # available types
j_data_type("")                          # json
j_data_type('{"a": 1}')                  # json
j_data_type(c('[{"a": 1}', '{"a": 2}]')) # json
j_data_type(c('{"a": 1}', '{"a": 2}'))   # ndjson
j_data_type(list(a = 1, b = 2))          # R
fl &lt;- system.file(package = "rjsoncons", "extdata", "example.json")
j_data_type(fl)                          # c('json', 'file')
j_data_type(readLines(fl))               # json

j_path_type()                            # available types
j_path_type("")                          # JSONpointer
j_path_type("/locations/0/name")         # JSONpointer
j_path_type("$.locations[0].name")       # JSONpath
j_path_type("locations[0].name")         # JMESpath

</code></pre>


</div>