<div class="container">

<table style="width: 100%;"><tr>
<td>pooledROC.BB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Bayesian bootstrap estimation of the pooled ROC curve.
</h2>

<h3>Description</h3>

<p>This function estimates the pooled ROC curve using the Bayesian bootstrap estimator proposed by Gu et al. (2008).
</p>


<h3>Usage</h3>

<pre><code class="language-R">pooledROC.BB(marker, group, tag.h, data, 
	p = seq(0, 1, l = 101), B = 5000, ci.level = 0.95, pauc = pauccontrol(),
  	parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the pooled ROC curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>An integer value specifying the number of Bayesian bootstrap resamples. By default 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the level for the credible interval. The default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>pauccontrol</code>. This argument is used to indicate whether the partial area under the pooled ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either "no" (default), "multicore" (not available on Windows) or "snow".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = "snow". If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates the pooled ROC curve (ROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The method implemented in this function makes use of the equivalence (see Gu et al., 2008)
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\} = 1 - Pr(1 - F_{\bar{D}}(Y_D) \leq p),</code>
</p>

<p>and estimates both <code class="reqn">F_{\bar{D}}</code> and the outer probability using the Bayesian bootstrap resampling distribution. 
</p>
<p>Regarding the area under the curve, we note that
</p>
<p style="text-align: center;"><code class="reqn">AUC = \int_{0}^{1}ROC(p)dp = 1 - E\{U_D\},</code>
</p>

<p>where <code class="reqn">U_D = 1 - F_{\bar{D}}(Y_D)</code>. In our implementation, the expectation is computed using the Bayesian bootstrap (using the same weights as those used to estimate the pooled ROC). As far as the partial area under the curve is concerned, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is 
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1)=\int_0^{u_1} ROC(p)dp = u_1 - E\{U_{D,u_1}\},</code>
</p>
 
<p>where <code class="reqn">U_{D,u_1} = \min\{u_1, 1 - F_{\bar{D}}(Y_D)\}</code>. Again, the expectation is computed using the Bayesian bootstrap. The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as 
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp,</code>
</p>
 
<p>where <code class="reqn">ROC_{TNF}(p)</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p) = F_{\bar{D}}\{F_{D}^{-1}(1-p)\}</code>. Thus
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp = E\{U_{\bar{D}, u_2} - u_2\},</code>
</p>
 
<p>where <code class="reqn">U_{\bar{D}, u_2} = \max\{u_2, 1 - F_{D}(Y_{\bar{D}})\}</code>, and the expectation is computed using the Bayesian bootstrap. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marker</code></td>
<td>
<p>A list with the diagnostic test outcomes in the healthy (h) and diseased (d) groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether missing values occur.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding <code>ci.level</code>*100% pointwise credible band.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding <code>ci.level</code>*100% credible interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the pooled ROC curve (posterior mean) and <code>ci.level</code>*100% credible interval. Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>list with the Dirichlet weights (involved in the estimation) in the healthy (h) and diseased (d) groups. These are matrices of dimension n0 x B and n1 x B, where n0 is the number of healthy individuals and n1 is the number of diseased individuals. </p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Gu, J., Ghosal, S., and Roy, A. (2008). Bayesian bootstrap estimation of ROC curve. Statistics in Medicine, <b>27</b>, 5407â€“5420.
</p>


<h3>See Also</h3>

<p><code>AROC.bnp</code>, <code>AROC.sp</code>, <code>AROC.kernel</code>, <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code>, <code>pooledROC.dpm</code>, <code>cROC.bnp</code>, <code>cROC.sp</code> or <code>AROC.kernel</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_BB &lt;- pooledROC.BB(marker = "l_marker1", group = "status",
tag.h = 0, data = newpsa, p = seq(0,1,l=101), B = 5000)

summary(m0_BB)

plot(m0_BB)


</code></pre>


</div>