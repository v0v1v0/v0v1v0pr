<div class="container">

<table style="width: 100%;"><tr>
<td>match_name</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Match a loanbook to asset-based company data (abcd) by the <code style="white-space: pre;">⁠name_*⁠</code> columns</h2>

<h3>Description</h3>

<p><code>match_name()</code> scores the match between names in a loanbook dataset (columns
can be <code>name_direct_loantaker</code>, <code style="white-space: pre;">⁠name_intermediate_parent*⁠</code> and
<code>name_ultimate_parent</code>) with names in an asset-based company data (column
<code>name_company</code>). The raw names are first internally transformed, and aliases
are assigned. The similarity between aliases in each of the loanbook and abcd
is scored using <code>stringdist::stringsim()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">match_name(
  loanbook,
  abcd,
  by_sector = TRUE,
  min_score = 0.8,
  method = "jw",
  p = 0.1,
  overwrite = NULL,
  join_id = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>loanbook, abcd</code></td>
<td>
<p>data frames structured like r2dii.data::loanbook_demo
and r2dii.data::abcd_demo.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_sector</code></td>
<td>
<p>Should names only be compared if companies belong to the
same <code>sector</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_score</code></td>
<td>
<p>A number between 0-1, to set the minimum <code>score</code> threshold.
A <code>score</code> of 1 is a perfect match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method for distance calculation. One of <code>c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw", "soundex")</code>. See
stringdist::stringdist-metrics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Prefix factor for Jaro-Winkler distance. The valid range for 
<code>p</code> is <code>0 &lt;= p &lt;= 0.25</code>. If <code>p=0</code> (default), the
Jaro-distance is returned. Applies only to <code>method='jw'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>A data frame used to overwrite the <code>sector</code> and/or <code>name</code>
columns of a particular direct loantaker or ultimate parent. To overwrite
only <code>sector</code>, the value in the <code>name</code> column should be <code>NA</code> and
vice-versa. This file can be used to manually match loanbook companies to
abcd.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>join_id</code></td>
<td>
<p>A join specification passed to <code>dplyr::inner_join()</code>. If a
character string, it assumes identical join columns between <code>loanbook</code> and
<code>abcd</code>. If a named character vector, it uses the name as the join column of <code>loanbook</code> and
the value as the join column of <code>abcd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed on to <code>stringdist::stringsim()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data frame with the same groups (if any) and columns as <code>loanbook</code>,
and the additional columns:
</p>

<ul>
<li> <p><code>id_2dii</code> - an id used internally by <code>match_name()</code> to distinguish
companies
</p>
</li>
<li> <p><code>level</code> - the level of granularity that the loan was matched at
(e.g <code>direct_loantaker</code> or <code>ultimate_parent</code>)
</p>
</li>
<li> <p><code>sector</code> - the sector of the <code>loanbook</code> company
</p>
</li>
<li> <p><code>sector_abcd</code> - the sector of the <code>abcd</code> company
</p>
</li>
<li> <p><code>name</code> - the name of the <code>loanbook</code> company
</p>
</li>
<li> <p><code>name_abcd</code> - the name of the <code>abcd</code> company
</p>
</li>
<li> <p><code>score</code> - the score of the match (manually set this to <code>1</code>
prior to calling <code>prioritize()</code> to validate the match)
</p>
</li>
<li> <p><code>source</code> - determines the source of the match. (equal to <code>loanbook</code>
unless the match is from <code>overwrite</code>
</p>
</li>
</ul>
<p>The returned rows depend on the argument <code>min_value</code> and the result of the
column <code>score</code> for each loan: * If any row has <code>score</code> equal to 1,
<code>match_name()</code> returns all rows where <code>score</code> equals 1, dropping all other
rows. * If no row has <code>score</code> equal to 1,<code>match_name()</code> returns all rows
where <code>score</code> is equal to or greater than <code>min_score</code>. * If there is no
match the output is a 0-row tibble with the expected column names – for
type stability.
</p>


<h3>Package options</h3>

<p><code>r2dii.match.sector_classifications</code>: Allows you to use your own
<code>sector_classififications</code> instead of the default. This feature is
experimental and may be dropped and/or become a new argument to
<code>match_name()</code>.
</p>


<h3>Assigning aliases</h3>

<p>The transformation process used to compare names between loanbook and abcd
datasets applies best practices commonly used in name matching algorithms:
</p>

<ul>
<li>
<p> Remove special characters.
</p>
</li>
<li>
<p> Replace language specific characters.
</p>
</li>
<li>
<p> Abbreviate certain names to reduce their importance in the matching.
</p>
</li>
<li>
<p> Spell out numbers to increase their importance.
</p>
</li>
</ul>
<h3>Handling grouped data</h3>

<p>This function ignores but preserves existing groups.
</p>


<h3>See Also</h3>

<p>Other main functions: 
<code>prioritize()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(r2dii.data)
library(tibble)

# Small data for examples
loanbook &lt;- head(loanbook_demo, 50)
abcd &lt;- head(abcd_demo, 50)

match_name(loanbook, abcd)

match_name(loanbook, abcd, min_score = 0.9)

# Use your own `sector_classifications`
your_classifications &lt;- tibble(
  sector = "power",
  borderline = FALSE,
  code = "D35.11",
  code_system = "XYZ"
)

# match on LEI
loanbook &lt;- tibble(
  sector_classification_system = "XYZ",
  sector_classification_direct_loantaker = "D35.11",
  id_ultimate_parent = "UP15",
  name_ultimate_parent = "Won't fuzzy match",
  id_direct_loantaker = "C294",
  name_direct_loantaker = "Won't fuzzy match",
  lei_direct_loantaker = "LEI123"
)

abcd &lt;- tibble(
  name_company = "alpine knits india pvt. limited",
  sector = "power",
  lei = "LEI123"
)

match_name(loanbook, abcd, join_by = c(lei_direct_loantaker = "lei"))

restore &lt;- options(r2dii.match.sector_classifications = your_classifications)

loanbook &lt;- tibble(
  sector_classification_system = "XYZ",
  sector_classification_direct_loantaker = "D35.11",
  id_ultimate_parent = "UP15",
  name_ultimate_parent = "Alpine Knits India Pvt. Limited",
  id_direct_loantaker = "C294",
  name_direct_loantaker = "Yuamen Xinneng Thermal Power Co Ltd"
)

abcd &lt;- tibble(
  name_company = "alpine knits india pvt. limited",
  sector = "power"
)

match_name(loanbook, abcd)

# Cleanup
options(restore)

## End(Not run)
</code></pre>


</div>