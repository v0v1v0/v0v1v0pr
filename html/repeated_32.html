<div class="container">

<table style="width: 100%;"><tr>
<td>gausscop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Multivariate Gaussian Copula with Arbitrary Marginals</h2>

<h3>Description</h3>

<p><code>gausscop</code> fits multivariate repeated measurements models based on the
Gaussian copula with a choice of marginal distributions. Dependence among
responses is provided by the correlation matrix containing random effects
and/or autoregression.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gausscop(
  response = NULL,
  distribution = "gamma",
  mu = NULL,
  shape = NULL,
  autocorr = "exponential",
  pmu = NULL,
  pshape = NULL,
  par = NULL,
  pre = NULL,
  delta = NULL,
  shfn = FALSE,
  common = FALSE,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1,
  stepmax = 10 * sqrt(theta %*% theta),
  typsize = abs(c(theta))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>A list of two or three column matrices with response
values, times, and possibly nesting categories, for each individual, one
matrix or dataframe of response values, or an object of class,
<code>response</code> (created by <code>restovec</code>) or
<code>repeated</code> (created by <code>rmna</code> or
<code>lvna</code>). If the <code>repeated</code> data object contains
more than one response variable, give that object in <code>envir</code> and give
the name of the response variable to be used here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>The marginal distribution: exponential, gamma, Weibull,
Pareto, inverse Gauss, logistic, Cauchy, Laplace, or Levy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>The linear or nonlinear regression model to be fitted for the
location parameter. For marginal distributions requiring positive response
values, a log link is used. This model can be a function of the parameters
or a formula beginning with ~, specifying either a linear regression
function for the location parameter in the Wilkinson and Rogers notation or
a general function with named unknown parameters that describes the
location, returning a vector the same length as the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>The linear or nonlinear regression model to be fitted for the
log shape parameter. This can be a function of the parameters or a formula
beginning with ~, specifying either a linear regression function for the
location parameter in the Wilkinson and Rogers notation or a general
function with named unknown parameters that describes the location. If it
contains unknown parameters, the keyword <code>mu</code> may be used to specify a
function of the location parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autocorr</code></td>
<td>
<p>The form of the autocorrelation function:
<code>exponential</code> is the usual <code class="reqn">\rho^{|t_i-t_j|}</code>;
<code>gaussian</code> is <code class="reqn">\rho^{(t_i-t_j)^2}</code>;
<code>cauchy</code> is <code class="reqn">1/(1+\rho(t_i-t_j)^2)</code>;
<code>spherical</code> is
<code class="reqn">((|t_i-t_j|\rho)^3-3|t_i-t_j|\rho+2)/2</code>
for <code class="reqn">|t_i-t_j|\leq1/\rho</code> and zero otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmu</code></td>
<td>
<p>Initial parameter estimates for the location regression model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pshape</code></td>
<td>
<p>Initial parameter estimate for the shape regression model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>If supplied, an initial estimate for the autocorrelation
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre</code></td>
<td>
<p>Zero, one or two parameter estimates for the variance
components, depending on the number of levels of nesting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement for each
response value, set to unity by default. For example, if a response is
measured to two decimals, <code>delta=0.01</code>. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shfn</code></td>
<td>
<p>If TRUE, the supplied shape function depends on the location
function. The name of this location function must be the last argument of
the shape function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common</code></td>
<td>
<p>If TRUE, <code>mu</code> and <code>shape</code> must both be functions
with, as argument, a vector of parameters having some or all elements in
common between them so that indexing is in common between them; all
parameter estimates must be supplied in <code>pmu</code>. If FALSE, parameters
are distinct between the two functions and indexing starts at one in each
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>With two levels of nesting, the first is the individual and the second will
consist of clusters within individuals.
</p>
<p>For clustered (non-longitudinal) data, where only random effects will be
fitted, <code>times</code> are not necessary.
</p>
<p>This function is designed to fit linear and nonlinear models with
time-varying covariates observed at arbitrary time points. A
continuous-time AR(1) and zero, one, or two levels of nesting can be
handled.
</p>
<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code>finterp</code>.)
</p>


<h3>Value</h3>

<p>A list of class <code>gausscop</code> is returned that contains all of
the relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>References</h3>

<p>Song, P.X.K. (2000) Multivariate dispersion models generated
from Gaussian copula. Scandinavian Journal of Statistics 27, 305-320.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# linear models
y &lt;- matrix(rgamma(40,1,1),ncol=5)+rep(rgamma(8,0.5,1),5)
x1 &lt;- c(rep(0,4),rep(1,4))
reps &lt;- rmna(restovec(y),ccov=tcctomat(x1))
# independence with default gamma marginals
# compare with gnlm::gnlr(y, pmu=1, psh=0, dist="gamma", env=reps)
gausscop(y, pmu=1, pshape=0, env=reps)
gausscop(y, mu=~x1, pmu=c(1,0), pshape=0, env=reps)
# AR(1)
gausscop(y, pmu=1, pshape=0, par=0.1, env=reps)
## Not run: 
# random effect
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps)
# try other marginal distributions
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps, dist="Weibull")
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps, dist="inverse Gauss",
	stepmax=1)
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps, dist="Cauchy")
#
# first-order one-compartment model
# create data objects for formulae
dose &lt;- c(2,5)
dd &lt;- tcctomat(dose)
times &lt;- matrix(rep(1:20,2), nrow=2, byrow=TRUE)
tt &lt;- tvctomat(times)
# vector covariates for functions
dose &lt;- c(rep(2,20),rep(5,20))
times &lt;- rep(1:20,2)
# functions
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
lmu &lt;- function(p) p[1]-p[3]+log(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
lshape &lt;- function(p) p[1]-p[2]+log(times*dose)-exp(p[1])*times
# response
#conc &lt;- matrix(rgamma(40,shape(log(c(0.1,0.4))),
#	scale=mu(log(c(1,0.3,0.2))))/shape(log(c(0.1,0.4))),ncol=20,byrow=TRUE)
#conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
#	ncol=20,byrow=TRUE)[,1:19])
#conc &lt;- restovec(ifelse(conc&gt;0,conc,0.01),name="conc")
conc &lt;- matrix(c(3.65586845,0.01000000,0.01000000,0.01731192,1.68707608,
	0.01000000,4.67338974,4.79679942,1.86429851,1.82886732,1.54708795,
	0.57592054,0.08014232,0.09436425,0.26106139,0.11125534,0.22685364,
	0.22896015,0.04886441,0.01000000,33.59011263,16.89115866,19.99638316,
	16.94021361,9.95440037,7.10473948,2.97769676,1.53785279,2.13059515,
	0.72562344,1.27832563,1.33917155,0.99811111,0.23437424,0.42751355,
	0.65702300,0.41126684,0.15406463,0.03092312,0.14672610),
	ncol=20,byrow=TRUE)
conc &lt;- restovec(conc)
reps &lt;- rmna(conc, ccov=dd, tvcov=tt)
# constant shape parameter
gausscop(conc, mu=lmu, pmu=log(c(1,0.4,0.1)), par=0.5, pshape=0, envir=reps)
# or
gausscop(conc, mu=~absorption-volume+
	log(dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times))),
	pmu=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
	par=0.5, pshape=0, envir=reps)
# compare to gar autoregression
gar(conc, dist="gamma", times=1:20, mu=mu,
	preg=log(c(1,0.4,0.1)), pdepend=0.5, pshape=1)
#
# time dependent shape parameter
gausscop(conc, mu=lmu, shape=lshape,
	pmu=log(c(1,0.4,0.1)), par=0.5, pshape=c(-0.1,-0.1))
# or
gausscop(conc, mu=~absorption-volume+
	log(dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times))),
	shape=~b1-b2+log(times*dose)-exp(b1)*times,
	pmu=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
	par=0.5, pshape=list(b1=-0.1,b2=-0.1), envir=reps)
#
# shape depends on location
lshape &lt;- function(p, mu) p[1]*log(abs(mu))
gausscop(conc, mu=lmu, shape=lshape, shfn=TRUE, pmu=log(c(1,0.4,0.1)),
	par=0.5, pshape=1)
# or
gausscop(conc, mu=~absorption-volume+
	log(dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times))),
	shape=~d*log(abs(mu)), shfn=TRUE,
	pmu=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
	par=0.5, pshape=list(d=1), envir=reps)

## End(Not run)
</code></pre>


</div>