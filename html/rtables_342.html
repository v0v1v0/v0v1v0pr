<div class="container">

<table style="width: 100%;"><tr>
<td>list_wrap_x</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Returns a function that coerces the return values of a function to a list</h2>

<h3>Description</h3>

<p>Returns a function that coerces the return values of a function to a list
</p>


<h3>Usage</h3>

<pre><code class="language-R">list_wrap_x(f)

list_wrap_df(f)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>(<code>function</code>)<br> the function to wrap.</p>
</td>
</tr></table>
<h3>Details</h3>

<p><code>list_wrap_x</code> generates a wrapper which takes <code>x</code> as its first argument, while <code>list_wrap_df</code> generates an
otherwise identical wrapper function whose first argument is named <code>df</code>.
</p>
<p>We provide both because when using the functions as tabulation in <code>analyze()</code>, functions which take <code>df</code> as
their first argument are passed the full subset data frame, while those which accept anything else notably
including <code>x</code> are passed only the relevant subset of the variable being analyzed.
</p>


<h3>Value</h3>

<p>A function that returns a list of <code>CellValue</code> objects.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class="language-R">summary(iris$Sepal.Length)

f &lt;- list_wrap_x(summary)
f(x = iris$Sepal.Length)

f2 &lt;- list_wrap_df(summary)
f2(df = iris$Sepal.Length)

</code></pre>


</div>