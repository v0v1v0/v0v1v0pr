<div class="container">

<table style="width: 100%;"><tr>
<td>SO3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>'SO3' class for storing rotation data as rotation matrices</h2>

<h3>Description</h3>

<p>Creates or tests for objects of class "SO3".
</p>


<h3>Usage</h3>

<pre><code class="language-R">as.SO3(x, ...)

## Default S3 method:
as.SO3(x, theta = NULL, ...)

## S3 method for class 'Q4'
as.SO3(x, ...)

## S3 method for class 'SO3'
as.SO3(x, ...)

## S3 method for class 'data.frame'
as.SO3(x, ...)

is.SO3(x)

id.SO3
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object to be coerced or tested; see details for possible forms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>vector or single rotation angle; if <code>length(theta)==1</code> the
same theta is used for all axes</p>
</td>
</tr>
</table>
<h3>Format</h3>

<p><code>id.SO3</code> is the identity rotation given by the the 3-by-3
identity matrix.
</p>
<p>An object of class <code>SO3</code> with 1 rows and 9 columns.
</p>


<h3>Details</h3>

<p>Construct a single or sample of rotations in 3-dimensions in 3-by-3 matrix
form.  Several possible inputs for <code>x</code> are possible and they are
differentiated based on their class and dimension.
</p>
<p>For <code>x</code> an n-by-3 matrix or a vector of length 3, the angle-axis
representation of rotations is utilized.  More specifically, each rotation
matrix can be interpreted as a rotation of some reference frame about the
axis <code class="reqn">U</code> (of unit length) through the angle <code class="reqn">\theta</code>.  If a single
axis (in matrix or vector format) or matrix of axes are provided for
<code>x</code>, then for each axis and angle the matrix is formed through
</p>
<p style="text-align: center;"><code class="reqn">R=\exp[\Phi(U\theta)]</code>
</p>
<p> where <code class="reqn">U</code> is replace
by <code>x</code>.  If axes are provided but <code>theta</code> is not provided then the
length of each axis is taken to be the angle of rotation, theta.
</p>
<p>For <code>x</code> an n-by-4 matrix of quaternions or an object of class
<code>"Q4"</code>, this function will return the rotation matrix equivalent of
<code>x</code>.  See <code>Q4</code> or the vignette "rotations-intro" for more
details on quaternions.
</p>
<p>For <code>x</code> an n-by-9 matrix, rows are treated as 3-by-3 matrices; rows that
don't form matrices in SO(3) are projected into SO(3) and those that are
already in SO(3) are returned untouched.  See <code>project.SO3</code> for
more on projecting arbitrary matrices into SO(3).  A message is printed if
any of the rows are not proper rotations.
</p>
<p>For <code>x</code> a <code>"data.frame"</code>, it is translated into a matrix of the
same dimension and the dimensionality of <code>x</code> is used to determine the
data type: angle-axis, quaternion or rotation. As demonstrated below,
<code>is.SO3</code> may return <code>TRUE</code> for a data frame, but the functions
defined for objects of class <code>"SO3"</code> will not be called until
<code>as.SO3</code> has been used.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>as.SO3</code></td>
<td>
<p>coerces provided data into an SO3 type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.SO3</code></td>
<td>
<p>returns <code>TRUE</code> or <code>False</code> depending on whether its
argument satisfies the conditions to be an rotation matrix.  Namely, has
determinant one and its transpose is its inverse.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># Select one location to focus on
Loc698 &lt;- subset(nickel, location == 698)

is.SO3(Loc698[,5:13])          #Some of the rows are not rotations due to rounding or entry errors
                               #as.SO3 will project matrices not in SO(3) to SO(3)

Rs &lt;- as.SO3(Loc698[,5:13])    #Translate the Rs data.frame into an object of class 'SO3'
                               #Rows 4, 6 and 13 are not in SO(3) so they are projected to SO(3)

mean(Rs)                       #Estimate the central orientation with the average
median(Rs)                     #Re-estimate central orientation robustly
Qs &lt;- as.Q4(Rs)                #Coerse into "SO3" format, see ?as.SO3 for more

#Visualize the location, there appears to be two groups

  plot(Rs, col = c(1, 2, 3))

</code></pre>


</div>