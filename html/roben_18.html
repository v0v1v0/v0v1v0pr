<div class="container">

<table style="width: 100%;"><tr>
<td>roben</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>fit a robust Bayesian variable selection</h2>

<h3>Description</h3>

<p>fit a robust Bayesian variable selection model for G×E interactions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">roben(
  X,
  Y,
  E,
  clin = NULL,
  iterations = 10000,
  burn.in = NULL,
  robust = TRUE,
  sparse = TRUE,
  structure = c("sparsegroup", "group", "individual"),
  hyper = NULL,
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>the matrix of predictors (genetic factors) without intercept. Each row should be an observation vector. X will be centered and a column of 1 will be added to the X matrix
as the intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>the response variable. The current version of roben only supports continuous response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>a matrix of environmental factors. E will be centered. The interaction terms between X (G factors) and E will be automatically created and included in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clin</code></td>
<td>
<p>a matrix of clinical variables. Clinical variables are not subject to penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>the number of MCMC iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn.in</code></td>
<td>
<p>the number of iterations for burn-in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>logical flag. If TRUE, robust methods will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>logical flag. If TRUE, spike-and-slab priors will be used to shrink coefficients of irrelevant covariates to zero exactly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structure</code></td>
<td>
<p>three choices are available. "sparsegroup" for sparse-group selection, which is a bi-level selection on both group-level and individual-level. "group" for selection on group-level only. "individual" for selection on individual-level only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyper</code></td>
<td>
<p>a named list of hyperparameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debugging</code></td>
<td>
<p>logical flag. If TRUE, progress will be output to the console and extra information will be returned.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider the data model described in "<code>data</code>":
</p>
<p style="text-align: center;"><code class="reqn">Y_{i} = \alpha_{0} + \sum_{t=1}^{q}\alpha_{t}Clin_{it} + \sum_{m=1}^{k}\theta_{m}E_{im}  + \sum_{j=1}^{p} \big(U_{ij}^\top\beta_{j}\big) +\epsilon_{i},</code>
</p>

<p>where the main and interaction effects of the <code class="reqn">j</code>th genetic variant is corresponding to the coefficient vector <code class="reqn">\beta_{j}=(\beta_{j1}, \beta_{j2},\ldots,\beta_{jL})^\top</code>.
</p>
<p>When structure="sparsegroup" (default setting), selection will be conducted on both individual and group levels (bi-level selection):
</p>

<ul>
<li> <p><strong>Group-level selection:</strong> by determining whether <code class="reqn">||\beta_{j}||_{2}=0</code>, we can know if the <code class="reqn">j</code>th genetic variant has any effect at all.
</p>
</li>
<li> <p><strong>Individual-level selection:</strong> investigate whether the <code class="reqn">j</code>th genetic variant has main effect, G<code class="reqn">\times</code>E interaction or both, by determining which components in <code class="reqn">\beta_{j}</code> has non-zero values.
</p>
</li>
</ul>
<p>If structure="group", only group-level selection will be conducted on <code class="reqn">||\beta_{j}||_{2}</code>. If structure="individual", only individual-level selection will be conducted on each <code class="reqn">\beta_{jl}</code>, (<code class="reqn">l=1,\ldots,L</code>).
</p>
<p>When sparse=TRUE (default), spike–and–slab priors are imposed on individual and/or group levels to identify important main and interaction effects. Otherwise, Laplacian shrinkage will be used.
</p>
<p>When robust=TRUE (default), the distribution of <code class="reqn">\epsilon_{i}</code> is defined as a Laplace distribution with density
<code class="reqn">
f(\epsilon_{i}|\nu) = \frac{\nu}{2}\exp\left\{-\nu |\epsilon_{i}|\right\}
</code>, (<code class="reqn">i=1,\dots,n</code>), which leads to a Bayesian formulation of LAD regression. If robust=FALSE, <code class="reqn">\epsilon_{i}</code> follows a normal distribution.
<br></p>
<p>Both <code class="reqn">X</code> and <code class="reqn">E</code> will be centered before the generation of interaction terms, in order to prevent the multicollinearity between main effects and interaction terms.
<br></p>
<p>Users can modify the hyper-parameters by providing a named list of hyper-parameters via the argument ‘hyper’.
The list can have the following named components
</p>

<ul>
<li>
<p> a0, b0: shape parameters of the Beta priors (<code class="reqn">\pi^{a_{0}-1}(1-\pi)^{b_{0}-1}</code>) on <code class="reqn">\pi_{0}</code>.
</p>
</li>
<li>
<p> a1, b1: shape parameters of the Beta priors (<code class="reqn">\pi^{a_{1}-1}(1-\pi)^{b_{1}-1}</code>) on <code class="reqn">\pi_{1}</code>.
</p>
</li>
<li>
<p> c1, c2: the shape parameter and the rate parameter of the Gamma prior on <code class="reqn">\nu</code>.
</p>
</li>
<li>
<p> d1, d2: the shape parameter and the rate parameter of the Gamma priors on <code class="reqn">\eta</code>.
</p>
</li>
</ul>
<p>Please check the references for more details about the prior distributions.
</p>


<h3>See Also</h3>

<p><code>GxESelection</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(GxE_small)

## default method
iter=5000
fit=roben(X, Y, E, clin, iterations = iter)
fit$coefficient

## Ture values of parameters of main G effects and interactions
coeff$GE

## Compute TP and FP
sel=GxESelection(fit)
pos=which(sel$indicator != 0)
tp=length(intersect(which(coeff$GE != 0), pos))
fp=length(pos)-tp
list(tp=tp, fp=fp)


## alternative: robust group selection
fit=roben(X, Y, E, clin, iterations=iter, structure="g")
fit$coefficient

## alternative: non-robust sparse group selection
fit=roben(X, Y, E, clin, iterations=iter, robust=FALSE)
fit$coefficient


</code></pre>


</div>