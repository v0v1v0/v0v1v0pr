<div class="container">

<table style="width: 100%;"><tr>
<td>L1median</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the Multivariate L1-Median aka 'Spatial Median'</h2>

<h3>Description</h3>

<p>Compute the multivariate <code class="reqn">L_1</code>-median <code class="reqn">m</code>, also called
“Spatial Median”, i.e., the
minimizer of
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n \| x_i - m \|,</code>
</p>

<p>where <code class="reqn">\|u\| = \sqrt{\sum_{j=1}^p u_j^2}</code>.
</p>
<p>As a convex problem, there's always a global minimizer, computable not
by a closed formula but rather an iterative search.  As the
(partial) first derivatives of the objective function is
undefined at the data points, the minimization is not entirely trivial.
</p>


<h3>Usage</h3>

<pre><code class="language-R">L1median(X, m.init = colMedians(X), weights = NULL,
	method = c("nlm", "HoCrJo", "VardiZhang", optimMethods, nlminbMethods),
	pscale = apply(abs(centr(X, m.init)), 2, mean, trim = 0.40),
	tol = 1e-08, maxit = 200, trace = FALSE,
	zero.tol = 1e-15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>numeric <code>matrix</code> of dimension <code class="reqn">n \times p</code>,
say.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.init</code></td>
<td>
<p>starting value for <code class="reqn">m</code>; typically and by default the
coordinatewise median.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>optional numeric vector of non-negative weights;
currently only implemented for method <code>"VardiZhang"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string specifying the computational method,
i.e., the algorithm to be used (can be abbreviated).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pscale</code></td>
<td>
<p>numeric p-vector of positive numbers,
the coordinate-wise scale (typical size of
<code class="reqn">\delta{m_j}</code>), where <code class="reqn">m</code> is the problem's solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>positive number specifying the (relative) convergence
tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>positive integer specifying the maximal number of
iterations (before the iterations are stopped prematurely if necessary).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>an integer specifying the tracing level of the
iterations; <code>0</code> does no tracing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero.tol</code></td>
<td>
<p>for method <code>"VardiZhang"</code>, a small positive
number specifying the tolerance for determining that the iteration
is ‘exactly’ at a data point (which is a singularity).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments to <code>nlm()</code> or the
<code>control</code> (list) arguments of <code>optim()</code>, or
<code>nlminb()</code>, respectively.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Currently, we have to refer to the “References” below.

</p>


<h3>Value</h3>

<p>currently the result <em>depends</em> strongly on the <code>method</code>
used.
</p>
<p>FIXME. This will change considerably.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler.  Method <code>"HoCrJo"</code> is mostly based on Kristel
Joossens' <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, implementing Hossjer and Croux (1995).
</p>


<h3>References</h3>

<p>Hossjer and Croux, C. (1995).
Generalizing Univariate Signed Rank Statistics for Testing
and Estimating a Multivariate Location Parameter.
<em>Non-parametric Statistics</em> <b>4</b>, 293–308.
</p>
<p>Vardi, Y. and Zhang, C.-H. (2000).
The multivariate <code class="reqn">L_1</code>-median and associated data depth.
<em>Proc. National Academy of Science</em> <b>97</b>(4), 1423–1426.
</p>
<p>Fritz, H. and Filzmoser, P. and Croux, C. (2012)
A comparison of algorithms for the multivariate L1-median.
<em>Computational Statistics</em> <b>27</b>, 393–410.
</p>
<p>Kent, J. T., Er, F. and Constable, P. D. L. (2015)
Algorithms for the spatial median;, in K. Nordhausen and
S. Taskinen (eds), <em>Modern Nonparametric, Robust and Multivariate
Methods: Festschrift in Honour of Hannu Oja</em>,
Springer International Publishing, chapter 12, pp. 205–224.
<a href="https://doi.org/10.1007/978-3-319-22404-6_12">doi:10.1007/978-3-319-22404-6_12</a>
</p>


<h3>See Also</h3>

<p><code>median</code>, <code>covMcd</code>
</p>
<p>CRAN package <a href="https://CRAN.R-project.org/package=pcaPP"><span class="pkg">pcaPP</span></a> added more L1 median methods,
re-implementing our <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> versions in C++, see Fritz et al.(2012) and
e.g., <code>l1median_NLM()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(stackloss)
L1median(stackloss)
L1median(stackloss, method = "HoCrJo")


## Explore all methods:
m &lt;- eval(formals(L1median)$method); allMeths &lt;- m[m != "Brent"]
L1m &lt;- sapply(allMeths, function(meth) L1median(stackloss, method = meth))
## --&gt; with a warning for L-BFGS-B
str(L1m)
pm &lt;- sapply(L1m, function(.) if(is.numeric(.)) . else .$par)
t(pm) # SANN differs a bit; same objective ?
</code></pre>


</div>