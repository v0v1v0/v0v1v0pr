<div class="container">

<table style="width: 100%;"><tr>
<td>perry.seqModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Resampling-based prediction error for a sequential regression model</h2>

<h3>Description</h3>

<p>Estimate the prediction error of a previously fit sequential regression
model such as a robust least angle regression model or a sparse least
trimmed squares regression model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'seqModel'
perry(
  object,
  splits = foldControl(),
  cost,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  ...
)

## S3 method for class 'sparseLTS'
perry(
  object,
  splits = foldControl(),
  fit = c("reweighted", "raw", "both"),
  cost = rtmspe,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>the model fit for which to estimate the prediction error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splits</code></td>
<td>
<p>an object of class <code>"cvFolds"</code> (as returned by
<code>cvFolds</code>) or a control object of class
<code>"foldControl"</code> (see <code>foldControl</code>) defining the
folds of the data for (repeated) <code class="reqn">K</code>-fold cross-validation, an object of
class <code>"randomSplits"</code> (as returned by
<code>randomSplits</code>) or a control object of class
<code>"splitControl"</code> (see <code>splitControl</code>) defining
random data splits, or an object of class <code>"bootSamples"</code> (as returned
by <code>bootSamples</code>) or a control object of class
<code>"bootControl"</code> (see <code>bootControl</code>) defining
bootstrap samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>a cost function measuring prediction loss.  It should expect
vectors to be passed as its first two arguments, the first corresponding to
the observed values of the response and the second to the predicted values,
and must return a non-negative scalar value.  The default is to use the root
mean squared prediction error for non-robust models and the root trimmed
mean squared prediction error for robust models (see
<code>cost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code>makeCluster</code>.  If supplied, this is preferred over
<code>ncores</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code>.Random.seed</code>).  Note that also in case of parallel computing,
resampling is performed on the manager process rather than the worker
processes. On the parallel worker processes, random number streams are
used and the seed is set via <code>clusterSetRNGStream</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to the prediction loss
function <code>cost</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>a character string specifying for which fit to estimate the
prediction error.  Possible values are <code>"reweighted"</code> (the default) for
the prediction error of the reweighted fit, <code>"raw"</code> for the prediction
error of the raw fit, or <code>"both"</code> for the prediction error of both
fits.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The prediction error can be estimated via (repeated) <code class="reqn">K</code>-fold
cross-validation, (repeated) random splitting (also known as random
subsampling or Monte Carlo cross-validation), or the bootstrap.  In
each iteration, the optimal model is thereby selected from the training
data and used to make predictions for the test data.
</p>


<h3>Value</h3>

<p>An object of class <code>"perry"</code> with the following components:
</p>

<dl>
<dt><code>pe</code></dt>
<dd>
<p>a numeric vector containing the estimated prediction
errors for the requested model fits.  In case of more than one replication,
this gives the average value over all replications.</p>
</dd>
<dt><code>se</code></dt>
<dd>
<p>a numeric vector containing the estimated standard errors
of the prediction loss for the requested model fits.</p>
</dd>
<dt><code>reps</code></dt>
<dd>
<p>a numeric matrix in which each column contains the
estimated prediction errors from all replications for the requested model
fits.  This is only returned in case of more than one replication.</p>
</dd>
<dt><code>splits</code></dt>
<dd>
<p>an object giving the data splits used to estimate the
prediction error.</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>the response.</p>
</dd>
<dt><code>yHat</code></dt>
<dd>
<p>a list containing the predicted values from all
replications.</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>the matched function call.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code>rlars</code>, <code>sparseLTS</code>,
<code>predict</code>, <code>perry</code>,
<code>cost</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## fit and evaluate robust LARS model
fitRlars &lt;- rlars(x, y, sMax = 10)
perry(fitRlars)

## fit and evaluate sparse LTS model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
perry(fitSparseLTS)
</code></pre>


</div>