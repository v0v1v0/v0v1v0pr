<div class="container">

<table style="width: 100%;"><tr>
<td>consider_previous_information</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Remember the intermediate inferred GRN while generating the final inferred GRN
</h2>

<h3>Description</h3>

<p>This function combines the adjacency matrix A_prev obtained as a result of <code>first_GBM_step</code> with the adjacency matrix A obtained as a result of <code>second_GBM_step</code>. All the edges in the matrix A which have non-zero weights are given machine precision weights initially. We then perform a harmonic mean for each element of A_prev and A to obtain a regularized adjacency matrix (A_final). As a result of this procedure transcriptional regulations which were strong and present in both A_prev and A end up getting highest weights in A_final. We finally remove all edges whose weights are less than machine precision from A_final. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">consider_previous_information(A, A_prev,real)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>

<p>Inferred GRN from the <code>second_GBM_step</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A_prev</code></td>
<td>

<p>Inferred GRN from the <code>first_GBM_step</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>real</code></td>
<td>

<p>Numeric value 0 or 1 corresponding to simulated or real experiment respectively.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns an adjacency matrix A_final of the form Ntfs-by-Ntargets
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code>first_GBM_step</code>, <code>second_GBM_step</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## The function is currently defined as
function (A, A_prev) 
{
  #Utilize Past Information also to not remove true positives
  A_prev[A_prev==0] &lt;- .Machine$double.eps;
  A_prev &lt;- transform_importance_to_weights(A_prev);
  A[A==0] &lt;- .Machine$double.eps;
  epsilon &lt;- 1/log(1/.Machine$double.eps);
  A &lt;- transform_importance_to_weights(A);
  A_final &lt;- 2*A*A_prev/(A+A_prev);
  A_final &lt;- A_final - epislon;
  A_final[A_final&lt;0] &lt;- 0.0;
  return(A_final);
}
</code></pre>


</div>