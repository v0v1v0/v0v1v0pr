<div class="container">

<table style="width: 100%;"><tr>
<td>rdf_aggregate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregate RiverWare output for one or more scenarios</h2>

<h3>Description</h3>

<p>Process the user specified <code>rwd_agg</code> object for one or more scenarios to
aggregate and summarize RiverWare output data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rdf_aggregate(
  agg,
  rdf_dir = ".",
  scenario = NULL,
  keep_cols = FALSE,
  nans_are = "0",
  find_all_slots = TRUE,
  cpp = TRUE,
  verbose = TRUE
)

rw_scen_aggregate(
  scenarios,
  agg,
  scen_dir = ".",
  nans_are = "0",
  keep_cols = FALSE,
  file = NULL,
  scen_names = NULL,
  find_all_slots = TRUE,
  cpp = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>agg</code></td>
<td>
<p>A rwd_agg object specifying the rdfs, slots, and
aggregation methods to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rdf_dir</code></td>
<td>
<p>The top level directory that contains the rdf files. See
<strong>Directory Structure</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scenario</code></td>
<td>
<p>An optional parameter, that if it is not <code>NULL</code> or <code>NA</code>
(default) will be added to the tibble as another variable. Coerced to a
character if it is not already a character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_cols</code></td>
<td>
<p>Either boolean, or a character vector of column names to
keep in the returned tibble. The values of <code>keep_cols</code> work as follows:
</p>

<ul>
<li> <p><code>FALSE</code> (default) only includes the defaults columns:
<code>TraceNumber</code>, <code>ObjectSlot</code>, and <code>Value</code>. <code>Scenario</code> is also returned if
<code>scenario</code> is specified.
</p>
</li>
<li> <p><code>TRUE</code>, all columns are returned.
</p>
</li>
<li>
<p> A character vector, e.g., <code>c("ObjectName", "Units")</code>, allows the user to
include other columns that are not always required, in addition to the
"default" set of columns. If any of the values in <code>keep_cols</code> are not
found, a warning will post, but all other columns will be returned.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nans_are</code></td>
<td>
<p>Either "0" or "error". If "0", then <code>NaN</code>s in the rwtbl are
treated as 0s. If "error", then any <code>NaN</code>s will cause an error in this
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>find_all_slots</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), then the function will
abort if it cannot find a particular slot. If <code>FALSE</code>, then the function
will continue, even if a slot cannot be found. If a slot is not found,
then the function will return <code>-99</code> for the Trace, and <code>NaN</code> for Year, and
Value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpp</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), then use rdf_to_rwtbl2, which
relies on C++, otherwise, use original rdf_to_rwtbl function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), then print out status of
processing the scenario(s) and the slots in each scenario.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scenarios</code></td>
<td>
<p>A character vector of scenario folders. This is usually a
vector of folder names, where each folder name contains one scenario worth
of data. <code>scenarios</code> can be named or unnamed. The names are used as the
scenario name in the returned <code>tbl_df</code>. Scenario names can also be
specified through the <code>scen_names</code> argument. If <code>scen_names</code> is specified,
<code>scenarios</code> should not already have names. If <code>scen_names</code> is not specified
and, <code>scenarios</code> is not already named, then the scenario folders will also
be used as the scenario names. See <strong>Directory Structure</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scen_dir</code></td>
<td>
<p>File path to the directory that contains the scenario
folders. <strong>Directory Structure</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Optionally save the <code>tbl_df</code> of aggregated scenario data as a
.txt, .csv, or .feather file. If <code>file</code> is specified, then the data are
saved in the specified output format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scen_names</code></td>
<td>
<p>An alternative way to specify scenario names.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>rdf_aggregate()</code> aggregates a single scenario of data by processing a
rwd_agg object.
</p>
<p>In both cases, the user specifies the rwd_agg, which
determines the slots that are aggregated, and how they are aggregated. See
rwd_agg for more details on how it should be specified.
</p>
<p>See the <strong>Directory Structure</strong> section for how to specify <code>scenarios</code>,
<code>scen_dir</code>, and <code>rdf_dir</code>.
</p>
<p><code>rw_scen_aggregate()</code> aggregates multiple scenarios of data. It processes the
rwd_agg object (<code>agg</code>) for each single scenario, and then binds all of the
individual scenario data together into a single <code>tbl_df</code>.
</p>


<h3>Value</h3>

<p>A <code>tbl_df</code> containing all aggregated and summarized data for all of
the specified <code>scenarios</code>.
</p>


<h3>Directory Structure</h3>

<p>RiverWare and RiverSMART typically write data into an expected directory
structure. The below shows an example directory structure and corresponding
variable names for <code>rw_scen_aggregate()</code> and <code>rdf_aggregate()</code>. (In the
example below, C:/user/crss/CRSS.Jan2017/Scenario is the more complete
directory setup for the data included in <code>system.file("extdata/Scenario/")</code>.)
</p>
<pre>
C:/user/crss
|
|- CRSS.Jan2017
|    - model
|    - ruleset
|    - Scenario
|         - ISM1988_2014,2007Dems,IG,Most
|         - ISM1988_2014,2007Dems,IG,2002 
|    - ...
|- CRSS.Jan2018
|    - model
|    - ... (same general setup as CRSS.Jan2017)
</pre>
<p>To get one scenario's data, <code>rdf_aggregate()</code> can be called with <code>rdf_dir</code>
set to "C:/user/crss/CRSS.Jan2017/Scenario/ISM1988_2014,2007Dems,IG,Most".
(<code>scenario</code> can optionally be specified to git a scenario name.)
</p>
<p>To aggregate multiple scenarios of data together, <code>rw_scen_aggregate()</code>
should be called with <code>scen_dir</code> set to "C:/user/CRSS/CRSS.Jan2017/Scenario"
and <code>scenarios</code> set to
<code>c("ISM1988_2014,2007Dems,IG,Most", "ISM1988_2014,2007Dems,IG,2002")</code>.
(Optionally, <code>scenarios</code> can be named, or <code>scen_names</code> specified to use
scenario names that are different from the above scenario folders.)
</p>
<p>Finally, to aggregate scenario data from both CRSS.Jan2017 and CRSS.Jan2018,
<code>rw_scen_aggregate()</code> should be called with <code>scen_dir</code> set to
"C:/users/crss/". <code>scenarios</code> can then be set to
<code>c("CRSS.Jan2017/Scenario/ISM1988_2014,2007Dems,IG,Most","CRSS.Jan2018/Scenario/ISM1988_2014,2007Dems,IG,Most")</code>,
assuming the same scenario exists in both folders. In this case it is
advisable to also specify <code>scen_names</code> or name <code>scenarios</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># rdf_aggregate() ----------

rdfPath &lt;- system.file(
  "extdata/Scenario/ISM1988_2014,2007Dems,IG,Most", 
  package = "RWDataPlyr"
)

rwa &lt;- read_rwd_agg(
  system.file(
    "extdata/rwd_agg_files/passing_aggs.csv", 
    package = "RWDataPlyr"
  )
)

x &lt;- rdf_aggregate(rwa[1,], rdf_dir = rdfPath, scenario = "Most")

# rw_scen_aggregate() ----------

scens &lt;- c("ISM1988_2014,2007Dems,IG,2002", "ISM1988_2014,2007Dems,IG,Most")
scenNames &lt;- c("2002", "Most")
namedScens &lt;- scens
names(namedScens) &lt;- scenNames

scenPath &lt;- system.file("extdata/Scenario", package = "RWDataPlyr")

rwa &lt;- read_rwd_agg(
  system.file(
    "extdata/rwd_agg_files/passing_aggs.csv", 
    package = "RWDataPlyr"
  )
)

x &lt;- rw_scen_aggregate(namedScens, agg = rwa[1,], scen_dir = scenPath)

# y will be identical to x

y &lt;- rw_scen_aggregate(
  scens, 
  agg = rwa[1,], 
  scen_dir = scenPath, 
  scen_names = scenNames
)

identical(x, y) # is TRUE

</code></pre>


</div>