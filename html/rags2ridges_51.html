<div class="container">

<table style="width: 100%;"><tr>
<td>optPenalty.LOOCV</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Select optimal penalty parameter by leave-one-out cross-validation</h2>

<h3>Description</h3>

<p>This function is now deprecated. Please use <code>optPenalty.kCV</code> instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optPenalty.LOOCV(
  Y,
  lambdaMin,
  lambdaMax,
  step,
  type = "Alt",
  cor = FALSE,
  target = default.target(covML(Y)),
  output = "light",
  graph = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Data <code>matrix</code>. Variables assumed to be represented by columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaMin</code></td>
<td>
<p>A <code>numeric</code> giving the minimum value for the penalty
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaMax</code></td>
<td>
<p>A <code>numeric</code> giving the maximum value for the penalty
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>An <code>integer</code> determining the number of steps in moving
through the grid [<code>lambdaMin</code>, <code>lambdaMax</code>].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A <code>character</code> indicating the type of ridge estimator to be
used. Must be one of: "Alt", "ArchI", "ArchII".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor</code></td>
<td>
<p>A <code>logical</code> indicating if the evaluation of the LOOCV score
should be performed on the correlation scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>A target <code>matrix</code> (in precision terms) for Type I ridge
estimators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>A <code>character</code> indicating if the output is either heavy or
light. Must be one of: "all", "light".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A <code>logical</code> indicating if the grid search for the optimal
penalty parameter should be visualized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A <code>logical</code> indicating if information on progress should
be printed on screen.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function that selects the optimal penalty parameter for the
<code>ridgeP</code> call by usage of leave-one-out cross-validation. Its
output includes (a.o.) the precision matrix under the optimal value of the
penalty parameter.
</p>
<p>The function calculates a cross-validated negative log-likelihood score
(using a regularized ridge estimator for the precision matrix) for each
value of the penalty parameter contained in the search grid by way of
leave-one-out cross-validation. The value of the penalty parameter that
achieves the lowest cross-validated negative log-likelihood score is deemed
optimal. The penalty parameter must be positive such that <code>lambdaMin</code>
must be a positive scalar. The maximum allowable value of <code>lambdaMax</code>
depends on the type of ridge estimator employed. For details on the type of
ridge estimator one may use (one of: "Alt", "ArchI", "ArchII") see
<code>ridgeP</code>. The ouput consists of an object of class list (see
below). When <code>output = "light"</code> (default) only the <code>optLambda</code> and
<code>optPrec</code> elements of the list are given.
</p>


<h3>Value</h3>

<p>An object of class list: </p>
<table>
<tr style="vertical-align: top;">
<td><code>optLambda</code></td>
<td>
<p>A <code>numeric</code> giving
the optimal value of the penalty parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optPrec</code></td>
<td>
<p>A <code>matrix</code>
representing the precision matrix of the chosen type (see
<code>ridgeP</code>) under the optimal value of the penalty parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdas</code></td>
<td>
<p>A <code>numeric</code> vector representing all values of the
penalty parameter for which cross-validation was performed; Only given when
<code>output = "all"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LLs</code></td>
<td>
<p>A <code>numeric</code> vector representing the
mean of cross-validated negative log-likelihoods for each value of the
penalty parameter given in <code>lambdas</code>; Only given when <code>output =
"all"</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>When <code>cor = TRUE</code> correlation matrices are used in the
computation of the (cross-validated) negative log-likelihood score, i.e.,
the leave-one-out sample covariance matrix is a matrix on the correlation
scale. When performing evaluation on the correlation scale the data are
assumed to be standardized. If <code>cor = TRUE</code> and one wishes to used the
default target specification one may consider using <code>target =
default.target(covML(Y, cor = TRUE))</code>. This gives a default target under the
assumption of standardized data.
</p>


<h3>Author(s)</h3>

<p>Carel F.W. Peeters &lt;carel.peeters@wur.nl&gt;, Wessel N. van Wieringen
</p>


<h3>See Also</h3>

<p><code>ridgeP</code>, <code>optPenalty.LOOCVauto</code>,
<code>optPenalty.aLOOCV</code>, <br><code>default.target</code>,
<code>covML</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Obtain some (high-dimensional) data
p = 25
n = 10
set.seed(333)
X = matrix(rnorm(n*p), nrow = n, ncol = p)
colnames(X)[1:25] = letters[1:25]

## Obtain regularized precision under optimal penalty
OPT  &lt;- optPenalty.LOOCV(X, lambdaMin = .5, lambdaMax = 30, step = 100); OPT
OPT$optLambda	# Optimal penalty
OPT$optPrec	  # Regularized precision under optimal penalty

## Another example with standardized data
X &lt;- scale(X, center = TRUE, scale = TRUE)
OPT  &lt;- optPenalty.LOOCV(X, lambdaMin = .5, lambdaMax = 30, step = 100, cor = TRUE,
                         target = default.target(covML(X, cor = TRUE))); OPT
OPT$optLambda	# Optimal penalty
OPT$optPrec	  # Regularized precision under optimal penalty

</code></pre>


</div>