<div class="container">

<table style="width: 100%;"><tr>
<td>memory_alpha</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Memory Alpha API</h2>

<h3>Description</h3>

<p>Access Star Trek content from
<a href="https://memory-alpha.fandom.com/wiki/Portal:Main">Memory Alpha</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">memory_alpha(endpoint)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>endpoint</code></td>
<td>
<p>character, See details.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The content returned is always a data frame. The structure changes slightly
depending on the nature of the endpoint, but results from different endpoints
can be merged easily.
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Portals</h3>

<p>At the highest level, passing <code>endpoint = "portals"</code> returns a data frame
listing the available Memory Alpha portals supported by <code>rtrek</code>. A column of
relative URLs is also included for reference, but can be ignored.
</p>


<h3>Portal Categories</h3>

<p>In all other cases, the endpoint string must begin with one of the valid
portal IDs. Passing only the ID returns a data frame with IDs and relative
URLs associated with the available categories in the specific portal. There
are two additional columns, <code>group</code> and <code>subgroup</code>, that may provide
additional grouping context for the entry IDs in larger tables. As with the
relative URLs, you do not have to make explicit use of these variables.
</p>
<p>Selecting a specific category within a portal is done by appending the portal
ID in <code>endpoint</code> with the category ID, separated by a forward slash. You can
append nested subcategory IDs with forward slashes, provided the
subcategories exist.
</p>


<h3>Articles</h3>

<p>When the endpoint is neither a top-level portal or one of a portal's
categories (or subcategories, if available), it is an article. An article is
a terminal node, meaning you cannot nest further. An article will be any
entry whose URL does not begin with <code style="white-space: pre;">⁠Category:⁠</code>. In this case, the content
returned is still a data frame for consistency, but differs substantially
from the results of non-terminal endpoints.
</p>
<p>Memory Alpha is not a database containing convenient tables. Articles
comprise the bulk of what Memory Alpha has to offer. They are not completely
unstructured text, but are loosely structured. Some assumptions are made and
<code>memory_alpha()</code> returns a data frame containing article text and links. It is
up to the user what to do with this information, e.g., performing text
analyses.
</p>


<h3>Additional Notes</h3>

<p>The <code>url</code> column included in results for context uses relative paths to save
space. The full URLs all begin the same. To visit a URL directly, prepend it
with <code style="white-space: pre;">⁠https://memory-alpha.fandom.com/wiki/⁠</code>.
</p>
<p>Also note that once you know the relative URL for an article, e.g., <code>"Worf"</code>,
you do not need to traverse through one of the portals using an <code>endpoint</code>
string to retrieve its content. You can instead use <code>ma_article("Worf")</code>.
</p>
<p><code>memory_alpha()</code> provides an overview perspective on how content available at
Memory Alpha is organized and can be searched for through a variety of
hierarchical layouts. And in some cases this structure that can be obtained
in table form can be useful as data or metadata in itself. Alternatively,
<code>ma_article()</code> is focused exclusively on pulling back content from known
articles.
</p>


<h3>See Also</h3>

<p><code>ma_article()</code>, <code>memory_beta()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">memory_alpha("portals") # show available portals

memory_alpha("people") # show portal categories for People portal
memory_alpha("people/Klingons") # show people in Klingons subcategory
memory_alpha("people/Klingons/Worf") # return terminal article content

</code></pre>


</div>