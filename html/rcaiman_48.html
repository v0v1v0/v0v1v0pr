<div class="container">

<table style="width: 100%;"><tr>
<td>polar_qtree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Do quad-tree segmentation in the polar space</h2>

<h3>Description</h3>

<p>The quad-tree segmentation algorithm is a top-down process that makes
recursive divisions in four equal parts until a condition is satisfied and
stops locally. The usual implementation of the quad-tree algorithm is
based on the raster structure and this is why the result are squares of
different sizes. This method implements the quad-tree segmentation in a polar
space, so the segments are shaped like windshields, though some of them will
look elongated in height. The pattern is two opposite and converging straight
sides and two opposite and parallel curvy sides.
</p>


<h3>Usage</h3>

<pre><code class="language-R">polar_qtree(r, z, a, scale_parameter = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>SpatRaster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>SpatRaster built with <code>zenith_image()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>SpatRaster built with <code>azimuth_image()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_parameter</code></td>
<td>
<p>Numeric vector of length one. Quad-tree is a top-down
method. This parameter controls the stopping condition. Therefore, it
allows controlling the size of the resulting segments. Ultimately, segments
sizes will depend on both this parameter and the heterogeneity of <code>r</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithm splits segments of 30 degrees resolution into four sub-segments
and calculates the standard deviation of the pixels from <code>r</code> delimited
by each of those segments. The splitting process stops locally if the sum of
the standard deviation of the sub-segments minus the standard deviation of
the parent segment (named <em>delta</em>) is less or equal than the
<code>scale_parameter</code>. If <code>r</code> has more than one layer, <em>delta</em> is
calculated separately and <em>delta</em> mean is used to evaluate the stopping
condition.
</p>


<h3>Value</h3>

<p>A single layer image of the class SpatRaster with
integer values.
</p>


<h3>See Also</h3>

<p>Other Segmentation Functions: 
<code>chessboard()</code>,
<code>mask_hs()</code>,
<code>mask_sunlit_canopy()</code>,
<code>qtree()</code>,
<code>rings_segmentation()</code>,
<code>sectors_segmentation()</code>,
<code>sky_grid_segmentation()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
caim &lt;- read_caim() %&gt;% normalize()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
seg &lt;- polar_qtree(caim, z, a)
plot(seg)
plot(extract_feature(caim$Blue, seg))

## End(Not run)
</code></pre>


</div>