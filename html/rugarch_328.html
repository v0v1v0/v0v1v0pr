<div class="container">

<table style="width: 100%;"><tr>
<td>ugarchroll-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>function: Univariate GARCH Rolling Density Forecast and Backtesting</h2>

<h3>Description</h3>

<p>Method for creating rolling density forecast from ARMA-GARCH models with option
for refitting every n periods with parallel functionality.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ugarchroll(spec, data, n.ahead = 1, forecast.length = 500, 
n.start = NULL, refit.every = 25, refit.window = c("recursive", "moving"), 
window.size = NULL, solver = "hybrid", fit.control = list(), 
solver.control = list(), calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.05), 
cluster = NULL, keep.coef = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>

<p>A univariate GARCH specification object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A univariate dataset, ideally with time based index.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.ahead</code></td>
<td>

<p>The number of periods to forecast (only n.ahead=1 supported).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forecast.length</code></td>
<td>

<p>The length of the total forecast for which out of sample data 
from the dataset will be used for testing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.start</code></td>
<td>

<p>Instead of forecast.length, this determines the starting point in the dataset
from which to initialize the rolling forecast.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit.every</code></td>
<td>

<p>Determines every how many periods the model is re-estimated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refit.window</code></td>
<td>

<p>Whether the refit is done on an expanding window including all the previous data 
or a moving window where all previous data is used for the first estimation 
and then moved by a length equal to refit.every (unless the window.size option 
is used instead).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window.size</code></td>
<td>

<p>If not NULL, determines the size of the moving window in the rolling estimation,
which also determines the first point used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>

<p>The solver to use.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.control</code></td>
<td>

<p>Control parameters parameters passed to the fitting function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.control</code></td>
<td>

<p>Control parameters passed to the solver.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calculate.VaR</code></td>
<td>

<p>Whether to calculate forecast Value at Risk during the estimation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VaR.alpha</code></td>
<td>

<p>The Value at Risk tail level to calculate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation
of the refits (remember to stop the cluster on completion).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.coef</code></td>
<td>

<p>Whether to return the list of coefficients and their robust standard errors.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> In the case of the realized GARCH (realGARCH) model, the ‘realizedVol’ is
required (an xts object), and optionally the ‘n.sim’ argument indicates the samples
to generate for the realized vol forecast (does not affect the 1-ahead sigma forecast).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a wrapper function for creating rolling forecasts of the conditional
GARCH density, and optionally calculating the Value at Risk at specified levels.
The argument <code>refit.every</code> determines every how many periods the model is
re-estimated. Given a dataset of length N, it is possible to choose either
how many periods from the end to use for out of sample forecasting (using the
forecast.length option), or the starting point for initializing the rolling
forecast (and using all the data after that for the out of sample forecast).
Only rolling 1-ahead forecasts are supported spanning the dataset, which should
be useful for backtesting models. Anything more complicated should be wrapped by 
the user by making use of the underlying functions in the package.
The function has 2 main methods for viewing the data, a standard plot method and
a report methods (see class <code>uGARCHroll</code> for details on 
how to use these methods).
In case of no-convergence in some of all the windows, a new method called 
<code>resume</code> now allows to pass the returned (non-converged) object with
new solver and control parameters to be re-estimated (only the non-converged
windows are re-estimated). Non-convergence here implies both a failure of the
solver to converge to a solution (global failure) OR a failure to invert the 
resulting Hessian (local failure). The <code>convergence</code> method can be used
on an object (aside from the printed warning) to print out the number of the
non-converged estimation windows.<br>
Parallel functionality is now based entirely on the parallel package, and it is
up to the user to pass a cluster object, and then stop it once the routine is
completed.
</p>


<h3>Value</h3>

<p>An object of class <code>uGARCHroll</code>.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For specification <code>ugarchspec</code>, fitting <code>ugarchfit</code>, 
filtering <code>ugarchfilter</code>, forecasting <code>ugarchforecast</code>, 
simulation <code>ugarchsim</code>, parameter distribution and uncertainty 
<code>ugarchdistribution</code>, bootstrap forecast <code>ugarchboot</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(sp500ret)
spec = ugarchspec(distribution.model = "std")
mod = ugarchroll(spec, data = sp500ret, n.ahead = 1, 
n.start = 1000,  refit.every = 500, refit.window = "recursive", 
solver = "hybrid", fit.control = list(),
calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.025, 0.05),
keep.coef = TRUE)
report(mod, type="VaR", VaR.alpha = 0.01, conf.level = 0.95) 
report(mod, type="fpm")

## End(Not run)</code></pre>


</div>