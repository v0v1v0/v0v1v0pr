<div class="container">

<table style="width: 100%;"><tr>
<td>ootb_sky_reconstruction</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Out-of-the-box sky reconstruction</h2>

<h3>Description</h3>

<p>Build an above canopy image from a single below canopy image
</p>


<h3>Usage</h3>

<pre><code class="language-R">ootb_sky_reconstruction(
  r,
  z,
  a,
  bin,
  filling_source = NULL,
  dist_to_plant = 3,
  sun_coord = NULL,
  general_sky_type = NULL,
  twilight = TRUE,
  rmse = TRUE,
  method = "BFGS",
  try_grids = TRUE,
  thin_points = TRUE,
  refine_sun_coord = TRUE,
  try_optims = TRUE,
  force_sampling = TRUE,
  interpolate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>SpatRaster. A normalized greyscale image. Typically, the
blue channel extracted from a canopy photograph. Please see <code>read_caim()</code>
and <code>normalize()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>SpatRaster built with <code>zenith_image()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>SpatRaster built with <code>azimuth_image()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bin</code></td>
<td>
<p>SpatRaster. This should be a preliminary binarization of
<code>r</code> useful for masking pixels that are very likely pure sky pixels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filling_source</code></td>
<td>
<p>SpatRaster. An actual or reconstructed
above-canopy image to complement the sky pixels detected through the gaps
of <code>r</code>. A photograph taken immediately after or before taking <code>r</code> under the
open sky with the same equipment and configuration is a very good option
but not recommended under fleeting clouds. The orientation relative to the
North must be the same as for <code>r</code>. If it is set to <code>NULL</code> (default), only
sky pixels from <code>r</code> will be used as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_to_plant</code></td>
<td>
<p>Numeric vector of length one or <code>NULL</code>. See
<code>extract_sky_points()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sun_coord</code></td>
<td>
<p>An object of class <em>list</em>. The result of a call to
<code>extract_sun_coord()</code> or an object with same structure and names. See also
<code>row_col_from_zenith_azimuth()</code> in case you want to provide values based on
date and time of acquisition and the <code>suncalc</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>general_sky_type</code></td>
<td>
<p>Character vector of length one. It could be any of
these: "Overcast", "Clear", or "Partly cloudy". See Table 1 from
Li et al. (2016) for additional details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>twilight</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code> and the initial
standard parameters belong to the "Clear" general sky type, sun zenith
angles from 90 to 96 degrees will be tested (civic twilight). This is
necessary since <code>extract_sun_coord()</code> would mistakenly recognize the center
of what can be seen of the solar corona as the solar disk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmse</code></td>
<td>
<p>Logical vector of length one. If it is <code>TRUE</code>, the criteria for
selecting the best sky model is to choose the one with the lowest <strong>root
mean square error (RMSE)</strong> calculated by using the <code>sky_points</code> argument as
the source of reference values. Otherwise, the criteria is to evaluate the
whole image by calculating the <strong>out-of-range index</strong> as <code class="reqn">\sum_{i =
  1}^{N}(r_i/sky_i)^2</code>, where <code class="reqn">r</code> is the <code>r</code> argument, <code class="reqn">sky</code> is the
raster obtained from the fitted model with <code>cie_sky_model_raster()</code> and
<code>zenith_dn</code>, <code class="reqn">i</code> is the index that represents the position of a given
pixel on the raster grid, and <code class="reqn">N</code> is the total number of pixels that
satisfy either of these inequalities: <code class="reqn">r_i/sky_i&lt;0</code> and
<code class="reqn">r_i/sky_i&gt;1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Optimization method to use. See <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>try_grids</code></td>
<td>
<p>Logical vector of length one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin_points</code></td>
<td>
<p>Logical vector of length one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine_sun_coord</code></td>
<td>
<p>Logical vector of length one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>try_optims</code></td>
<td>
<p>Logical vector of length one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_sampling</code></td>
<td>
<p>Logical vector of length one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>
<p>Logical vector of length one. If <code>TRUE</code>,
<code>interpolate_sky_points()</code> will be used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is a hard-coded version of a pipeline that uses these main
functions <code>fit_cie_sky_model()</code> and <code>interpolate_sky_points()</code>.
</p>
<p>The pipeline is an automatic version of the
Lang et al. (2010) method.
</p>
<p>Providing a <code style="white-space: pre;">⁠filling source⁠</code> triggers an alternative pipeline in which the
sky is fully reconstructed with <code>interpolate_sky_points()</code> after a dense
sampling (<code class="reqn">1 \times 1</code> degree cells), which is supported by the fact that
sky digital numbers will be available for every pixel, either from <code>r</code> gaps
or from the filling source.
</p>


<h3>Value</h3>

<p>If a filling source is not provided, the result is an object from the
class <em>list</em> that includes the following: (1) the reconstructed sky
(SpatRaster), (2) the output produced by <code>fit_cie_sky_model()</code>, (3)
the out-of-range index (see <code>fit_cie_sky_model()</code>), (4) sky points that
were not involved in obtaining (2), (5) an object from the class <code>lm</code> (see
<code>stats::lm()</code>) that is the result of validating (1) with (4) and the method
recommended by Piñeiro et al. (2008), and (6) a
binarized image produced with (1), the coefficients from (4) and
<code>thr_mblt()</code> with <code>apply_thr()</code>, using 'w=0.95'. If a filling source is
provided, only a reconstructed sky (SpatRaster) is returned.
</p>


<h3>References</h3>

<p>Lang M, Kuusk A, M~ottus M, Rautiainen M, Nilson T (2010).
“Canopy gap fraction estimation from digital hemispherical images using sky radiance models and a linear conversion method.”
<em>Agricultural and Forest Meteorology</em>, <b>150</b>(1), 20–29.
<a href="https://doi.org/10.1016/j.agrformet.2009.08.001">doi:10.1016/j.agrformet.2009.08.001</a>.<br><br> Li DH, Lou S, Lam JC, Wu RH (2016).
“Determining solar irradiance on inclined planes from classified CIE (International Commission on Illumination) standard skies.”
<em>Energy</em>, <b>101</b>, 462–470.
<a href="https://doi.org/10.1016/j.energy.2016.02.054">doi:10.1016/j.energy.2016.02.054</a>.<br><br> Piñeiro G, Perelman S, Guerschman JP, Paruelo JM (2008).
“How to evaluate models: Observed vs. predicted or predicted vs. observed?”
<em>Ecological Modelling</em>, <b>216</b>(3-4), 316–322.
<a href="https://doi.org/10.1016/j.ecolmodel.2008.05.006">doi:10.1016/j.ecolmodel.2008.05.006</a>.
</p>


<h3>See Also</h3>

<p>Other Sky Reconstruction Functions: 
<code>cie_sky_model_raster()</code>,
<code>fit_cie_sky_model()</code>,
<code>fit_coneshaped_model()</code>,
<code>fit_trend_surface()</code>,
<code>fix_reconstructed_sky()</code>,
<code>interpolate_sky_points()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
caim &lt;- read_caim()
z &lt;- zenith_image(ncol(caim), lens())
a &lt;- azimuth_image(z)
m &lt;- !is.na(z)

m &lt;- !is.na(z)
mn &lt;- quantile(caim$Blue[m], 0.01)
mx &lt;- quantile(caim$Blue[m], 0.99)
r &lt;- normalize(caim$Blue, mn, mx, TRUE)

bin &lt;- find_sky_pixels(r, z, a)
bin &lt;- ootb_mblt(r, z, a, bin)
plot(bin$bin)

mx &lt;- optim_normalize(caim, m)

r &lt;- normalize(caim$Blue)
caim &lt;- normalize(caim, mx = mx, force_range = TRUE)

bin &lt;- ootb_obia(caim, z, a, m, HSV(239, 0.85, 0.5), gamma = NULL)
plot(bin)
bin &lt;- ootb_mblt(r, z, a, bin)$bin
plot(bin)

set.seed(7)
sky &lt;- ootb_sky_reconstruction(r, z, a, bin)

sky$sky
sky$validation %&gt;% summary()
plot(sky$sky)
plot(r/sky$sky)
hist(r/sky$sky, xlim = c(0, 2), breaks = 255)
hist((r/sky$sky)[bin], xlim = c(0, 2), breaks = 255)
plot((r/sky$sky)&gt;1.1)

plot(sky$bin)

sky2 &lt;- ootb_sky_reconstruction(r, z, a, sky$bin, sky$sky)
plot(sky2)
plot(r/sky2)
hist(r/sky2, xlim = c(0, 2), breaks = 255)
hist((r/sky2)[sky$bin], xlim = c(0, 2), breaks = 255)
plot((r/sky2)&gt;1.1)

## End(Not run)
</code></pre>


</div>