<div class="container">

<table style="width: 100%;"><tr>
<td>bake</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a trained preprocessing recipe</h2>

<h3>Description</h3>

<p>For a recipe with at least one preprocessing operation that has been trained by
<code>prep()</code>, apply the computations to new data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bake(object, ...)

## S3 method for class 'recipe'
bake(object, new_data, ..., composition = "tibble")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A trained object such as a <code>recipe()</code> with at least
one preprocessing operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One or more selector functions to choose which variables will be
returned by the function. See <code>selections()</code> for more details.
If no selectors are given, the default is to use
<code>dplyr::everything()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_data</code></td>
<td>
<p>A data frame or tibble for whom the preprocessing will be
applied. If <code>NULL</code> is given to <code>new_data</code>, the pre-processed <em>training
data</em> will be returned (assuming that <code>prep(retain = TRUE)</code> was used).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>composition</code></td>
<td>
<p>Either "tibble", "matrix", "data.frame", or
"dgCMatrix" for the format of the processed data set. Note that
all computations during the baking process are done in a
non-sparse format. Also, note that this argument should be
called <strong>after</strong> any selectors and the selectors should only
resolve to numeric columns (otherwise an error is thrown).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>bake()</code> takes a trained recipe and applies its operations to a
data set to create a design matrix. If you are using a recipe as a
preprocessor for modeling, we <strong>highly recommend</strong> that you use a <code>workflow()</code>
instead of manually applying a recipe (see the example in <code>recipe()</code>).
</p>
<p>If the data set is not too large, time can be saved by using the
<code>retain = TRUE</code> option of <code>prep()</code>. This stores the processed version of the
training set. With this option set, <code>bake(object, new_data = NULL)</code>
will return it for free.
</p>
<p>Also, any steps with <code>skip = TRUE</code> will not be applied to the
data when <code>bake()</code> is invoked with a data set in <code>new_data</code>.
<code>bake(object, new_data = NULL)</code> will always have all of the steps applied.
</p>


<h3>Value</h3>

<p>A tibble, matrix, or sparse matrix that may have different
columns than the original columns in <code>new_data</code>.
</p>


<h3>See Also</h3>

<p><code>recipe()</code>, <code>prep()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(ames, package = "modeldata")

ames &lt;- mutate(ames, Sale_Price = log10(Sale_Price))

ames_rec &lt;-
  recipe(Sale_Price ~ ., data = ames[-(1:6), ]) %&gt;%
  step_other(Neighborhood, threshold = 0.05) %&gt;%
  step_dummy(all_nominal()) %&gt;%
  step_interact(~ starts_with("Central_Air"):Year_Built) %&gt;%
  step_ns(Longitude, Latitude, deg_free = 2) %&gt;%
  step_zv(all_predictors()) %&gt;%
  prep()

# return the training set (already embedded in ames_rec)
bake(ames_rec, new_data = NULL)

# apply processing to other data:
bake(ames_rec, new_data = head(ames))

# only return selected variables:
bake(ames_rec, new_data = head(ames), all_numeric_predictors())
bake(ames_rec, new_data = head(ames), starts_with(c("Longitude", "Latitude")))

</code></pre>


</div>