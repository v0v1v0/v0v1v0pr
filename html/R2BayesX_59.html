<div class="container">

<table style="width: 100%;"><tr>
<td>plot2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
2D Effect Plot 
</h2>

<h3>Description</h3>

<p>Function to plot simple 2D graphics for univariate effects/functions, typically used for objects 
of class <code>"linear.bayesx"</code> and <code>"sm.bayesx"</code> returned from function <code>bayesx</code> 
and <code>read.bayesx.output</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot2d(x, residuals = FALSE, rug = TRUE, jitter = TRUE, 
  col.residuals = NULL, col.lines = NULL, col.polygons = NULL, 
  col.rug = NULL, c.select = NULL, fill.select = NULL, 
  data = NULL, sep = "", month = NULL, year = NULL,
  step = 12, shift = NULL, trans = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix or data frame, containing the covariate for which the effect should be plotted 
in the first column and at least a second column containing the effect, typically the structure 
for univariate functions returned within <code>bayesx</code> and 
<code>read.bayesx.output</code> model term objects is used, also see 
<code>fitted.bayesx</code>. Another possibility is to specify the plot via a <code>formula</code>, 
e.g. <code>y ~ x</code>, also see the example. <code>x</code> may also be a character file path to the
data to be used for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>if set to <code>TRUE</code>, partial residuals may also be plotted if available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>
<p>add a <code>rug</code> to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p>if set to <code>TRUE</code> a <code>jitter</code>ed 
<code>rug</code> plot is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.residuals</code></td>
<td>
<p>the color of the partial residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.lines</code></td>
<td>
<p>the color of the lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.polygons</code></td>
<td>
<p>specify the background color of polygons, if <code>x</code> has at least 3 columns, 
i.e. column 2 and 3 can form one polygon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.rug</code></td>
<td>
<p>specify the color of the rug representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p><code>integer</code> vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. Note that
first element of <code>c.select</code> should always be the column that holds the variable for the
x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill.select</code></td>
<td>
<p><code>integer</code> vector, select pairwise the columns of the resulting data matrix 
that should form one polygon with a certain background color specified in argument <code>col</code>. 
E.g. <code>x</code> has three columns, or is specified with formula <code>f1 + f2 ~ x</code>, then setting 
<code>fill.select = c(0, 1, 1)</code> will draw a polygon with <code>f1</code> and <code>f2</code> as boundaries. 
If <code>x</code> has five columns or the formula is e.g. <code>f1 + f2 + f3 + f4 ~ x</code>, then setting
<code>fill.select = c(0, 1, 1, 2, 2)</code>, the pairs <code>f1</code>, <code>f2</code> and <code>f3</code>, <code>f4</code>
are selected to form two polygons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>if <code>x</code> is a formula, a <code>data.frame</code> or <code>list</code>. By default the variables 
are taken from <code>environment(x)</code>: typically the environment from which <code>plot2d</code> is 
called. Note that <code>data</code> may also be a character file path to the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>the field separator character when <code>x</code> or <code>data</code> is a character, see function
<code>read.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>month, year, step</code></td>
<td>
<p>provide specific annotation for plotting estimation results for temporal
variables. <code>month</code> and <code>year</code> define the minimum time point whereas step specifies the
type of temporal data with <code>step = 4</code>, <code>step = 2</code> and <code>step = 1</code> corresponding to
quartely, half yearly and yearly data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>numeric. Constant to be added to the smooth before plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other graphical parameters, please see the details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For 2D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: specify the size of partial residuals,
</p>
</li>
<li> <p><code>lty</code>: the line type for each column that is plotted, e.g. <code>lty = c(1, 2)</code>,
</p>
</li>
<li> <p><code>lwd</code>: the line width for each column that is plotted, e.g. <code>lwd = c(1, 2)</code>,
</p>
</li>
<li> <p><code>poly.lty</code>: the line type to be used for the polygons,
</p>
</li>
<li> <p><code>poly.lwd</code>: the line width to be used for the polygons,
</p>
</li>
<li> <p><code>density</code> <code>angle</code>, <code>border</code>: see <code>polygon</code>,
</p>
</li>
<li> <p><code>...</code>: other graphical parameters, see function <code>plot</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code>plot.bayesx</code>, <code>bayesx</code>, <code>read.bayesx.output</code>,
<code>fitted.bayesx</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate some data
set.seed(111)
n &lt;- 500
## regressor
dat &lt;- data.frame(x = runif(n,-3,3))

##  response 
dat$y &lt;- with(dat, 10 + sin(x) + rnorm(n,sd=0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(x), data = dat)
summary(b)

## plot estimated effect
plot(b, which = 1)
plot(b, which = 1, rug = FALSE)

## extract fitted effects
f &lt;- fitted(b, term = "sx(x)")

## now use plot2d
plot2d(f)
plot2d(f, residuals = TRUE)
plot2d(f, residuals = TRUE, pch = 2, col.resid = "green3")
plot2d(f, col.poly = NA, lwd = 1, lty = 1)
plot2d(f, col.poly = NA, lwd = 1, lty = 1, col.lines = 4)
plot2d(f, col.poly = c(2, 3), lwd = 1, col.lines = 4, lty = 1)
plot2d(f, lwd = c(1, 3, 2, 2, 3), col.poly = NA, lty = 1)
plot2d(f, lwd = c(1, 3, 2, 2, 3), col.poly = NA, lty = 1, col.lines = 2:6)
plot2d(f, lwd = c(1, 3, 2, 2, 3), col.poly = NA, lty = 1, col.lines = 2:6,
  resid = TRUE, pch = 4, col.resid = 7)

## End(Not run)

## another variation
plot2d(sin(x) ~ x, data = dat)
dat$f &lt;- with(dat, sin(dat$x))
plot2d(f ~ x, data = dat)
dat$f1 &lt;- with(dat, f + 0.1)
dat$f2 &lt;- with(dat, f - 0.1)
plot2d(f1 + f2 ~ x, data = dat)
plot2d(f1 + f2 ~ x, data = dat, fill.select = c(0, 1, 1), lty = 0)
plot2d(f1 + f2 ~ x, data = dat, fill.select = c(0, 1, 1), lty = 0,
  density = 20, poly.lty = 1, poly.lwd = 2)
plot2d(f1 + f + f2 ~ x, data = dat, fill.select = c(0, 1, 0, 1), 
  lty = c(0, 1, 0), density = 20, poly.lty = 1, poly.lwd = 2)
</code></pre>


</div>