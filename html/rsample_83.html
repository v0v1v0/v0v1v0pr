<div class="container">

<table style="width: 100%;"><tr>
<td>rset_reconstruct</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extending rsample with new rset subclasses</h2>

<h3>Description</h3>

<p><code>rset_reconstruct()</code> encapsulates the logic for allowing new rset
subclasses to work properly with vctrs (through <code>vctrs::vec_restore()</code>) and
dplyr (through <code>dplyr::dplyr_reconstruct()</code>). It is intended to be a
developer tool, and is not required for normal usage of rsample.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rset_reconstruct(x, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A data frame to restore to an rset subclass.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>An rset subclass to restore to.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>rset objects are considered "reconstructable" after a vctrs/dplyr operation
if:
</p>

<ul>
<li> <p><code>x</code> and <code>to</code> both have an identical column named <code>"splits"</code> (column
and row order do not matter).
</p>
</li>
<li> <p><code>x</code> and <code>to</code> both have identical columns prefixed with <code>"id"</code> (column
and row order do not matter).
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>x</code> restored to the rset subclass of <code>to</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">to &lt;- bootstraps(mtcars, times = 25)

# Imitate a vctrs/dplyr operation,
# where the class might be lost along the way
x &lt;- tibble::as_tibble(to)

# Say we added a new column to `x`. Here we mock a `mutate()`.
x$foo &lt;- "bar"

# This is still reconstructable to `to`
rset_reconstruct(x, to)

# Say we lose the first row
x &lt;- x[-1, ]

# This is no longer reconstructable to `to`, as `x` is no longer an rset
# bootstraps object with 25 bootstraps if one is lost!
rset_reconstruct(x, to)
</code></pre>


</div>