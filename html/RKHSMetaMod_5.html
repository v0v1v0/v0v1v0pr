<div class="container">

<table style="width: 100%;"><tr>
<td>pen_MetMod</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to fit a solution of the RKHS Ridge Group Sparse problem.
</h2>

<h3>Description</h3>

<p>Fits the solution of the RKHS ridge group sparse optimization problem for the Gaussian regression model.</p>


<h3>Usage</h3>

<pre><code class="language-R">pen_MetMod(Y, Kv, gamma, mu, resg, gama_v, mu_v, maxIter, verbose, calcStwo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Vector of response observations of size <code class="reqn">n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kv</code></td>
<td>
<p>List, includes the eigenvalues and eigenvectors of the positive definite Gram matrices <code class="reqn">K_v, v=1,...,</code>vMax and their associated group names. It should have the same format as the output of the function <code>calc_Kv</code> (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Vector of positive scalars. Values of the penalty parameter <code class="reqn">\gamma</code> in decreasing order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Vector of positive scalars. Values of the penalty parameter <code class="reqn">\mu</code> in decreasing order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resg</code></td>
<td>
<p>List of initial parameters, includes the <code>RKHSgrplasso</code> objects for each value of the penalty parameter <code class="reqn">\mu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gama_v</code></td>
<td>
<p>Scalar zero or vector of vMax positive scalars, considered as weights for the Ridge penalty. Set to zero, to consider no weights, i.e. all weights equal to <code class="reqn">1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu_v</code></td>
<td>
<p>Scalar zero or a vector with vMax scalars, considered as weigths of Sparse Group penalty. Set to zero, to consider no weights, i.e. all weights equal to <code class="reqn">1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>Integer, shows the maximum number of loops through initial active groups at the first step and maximum number of loops through all groups at the second step. Set as <code class="reqn">1000</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical, if TRUE, for each pair of penalty parameters <code class="reqn">(\mu,\gamma)</code> it prints: the number of current iteration, active groups and convergence criterias. Set as FALSE by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calcStwo</code></td>
<td>
<p>Logical, if TRUE, the program does a second step after convergence: the algorithm is done over all groups by taking the estimated parameters at the first step as initial values. Set as FALSE by default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Input Kv should contain the eigenvalues and eigenvectors of positive definite Gram matrices <code class="reqn">K_v</code>. It is necessary to set input "correction" in the function <code>calc_Kv</code> equal to "TRUE".
</p>


<h3>Value</h3>

<p>List of l components, with l equals to the number of pairs of the penalty parameters <code class="reqn">(\mu,\gamma)</code>. Each component of the list is a list of <code class="reqn">3</code> components "mu", "gamma" and "Meta-Model":
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Positive scalar, an element of the input vector mu associated with the estimated Meta-Model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Positive scalar, an element of the input vector gamma associated with the estimated Meta-Model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Meta-Model</code></td>
<td>
<p>Estimated meta model associated with penalty parameters mu and gamma. List of <code class="reqn">16</code> components:</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Scalar, estimated value of intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teta</code></td>
<td>
<p>Matrix with vMax rows and <code class="reqn">n</code> columns. Each row of the matrix is the estimated vector <code class="reqn">\theta_{v}</code> for <code class="reqn">v=1,...,</code>vMax.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.v</code></td>
<td>
<p>Matrix with <code class="reqn">n</code> rows and vMax columns. Each row of the matrix is the estimated value of <code class="reqn">f_{v}=K_{v}\theta_{v}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>Vector of size <code class="reqn">n</code>, indicates the estimator of <code class="reqn">m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Norm.n</code></td>
<td>
<p>Vector of size vMax, estimated values for the Ridge penalty norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Norm.H</code></td>
<td>
<p>Vector of size vMax, estimated values for the Group Sparse penalty norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>supp</code></td>
<td>
<p>Vector of active groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsupp</code></td>
<td>
<p>Vector of the names of the active groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SCR</code></td>
<td>
<p>Scalar equals to <code class="reqn">\Vert Y-f_{0}-\sum_{v}K_{v}\theta_{v}\Vert ^{2}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>Scalar indicates the value of the penalized criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.v</code></td>
<td>
<p>Vector of size vMax, coefficients of the Ridge penalty norm, <code class="reqn">\sqrt{n}\gamma\times</code>gama_v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.v</code></td>
<td>
<p>Vector of size vMax, coefficients of the Group Sparse penalty norm, <code class="reqn">n\mu\times</code>mu_v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>List of three components if calcStwo<code class="reqn">=</code>TRUE <code class="reqn">(</code>two components if calcStwo<code class="reqn">=</code>FALSE<code class="reqn">)</code>: maxIter, number of iterations until convergence is reached at first step and the number of iterations until convergence is reached at second step <code class="reqn">(</code>maxIter, and the number of iterations until convergence is reached at first step<code class="reqn">)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>TRUE or FALSE. Indicates whether the algorithm has converged or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RelDiffCrit</code></td>
<td>
<p>List of two components if calcStwo<code class="reqn">=</code>TRUE <code class="reqn">(</code>one component if calcStwo<code class="reqn">=</code>FALSE<code class="reqn">)</code>: value of convergence criteria at the last iteration of each step, <code class="reqn">\Vert\frac{\theta_{lastIter}-\theta_{lastIter-1}}{\theta_{lastIter-1}}\Vert ^{2}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RelDiffPar</code></td>
<td>
<p>List of two components if calcStwo<code class="reqn">=</code>TRUE (one component if calcStwo<code class="reqn">=</code>FALSE): value of convergence criteria at the last iteration, <code class="reqn">\frac{crit_{lastIter}-crit_{lastIter-1}}{crit_{lastIter-1}}</code> of each step.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Note.
</p>


<h3>Author(s)</h3>

<p>Halaleh Kamari
</p>


<h3>References</h3>

<p>Huet, S. and Taupin, M. L. (2017) Metamodel construction for sensitivity analysis. ESAIM:
Procs 60, 27-69.
</p>
<p>Kamari, H., Huet, S. and Taupin, M.-L. (2019) RKHSMetaMod : An R package to estimate the Hoeffding decomposition of an unknown function by solving RKHS Ridge Group Sparse optimization problem. &lt;arXiv:1905.13695&gt;
</p>


<h3>See Also</h3>

<p><code>calc_Kv</code>, <code>RKHSgrplasso</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">d &lt;- 3
n &lt;- 50
library(lhs)
X &lt;- maximinLHS(n, d)
c &lt;- c(0.2,0.6,0.8)
F &lt;- 1;for (a in 1:d) F &lt;- F*(abs(4*X[,a]-2)+c[a])/(1+c[a])
epsilon &lt;- rnorm(n,0,1);sigma &lt;- 0.2
Y &lt;- F + sigma*epsilon
Dmax &lt;- 3
kernel &lt;- "matern"
Kv &lt;- calc_Kv(X, kernel, Dmax, TRUE,TRUE, tol = 1e-08)
vMax &lt;- length(Kv$names.Grp)
matZ &lt;- Kv$kv
mumax &lt;- mu_max(Y, matZ)
mug1 &lt;- mumax/10
mug2 &lt;- mumax/100
gr1 &lt;- RKHSgrplasso(Y,Kv, mug1)
gr2 &lt;- RKHSgrplasso(Y,Kv, mug2)
gamma &lt;- c(.5,.01,.001)
#rescaling the penalty parameter
mu &lt;- c(mug1/sqrt(n),mug2/sqrt(n))
resg &lt;- list(gr1,gr2)
res &lt;- pen_MetMod(Y,Kv,gamma,mu,resg,0,0)
l &lt;- length(res)
for(i in 1:l){print(res[[i]]$mu)}
for(i in 1:l){print(res[[i]]$gamma)}
for(i in 1:l){print(res[[i]]$`Meta-Model`$Nsupp)}
gama_v &lt;- rep(1,vMax)
mu_v &lt;- rep(1,vMax)
res.w &lt;- pen_MetMod(Y,Kv,gamma,mu,resg,gama_v,mu_v)
for(i in 1:l){print(res.w[[i]]$`Meta-Model`$Nsupp)}
</code></pre>


</div>