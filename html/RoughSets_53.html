<div class="container">

<table style="width: 100%;"><tr>
<td>RI.GFRS.FRST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized fuzzy rough set rule induction based on FRST</h2>

<h3>Description</h3>

<p>It is a function generating rules in classification tasks using the fuzzy variable precision rough sets (FVPRS) approach (see <code>BC.LU.approximation.FRST</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">RI.GFRS.FRST(decision.table, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decision.table</code></td>
<td>
<p>a <code>"DecisionTable"</code> class representing the decision table. See <code>SF.asDecisionTable</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of other parameters which consist of
</p>

<ul>
<li> <p><code>alpha.precision</code>: a numeric value representing variable precision of FVPRS.
The default value is 0.05. See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>type.aggregation</code>: a list of a type of aggregations. The default value is <code>type.aggregation = c("t.tnorm", "lukasiewicz")</code>.
</p>
<p>See <code>BC.IND.relation.FRST</code>.
</p>
</li>
<li> <p><code>type.relation</code>: a type of indiscernibility relation. The default value is <code>type.relation = c("tolerance", "eq.1")</code>.
See <code>BC.IND.relation.FRST</code>.
</p>
</li>
<li> <p><code>t.implicator</code>: a type of implication function. The default value is <code>"lukasiewicz"</code>.
See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The method proposed by (Zhao, 2010) consists of three steps as follows.
First, it builds a general lower approximation that is able to deal with misclassification and perturbation.
In this case, the fuzzy variable precision rough sets (FVPRS)
is used to calculate the lower approximation (see <code>BC.LU.approximation.FRST</code>).
Secondly, a discernibility matrix considering a consistence degree is constructed for obtaining rules.
The details about the matrix can be seen in <code>BC.discernibility.mat.FRST</code>.
Then, we calculate attribute value reduction of every object and perform near-minimal rule set.
The final step is to construct rules considering the consistence degree of associated objects.
</p>
<p>It should be noted that this function only allows classification problems. After obtaining the rules,
predicting can be done by calling <code>predict</code> or <code>predict.RuleSetFRST</code>.
Additionally, to get better representation we can execute <code>summary</code>.
</p>


<h3>Value</h3>

<p>A class <code>"RuleSetFRST"</code> which has following components:
</p>

<ul>
<li> <p><code>rules</code>: It is a list containing two elements which are <code>rules</code> and <code>threshold</code>.
The <code>rules</code> represent knowledge in data set that can be expressed as an IF-THEN form.
For example, we got the rule as follows: <code>90 8 2</code> and its colnames: <code>pres</code>, <code>preg</code>, and <code>class</code>.
It refers to the following rule: <code>IF pres is about 90 and preg is about 8 THEN class is 2</code>.
In other words, while the last column represents the consequent part,
the rest expresses the antecedent part.
The second part of this object is <code>threshold</code> representing a value used to predict new data.
In order to change IF-THEN form, we can use <code>summary</code>.
</p>
</li>
<li> <p><code>type.model</code>: It is the type of the theory whether <code>"FRST"</code> or <code>"RST"</code>. In this case, it is <code>FRST</code>.
</p>
</li>
<li> <p><code>type.method</code>: It is the considered method. In this case, it is <code>RI.GFRS.FRST</code>.
</p>
</li>
<li> <p><code>type.task</code>: It is the type of task. In this case, it is <code>"classification"</code>.
</p>
</li>
<li> <p><code>t.similariy</code>: It is the type of similarity equation. See <code>BC.IND.relation.FRST</code>.
</p>
</li>
<li> <p><code>t.tnorm</code>: It is the type of triangular operator. See <code>BC.IND.relation.FRST</code>.
</p>
</li>
<li> <p><code>variance.data</code>: It represents the variance of the data set. It has <code>NA</code> values when the associated attributes are nominal values.
</p>
</li>
<li> <p><code>range.data</code>: It represents the range of the data set. It has <code>NA</code> values when the associated attributes are nominal values.
</p>
</li>
<li> <p><code>antecedent.attr</code>: It is a list of attribute names involved in the antecedent part.
</p>
</li>
<li> <p><code>consequent.attr</code>: It is the attribute in the consequent part.
</p>
</li>
<li> <p><code>nominal.att</code>: It is a list of boolean that represent whether a attribute is nominal or not.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Lala Septem Riza
</p>


<h3>References</h3>

<p>S. Y. Zhao, E. C. C. Tsang, D. G. Chen, and X. Z. Wang, "Building a Rule-based
Classifier â€“ A Fuzzy-rough Set Approach",
IEEE Trans. on Knowledge and Data Engineering, vol. 22, no. 5, p. 624 - 638 (2010).
</p>


<h3>See Also</h3>

<p><code>RI.indiscernibilityBasedRules.RST</code>, <code>predict.RuleSetFRST</code>, and <code>RI.hybridFS.FRST</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">###########################################################
## Example
##############################################################
data(RoughSetData)
decision.table &lt;- RoughSetData$pima7.dt

control &lt;- list(alpha.precision = 0.01, type.aggregation = c("t.tnorm", "lukasiewicz"),
                type.relation = c("tolerance", "eq.3"), t.implicator = "lukasiewicz")
rules &lt;- RI.GFRS.FRST(decision.table, control)

</code></pre>


</div>