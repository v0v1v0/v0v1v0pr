<div class="container">

<table style="width: 100%;"><tr>
<td>model.average.list</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute model averaged estimates of real parameters from a list structure
for estimates</h2>

<h3>Description</h3>

<p>A generic function to compute model averaged estimates and their standard
errors or variance-covariance matrix
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'list'
model.average(x, revised=TRUE, mata=FALSE, normal.lm=FALSE, 
                                       residual.dfs=0, alpha=0.025,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a list containing the following elements: 1) <code>estimate</code> - a
vector or matrix of estimates, 2)a vector of model selection criterion value
named <code>AIC,AICc,QAIC,QAICc</code> or a <code>weight</code> variable that sums to 1
across models, and 3) a vector or matrix named <code>se</code> which give the
model-specific standard errors for each estimate or a list of matrices named
<code>vcv</code> which give the model-specific variance-covariance matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>revised</code></td>
<td>
<p>if TRUE it uses eq 6.12 from Burnham and Anderson (2002) for
model averaged se; otherwise it uses eq 4.9</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mata</code></td>
<td>
<p>if TRUE, create model averaged tail area confidence intervals as described by Turek and Fletcher</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normal.lm</code></td>
<td>
<p>Specify normal.lm=TRUE for the normal linear model case, and 
normal.lm=FALSE otherwise.  When normal.lm=TRUE, the argument 
'residual.dfs' must also be supplied.  See USAGE section, 
and Turek and Fletcher (2012) for additional details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residual.dfs</code></td>
<td>
<p>A vector containing the residual (error) degrees of freedom 
under each candidate model.  This argument must be provided 
when the argument normal.lm=TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The desired lower and upper error rate.  Specifying alpha=0.025
corresponds to a 95
alpha=0.05 to a 90
Default value is alpha=0.025.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to specific functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a single estimate is being model-averaged then <code>estimate</code> and
<code>se</code> are vectors with an entry for each model.  However, if there are
several estimates being averaged then both <code>estimate</code> and <code>se</code>
should be matrices in which the estimates for each model are a row in the
matrix.  Regardless, if <code>vcv</code> is specified it should be a list of
matrices and in the case of a single estimate, each matrix is 1x1 containing
the estimated sample-variance but that would be rather useless and <code>se</code>
should be used instead.
</p>
<p>If the list contains an element named <code>AIC</code>,<code>AICc</code>,<code>QAIC</code>, or
<code>QAICc</code>, then the minimum value is computed and subtracted to compute
delta values relative to the minimum. These are then converted to Akaike
weights which are <code>exp(-.5*delta)</code> and these are normalized to sum to
1.  If the list does not contain one of the above values then it should have
a variable named <code>weight</code>.  It is normalized to 1.  The model-averaged
estimates are computed using equation 4.1 of Burnham and Anderson (2002).
</p>
<p>If the contains a matrix named <code>vcv</code>, then a model-averaged
variance-covariance matrix is computed using formulae given on page 163 of
Burnham and Anderson (2002).  If there is no element named <code>vcv</code> then
there must be an element <code>se</code> which contains the model-specific
estimates of the standard errors.  The unconditional standard error for the
model-averaged estimates is computed using equation 4.9 of Burnham and
Anderson (2002) if if <code>revised=FALSE</code>; otherwise it uses eq 6.12.
</p>


<h3>Value</h3>

<p>A list containing elements: </p>
<table>
<tr style="vertical-align: top;">
<td><code>estimate</code></td>
<td>
<p>vector of model-averaged
estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>vector of unconditional standard errors (square root of
unconditional variance estimator)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcv</code></td>
<td>
<p>model-averaged
variance-covariance matrix if <code>vcv</code> was specified input list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lcl</code></td>
<td>
<p>lower confidence interval if mata=TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ucl</code></td>
<td>
<p>upper confidence interval if mata=TRUE</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>References</h3>

<p>BURNHAM, K. P., AND D. R. ANDERSON. 2002. Model selection and
multimodel inference. A practical information-theoretic approach. Springer,
New York.
Turek, D. and Fletcher, D. (2012). Model-Averaged Wald Confidence Intervals. Computational Statistics and Data Analysis, 56(9), p.2809-2815.
</p>


<h3>See Also</h3>

<p><code>model.average.marklist</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# This example is excluded from testing to reduce package check time
# Create a set of models from dipper data
data(dipper)
run.dipper=function()
{
dipper$nsex=as.numeric(dipper$sex)-1
mod1=mark(dipper,groups="sex",
   model.parameters=list(Phi=list(formula=~sex)),delete=TRUE)
mod2=mark(dipper,groups="sex",
   model.parameters=list(Phi=list(formula=~1)),delete=TRUE)
mod3=mark(dipper,groups="sex",
   model.parameters=list(p=list(formula=~time),
   Phi=list(formula=~1)),delete=TRUE)
dipper.list=collect.models()
return(dipper.list)
}
dipper.results=run.dipper()
# Extract indices for first year survival from 
#  Females (group 1) and Males (group 2)
Phi.indices=extract.indices(dipper.results[[1]],
   "Phi",df=data.frame(group=c(1,2),row=c(1,1),col=c(1,1)))
# Create a matrix for estimates
estimate=matrix(0,ncol=length(Phi.indices),
    nrow=nrow(dipper.results$model.table))
# Extract weights for models
weight=dipper.results$model.table$weight
# Create an empty list for vcv matrices
vcv=vector("list",length=nrow(dipper.results$model.table))
# Loop over each model in model.table for dipper.results
for (i in 1:nrow(dipper.results$model.table))
{
# The actual model number is the row number for the model.table
  model.numbers= as.numeric(row.names(dipper.results$model.table))
# For each model extract those real parameter values and their
# vcv matrix and store them
  x=covariate.predictions(dipper.results[[model.numbers[i]]],
      data=data.frame(index=Phi.indices))
  estimate[i,]=x$estimates$estimate
  vcv[[i]]=x$vcv
}
# Call model.average using the list structure which includes 
#  estimate, weight and vcv list in this case
model.average(list(estimate=estimate,weight=weight,vcv=vcv))
#
# Now get same model averaged estimates using model.average.marklist
# Obviously this is a much easier approach and what would be used 
# if all you are doing is model averaging real parameters in the model.  
# The other form is more useful for model averaging
# functions of estimates of the real parameters (eg population estimate)
#
mavg=model.average(dipper.results,"Phi",vcv=TRUE)
print(mavg$estimates[Phi.indices,])
print(mavg$vcv.real[Phi.indices,Phi.indices])


</code></pre>


</div>