<div class="container">

<table style="width: 100%;"><tr>
<td>rid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Randomized interpolative decomposition (ID).</h2>

<h3>Description</h3>

<p>Randomized interpolative decomposition.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rid(A, k = NULL, mode = "column", p = 10, q = 0, idx_only = FALSE, rand = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>array_like; <br>
numeric <code class="reqn">(m, n)</code> input matrix (or data frame). <br>
If the data contain <code class="reqn">NA</code>s na.omit is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer, optional; <br>
number of rows/columns to be selected. 
It is required that <code class="reqn">k</code> is smaller or equal to <code class="reqn">min(m,n)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>string c('column', 'row'), optional; <br>
columns or rows ID.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer, optional; <br>
oversampling parameter (default <code class="reqn">p=10</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>integer, optional. <br>
number of additional power iterations (default <code class="reqn">q=0</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx_only</code></td>
<td>
<p>bool, optional; <br>
if (<code class="reqn">TRUE</code>), the index set <code>idx</code> is returned, but not the matrix <code>C</code> or <code>R</code>. 
This is more memory efficient, when dealing with large-scale data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand</code></td>
<td>
<p>bool, optional; <br>
if (<code class="reqn">TRUE</code>), a probabilistic strategy is used, otherwise a deterministic algorithm is used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Algorithm for computing the ID of a rectangular <code class="reqn">(m, n)</code> matrix <code class="reqn">A</code>, with target rank 
<code class="reqn">k &lt;&lt; min(m,n)</code>. The input matrix is factored as 
</p>
<p style="text-align: center;"><code class="reqn">A = C * Z</code>
</p>
 
<p>using the column pivoted QR decomposition. The factor matrix <code class="reqn">C</code> is formed as a subset of 
columns of <code class="reqn">A</code>, also called the partial column skeleton. 
If <code>mode='row'</code>, then the input matrix is factored as 
</p>
<p style="text-align: center;"><code class="reqn">A = Z * R</code>
</p>
 
<p>using the row pivoted QR decomposition. The factor matrix <code class="reqn">R</code> is now formed as
a subset of rows of <code class="reqn">A</code>, also called the partial row skeleton. 
The factor matrix <code class="reqn">Z</code> contains a <code class="reqn">(k, k)</code> identity matrix as a submatrix, 
and is well-conditioned. 
</p>
<p>If <code class="reqn">rand='TRUE'</code> a probabilistic strategy is used to compute the decomposition, otherwise a
deterministic algorithm is used.
</p>


<h3>Value</h3>

<p><code>rid</code> returns a list containing the following components:
</p>

<dl>
<dt>C</dt>
<dd>
<p> array_like; <br>
column subset <code class="reqn">C = A[,idx]</code>, if <code>mode='column'</code>; array with dimensions <code class="reqn">(m, k)</code>.
</p>
</dd>
<dt>R</dt>
<dd>
<p> array_like; <br>
row subset <code class="reqn">R = A[idx, ]</code>, if <code>mode='row'</code>; array with dimensions <code class="reqn">(k, n)</code>.
</p>
</dd>
<dt>Z</dt>
<dd>
<p> array_like; <br>
well conditioned matrix; Depending on the selected mode, this is an 
array with dimensions <code class="reqn">(k,n)</code> or <code class="reqn">(m,k)</code>.
</p>
</dd>
<dt>idx</dt>
<dd>
<p> array_like; <br>
index set of the <code class="reqn">k</code> selected columns or rows used to form <code class="reqn">C</code> or <code class="reqn">R</code>. 
</p>
</dd>   
<dt>pivot</dt>
<dd>
<p> array_like; <br>
information on the pivoting strategy used during the decomposition. 
</p>
</dd>  
<dt>scores</dt>
<dd>
<p> array_like; <br>
scores of the columns or rows of the input matrix <code class="reqn">A</code>.
</p>
</dd> 
<dt>scores.idx</dt>
<dd>
<p> array_like; <br>
scores of the <code class="reqn">k</code> selected columns or rows in <code class="reqn">C</code> or <code class="reqn">R</code>.                    
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>N. Benjamin Erichson, <a href="mailto:erichson@uw.edu">erichson@uw.edu</a>
</p>


<h3>References</h3>


<ul>
<li>
<p>  [1] N. Halko, P. Martinsson, and J. Tropp.
"Finding structure with randomness: probabilistic
algorithms for constructing approximate matrix
decompositions" (2009).
(available at arXiv <a href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a>).
</p>
</li>
<li>
<p> [2] N. B. Erichson, S. Voronin, S. L. Brunton and J. N. Kutz. 2019.
Randomized Matrix Decompositions Using R. 
Journal of Statistical Software, 89(11), 1-48.
doi: <a href="https://doi.org/10.18637/jss.v089.i11">10.18637/jss.v089.i11</a>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>rcur</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Load test image
data("tiger")

# Compute (column) randomized interpolative decompsition
# Note that the image needs to be transposed for correct plotting
out &lt;- rid(t(tiger), k = 150)

# Show selected columns 
tiger.partial &lt;- matrix(0, 1200, 1600)
tiger.partial[,out$idx] &lt;- t(tiger)[,out$idx]
image(t(tiger.partial), col = gray((0:255)/255), useRaster = TRUE)

# Reconstruct image
tiger.re &lt;- t(out$C %*% out$Z)

# Compute relative error
print(norm(tiger-tiger.re, 'F') / norm(tiger, 'F')) 

# Plot approximated image
image(tiger.re, col = gray((0:255)/255))

## End(Not run)
</code></pre>


</div>