<div class="container">

<table style="width: 100%;"><tr>
<td>base_pref_macros</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Useful Base Preference Macros</h2>

<h3>Description</h3>

<p>In addition to the base preferences, 
rPref offers some macros to define preferences where a given interval or point is preferred.
</p>


<h3>Usage</h3>

<pre><code class="language-R">around(expr, center, df = NULL)

between(expr, left, right, df = NULL)

pos(expr, pos_value, df = NULL)

layered(expr, ..., df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>A numerical expression (for <code>around</code> and <code>between</code>)
or an arbitrary expression (for <code>pos</code> and <code>layered</code>).
The objective are those tuples where <code>expr</code> evaluates to a value within the preferred interval, layer, etc. 
Regarding attributes, functions and variables, the same requirements as for <code>base_pref</code> apply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>Preferred numerical value for <code>around</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>(optional) Data frame for partial evaluation and association of preference and data set.
See <code>base_pref</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left</code></td>
<td>
<p>Lower limit (numerical) of the preferred interval for <code>between</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p>Upper limit (numerical) of the preferred interval for <code>between</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos_value</code></td>
<td>
<p>A vector containing the preferred values for a <code>pos</code> preference.
It has to be of the same type (numeric, logical, character, ...) as <code>expr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Layers (sets) for a <code>layered</code> preference. Each parameter corresponds to a layer 
and the first one characterizes the most preferred values.</p>
</td>
</tr>
</table>
<h3>Definition of the Preference Macros</h3>


<dl>
<dt><code>between(expr, left, right)</code></dt>
<dd>
<p>Those tuples are preferred where <code>expr</code> evaluates
to a value between <code>left</code> and <code>right</code>.
For values not in this interval, the values nearest to the interval are preferred.</p>
</dd>
<dt><code>around(expr, center)</code></dt>
<dd>
<p>Same as <code>between(expr, center, center)</code>.</p>
</dd>
<dt><code>pos(expr, pos_value)</code></dt>
<dd>
<p>Those tuples are preferred, where <code>expr</code> evaluates 
to a value which is contained in <code>pos_value</code>.</p>
</dd>
<dt><code>layered(expr, layer1, layer2, ..., layerN)</code></dt>
<dd>
<p>For the most preferred tuples <code>expr</code>
must evaluate to a value in <code>layer1</code>. 
The second-best tuples are those where <code>expr</code> evaluates to a value in <code>layer2</code> and so forth. 
Values occurring in none of the layers are considered worse than those in <code>layerN</code>.
Technically, this is realized by a prioritization chain (lexicographical order)
of <code>true</code> preferences.</p>
</dd>
</dl>
<p>Note that only the argument <code>expr</code> may contain columns from the data frame, 
all other variables must evaluate to explicit values. 
For example <code>around(mpg, mean(mpg))</code> is not allowed. In this case, one can use 
<code>around(mpg, mean(mtcars$mpg))</code> instead. Or alternatively, without using the base preference macros, 
<code>low(abs(mpg - mean(mpg)))</code> does the same. There, the actual mean value of <code>mpg</code> is calculated 
just when the preference selection via <code>psel</code> is called.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Search for cars where mpg is near to 25.
psel(mtcars, around(mpg, 25))

# Consider cyl = 2 and cyl = 4 as equally good, while cyl = 6 is worse.
psel(mtcars, layered(cyl, c(2, 4), 6))
</code></pre>


</div>