<div class="container">

<table style="width: 100%;"><tr>
<td>plotCalibration</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot Calibration curve</h2>

<h3>Description</h3>

<p>Plot Calibration curves for risk prediction models
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotCalibration(
  x,
  models,
  times,
  method = "nne",
  cens.method,
  round = TRUE,
  bandwidth = NULL,
  q = 10,
  bars = FALSE,
  hanging = FALSE,
  names = "quantiles",
  pseudo = FALSE,
  rug,
  show.frequencies = FALSE,
  plot = TRUE,
  add = FALSE,
  diag = !add,
  legend = !add,
  auc.in.legend,
  brier.in.legend,
  axes = !add,
  xlim = c(0, 1),
  ylim = c(0, 1),
  xlab = ifelse(bars, "Risk groups", "Predicted risk"),
  ylab,
  col,
  lwd,
  lty,
  pch,
  type,
  percent = TRUE,
  na.action = na.fail,
  cex = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object obtained with function <code>Score</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>Choice of models to plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Time point specifying the prediction horizon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method for estimating the calibration curve(s):
</p>

<ul>
<li> <p><code>"quantile"</code>: The observed proportion at predicted risk value 'p'
is obtained in groups
defined by quantiles of the predicted event probabilities of all subjects.
The number of groups is controlled by argument <code>q</code>.
</p>
</li>
<li> <p><code>"nne"</code>: The observed proportion at predicted risk value 'p' is obtained based
on the subjects whose predicted risk is inside a nearest
neighborhood around the value 'p'. The larger the
bandwidth the more subjects are included in the current neighborhood. </p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cens.method</code></td>
<td>
<p>For right censored data only. How observed proportions are calculated. Either <code>"jackknife"</code> or <code>"local"</code>:
</p>

<ul>
<li> <p><code>"jackknife"</code>: Compute a running mean of the jackknife pseudovalues across neighborhoods/groups of the predicted risks.
Here we rely on the
assumption that censoring is independent of the event time and the covariates, see References. 
</p>
</li>
<li> <p><code>"local"</code>: Compute the Kaplan-Meier estimator in absence of competing risks and the Aalen-Johansen estimator in presence of competing risks
locally like a running mean in neighborhoods of the predicted risks. The widths of the neighborhoods
are defined according to method. </p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round</code></td>
<td>
<p>If <code>TRUE</code> predicted probabilities are rounded to
two digits before smoothing. This may have a considerable
effect on computing efficiency in large data sets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>The bandwidth for <code>method="nne"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>The number of quantiles for <code>method="quantile"</code> and
<code>bars=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bars</code></td>
<td>
<p>If <code>TRUE</code>, use barplots to show calibration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hanging</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, hang bars
corresponding to observed frequencies (estimated actual risk)  at the value of the
corresponding prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Barplots only. Names argument passed to
<code>names.arg</code> of <code>barplot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo</code></td>
<td>
<p>If <code>TRUE</code> show pseudo values (only for right
censored data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>
<p>If <code>TRUE</code> show rug plot at the predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.frequencies</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, show
frequencies above the bars.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>If <code>FALSE</code>, do not plot the results, just return
a plottable object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>If <code>TRUE</code> the line(s) are added to an existing
plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>
<p>If <code>FALSE</code> no diagonal line is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> draw legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auc.in.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> add AUC to legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>brier.in.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> add Brier score to
legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>
<p>If <code>FALSE</code> no axes are drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>Limits of x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>Limits of y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab</code></td>
<td>
<p>Label for y-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab</code></td>
<td>
<p>Label for x-axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Vector with colors, one for each element of
object. Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>Vector with line widths, one for each element of
object. Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>lwd Vector with line style, one for each element of
object.  Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch</code></td>
<td>
<p>Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Passed to <code>lines</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percent</code></td>
<td>
<p>If TRUE axes labels are multiplied by 100 and thus
interpretable on a percent scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>what to do with NA values. Passed to
<code>model.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p>Default cex used for legend and labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Used to control the subroutines: plot, axis, lines,
barplot, legend, addtable2plot, points (pseudo values), rug. See
<code>SmartControl</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In uncensored data, the observed frequency of the outcome event is calculated locally at the predicted risk.
In right censored data with and without competing risks, the actual risk
is calculated using the Kaplan-Meier and the Aalen-Johansen method, respectively,
locally at the predicted risk.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(prodlim)
# binary
set.seed(10)
db=sampleData(100,outcome="binary")
fb1=glm(Y~X1+X5+X7,data=db,family="binomial")
fb2=glm(Y~X1+X3+X6+X7,data=db,family="binomial")
xb=Score(list(model1=fb1,model2=fb2),Y~1,data=db,
          plots="cal")
plotCalibration(xb,brier.in.legend=TRUE)
plotCalibration(xb,bars=TRUE,model="model1")
plotCalibration(xb,models=1,bars=TRUE,names.cex=1.3)

# survival
library(survival)
library(prodlim)
dslearn=sampleData(56,outcome="survival")
dstest=sampleData(100,outcome="survival")
fs1=coxph(Surv(time,event)~X1+X5+X7,data=dslearn,x=1)
fs2=coxph(Surv(time,event)~strata(X1)+X3+X6+X7,data=dslearn,x=1)
xs=Score(list(Cox1=fs1,Cox2=fs2),Surv(time,event)~1,data=dstest,
          plots="cal",metrics=NULL)
plotCalibration(xs)
plotCalibration(xs,cens.method="local",pseudo=1)
plotCalibration(xs,method="quantile")


# competing risks

## Not run: 
data(Melanoma)
f1 &lt;- CSC(Hist(time,status)~age+sex+epicel+ulcer,data=Melanoma)
f2 &lt;- CSC(Hist(time,status)~age+sex+logthick+epicel+ulcer,data=Melanoma)
x &lt;- Score(list(model1=f1,model2=f2),Hist(time,status)~1,data=Melanoma,
           cause= 2,times=5*365.25,plots="cal")
plotCalibration(x)

## End(Not run)

</code></pre>


</div>