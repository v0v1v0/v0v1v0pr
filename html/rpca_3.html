<div class="container">

<table style="width: 100%;"><tr>
<td>rpca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Decompose a matrix into a low-rank component and a sparse component by solving Principal Components Pursuit
</h2>

<h3>Description</h3>

<p>This function decomposes a rectangular matrix <var>M</var> into a low-rank component, and a sparse component, by solving a convex program called Principal Component Pursuit.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rpca(M, 
     lambda = 1/sqrt(max(dim(M))), mu = prod(dim(M))/(4 * sum(abs(M))), 
     term.delta = 10^(-7), max.iter = 5000, trace = FALSE,
     thresh.nuclear.fun = thresh.nuclear, thresh.l1.fun = thresh.l1, 
     F2norm.fun = F2norm)




</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p> a rectangular matrix that is to be decomposed into a low-rank component and a sparse component
<code class="reqn">M = L + S</code> .
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>parameter of the convex problem <code class="reqn">\|L\|_{*} + \lambda \|S\|_{1} </code>
which is minimized in the Principal Components Pursuit algorithm. 
The default value is the one suggested in Candès, E. J., section 1.4, 
and together with reasonable assumptions about <var>L</var> and <var>S</var> 
guarantees that a correct decomposition is obtained.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>

<p>parameter from the augumented Lagrange multiplier formulation of the PCP, Candès, E. J., section 5. 
Default value is the one suggested in references.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>term.delta</code></td>
<td>

<p>The algorithm terminates when <code class="reqn">\|M-L-S\|_{F} \leq \delta \|M\|_{F}</code> 
where <code class="reqn">\|\ \|_{F}</code> is Frobenius norm of a matrix. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>

<p>Maximal number of iterations of the augumented Lagrange multiplier algorithm. 
A warning is issued if the algorithm does not converge by then.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>Print out information with every iteration. 
</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>thresh.nuclear.fun, thresh.l1.fun, F2norm.fun</code></td>
<td>

<p>Arguments for internal use only.
</p>
</td>
</tr></table>
<h3>Details</h3>

<p>These functions decompose a rectangular matrix <var>M</var> into a low-rank component, and a sparse component, by solving a convex program called Principal Component Pursuit:
</p>
<p style="text-align: center;"><code class="reqn"> \textrm{minimize}\quad   \|L\|_{*} + \lambda \|S\|_{1} </code>
</p>
                                                                    
<p style="text-align: center;"><code class="reqn"> \textrm{subject to}\quad   L+S = M </code>
</p>

<p>where <code class="reqn">\|L\|_{*}</code> is the nuclear norm of <var>L</var> (sum of singular values).
</p>


<h3>Value</h3>

<p>The function returns two matrices <code>S</code> and <code>L</code>, which have the property that 
<code class="reqn">L+S \simeq M</code>, where the quality of the approximation depends on the argument <code>term.delta</code>,
and the convergence of the algorithm.


</p>
<table>
<tr style="vertical-align: top;">
<td><code>S </code></td>
<td>
<p>The sparse component of the matrix decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L </code></td>
<td>
<p>The low-rank component of the matrix decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L.svd</code></td>
<td>
<p>The singular value decomposition of <code>L</code>, as returned by the function <code>La.svd</code> .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence$converged</code></td>
<td>
<p><code>TRUE</code> if the algorithm converged with respect to <code>term.delta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence$iterations</code></td>
<td>
<p>Number of performed iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence$final.delta</code></td>
<td>
<p>The final iteration <code>delta</code> which is compared with <code>term.delta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence$all.delta</code></td>
<td>
<p>All <code>delta</code> from all iterations.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Maciek Sykulski [aut, cre]
</p>


<h3>References</h3>

<p>Candès, E. J., Li, X., Ma, Y., &amp; Wright, J. (2011). Robust principal component analysis?. Journal of the ACM (JACM), 58(3), 11.
</p>
<p>Yuan, X., &amp; Yang, J. (2009). Sparse and low-rank matrix decomposition via alternating direction methods. preprint, 12.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(iris)
M &lt;- as.matrix(iris[,1:4])
Mcent &lt;- sweep(M,2,colMeans(M))

res &lt;- rpca(Mcent)

## Check convergence and number of iterations
with(res$convergence,list(converged,iterations))
## Final delta F2 norm divided by F2norm(Mcent)
with(res$convergence,final.delta)

## Check properites of the decomposition
with(res,c(
all(abs( L+S - Mcent ) &lt; 10^-5),
all( L == L.svd$u%*%(L.svd$d*L.svd$vt) )
))
# [1] TRUE TRUE

## The low rank component has rank 2
length(res$L.svd$d)
## However, the sparse component is not sparse 
## - thus this data set is not the best example here.
mean(res$S==0)

## Plot the first (the only) two principal components
## of the low-rank component L
rpc&lt;-res$L.svd$u%*%diag(res$L.svd$d)
plot(jitter(rpc[,1:2],amount=.001),col=iris[,5])

## Compare with classical principal components
pc &lt;- prcomp(M,center=TRUE)
plot(pc$x[,1:2],col=iris[,5])
points(rpc[,1:2],col=iris[,5],pch="+")

## "Sparse" elements distribution
plot(density(abs(res$S),from=0))
curve(dexp(x,rate=1/mean(abs(res$S))),add=TRUE,lty=2)

## Plot measurements against measurements corrected by sparse components
par(mfcol=c(2,2))
for(i in 1:4) {
plot(M[,i],M[,i]-res$S[,i],col=iris[,5],xlab=colnames(M)[i])
}
</code></pre>


</div>