<div class="container">

<table style="width: 100%;"><tr>
<td>calibrate_lens</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calibrate lens</h2>

<h3>Description</h3>

<p>Calibrate a fisheye lens
</p>


<h3>Usage</h3>

<pre><code class="language-R">calibrate_lens(path_to_csv, degree = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>path_to_csv</code></td>
<td>
<p>Character vector. Path to a CSV file created with the
<a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool of ‘ImageJ’ software</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>Numeric vector of length one. Polynomial model degree.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Fisheye lenses have a wide field of view and the same distortion in all
directions running orthogonally to the optical axis. The latter property
allows fitting a precise mathematical relationship between distances to the
zenith on the image space and zenith angles on the hemispherical space
(assuming upward-looking hemispherical photography with the optical axis
vertically aligned).
</p>
<p>The method
outlined here, known as the simple method, is explained in details in
Díaz and et al. (2024). Next explanation might serve mostly
as a handbook.
</p>


<h4>Step-by-step guide for producing a CSV file to feed this function</h4>



<h5>Materials</h5>


<ul>
<li>
<p> this package and <a href="https://imagej.net/ij/download.html">ImageJ</a>
</p>
</li>
<li>
<p> camera and lens
</p>
</li>
<li>
<p> tripod
</p>
</li>
<li>
<p> standard yoga mat
</p>
</li>
<li>
<p> table at least as wide as the yoga mat width
</p>
</li>
<li>
<p> twenty two push pins of different colors
</p>
</li>
<li>
<p> one print of this <a href="https://osf.io/tudzc">sheet</a> (A1 size,
almost like a research poster).
</p>
</li>
<li>
<p> scissors
</p>
</li>
<li>
<p> some patience
</p>
</li>
</ul>
<h5>Instructions</h5>

<p>Cut the sheet by the dashed line. Place the yoga mat extended on top of the
table. Place the sheet on top of the yoga mat. Align the dashed line with the
yoga mat border closest to you. Place push pins on each cross. If you are
gentle, the yoga mat will allow you to do that without damaging the table. Of
course, other materials could be used to obtain the same result, such as
cardboard, foam, nails, etc.
</p>
<p><img src="../help/figures/calibrationBoard.jpg" alt="Calibration board"></p>
<p>Place the camera on the tripod. Align its optical axis with the table while
looking for getting an image showing the overlapping of the three pairs of
push pins, as instructed in the print. In order to take care of the line of
pins at 90º relative to the optical axis, it may be of help to use the naked
eye to align the entrance pupil of the lens with the pins. The alignment of
the push pins only guarantees the position of the lens entrance pupil, the
leveling should be cheeked with an instrument, and the alignment between the
optical axis and the radius of the zenith push pin should be taken into
account. In practice, the latter is achieved by aligning the camera body with
the orthogonal frame made by the quarter circle.
</p>
<p>Take a photo and transfer it to the computer, open it with ImageJ, and use
the <a href="https://imagej.net/ij/docs/guide/146-19.html#sec:Multi-point-Tool">point selection tool</a>
to digitize the push pins, starting from the zenith push pin and not skipping
any shown push pin. End with an additional point where the image meets the
surrounding black (or the last pixel in case there is not blackness because
it is not a circular hemispherical image. There is no need to follow the line
formed by the push pins). Then, use the dropdown menu Analyze&gt;Measure to open
the window Results. To obtain the CSV, use File&gt;Save As...
</p>
<p><img src="../help/figures/pushpinsImageJ.jpg" alt="Points digitization with ImageJ"></p>
<p>Use <code>test_lens_coef()</code> to test if coefficients are OK.
</p>




<h3>Value</h3>

<p>An object of class <em>list</em> with named elements. <em>ds</em> is the dataset
used to fit the model, <em>model</em> is the fitted model (class <code>lm</code>, see
<code>stats::lm()</code>), <em>horizon_radius</em> is the radius at 90º, <em>lens_coef</em> is a
numeric vector of length equal to the <code>degree</code> argument containing the
polynomial model coefficients for predicting relative radius
(<code>coefficients(model)/horizon_radius</code>),
<em>zenith_colrow</em> are the raster coordinates of the zenith push pin,
<em>max_theta</em> is the maximum zenith angle in degrees, and <em>max_theta_px</em> is
the distance in pixels between the zenith and the maximum zenith angle in
pixels units.
</p>


<h3>Note</h3>

<p>If we imagine the fisheye image as an analog clock, it is possible to
calibrate 3 o'clock by attaching the camera to the tripod in landscape mode
while leaving the quarter-circle at the lens's right side. To calibrate 9
o'clock, it will be necessary to rotate the camera to put the quarter-circle
at the lens's left side. To calibrate 12 and 6 o'clock, it will be necessary
to do the same but with the camera in portrait mode. If several directions
are sampled with this procedure, a character vector of length greater than
one in which each element is a path to a CSV files could be provided as the
<code>path_to_csv</code> argument.
</p>


<h3>References</h3>

<p>Díaz GM, et al. (2024).
“Simple calibration of fisheye lenses for hemipherical photography of the forest canopy.”
<em>Manuscript in preparation</em>.
</p>


<h3>See Also</h3>

<p>Other Lens Functions: 
<code>azimuth_image()</code>,
<code>calc_diameter()</code>,
<code>calc_relative_radius()</code>,
<code>calc_zenith_colrow()</code>,
<code>crosscalibrate_lens()</code>,
<code>expand_noncircular()</code>,
<code>extract_radiometry()</code>,
<code>fisheye_to_equidistant()</code>,
<code>fisheye_to_pano()</code>,
<code>lens()</code>,
<code>test_lens_coef()</code>,
<code>zenith_image()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">path &lt;- system.file("external/Results_calibration.csv", package = "rcaiman")
calibration &lt;- calibrate_lens(path)
coefficients(calibration$model)
calibration$lens_coef %&gt;% signif(3)
calibration$horizon_radius

## Not run: 
test_lens_coef(calibration$lens_coef) #MacOS and Windows tend to differ here
test_lens_coef(c(0.628, 0.0399, -0.0217))

## End(Not run)

.fp &lt;- function(theta, lens_coef) {
  x &lt;- lens_coef[1:5]
  x[is.na(x)] &lt;- 0
  for (i in 1:5) assign(letters[i], x[i])
  a * theta + b * theta^2 + c * theta^3 + d * theta^4 + e * theta^5
}

plot(calibration$ds)
theta &lt;- seq(0, pi/2, pi/180)
lines(theta, .fp(theta, coefficients(calibration$model)))
</code></pre>


</div>