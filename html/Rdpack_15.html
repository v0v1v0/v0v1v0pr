<div class="container">

<table style="width: 100%;"><tr>
<td>deparse_usage</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert f_usage objects to text appropriate for usage sections in
Rd files

</h2>

<h3>Description</h3>

<p>Converts f_usage objects to text appropriate for usage sections in
Rd files. Handles S3 methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">deparse_usage(x)
deparse_usage1(x, width = 72)
## S3 method for class 'f_usage'
as.character(x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>an object from class <code>"f_usage"</code>. For <code>deparse_usage</code>,
<code>x</code> can also be a list of <code>"f_usage"</code> objects.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width</code></td>
<td>
<p>maximal width of text on a line.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Both, <code>deparse_usage1</code> and the <code>as.character</code> method for
class <code>"f_usage"</code>, convert an <code>"f_usage"</code> object to a
character string suitable for Rd documentation. The
<code>as.character</code> method is the user level function (it just calls
<code>deparse_usage1</code>), <code>deparse_usage1</code> is internal function for
programming. In the example below the first command creates an
<code>"f_usage"</code> object, then the second converts it to character string.
</p>
<pre>(a &lt;- pairlist2f_usage1(formals(cor), "cor"))
##: name      = cor 
##: S3class   =  
##: S4sig     =  
##: infix     = FALSE 
##: fu        = TRUE 
##: argnames  = x y use method 
##: defaults  : y = NULL 
##:             use = "everything" 
##:             method = c("pearson", "kendall", "spearman") 

cat(as.character(a))
##: cor(x, y = NULL, use = "everything", 
##:     method = c("pearson", "kendall", "spearman"))
</pre>
  
<p>Each usage entriy is formatted and, if necessary, split over several
lines. The width (number of characters) on a line can be changed with
argument <code>width</code>.
</p>
<p><code>deparse_usage</code> can be used when <code>x</code> is a list of
<code>"f_usage"</code> objects. It calls <code>deparse_usage1</code> with each of
them and returns a character vector with one element for each
component of <code>x</code>.  When <code>x</code> is an object from class
<code>"f_usage"</code>, <code>deparse_usage</code> is equivalent to
<code>deparse_usage1</code>.
</p>


<h3>Value</h3>

<p>For <code>deparse_usage1</code> and <code>as.character.f_usage</code>, a named
character vector of length one (the name is the function name).
</p>
<p>For <code>deparse_usage</code>, a named character vector with one entry for
the usage text for each function.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code>pairlist2f_usage1</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">cur_wd &lt;- getwd()
tmpdir &lt;- tempdir()
setwd(tmpdir)

## prepare a list of "f_usage" objects
fnseq &lt;- reprompt(seq)            # get and save the help page of "seq"
rdoseq &lt;- tools::parse_Rd(fnseq)  # parse the Rd file
ut &lt;- get_usage_text(rdoseq)      # get the contents of the usage section
cat(ut, "\n")                     #     of seq() (a character string)
utp &lt;- parse_usage_text(ut)       # parse to a list of "f_usage" objects

## deparse the "f_usage" list - each statement gets a separate string
cat(deparse_usage(utp), sep = "\n")

## explore some of the usage entries individually;
## the generic seq() has a boring signature
utp[[1]]
as.character(utp[[1]])
deparse_usage1(utp[[1]])  # same

## the default S3 method is more interesting
utp[[2]]
cat(deparse_usage1(utp[[2]]))
cat(as.character(utp[[2]]))   # same

unlink(fnseq)
setwd(cur_wd)
unlink(tmpdir)
</code></pre>


</div>