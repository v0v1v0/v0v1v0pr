<div class="container">

<table style="width: 100%;"><tr>
<td>DecisionTree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A decision tree</h2>

<h3>Description</h3>

<p>An R6 class to represent a decision tree model.
</p>


<h3>Details</h3>

<p>A class to represent a decision tree. An object contains a tree of
decision nodes, chance nodes and leaf nodes, connected by edges
(either actions or reactions). It inherits from class <code>Arborescence</code> and
satisfies the following conditions:
</p>

<ol>
<li>
<p>Nodes and edges must form a tree with a single root and
there must be a unique path from the root to each node.
In graph theory terminology, the directed graph formed by the nodes
and edges must be an <dfn>arborescence</dfn>.
</p>
</li>
<li>
<p>Each node must inherit from one of <code>DecisionNode</code>,
<code>ChanceNode</code> or <code>LeafNode</code>. Formally the set of vertices
must be a disjoint union of sets of decision nodes, chance nodes
and leaf nodes.
</p>
</li>
<li>
<p>All and only leaf nodes must have no children.
</p>
</li>
<li>
<p>Each edge must inherit from either <code>Action</code> or
<code>Reaction</code>.
</p>
</li>
<li>
<p>All and only edges that have source endpoints joined to
decision nodes must inherit from <code>Action</code>.
</p>
</li>
<li>
<p>All and only edges that have source endpoints joined to
chance nodes must inherit from <code>Reaction</code>.
</p>
</li>
<li>
<p>The sum of probabilities of each set of reaction edges
with a common source endpoint must be 1.
</p>
</li>
<li>
<p>Each <code>DecisionNode</code> must have a label, and the labels of all
<code>DecisionNodes</code> must be unique within the model.
</p>
</li>
<li>
<p>Each <code>Action</code> must have a label, and the labels of
<code>Action</code>s that share a common source endpoint must be unique.
</p>
</li>
</ol>
<h3>Super classes</h3>

<p><code>rdecision::Graph</code> -&gt; <code>rdecision::Digraph</code> -&gt; <code>rdecision::Arborescence</code> -&gt; <code>DecisionTree</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DecisionTree-new"><code>DecisionTree$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-decision_nodes"><code>DecisionTree$decision_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-chance_nodes"><code>DecisionTree$chance_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-leaf_nodes"><code>DecisionTree$leaf_nodes()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-actions"><code>DecisionTree$actions()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-modvars"><code>DecisionTree$modvars()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-modvar_table"><code>DecisionTree$modvar_table()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-draw"><code>DecisionTree$draw()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-is_strategy"><code>DecisionTree$is_strategy()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-strategy_table"><code>DecisionTree$strategy_table()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-strategy_paths"><code>DecisionTree$strategy_paths()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-edge_properties"><code>DecisionTree$edge_properties()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-evaluate_walks"><code>DecisionTree$evaluate_walks()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-evaluate"><code>DecisionTree$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-tornado"><code>DecisionTree$tornado()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-threshold"><code>DecisionTree$threshold()</code></a>
</p>
</li>
<li> <p><a href="#method-DecisionTree-clone"><code>DecisionTree$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="degree"><a href="../../rdecision/html/Graph.html#method-Graph-degree"><code>rdecision::Graph$degree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_along"><a href="../../rdecision/html/Graph.html#method-Graph-edge_along"><code>rdecision::Graph$edge_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_at"><a href="../../rdecision/html/Graph.html#method-Graph-edge_at"><code>rdecision::Graph$edge_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_index"><a href="../../rdecision/html/Graph.html#method-Graph-edge_index"><code>rdecision::Graph$edge_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_label"><a href="../../rdecision/html/Graph.html#method-Graph-edge_label"><code>rdecision::Graph$edge_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edges"><a href="../../rdecision/html/Graph.html#method-Graph-edges"><code>rdecision::Graph$edges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="graph_adjacency_matrix"><a href="../../rdecision/html/Graph.html#method-Graph-graph_adjacency_matrix"><code>rdecision::Graph$graph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_edge"><a href="../../rdecision/html/Graph.html#method-Graph-has_edge"><code>rdecision::Graph$has_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_vertex"><a href="../../rdecision/html/Graph.html#method-Graph-has_vertex"><code>rdecision::Graph$has_vertex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="is_simple"><a href="../../rdecision/html/Graph.html#method-Graph-is_simple"><code>rdecision::Graph$is_simple()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="neighbours"><a href="../../rdecision/html/Graph.html#method-Graph-neighbours"><code>rdecision::Graph$neighbours()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="order"><a href="../../rdecision/html/Graph.html#method-Graph-order"><code>rdecision::Graph$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="size"><a href="../../rdecision/html/Graph.html#method-Graph-size"><code>rdecision::Graph$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_along"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_along"><code>rdecision::Graph$vertex_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_at"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_at"><code>rdecision::Graph$vertex_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_index"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_index"><code>rdecision::Graph$vertex_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_label"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_label"><code>rdecision::Graph$vertex_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertexes"><a href="../../rdecision/html/Graph.html#method-Graph-vertexes"><code>rdecision::Graph$vertexes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_source"><a href="../../rdecision/html/Digraph.html#method-Digraph-arrow_source"><code>rdecision::Digraph$arrow_source()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="arrow_target"><a href="../../rdecision/html/Digraph.html#method-Digraph-arrow_target"><code>rdecision::Digraph$arrow_target()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="as_DOT"><a href="../../rdecision/html/Digraph.html#method-Digraph-as_DOT"><code>rdecision::Digraph$as_DOT()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_adjacency_matrix"><a href="../../rdecision/html/Digraph.html#method-Digraph-digraph_adjacency_matrix"><code>rdecision::Digraph$digraph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="digraph_incidence_matrix"><a href="../../rdecision/html/Digraph.html#method-Digraph-digraph_incidence_matrix"><code>rdecision::Digraph$digraph_incidence_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_predecessors"><a href="../../rdecision/html/Digraph.html#method-Digraph-direct_predecessors"><code>rdecision::Digraph$direct_predecessors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="direct_successors"><a href="../../rdecision/html/Digraph.html#method-Digraph-direct_successors"><code>rdecision::Digraph$direct_successors()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_acyclic"><a href="../../rdecision/html/Digraph.html#method-Digraph-is_acyclic"><code>rdecision::Digraph$is_acyclic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_arborescence"><a href="../../rdecision/html/Digraph.html#method-Digraph-is_arborescence"><code>rdecision::Digraph$is_arborescence()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_connected"><a href="../../rdecision/html/Digraph.html#method-Digraph-is_connected"><code>rdecision::Digraph$is_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_polytree"><a href="../../rdecision/html/Digraph.html#method-Digraph-is_polytree"><code>rdecision::Digraph$is_polytree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_tree"><a href="../../rdecision/html/Digraph.html#method-Digraph-is_tree"><code>rdecision::Digraph$is_tree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="is_weakly_connected"><a href="../../rdecision/html/Digraph.html#method-Digraph-is_weakly_connected"><code>rdecision::Digraph$is_weakly_connected()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="paths"><a href="../../rdecision/html/Digraph.html#method-Digraph-paths"><code>rdecision::Digraph$paths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="topological_sort"><a href="../../rdecision/html/Digraph.html#method-Digraph-topological_sort"><code>rdecision::Digraph$topological_sort()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Digraph" data-id="walk"><a href="../../rdecision/html/Digraph.html#method-Digraph-walk"><code>rdecision::Digraph$walk()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="is_leaf"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-is_leaf"><code>rdecision::Arborescence$is_leaf()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="is_parent"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-is_parent"><code>rdecision::Arborescence$is_parent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="is_root"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-is_root"><code>rdecision::Arborescence$is_root()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="parent"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-parent"><code>rdecision::Arborescence$parent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="postree"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-postree"><code>rdecision::Arborescence$postree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="root"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-root"><code>rdecision::Arborescence$root()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="root_to_leaf_paths"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-root_to_leaf_paths"><code>rdecision::Arborescence$root_to_leaf_paths()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Arborescence" data-id="siblings"><a href="../../rdecision/html/Arborescence.html#method-Arborescence-siblings"><code>rdecision::Arborescence$siblings()</code></a></span></li>
</ul></details><hr>
<a id="method-DecisionTree-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new decision tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$new(V, E)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt>
<dd>
<p>A list of nodes.</p>
</dd>
<dt><code>E</code></dt>
<dd>
<p>A list of edges.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The tree must consist of a set of nodes and a set of edges
which satisfy the conditions given in the details section of this class.
In addition, the decision nodes must not be labelled with any of the
words used as the column headings listed in <code>evaluate</code>.
</p>



<h5>Returns</h5>

<p>A <code>DecisionTree</code> object
</p>


<hr>
<a id="method-DecisionTree-decision_nodes"></a>



<h4>Method <code>decision_nodes()</code>
</h4>

<p>Find the decision nodes in the tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$decision_nodes(what = "node")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt>
<dd>
<p>A character string defining what to return. Must be one
of "node", "label" or "index".</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of <code>DecisionNode</code> objects (for what = "node"); a list
of character strings (for what = "label"), or an integer vector with
indexes of the decision nodes (for what = "index").
</p>


<hr>
<a id="method-DecisionTree-chance_nodes"></a>



<h4>Method <code>chance_nodes()</code>
</h4>

<p>Find the chance nodes in the tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$chance_nodes(what = "node")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt>
<dd>
<p>A character string defining what to return. Must be one
of "node", "label" or "index".</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of <code>ChanceNode</code> objects (for what = "node"); a list
of character strings (for what = "label"), or an integer vector with
indexes of the decision nodes (for what = "index").
</p>


<hr>
<a id="method-DecisionTree-leaf_nodes"></a>



<h4>Method <code>leaf_nodes()</code>
</h4>

<p>Find the leaf nodes in the tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$leaf_nodes(what = "node")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt>
<dd>
<p>One of "node" (returns Node objects), "label" (returns the
leaf node labels) or "index" (returns the vertex indexes of the leaf
nodes).</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of <code>LeafNode</code> objects (for what = "node"); a list
of character strings (for what = "label"); or an integer vector of
leaf node indexes (for what = "index").
</p>


<hr>
<a id="method-DecisionTree-actions"></a>



<h4>Method <code>actions()</code>
</h4>

<p>Find the edges that have the specified decision node as
their source.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$actions(d)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>d</code></dt>
<dd>
<p>A decision node.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of <code>Action</code> edges.
</p>


<hr>
<a id="method-DecisionTree-modvars"></a>



<h4>Method <code>modvars()</code>
</h4>

<p>Find all the model variables of type <code>ModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$modvars()</pre></div>



<h5>Details</h5>

<p>Find <code>ModVar</code>s that have been specified as values
associated with the nodes and edges of the tree.
</p>



<h5>Returns</h5>

<p>A list of <code>ModVar</code>s.
</p>


<hr>
<a id="method-DecisionTree-modvar_table"></a>



<h4>Method <code>modvar_table()</code>
</h4>

<p>Tabulate the model variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$modvar_table(expressions = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expressions</code></dt>
<dd>
<p>A logical that defines whether expression model
variables should be included in the tabulation.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Data frame with one row per model variable, as follows:
</p>

<dl>
<dt><code>Description</code></dt>
<dd>
<p>As given at initialization.</p>
</dd>
<dt><code>Units</code></dt>
<dd>
<p>Units of the variable.</p>
</dd>
<dt><code>Distribution</code></dt>
<dd>
<p>Either the uncertainty distribution, if
it is a regular model variable, or the expression used to create it,
if it is an <code>ExprModVar</code>.</p>
</dd>
<dt><code>Mean</code></dt>
<dd>
<p>Mean; calculated from means of operands if
an expression.</p>
</dd>
<dt><code>E</code></dt>
<dd>
<p>Expectation; estimated from random sample if expression,
mean otherwise.</p>
</dd>
<dt><code>SD</code></dt>
<dd>
<p>Standard deviation; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Q2.5</code></dt>
<dd>
<p>p=0.025 quantile; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Q97.5</code></dt>
<dd>
<p>p=0.975 quantile; estimated from random sample if
expression, exact value otherwise.</p>
</dd>
<dt><code>Est</code></dt>
<dd>
<p>TRUE if the quantiles and SD have been estimated by
random sampling.</p>
</dd>
</dl>
<hr>
<a id="method-DecisionTree-draw"></a>



<h4>Method <code>draw()</code>
</h4>

<p>Draw the decision tree to the current graphics output.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$draw(border = FALSE, fontsize = 8)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>border</code></dt>
<dd>
<p>If TRUE draw a light grey border around the plot area.</p>
</dd>
<dt><code>fontsize</code></dt>
<dd>
<p>Font size for labels in point. Symbols for nodes scale
with font size.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Uses the algorithm of Walker (1989) to distribute the nodes
compactly (see the Arborescence class help for details).
</p>



<h5>Returns</h5>

<p>No return value.
</p>


<hr>
<a id="method-DecisionTree-is_strategy"></a>



<h4>Method <code>is_strategy()</code>
</h4>

<p>Tests whether an object is a valid strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$is_strategy(strategy)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>strategy</code></dt>
<dd>
<p>A list of Action edges.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A strategy is a unanimous prescription of an action taken at
each decision node, coded as a list of action edges. This checks
whether the strategy is valid for this decision tree.
</p>



<h5>Returns</h5>

<p>TRUE if the strategy is valid for this tree. Returns
FALSE if the list of Action edges are not a valid strategy.
</p>


<hr>
<a id="method-DecisionTree-strategy_table"></a>



<h4>Method <code>strategy_table()</code>
</h4>

<p>Find all potential strategies for the decision tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$strategy_table(what = "index", select = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt>
<dd>
<p>A character string defining what to return. Must be one
of "label" or "index".</p>
</dd>
<dt><code>select</code></dt>
<dd>
<p>A single strategy (given as a list of action edges, with
one action edge per decision node). If provided, only that strategy
is selected from the returned table. Intended for tabulating a
single strategy into a readable form.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A strategy is a unanimous prescription of the actions at each
decision node. If there are decision nodes that are descendants of other
nodes in the tree, the strategies returned will not necessarily
be unique.
</p>



<h5>Returns</h5>

<p>A data frame where each row is a potential strategy
and each column is a decision node, ordered lexicographically. Values
are either the index of each action edge, or their label. The row names
are the edge labels of each strategy, concatenated with underscores.
</p>


<hr>
<a id="method-DecisionTree-strategy_paths"></a>



<h4>Method <code>strategy_paths()</code>
</h4>

<p>Find all paths walked in each possible strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$strategy_paths()</pre></div>



<h5>Details</h5>

<p>A strategy is a unanimous prescription of an action in each
decision node. Some paths can be walked in more than one strategy, if
there exist paths that do not pass a decision node.
</p>



<h5>Returns</h5>

<p>A data frame, where each row is a path walked in a strategy. The
structure is similar to that returned by <code>strategy_table</code> but
includes an extra column, <code>Leaf</code> which gives the leaf node index of
each path, and there is one row for each path in each strategy.
</p>


<hr>
<a id="method-DecisionTree-edge_properties"></a>



<h4>Method <code>edge_properties()</code>
</h4>

<p>Properties of all actions and reactions as a matrix.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$edge_properties()</pre></div>



<h5>Details</h5>

<p>Gets the properties (probability, cost, benefit) of each
action and reaction in the decision tree in matrix form. If there are
reactions from chance nodes whose conditional probability of
traversal set to NA, the missing values are replaced by one minus
the sum of the conditional probabilities of the other reaction edges
from that node (provided there is no more than one with NA). If the
method is called at evaluation, the replacement of NAs happens after
sampling from model variables.
</p>



<h5>Returns</h5>

<p>A numeric matrix with one row per edge, and with four columns:
the index of the edge, the conditional probability of traversing the
edge, the cost of traversing the edge and the benefit associated with
traversing the edge. The column names are <code>index</code>,
<code>probability</code>, <code>cost</code>, <code>benefit</code> and the row names are
the labels of the edges.
</p>


<hr>
<a id="method-DecisionTree-evaluate_walks"></a>



<h4>Method <code>evaluate_walks()</code>
</h4>

<p>Evaluate the components of pay-off associated with a set of
walks in the decision tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$evaluate_walks(W = NULL, Wi = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>W</code></dt>
<dd>
<p>A list of root-to-leaf walks. A walk is a sequence of edges
(actions and reactions), stored as a list. Each walk must start with an
edge whose source is the root node and end with an edge whose target is
a leaf node. The list of walks is normally the walks associated with all
the root to leaf paths in a tree.</p>
</dd>
<dt><code>Wi</code></dt>
<dd>
<p>As <var>W</var> but with edge indices instead of Edge objects. One
of <var>W</var> and <var>Wi</var> must be NULL. It is more efficient to provide
<var>Wi</var> during PSA, where the paths do not change between cycles, to
avoid repeated conversion of edges to indices.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For each walk, probability, cost, benefit and utility are
calculated. There is minimal checking of the argument because this
function is intended to be called repeatedly during tree evaluation,
including PSA.
</p>



<h5>Returns</h5>

<p>A pay-off table, represented as a matrix of numeric values
with response columns as follows:
</p>

<dl>
<dt><code>Probability</code></dt>
<dd>
<p>The probability of traversing the pathway. </p>
</dd>
<dt><code>Path.Cost</code></dt>
<dd>
<p>The cost of traversing the pathway.</p>
</dd>
<dt><code>Path.Benefit</code></dt>
<dd>
<p>The benefit derived from traversing the
pathway.</p>
</dd>
<dt><code>Path.Utility</code></dt>
<dd>
<p>The utility associated with the outcome (leaf
node).</p>
</dd>
<dt><code>Path.QALY</code></dt>
<dd>
<p>The QALYs associated with the outcome (leaf
node).</p>
</dd>
<dt><code>Cost</code></dt>
<dd>
<p><code>Path.Cost</code> <code class="reqn">*</code> probability of traversing the
pathway.</p>
</dd>
<dt><code>Benefit</code></dt>
<dd>
<p><code>Path.Benefit</code> <code class="reqn">*</code> probability of
traversing the pathway.</p>
</dd>
<dt><code>Utility</code></dt>
<dd>
<p><code>Path.Utility</code> <code class="reqn">*</code> probability of
traversing the pathway.</p>
</dd>
<dt><code>QALY</code></dt>
<dd>
<p><code>Path.QALY</code> <code class="reqn">*</code> probability of traversing the
pathway.</p>
</dd>
</dl>
<p>The matrix has one row per path, with the row label equal to the
character representation of the index of the leaf node at the end of
the path.
</p>


<hr>
<a id="method-DecisionTree-evaluate"></a>



<h4>Method <code>evaluate()</code>
</h4>

<p>Evaluate each strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$evaluate(setvars = "expected", N = 1L, by = "strategy")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>setvars</code></dt>
<dd>
<p>One of "expected" (evaluate with each model variable at
its mean value), "random" (sample each variable from its uncertainty
distribution and evaluate the model), "q2.5", "q50", "q97.5" (set each
model variable to its 2.5%, 50% or 97.5% quantile, respectively, and
evaluate the model) or "current" (leave each model variable at its
current value prior to calling the function and evaluate the model).</p>
</dd>
<dt><code>N</code></dt>
<dd>
<p>Number of replicates. Intended for use with PSA
(<code>modvars = "random"</code>); use with <code>modvars</code> = "expected"
will be repetitive and uninformative.</p>
</dd>
<dt><code>by</code></dt>
<dd>
<p>One of {"path", "strategy", "run"}. If "path", the table has
one row per path walked per strategy, per run, and includes the label of
the terminating leaf node to identify each path. If "strategy" (the
default), the table is aggregated by strategy, i.e., there is one row per
strategy per run. If "run", the table has one row per run and uses
concatenated strategy names (as above) and one (cost, benefit, utility,
QALY) as row names.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Starting with the root, the function works though all possible
paths to leaf nodes and computes the probability, cost, benefit and
utility of each, optionally aggregated by strategy or run.
The columns of the returned data frame are:
</p>

<dl>
<dt><code>by = "path"</code></dt>
<dd>

<dl>
<dt><code>Run</code></dt>
<dd>
<p>Run number</p>
</dd>
<dt><code>&lt;label of first decision node&gt;</code></dt>
<dd>
<p>label of action leaving
the node</p>
</dd>
<dt><code>&lt;label of second decision node (etc.)&gt;</code></dt>
<dd>
<p>label of action
leaving the node</p>
</dd>
<dt><code>Leaf</code></dt>
<dd>
<p>The label of terminating leaf node</p>
</dd>
<dt><code>Probability</code></dt>
<dd>
<p>Probability of traversing the path</p>
</dd>
<dt><code>Cost</code></dt>
<dd>
<p>Cost of traversing the path</p>
</dd>
<dt><code>Benefit</code></dt>
<dd>
<p>Benefit of traversing the path</p>
</dd>
<dt><code>Utility</code></dt>
<dd>
<p>Utility of traversing the path</p>
</dd>
<dt><code>QALY</code></dt>
<dd>
<p>QALY of traversing the path</p>
</dd>
</dl>
</dd>
<dt><code>by = "strategy"</code></dt>
<dd>

<dl>
<dt><code>Run</code></dt>
<dd>
<p>Run number</p>
</dd>
<dt><code>&lt;label of first decision node&gt;</code></dt>
<dd>
<p>label of action leaving
the node</p>
</dd>
<dt><code>&lt;label of second decision node (etc)</code></dt>
<dd>
<p>label of action</p>
</dd>
<dt><code>Probability</code></dt>
<dd>
<p><code class="reqn">\Sigma p_i</code> for the run (1)</p>
</dd>
<dt><code>Cost</code></dt>
<dd>
<p>Aggregate cost of the strategy</p>
</dd>
<dt><code>Benefit</code></dt>
<dd>
<p>Aggregate benefit of the strategy</p>
</dd>
<dt><code>Utility</code></dt>
<dd>
<p>Aggregate utility of the strategy</p>
</dd>
<dt><code>QALY</code></dt>
<dd>
<p>Aggregate QALY of the strategy</p>
</dd>
</dl>
</dd>
<dt><code>by = "run"</code></dt>
<dd>

<dl>
<dt><code>Run</code></dt>
<dd>
<p>Run number</p>
</dd>
<dt><code>Probability.&lt;S&gt;</code></dt>
<dd>
<p>Probability for strategy S</p>
</dd>
<dt><code>Cost.&lt;S&gt;</code></dt>
<dd>
<p>Cost for strategy S</p>
</dd>
<dt><code>Benefit.&lt;S&gt;</code></dt>
<dd>
<p>Benefit for strategy S</p>
</dd>
<dt><code>Utility.&lt;S&gt;</code></dt>
<dd>
<p>Benefit for strategy S</p>
</dd>
<dt><code>QALY.&lt;S&gt;</code></dt>
<dd>
<p>QALY for strategy S</p>
</dd>
</dl>
<p>where &lt;S&gt; is a label associated with strategy <code>S</code>. Each strategy
label is
a list of the labels of the action edges that are traversed in the
strategy, concatenated with underscores. The ordering of each label
part follows the lexicographical order of the decision node labels
concatenated with underscores. For example, if there are three
decision nodes labelled d1, d2 and d3, each strategy label will be of
the form a1i_a2i_a3i where a1i is the label of one action edge
emanating from decision node d1, etc. There will be one probability,
cost, benefit, utility and QALY column for each strategy.
</p>
</dd>
</dl>
<h5>Returns</h5>

<p>A data frame whose columns depend on <code>by</code>; see "Details".
</p>


<hr>
<a id="method-DecisionTree-tornado"></a>



<h4>Method <code>tornado()</code>
</h4>

<p>Create a "tornado" diagram.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$tornado(
  index,
  ref,
  outcome = "saving",
  exclude = NULL,
  draw = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt>
<dd>
<p>The index strategy (option) to be evaluated.</p>
</dd>
<dt><code>ref</code></dt>
<dd>
<p>The reference strategy (option) with which the index strategy
will be compared.</p>
</dd>
<dt><code>outcome</code></dt>
<dd>
<p>One of <code>"saving"</code> or <code>"ICER"</code>. For
<code>"saving"</code> (e.g. in cost consequence analysis), the x axis is cost
saved (cost of reference minus
cost of index), on the presumption that the new technology will be cost
saving at the point estimate. For <code>"ICER"</code> the x axis is
<code class="reqn">\Delta C/\Delta E</code> and is expected to be positive at the point
estimate (i.e. in the NE or SW quadrants of the cost-effectiveness
plane), where <code class="reqn">\Delta C</code> is cost of index minus cost of reference,
and <code class="reqn">\Delta E</code> is utility of index minus utility of reference.</p>
</dd>
<dt><code>exclude</code></dt>
<dd>
<p>A list of descriptions of model variables to be excluded
from the tornado.</p>
</dd>
<dt><code>draw</code></dt>
<dd>
<p>TRUE if the graph is to be drawn; otherwise return the
data frame silently.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Used to compare two strategies for traversing the decision tree.
A strategy is a unanimous prescription of the actions at each
decision node. The extreme values of each input variable are the upper
and lower 95% confidence limits of the uncertainty distributions of each
variable. This ensures that the range of each input is defensible
(Briggs 2012).
</p>



<h5>Returns</h5>

<p>A data frame with one row per input model variable and columns
for: minimum value of the variable, maximum value of the variable,
minimum value of the outcome and maximum value of the outcome. NULL
if there are no <code>ModVar</code>s.
</p>


<hr>
<a id="method-DecisionTree-threshold"></a>



<h4>Method <code>threshold()</code>
</h4>

<p>Find the threshold value of a model variable at which
the cost difference is zero or the ICER is equal to a threshold, for an
index strategy compared with a reference strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$threshold(
  index,
  ref,
  outcome,
  mvd,
  a,
  b,
  tol,
  lambda = NULL,
  nmax = 1000L
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt>
<dd>
<p>The index strategy (option) to be evaluated.</p>
</dd>
<dt><code>ref</code></dt>
<dd>
<p>The reference strategy (option) with which the index strategy
will be compared.</p>
</dd>
<dt><code>outcome</code></dt>
<dd>
<p>One of <code>"saving"</code> or <code>"ICER"</code>. For
<code>"saving"</code> (e.g., in cost consequence analysis), the value of
<code>mvd</code>
is found at which cost saved is zero (cost saved is cost of reference
minus cost of index, on the presumption that the new technology will be
cost saving at the point estimate). For <code>"ICER"</code> the value of
<code>mvd</code>
is found for which the incremental cost effectiveness ratio (ICER) is
equal to the threshold <code>lambda</code>. ICER is calculated as
<code class="reqn">\Delta C/\Delta E</code>, which will normally be positive
at the point estimate (i.e. in the NE or SW quadrants of the
cost-effectiveness plane), where <code class="reqn">\Delta C</code> is cost of index minus
cost of reference and <code class="reqn">\Delta E</code> is utility of index minus utility
of reference.</p>
</dd>
<dt><code>mvd</code></dt>
<dd>
<p>The description of the model variable for which the threshold
is to be found.</p>
</dd>
<dt><code>a</code></dt>
<dd>
<p>The lower bound of the range of values of <code>mvd</code> to search
for the root (numeric).</p>
</dd>
<dt><code>b</code></dt>
<dd>
<p>The upper bound of the range of values of <code>mvd</code> to search
for the root (numeric).</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>The tolerance to which the threshold should be
calculated (numeric).</p>
</dd>
<dt><code>lambda</code></dt>
<dd>
<p>The ICER threshold (threshold ratio) for outcome="ICER".</p>
</dd>
<dt><code>nmax</code></dt>
<dd>
<p>Maximum number if iterations allowed to reach convergence.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Uses a rudimentary bisection method method to find the root.
In PSA terms, the algorithm finds the value of the specified model
variable for which 50% of runs are cost saving (or above the ICER
threshold) and 50% are cost incurring (below the ICER threshold).
</p>



<h5>Returns</h5>

<p>Value of the model variable of interest at the threshold.
</p>


<hr>
<a id="method-DecisionTree-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DecisionTree$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health economic
evaluation. Oxford, UK: Oxford University Press; 2006.
</p>
<p>Briggs AH, Weinstein MC, Fenwick EAL, Karnon J, Sculpher MJ, Paltiel AD.
Model Parameter Estimation and Uncertainty: A Report of the
<abbr><span class="acronym">ISPOR-SMDM</span></abbr> Modeling Good Research Practices Task Force-6.
<em>Value in Health</em> 2012;<b>15</b>:835–42,
<a href="https://doi.org/10.1016/j.jval.2012.04.014">doi:10.1016/j.jval.2012.04.014</a>.
</p>
<p>Kaminski B, Jakubczyk M, Szufel P. A framework for sensitivity analysis of
decision trees. <em>Central European Journal of Operational Research</em>
2018;<b>26</b>:135–59, <a href="https://doi.org/10.1007/s10100-017-0479-6">doi:10.1007/s10100-017-0479-6</a>.

</p>


</div>