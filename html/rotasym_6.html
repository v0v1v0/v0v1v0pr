<div class="container">

<table style="width: 100%;"><tr>
<td>ACG</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Angular central Gaussian distribution</h2>

<h3>Description</h3>

<p>Density and simulation of the Angular Central Gaussian (ACG)
distribution on
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p\ge 1</code>. The density at
<code class="reqn">\mathbf{x} \in S^{p-1}</code>, <code class="reqn">p\ge 2</code>, is given by
</p>
<p style="text-align: center;"><code class="reqn">c^{\mathrm{ACG}}_{p,\boldsymbol{\Lambda}}
(\mathbf{x}' \boldsymbol{\Lambda}^{-1} \mathbf{x})^{-p/2}
\quad\mathrm{with}\quad c^{\mathrm{ACG}}_{p,\boldsymbol{\Lambda}}:=
1 / (\omega_p |\boldsymbol{\Lambda}|^{1/2})</code>
</p>

<p>where <code class="reqn">\boldsymbol{\Lambda}</code> is the shape matrix, a
<code class="reqn">p\times p</code> symmetric and positive definite matrix, and
<code class="reqn">\omega_p</code> is the surface area of <code class="reqn">S^{p-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">d_ACG(x, Lambda, log = FALSE)

c_ACG(p, Lambda, log = FALSE)

r_ACG(n, Lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>locations in <code class="reqn">S^{p-1}</code> to evaluate the density. Either a
matrix of size <code>c(nx, p)</code> or a vector of length <code>p</code>. Normalized
internally if required (with a <code>warning</code> message).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda</code></td>
<td>
<p>the shape matrix <code class="reqn">\boldsymbol{\Lambda}</code> of the
ACG. A symmetric and positive definite matrix of size <code>c(p, p)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>flag to indicate if the logarithm of the density (or the
normalizing constant) is to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>dimension of the ambient space <code class="reqn">R^p</code> that contains
<code class="reqn">S^{p-1}</code>. A positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>sample size, a positive integer.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Due to the projection of the ACG, the shape matrix
<code class="reqn">\boldsymbol{\Lambda}</code> is only identified up to a constant,
that is, <code class="reqn">\boldsymbol{\Lambda}</code> and
<code class="reqn">c\boldsymbol{\Lambda}</code> give the same ACG distribution.
Usually, <code class="reqn">\boldsymbol{\Lambda}</code> is normalized to have trace
equal to <code class="reqn">p</code>.
</p>
<p><code>c_ACG</code> is vectorized on <code>p</code>. If <code class="reqn">p = 1</code>, then the ACG is the
uniform distribution in the set <code class="reqn">\{-1, 1\}</code>.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>d_ACG</code>: a vector of length <code>nx</code> or <code>1</code> with the
evaluated density at <code>x</code>.
</p>
</li>
<li> <p><code>r_ACG</code>: a matrix of size <code>c(n, p)</code> with the random sample.
</p>
</li>
<li> <p><code>c_ACG</code>: the normalizing constant.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>Tyler, D. E. (1987). Statistical analysis for the angular central Gaussian
distribution on the sphere. <em>Biometrika</em>, 74(3):579–589.
<a href="https://doi.org/10.1093/biomet/74.3.579">doi:10.1093/biomet/74.3.579</a>
</p>


<h3>See Also</h3>

<p><code>tangent-elliptical</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Simulation and density evaluation for p = 2
Lambda &lt;- diag(c(5, 1))
n &lt;- 1e3
x &lt;- r_ACG(n = n, Lambda = Lambda)
col &lt;- viridisLite::viridis(n)
r &lt;- runif(n, 0.95, 1.05) # Radius perturbation to improve visualization
plot(r * x, pch = 16, col = col[rank(d_ACG(x = x, Lambda = Lambda))])

# Simulation and density evaluation for p = 3
Lambda &lt;- rbind(c(5, 1, 0.5),
                c(1, 2, 1),
                c(0.5, 1, 1))
x &lt;- r_ACG(n = n, Lambda = Lambda)
if (requireNamespace("rgl")) {
  rgl::plot3d(x, col = col[rank(d_ACG(x = x, Lambda = Lambda))], size = 5)
}
</code></pre>


</div>