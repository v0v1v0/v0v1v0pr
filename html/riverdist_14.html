<div class="container">

<table style="width: 100%;"><tr>
<td>detectroute</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Detect Route</h2>

<h3>Description</h3>

<p>Called internally within riverdistance.  Detects the 
sequential route from one river network segment to another.
</p>


<h3>Usage</h3>

<pre><code class="language-R">detectroute(
  start,
  end,
  rivers,
  verbose = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Segment number of the start of the route</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>
<p>Segment number of the end of the route</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rivers</code></td>
<td>
<p>The river network object to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether or not to print all routes being considered (used for 
error checking).  Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
<code>detectroute()</code> will return <code>NA</code>.  Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>Which route detection algorithm to use.  If set to <code>NULL</code> (the default), the function will automatically make a selection.  Choices are:
</p>

<ul>
<li>
<p> Setting <code>algorithm="sequential"</code> will be quite slow, and may give inaccurate results in the event of braiding.  This algorithm returns the first complete route detected, which may not be the shortest.  This algorithm is not recommended in almost all cases, but is retained as an option for certain checks.  It will not be used unless specified.
</p>
</li>
<li>
<p> Setting <code>algorithm="Dijkstra"</code> will be much faster, and will return the shortest route in the event of braiding.  If braiding is present or unknown, this will be the algorithm automatically chosen.
</p>
</li>
<li>
<p> Setting <code>algorithm="segroutes"</code> will be the fastest of all, but will only return results in a non-braided network.  This will be the algorithm automatically selected if segment routes are present - see buildsegroutes.</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector of segment numbers corresponding to the ordered route.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(Gulk)
plot(x=Gulk, cex=1)

detectroute(start=6, end=14, rivers=Gulk)

tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams, algorithm="sequential")
tend &lt;- Sys.time()
tend - tstart

data(abstreams)
tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams, algorithm="Dijkstra")
tend &lt;- Sys.time()
tend - tstart

tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams, algorithm="segroutes")
tend &lt;- Sys.time()
tend - tstart
</code></pre>


</div>