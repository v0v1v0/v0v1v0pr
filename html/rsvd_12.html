<div class="container">

<table style="width: 100%;"><tr>
<td>rsvd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Randomized Singular Value Decomposition (rsvd).</h2>

<h3>Description</h3>

<p>The randomized SVD computes the near-optimal low-rank approximation of a rectangular matrix
using a fast probablistic algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rsvd(A, k = NULL, nu = NULL, nv = NULL, p = 10, q = 2, sdist = "normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>array_like; <br>
a real/complex <code class="reqn">(m, n)</code> input matrix (or data frame) to be decomposed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer; <br>
specifies the target rank of the low-rank decomposition. <code class="reqn">k</code> should satisfy <code class="reqn">k &lt;&lt; min(m,n)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>integer, optional; <br>
number of left singular vectors to be returned. <code class="reqn">nu</code> must be between <code class="reqn">0</code> and <code class="reqn">k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nv</code></td>
<td>
<p>integer, optional; <br>
number of right singular vectors to be returned. <code class="reqn">nv</code> must be between <code class="reqn">0</code> and <code class="reqn">k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer, optional; <br>
oversampling parameter (by default <code class="reqn">p=10</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>integer, optional; <br>
number of additional power iterations (by default <code class="reqn">q=2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sdist</code></td>
<td>
<p>string <code class="reqn">c( 'unif', 'normal', 'rademacher')</code>, optional; <br>
specifies the sampling distribution of the random test matrix: <br><code class="reqn">'unif'</code> :  Uniform '[-1,1]'. <br><code class="reqn">'normal</code>' (default) : Normal '~N(0,1)'. <br><code class="reqn">'rademacher'</code> : Rademacher random variates. <br></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The singular value decomposition (SVD) plays an important role in data analysis, and scientific computing.
Given a rectangular <code class="reqn">(m,n)</code> matrix <code class="reqn">A</code>, and a target rank <code class="reqn">k &lt;&lt; min(m,n)</code>, 
the SVD factors the input matrix <code class="reqn">A</code> as
</p>
<p style="text-align: center;"><code class="reqn"> A  =  U_{k} diag(d_{k}) V_{k}^\top </code>
</p>

<p>The <code class="reqn">k</code> left singular vectors are the columns of the
real or complex unitary matrix <code class="reqn">U</code>. The <code class="reqn">k</code> right singular vectors are the columns
of the real or complex unitary matrix <code class="reqn">V</code>. The <code class="reqn">k</code> dominant singular values are the 
entries of <code class="reqn">d</code>, and non-negative and real numbers.
</p>
<p><code class="reqn">p</code> is an oversampling parameter to improve the approximation.
A value of at least 10 is recommended, and <code class="reqn">p=10</code> is set by default.
</p>
<p>The parameter <code class="reqn">q</code> specifies the number of power (subspace) iterations
to reduce the approximation error. The power scheme is recommended,
if the singular values decay slowly. In practice, 2 or 3 iterations
achieve good results, however, computing power iterations increases the
computational costs. The power scheme is set to <code class="reqn">q=2</code> by default.
</p>
<p>If <code class="reqn">k &gt; (min(n,m)/4)</code>, a deterministic partial or truncated <code>svd</code>
algorithm might be faster.
</p>


<h3>Value</h3>

<p><code>rsvd</code> returns a list containing the following three components:
</p>

<dl>
<dt>d</dt>
<dd>
<p>  array_like; <br>
singular values; vector of length <code class="reqn">(k)</code>.
</p>
</dd>
<dt>u</dt>
<dd>
<p>  array_like; <br>
left singular vectors; <code class="reqn">(m, k)</code> or <code class="reqn">(m, nu)</code> dimensional array.
</p>
</dd>
<dt>v</dt>
<dd>
<p>  array_like; <br>
right singular vectors; <code class="reqn">(n, k)</code> or <code class="reqn">(n, nv)</code> dimensional array. <br></p>
</dd>
</dl>
<h3>Note</h3>

<p>The singular vectors are not unique and only defined up to sign
(a constant of modulus one in the complex case). If a left singular vector
has its sign changed, changing the sign of the corresponding right vector
gives an equivalent decomposition.
</p>


<h3>Author(s)</h3>

<p>N. Benjamin Erichson, <a href="mailto:erichson@berkeley.edu">erichson@berkeley.edu</a>
</p>


<h3>References</h3>


<ul>
<li>
<p> [1] N. B. Erichson, S. Voronin, S. L. Brunton and J. N. Kutz. 2019.
Randomized Matrix Decompositions Using R. 
Journal of Statistical Software, 89(11), 1-48.
doi: <a href="https://doi.org/10.18637/jss.v089.i11">10.18637/jss.v089.i11</a>.
</p>
</li>
<li>
<p>  [2] N. Halko, P. Martinsson, and J. Tropp.
"Finding structure with randomness: probabilistic
algorithms for constructing approximate matrix
decompositions" (2009).
(available at arXiv <a href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a>).
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>svd</code>, <code>rpca</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library('rsvd')

# Create a n x n Hilbert matrix of order n,
# with entries H[i,j] = 1 / (i + j + 1).
hilbert &lt;- function(n) { i &lt;- 1:n; 1 / outer(i - 1, i, "+") }
H &lt;- hilbert(n=50)

# Low-rank (k=10) matrix approximation using rsvd
k=10
s &lt;- rsvd(H, k=k)
Hre &lt;- s$u %*% diag(s$d) %*% t(s$v) # matrix approximation
print(100 * norm( H - Hre, 'F') / norm( H,'F')) # percentage error
# Compare to truncated base svd
s &lt;- svd(H)
Hre &lt;- s$u[,1:k] %*% diag(s$d[1:k]) %*% t(s$v[,1:k]) # matrix approximation
print(100 * norm( H - Hre, 'F') / norm( H,'F')) # percentage error

</code></pre>


</div>