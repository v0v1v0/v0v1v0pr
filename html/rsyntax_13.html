<div class="container">

<table style="width: 100%;"><tr>
<td>climb_tree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Have a node adopt its parent's position</h2>

<h3>Description</h3>

<p>given a tquery that identfies a node labeled "origin", that has a parent labeled "target", 
recursively have child adopt the parent's position (parent and relation column)
and adopt parents fill nodes. only_new restricts adding fill nodes to relations that child
does not already have. This seems to be a good heuristic for dealing with argument drop
</p>


<h3>Usage</h3>

<pre><code class="language-R">climb_tree(
  .tokens,
  tq,
  unpack = TRUE,
  isolate = TRUE,
  take_fill = TRUE,
  give_fill = TRUE,
  only_new = "relation",
  max_iter = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.tokens</code></td>
<td>
<p>A tokenIndex</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tq</code></td>
<td>
<p>A tquery. Needs to have a node labeled "origin" that has a parent labeled "target"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unpack</code></td>
<td>
<p>If TRUE (default), create separate branches for the parent and the node that inherits the parent position</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isolate</code></td>
<td>
<p>If unpack is TRUE and isolate is TRUE (default is FALSE), isolate the new branch by recursively unpacking</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>take_fill</code></td>
<td>
<p>If TRUE (default), give the node that will inherit the parent position a copy of the parent children (but only if it does not already have children with this relation; see only_new)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>give_fill</code></td>
<td>
<p>If TRUE (default), copy the children of the node that will inherit the parent position to the parent (but only if it does not already have children with this relation; see only_new)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only_new</code></td>
<td>
<p>A characetr vector giving one or multiple column names that need to be unique for take_fill and give_fill</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>The climb tree function repeatedly resolves the first conjunction it encounters in a sentence. This can lead to many iterations
for sentences with many (nested) conjunctions. It could be the case that in unforseen cases or with certain parsers
an infinite loop is reached, which is why we use a max_iter argument that breaks the loop and sends a warning if the max is reached.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The reshaped tokenIndex
</p>


<h3>Examples</h3>

<pre><code class="language-R">
spacy_conjunctions &lt;- function(tokens) {
  no_fill = c('compound*','case', 'relcl')
  tq = tquery(label='target', NOT(relation = 'conj'),
              rsyntax::fill(NOT(relation = no_fill), max_window = c(Inf,0)),
              children(relation = 'conj', label='origin',
                       rsyntax::fill(NOT(relation = no_fill), max_window=c(0,Inf))))
  tokens = climb_tree(tokens, tq)
  chop(tokens, relation = 'cc')
}

## spacy tokens for "Bob and John ate bread and drank wine"
tokens = tokens_spacy[tokens_spacy$doc_id == 'text5',]

tokens = spacy_conjunctions(tokens)

tokens

if (interactive()) plot_tree(tokens)

</code></pre>


</div>