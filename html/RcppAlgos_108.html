<div class="container">

<table style="width: 100%;"><tr>
<td>primeCount</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Prime Counting Function <code class="reqn">\pi(x)</code>
</h2>

<h3>Description</h3>

<p><a href="https://en.wikipedia.org/wiki/Prime-counting_function">Prime counting function</a> for counting the prime numbers less than an integer, <code class="reqn">n</code>, using Legendre's formula. It is based on the the algorithm developed by Kim Walisch found here: <a href="https://github.com/kimwalisch/primecount">kimwalisch/primecount</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">primeCount(n, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Positive number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><a href="https://mathworld.wolfram.com/LegendresFormula.html">Legendre's Formula</a> for counting the number of primes less than <code class="reqn">n</code> makes use of the <a href="https://en.wikipedia.org/wiki/Inclusion-exclusion_principle">inclusion-exclusion principle</a> to avoid explicitly counting every prime up to <code class="reqn">n</code>. It is given by:
</p>
<p style="text-align: center;"><code class="reqn">\pi(x) = \pi(\sqrt x) + \Phi(x, \sqrt x) - 1</code>
</p>

<p>Where <code class="reqn">\Phi(x, a)</code> is the number of positive integers less than or equal to <code class="reqn">x</code> that are relatively prime to the first <code class="reqn">a</code> primes (i.e. not divisible by any of the first <code class="reqn">a</code> primes). It is given by the recurrence relation (<code class="reqn">p_a</code> is the <code class="reqn">ath</code> prime (e.g. <code class="reqn">p_4 = 7</code>)):
</p>
<p style="text-align: center;"><code class="reqn">\Phi(x, a) = \Phi(x, a - 1) + \Phi(x / p_a, a - 1)</code>
</p>

<p>This algorithm implements five modifications developed by Kim Walisch for calculating <code class="reqn">\Phi(x, a)</code> efficiently.
</p>

<ol>
<li>
<p>Cache results of <code class="reqn">\Phi(x, a)</code>
</p>
</li>
<li>
<p>Calculate <code class="reqn">\Phi(x, a)</code> using <code class="reqn">\Phi(x, a) = (x / pp) * \phi(pp) + \Phi(x mod pp, a)</code>  if <code class="reqn">a &lt;= 6</code>
</p>

<ul>
<li>
<p><code class="reqn">pp = 2 * 3 * ... * </code> <code>prime[a]</code>
</p>
</li>
<li>
<p><code class="reqn">\phi(pp) = (2 - 1) * (3 - 1) * ... * </code> <code class="reqn">(</code><code>prime[a]</code> <code class="reqn">- 1)</code> (i.e. Euler's totient function)
</p>
</li>
</ul>
</li>
<li>
<p>Calculate <code class="reqn">\Phi(x, a)</code> using <code class="reqn">\pi(x)</code> lookup table
</p>
</li>
<li>
<p>Calculate all <code class="reqn">\Phi(x, a) = 1</code> upfront
</p>
</li>
<li>
<p>Stop recursion at <code class="reqn">6</code> if <code class="reqn">\sqrt x &gt;= 13</code> or <code class="reqn">\pi(\sqrt x)</code> instead of <code class="reqn">1</code>
</p>
</li>
</ol>
<h3>Value</h3>

<p>Whole number representing the number of prime numbers less than or equal to <code class="reqn">n</code>.
</p>


<h3>Note</h3>

<p>The maximum value of <code class="reqn">n</code> is <code class="reqn">2^{53} - 1</code>
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://sweet.ua.pt/tos/bib/5.4.pdf">Computing <code class="reqn">\pi(x)</code>: the combinatorial method</a></p>
<ul><li>
<p>Tom√°s Oliveira e Silva, Computing pi(x): the combinatorial method, Revista do DETUA, vol. 4, no. 6, March 2006, p. 761. https://sweet.ua.pt/tos/bib/5.4.pdf</p>
</li></ul>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>primeSieve</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Get the number of primes less than a billion
primeCount(10^9)

## Using nThreads
system.time(primeCount(10^10, nThreads = 2))
</code></pre>


</div>