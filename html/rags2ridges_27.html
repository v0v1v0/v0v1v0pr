<div class="container">

<table style="width: 100%;"><tr>
<td>GGMblockNullPenalty</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate the distribution of the penalty parameter under the null hypothesis
of block-independence</h2>

<h3>Description</h3>

<p>Function that serves as a precursor function to the block-independence test
(see <code>GGMblockTest</code>). It generates an empirical distribution of
the penalty parameter under the null hypothesis of block independence (in
the regularized precision matrix).
</p>


<h3>Usage</h3>

<pre><code class="language-R">GGMblockNullPenalty(
  Y,
  id,
  nPerm = 25,
  lambdaMin,
  lambdaMax,
  lambdaInit = (lambdaMin + lambdaMax)/2,
  target = default.target(covML(Y)),
  type = "Alt",
  ncpus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Data <code>matrix</code>. Variables assumed to be represented by columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>A <code>numeric</code> vector acting as an indicator variable for two
blocks of the precision matrix. The blocks should be coded as <code>0</code> and
<code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nPerm</code></td>
<td>
<p>A <code>numeric</code> or <code>integer</code> determining the number of
permutations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaMin</code></td>
<td>
<p>A <code>numeric</code> giving the minimum value for the penalty
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaMax</code></td>
<td>
<p>A <code>numeric</code> giving the maximum value for the penalty
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaInit</code></td>
<td>
<p>A <code>numeric</code> giving the initial value for the penalty
parameter for starting optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>A target <code>matrix</code> (in precision terms) for Type I ridge
estimators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A <code>character</code> indicating the type of ridge estimator to be
used. Must be one of: "Alt", "ArchI", "ArchII".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>A <code>numeric</code> or <code>integer</code> indicating the desired
number of cpus to be used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function can be viewed as a precursor to the function for the
block-independence test (see <code>GGMblockTest</code>). The mentioned test
evaluates the null hypothesis of block-independence against the alternative
of block-dependence (presence of non-zero elements in the off-diagonal
block) in the precision matrix using high-dimensional data. To accommodate
the high-dimensionality the parameters of interest are estimated in a
penalized manner (ridge-type penalization, see <code>ridgeP</code>).
Penalization involves a degree of freedom (the penalty parameter) which
needs to be fixed before testing. This function then generates an empirical
distribution of this penalty parameter. Hereto the samples are permutated
within block. The resulting permuted data sets represent the null
hypothesis. To avoid the dependence on a single permutation, many permuted
data sets are generated. For each permutation the optimal penalty parameter
is determined by means of cross-validation (see
<code>optPenalty.LOOCVauto</code>). The resulting optimal penalty
parameters are returned. An estimate of the location (such as the median) is
recommended for use in the block-independence test.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector, representing the distribution of the (LOOCV
optimal) penalty parameter under the null hypothesis of block-independence.
</p>


<h3>Author(s)</h3>

<p>Wessel N. van Wieringen, Carel F.W. Peeters &lt;carel.peeters@wur.nl&gt;
</p>


<h3>See Also</h3>

<p><code>ridgeP</code>, <code>optPenalty.LOOCVauto</code>,
<code>default.target</code>, <code>GGMblockTest</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Obtain some (high-dimensional) data
p = 15
n = 10
set.seed(333)
X = matrix(rnorm(n*p), nrow = n, ncol = p)
colnames(X)[1:15] = letters[1:15]
id &lt;- c(rep(0, 10), rep(1, 5))

## Generate null distribution of the penalty parameter
lambda0dist &lt;- GGMblockNullPenalty(X, id, 5, 0.001, 10)

## Location of null distribution
lambdaNull &lt;- median(lambda0dist)

</code></pre>


</div>