<div class="container">

<table style="width: 100%;"><tr>
<td>rename_cols</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ICU class data utilities</h2>

<h3>Description</h3>

<p>Several utility functions for working with <code>id_tbl</code> and <code>ts_tbl</code> objects
are available, including functions for changing column names, removing
columns, as well as aggregating or removing rows. An important thing to
note is that as <code>id_tbl</code> (and consequently <code>ts_tbl</code>) inherits from
<code>data.table</code>, there are several functions provided by the <code>data.table</code>
package that are capable of modifying <code>id_tbl</code> in a way that results in an
object with inconsistent state. An example for this is
<code>data.table::setnames()</code>: if an ID column or the index column name is
modified without updating the attribute marking the column as such, this
leads to an invalid object. As <code>data.table::setnames()</code> is not an S3
generic function, the only way to control its behavior with respect to
<code>id_tbl</code> objects is masking the function. As such an approach has its own
down-sides, a separate function, <code>rename_cols()</code> is provided, which is able
to handle column renaming correctly.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rename_cols(
  x,
  new,
  old = colnames(x),
  skip_absent = FALSE,
  by_ref = FALSE,
  ...
)

rm_cols(x, cols, skip_absent = FALSE, by_ref = FALSE)

change_interval(x, new_interval, cols = time_vars(x), by_ref = FALSE)

change_dur_unit(x, new_unit, by_ref = FALSE)

rm_na(x, cols = data_vars(x), mode = c("all", "any"))

## S3 method for class 'id_tbl'
sort(
  x,
  decreasing = FALSE,
  by = meta_vars(x),
  reorder_cols = TRUE,
  by_ref = FALSE,
  ...
)

is_sorted(x)

## S3 method for class 'id_tbl'
duplicated(x, incomparables = FALSE, by = meta_vars(x), ...)

## S3 method for class 'id_tbl'
anyDuplicated(x, incomparables = FALSE, by = meta_vars(x), ...)

## S3 method for class 'id_tbl'
unique(x, incomparables = FALSE, by = meta_vars(x), ...)

is_unique(x, ...)

## S3 method for class 'id_tbl'
aggregate(
  x,
  expr = NULL,
  by = meta_vars(x),
  vars = data_vars(x),
  env = NULL,
  ...
)

dt_gforce(
  x,
  fun = c("mean", "median", "min", "max", "sum", "prod", "var", "sd", "first", "last",
    "any", "all"),
  by = meta_vars(x),
  vars = data_vars(x),
  na_rm = !fun %in% c("first", "last")
)

replace_na(x, val, type = "const", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object to query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new, old</code></td>
<td>
<p>Replacement names and existing column names for renaming
columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_absent</code></td>
<td>
<p>Logical flag for ignoring non-existent column names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_ref</code></td>
<td>
<p>Logical flag indicating whether to perform the operation by
reference</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>Column names of columns to consider</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_interval</code></td>
<td>
<p>Replacement interval length specified as scalar-valued
<code>difftime</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_unit</code></td>
<td>
<p>New <code>difftime</code> unit for the <code>dur_var</code> column</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>Switch between <code>all</code> where all entries of a row have to be
missing (for the selected columns) or <code>any</code>, where a single missing entry
suffices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>Logical flag indicating the sort order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>Character vector indicating which combinations of columns from
<code>x</code> to use for uniqueness checks</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reorder_cols</code></td>
<td>
<p>Logical flag indicating whether to move the <code>by</code>
columns to the front.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incomparables</code></td>
<td>
<p>Not used. Here for S3 method consistency</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>Expression to apply over groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>Column names to apply the function to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>Environment to look up names in <code>expr</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Function name (as string) to apply over groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>Logical flag indicating how to treat <code>NA</code> values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>val</code></td>
<td>
<p>Replacement value (if <code>type</code> is <code>"const"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p> character, one of <em>"const"</em>, <em>"locf"</em> or <em>"nocb"</em>. Defaults to <code>"const"</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Apart from a function for renaming columns while respecting attributes
marking columns a index or ID columns, several other utility functions are
provided to make handling of <code>id_tbl</code> and <code>ts_tbl</code> objects more convenient.
</p>


<h4>Sorting</h4>

<p>An <code>id_tbl</code> or <code>ts_tbl</code> object is considered sorted when rows are in
ascending order according to columns as specified by <code>meta_vars()</code>. This
means that for an <code>id_tbl</code> object rows have to be ordered by <code>id_vars()</code>
and for a <code>ts_tbl</code> object rows have to be ordered first by <code>id_vars()</code>,
followed by the <code>index_var()</code>. Calling the S3 generic function
<code>base::sort()</code> on an object that inherits form <code>id_tbl</code> using default
arguments yields an object that is considered sorted. For convenience
(mostly in printing), the column by which the table was sorted are moved to
the front (this can be disabled by passing <code>FALSE</code> as <code>reorder_cols</code>
argument). Internally, sorting is handled by either setting a
<code>data.table::key()</code> in case <code>decreasing = FALSE</code> or be calling
<code>data.table::setorder()</code> in case <code>decreasing = TRUE</code>.
</p>



<h4>Uniqueness</h4>

<p>On object inheriting form <code>id_tbl</code> is considered unique if it is unique in
terms of the columns as specified by <code>meta_vars()</code>. This means that for an
<code>id_tbl</code> object, either zero or a single row is allowed per combination of
values in columns <code>id_vars()</code> and consequently for <code>ts_tbl</code> objects a
maximum of one row is allowed per combination of time step and ID. In order
to create a unique <code>id_tbl</code> object from a non-unique <code>id_tbl</code> object,
<code>aggregate()</code> will combine observations that represent repeated
measurements within a group.
</p>



<h4>Aggregating</h4>

<p>In order to turn a non-unique <code>id_tbl</code> or <code>ts_tbl</code> object into an object
considered unique, the S3 generic function <code>stats::aggregate()</code> is
available. This applied the expression (or function specification) passed
as <code>expr</code> to each combination of grouping variables. The columns to be
aggregated can be controlled using the <code>vars</code> argument and the grouping
variables can be changed using the <code>by</code> argument. The argument <code>expr</code> is
fairly flexible: it can take an expression that will be evaluated in the
context of the <code>data.table</code> in a clean environment inheriting from <code>env</code>,
it can be a function, or it can be a string in which case <code>dt_gforce()</code> is
called. The default value <code>NULL</code> chooses a string dependent on data types,
where <code>numeric</code> resolves to <code>median</code>, <code>logical</code> to <code>sum</code> and <code>character</code> to
<code>first</code>.
</p>
<p>As aggregation is used in concept loading (see <code>load_concepts()</code>),
performance is important. For this reason, <code>dt_gforce()</code> allows for any of
the available functions to be applied using the <code>GForce</code> optimization of
<code>data.table</code> (see data.table::datatable.optimize).
</p>



<h3>Value</h3>

<p>Most of the utility functions return an object inheriting from
<code>id_tbl</code>, potentially modified by reference, depending on the type of the
object passed as <code>x</code>. The functions <code>is_sorted()</code>, <code>anyDuplicated()</code> and
<code>is_unique()</code> return logical flags, while <code>duplicated()</code> returns a logical
vector of the length <code>nrow(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tbl &lt;- id_tbl(a = rep(1:5, 4), b = rep(1:2, each = 10), c = rnorm(20),
              id_vars = c("a", "b"))
is_unique(tbl)
is_sorted(tbl)

is_sorted(tbl[order(c)])

identical(aggregate(tbl, list(c = sum(c))), aggregate(tbl, "sum"))

tbl &lt;- aggregate(tbl, "sum")
is_unique(tbl)
is_sorted(tbl)

</code></pre>


</div>