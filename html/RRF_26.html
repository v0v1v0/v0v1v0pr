<div class="container">

<table style="width: 100%;"><tr>
<td>predict.RRF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>predict method for random forest objects</h2>

<h3>Description</h3>

<p>Prediction of test data using random forest.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'RRF'
predict(object, newdata, type="response",
  norm.votes=TRUE, predict.all=FALSE, proximity=FALSE, nodes=FALSE,
  cutoff, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>RRF</code>, as that
created by the function <code>RRF</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a data frame or matrix containing new data.  (Note: If
not given, the out-of-bag prediction in <code>object</code> is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>one of <code>response</code>, <code>prob</code>. or <code>votes</code>,
indicating the type of output: predicted values, matrix of class
probabilities, or matrix of vote counts.  <code>class</code> is allowed, but
automatically converted to "response", for backward compatibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.votes</code></td>
<td>
<p>Should the vote counts be normalized (i.e.,
expressed as fractions)?  Ignored if <code>object$type</code> is
<code>regression</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict.all</code></td>
<td>
<p>Should the predictions of all trees be kept?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proximity</code></td>
<td>
<p>Should proximity measures be computed?  An error is
issued if <code>object$type</code> is <code>regression</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>Should the terminal node indicators (an n by ntree
matrix) be return?  If so, it is in the “nodes” attribute of the
returned object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>(Classification only)  A vector of length equal to
number of classes.  The ‘winning’ class for an observation is the
one with the maximum ratio of proportion of votes to cutoff.
Default is taken from the <code>forest$cutoff</code> component of
<code>object</code> (i.e., the setting used when running
<code>RRF</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used currently.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>object$type</code> is <code>regression</code>, a vector of predicted
values is returned.  If <code>predict.all=TRUE</code>, then the returned
object is a list of two components: <code>aggregate</code>, which is the
vector of predicted values by the forest, and <code>individual</code>, which
is a matrix where each column contains prediction by a tree in the
forest.
</p>
<p>If <code>object$type</code> is <code>classification</code>, the object returned
depends on the argument <code>type</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>predicted classes (the classes with majority vote).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>matrix of class probabilities (one column for each class
and one row for each input).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vote</code></td>
<td>
<p>matrix of vote counts (one column for each class
and one row for each new input); either in raw counts or in fractions
(if <code>norm.votes=TRUE</code>).</p>
</td>
</tr>
</table>
<p>If <code>predict.all=TRUE</code>, then the <code>individual</code> component of the
returned object is a character matrix where each column contains the
predicted class by a tree in the forest.
</p>
<p>If <code>proximity=TRUE</code>, the returned object is a list with two
components: <code>pred</code> is the prediction (as described above) and
<code>proximity</code> is the proximitry matrix.  An error is issued if
<code>object$type</code> is <code>regression</code>.
</p>
<p>If <code>nodes=TRUE</code>, the returned object has a “nodes” attribute,
which is an n by ntree matrix, each column containing the node number
that the cases fall in for that tree.
</p>
<p>NOTE: If the <code>object</code> inherits from <code>RRF.formula</code>,
then any data with <code>NA</code> are silently omitted from the prediction.
The returned value will contain <code>NA</code> correspondingly in the
aggregated and individual tree predictions (if requested), but not in
the proximity or node matrices.
</p>
<p>NOTE2: Any ties are broken at random, so if this is undesirable, avoid it by
using odd number <code>ntree</code> in <code>RRF()</code>.
</p>


<h3>Author(s)</h3>

<p> Andy Liaw <a href="mailto:andy_liaw@merck.com">andy_liaw@merck.com</a> and Matthew Wiener
<a href="mailto:matthew_wiener@merck.com">matthew_wiener@merck.com</a>, based on original Fortran code by
Leo Breiman and Adele Cutler.</p>


<h3>References</h3>

<p>Breiman, L. (2001), <em>Random Forests</em>, Machine Learning 45(1),
5-32.
</p>


<h3>See Also</h3>

<p><code>RRF</code></p>


<h3>Examples</h3>

<pre><code class="language-R">data(iris)
set.seed(111)
ind &lt;- sample(2, nrow(iris), replace = TRUE, prob=c(0.8, 0.2))
iris.rf &lt;- RRF(Species ~ ., data=iris[ind == 1,])
iris.pred &lt;- predict(iris.rf, iris[ind == 2,])
table(observed = iris[ind==2, "Species"], predicted = iris.pred)
## Get prediction for all trees.
predict(iris.rf, iris[ind == 2,], predict.all=TRUE)
## Proximities.
predict(iris.rf, iris[ind == 2,], proximity=TRUE)
## Nodes matrix.
str(attr(predict(iris.rf, iris[ind == 2,], nodes=TRUE), "nodes"))
</code></pre>


</div>