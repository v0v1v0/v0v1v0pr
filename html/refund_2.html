<div class="container">

<table style="width: 100%;"><tr>
<td>af</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct an FGAM regression term</h2>

<h3>Description</h3>

<p>Defines a term <code class="reqn">\int_{T}F(X_i(t),t)dt</code> for inclusion in an <code>mgcv::gam</code>-formula (or
<code>{bam}</code> or <code>{gamm}</code> or <code>gamm4:::gamm</code>) as constructed by
<code>{pfr}</code>, where <code class="reqn">F(x,t)</code> is an unknown smooth bivariate function and <code class="reqn">X_i(t)</code>
is a functional predictor on the closed interval <code class="reqn">T</code>. See <code>{smooth.terms}</code>
for a list of bivariate basis and penalty options; the default is a tensor
product basis with marginal cubic regression splines for estimating <code class="reqn">F(x,t)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">af(
  X,
  argvals = NULL,
  xind = NULL,
  basistype = c("te", "t2", "s"),
  integration = c("simpson", "trapezoidal", "riemann"),
  L = NULL,
  presmooth = NULL,
  presmooth.opts = NULL,
  Xrange = range(X, na.rm = T),
  Qtransform = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>functional predictors, typically expressed as an <code>N</code> by <code>J</code> matrix,
where <code>N</code> is the number of columns and <code>J</code> is the number of
evaluation points. May include missing/sparse functions, which are
indicated by <code>NA</code> values. Alternatively, can be an object of class
<code>"fd"</code>; see <code>[fda]{fd}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>indices of evaluation of <code>X</code>, i.e. <code class="reqn">(t_{i1},.,t_{iJ})</code> for
subject <code class="reqn">i</code>. May be entered as either a length-<code>J</code> vector, or as
an <code>N</code> by <code>J</code> matrix. Indices may be unequally spaced. Entering
as a matrix allows for different observations times for each subject. If
<code>NULL</code>, defaults to an equally-spaced grid between 0 or 1 (or within
<code>X$basis$rangeval</code> if <code>X</code> is a <code>fd</code> object.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xind</code></td>
<td>
<p>same as argvals. It will not be supported in the next version of refund.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basistype</code></td>
<td>
<p>defaults to <code>"te"</code>, i.e. a tensor product spline to represent <code class="reqn">F(x,t)</code> Alternatively,
use <code>"s"</code> for bivariate basis functions (see <code>{s}</code>) or <code>"t2"</code> for an alternative
parameterization of tensor product splines (see <code>{t2}</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integration</code></td>
<td>
<p>method used for numerical integration. Defaults to <code>"simpson"</code>'s rule
for calculating entries in <code>L</code>. Alternatively and for non-equidistant grids,
<code>"trapezoidal"</code> or <code>"riemann"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>an optional <code>N</code> by <code>ncol(argvals)</code> matrix giving the weights for the numerical
integration over <code>t</code>. If present, overrides <code>integration</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>presmooth</code></td>
<td>
<p>string indicating the method to be used for preprocessing functional predictor prior
to fitting. Options are <code>fpca.sc</code>, <code>fpca.face</code>, <code>fpca.ssvd</code>, <code>fpca.bspline</code>, and
<code>fpca.interpolate</code>. Defaults to <code>NULL</code> indicateing no preprocessing. See
<code>{create.prep.func}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>presmooth.opts</code></td>
<td>
<p>list including options passed to preprocessing method
<code>{create.prep.func}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xrange</code></td>
<td>
<p>numeric; range to use when specifying the marginal basis for the <em>x</em>-axis.  It may
be desired to increase this slightly over the default of <code>range(X)</code> if concerned about predicting
for future observed curves that take values outside of <code>range(X)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qtransform</code></td>
<td>
<p>logical; should the functional be transformed using the empirical cdf and
applying a quantile transformation on each column of <code>X</code> prior to fitting?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments for basis and penalization to be passed to the
function indicated by <code>basistype</code>. These could include, for example,
<code>"bs"</code>, <code>"k"</code>, <code>"m"</code>, etc. See <code>{te}</code> or
<code>{s}</code> for details.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>a <code>"call"</code> to <code>te</code> (or <code>s</code>, <code>t2</code>) using the appropriately
constructed covariate and weight matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>the <code>argvals</code> argument supplied to <code>af</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>the  matrix of weights used for the integration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xindname</code></td>
<td>
<p>the name used for the functional predictor variable in the <code>formula</code> used by <code>mgcv</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tindname</code></td>
<td>
<p>the name used for <code>argvals</code> variable in the <code>formula</code> used by <code>mgcv</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lname</code></td>
<td>
<p>the name used for the <code>L</code> variable in the <code>formula</code> used by <code>mgcv</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>presmooth</code></td>
<td>
<p>the <code>presmooth</code> argument supplied to <code>af</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xrange</code></td>
<td>
<p>the <code>Xrange</code> argument supplied to <code>af</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prep.func</code></td>
<td>
<p>a function that preprocesses data based on the preprocessing method specified in <code>presmooth</code>. See
<code>{create.prep.func}</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Mathew W. McLean <a href="mailto:mathew.w.mclean@gmail.com">mathew.w.mclean@gmail.com</a>, Fabian Scheipl,
and Jonathan Gellar
</p>


<h3>References</h3>

<p>McLean, M. W., Hooker, G., Staicu, A.-M., Scheipl, F., and Ruppert, D. (2014). Functional
generalized additive models. <em>Journal of Computational and Graphical Statistics</em>, <b>23 (1)</b>,
pp. 249-269.
</p>


<h3>See Also</h3>

<p><code>pfr</code>, <code>lf</code>, mgcv's <code>linear.functional.terms</code>,
<code>pfr</code> for examples
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(DTI)
## only consider first visit and cases (no PASAT scores for controls)
DTI1 &lt;- DTI[DTI$visit==1 &amp; DTI$case==1,]
DTI2 &lt;- DTI1[complete.cases(DTI1),]

## fit FGAM using FA measurements along corpus callosum
## as functional predictor with PASAT as response
## using 8 cubic B-splines for marginal bases with third
## order marginal difference penalties
## specifying gamma &gt; 1 enforces more smoothing when using
## GCV to choose smoothing parameters
fit1 &lt;- pfr(pasat ~ af(cca, k=c(8,8), m=list(c(2,3), c(2,3)),
                       presmooth="bspline", bs="ps"),
            method="GCV.Cp", gamma=1.2, data=DTI2)
plot(fit1, scheme=2)
vis.pfr(fit1)

## af term for the cca measurements plus an lf term for the rcst measurements
## leave out 10 samples for prediction
test &lt;- sample(nrow(DTI2), 10)
fit2 &lt;- pfr(pasat ~ af(cca, k=c(7,7), m=list(c(2,2), c(2,2)), bs="ps",
                       presmooth="fpca.face") +
                    lf(rcst, k=7, m=c(2,2), bs="ps"),
            method="GCV.Cp", gamma=1.2, data=DTI2[-test,])
par(mfrow=c(1,2))
plot(fit2, scheme=2, rug=FALSE)
vis.pfr(fit2, select=1, xval=.6)
pred &lt;- predict(fit2, newdata = DTI2[test,], type='response', PredOutOfRange = TRUE)
sqrt(mean((DTI2$pasat[test] - pred)^2))

## Try to predict the binary response disease status (case or control)
##   using the quantile transformed measurements from the rcst tract
##   with a smooth component for a scalar covariate that is pure noise
DTI3 &lt;- DTI[DTI$visit==1,]
DTI3 &lt;- DTI3[complete.cases(DTI3$rcst),]
z1 &lt;- rnorm(nrow(DTI3))
fit3 &lt;- pfr(case ~ af(rcst, k=c(7,7), m = list(c(2, 1), c(2, 1)), bs="ps",
                      presmooth="fpca.face", Qtransform=TRUE) +
                    s(z1, k = 10), family="binomial", select=TRUE, data=DTI3)
par(mfrow=c(1,2))
plot(fit3, scheme=2, rug=FALSE)
abline(h=0, col="green")

# 4 versions: fit with/without Qtransform, plotted with/without Qtransform
fit4 &lt;- pfr(case ~ af(rcst, k=c(7,7), m = list(c(2, 1), c(2, 1)), bs="ps",
                      presmooth="fpca.face", Qtransform=FALSE) +
                    s(z1, k = 10), family="binomial", select=TRUE, data=DTI3)
par(mfrow=c(2,2))
zlms &lt;- c(-7.2,4.3)
plot(fit4, select=1, scheme=2, main="QT=FALSE", zlim=zlms, xlab="t", ylab="rcst")
plot(fit4, select=1, scheme=2, Qtransform=TRUE, main="QT=FALSE", rug=FALSE,
     zlim=zlms, xlab="t", ylab="p(rcst)")
plot(fit3, select=1, scheme=2, main="QT=TRUE", zlim=zlms, xlab="t", ylab="rcst")
plot(fit3, select=1, scheme=2, Qtransform=TRUE, main="QT=TRUE", rug=FALSE,
     zlim=zlms, xlab="t", ylab="p(rcst)")

vis.pfr(fit3, select=1, plot.type="contour")

## End(Not run)

</code></pre>


</div>