<div class="container">

<table style="width: 100%;"><tr>
<td>GGMpathStats</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gaussian graphical model node pair path statistics</h2>

<h3>Description</h3>

<p>Function that calculates, for a specified node pair representing endpoints,
path statistics from a sparse precision matrix. The sparse precision matrix
is taken to represent the conditional independence graph of a Gaussian
graphical model. The contribution to the observed covariance between the
specified endpoints is calculated for each (heuristically) determined path
between the endpoints.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GGMpathStats(
  P0,
  node1,
  node2,
  neiExpansions = 2,
  verbose = TRUE,
  graph = TRUE,
  nrPaths = 2,
  lay = "layout_in_circle",
  coords = NULL,
  nodecol = "skyblue",
  Vsize = 15,
  Vcex = 0.6,
  VBcolor = "darkblue",
  VLcolor = "black",
  all.edges = TRUE,
  prune = TRUE,
  legend = TRUE,
  scale = 1,
  Lcex = 0.8,
  PTcex = 2,
  main = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P0</code></td>
<td>
<p>Sparse (possibly standardized) precision matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node1</code></td>
<td>
<p>A <code>numeric</code> specifying an endpoint. The numeric should
correspond to a row/column of the precision matrix and as such represents
the corresponding variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node2</code></td>
<td>
<p>A <code>numeric</code> specifying a second endpoint. The numeric
should correspond to a row/column of the precision matrix and as such
represents the corresponding variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neiExpansions</code></td>
<td>
<p>A <code>numeric</code> determining how many times the
neighborhood around the respective endpoints should be expanded in the
search for shortest paths between the node pair.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A <code>logical</code> indicating if a summary of the results
should be printed on screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A <code>logical</code> indicating if the strongest paths should be
visualized with a graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrPaths</code></td>
<td>
<p>A <code>numeric</code> indicating the number of paths (with the
highest contribution to the marginal covariance between the indicated node
pair) to be visualized/highlighted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lay</code></td>
<td>
<p>A <code>character</code> mimicking a call to <code>igraph</code>
layout functions. Determines the placement of vertices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>A <code>matrix</code> containing coordinates. Alternative to the
lay-argument for determining the placement of vertices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodecol</code></td>
<td>
<p>A <code>character</code> determining the color of <code>node1</code> and
<code>node2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vsize</code></td>
<td>
<p>A <code>numeric</code> determining the vertex size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vcex</code></td>
<td>
<p>A <code>numeric</code> determining the size of the vertex labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VBcolor</code></td>
<td>
<p>A <code>character</code> determining the color of the vertex
borders.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VLcolor</code></td>
<td>
<p>A <code>character</code> determining the color of the vertex
labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.edges</code></td>
<td>
<p>A <code>logical</code> indicating if edges other than those
implied by the <code>nrPaths</code>-paths between <code>node1</code> and node2 should
also be visualized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prune</code></td>
<td>
<p>A <code>logical</code> determining if vertices of degree 0 should be
removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>A <code>logical</code> indicating if the graph should come with a
legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A <code>numeric</code> representing a scale factor for visualizing
strenght of edges. It is a relative scaling factor, in the sense that the
edges implied by the <code>nrPaths</code>-paths between <code>node1</code> and node2
have edge thickness that is twice this scaling factor (so it is a scaling
factor vis-a-vis the unimplied edges).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lcex</code></td>
<td>
<p>A <code>numeric</code> determining the size of the legend box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PTcex</code></td>
<td>
<p>A <code>numeric</code> determining the size of the exemplary lines in
the legend box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>A <code>character</code> giving the main figure title.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The conditional independence graph (as implied by the sparse precision
matrix) is undirected. In undirected graphs origin and destination are
interchangeable and are both referred to as 'endpoints' of a path. The
function searches for shortest paths between the specified endpoints
<code>node1</code> and <code>node2</code>. It searches for shortest paths that visit
nodes only once. The shortest paths between the provided endpoints are
determined heuristically by the following procedure. The search is initiated
by application of the <code>get.all.shortest.paths</code>-function from the
<code>igraph</code>-package, which yields all shortest paths between the
nodes. Next, the neighborhoods of the endpoints are defined (excluding the
endpoints themselves). Then, the shortest paths are found between: (a)
<code>node1</code> and node <em>Vs</em> in its neighborhood; (b) node <em>Vs</em> in
the <code>node1</code>-neighborhood and node <em>Ve</em> in the
<code>node2</code>-neighborhood; and (c) node <em>Ve</em> in the
<code>node2</code>-neighborhood and <code>node2</code>. These paths are glued and new
shortest path candidates are obtained (preserving only novel paths). In
additional iterations (specified by <code>neiExpansions</code>) the <code>node1</code>-
and <code>node2</code>-neighborhood are expanded by including their neighbors
(still excluding the endpoints) and shortest paths are again searched as
described above.
</p>
<p>The contribution of a particular path to the observed covariance between the
specified node pair is calculated in accordance with Theorem 1 of Jones and
West (2005). As in Jones and West (2005), paths whose weights have an
opposite sign to the marginal covariance (between endnodes of the path) are
referred to as 'moderating paths' while paths whose weights have the same
sign as the marginal covariance are referred to as 'mediating' paths. Such
paths are visualized when <code>graph = TRUE</code>.
</p>
<p>All arguments following the <code>graph</code> argument are only (potentially)
used when <code>graph = TRUE</code>. When <code>graph = TRUE</code> the conditional
independence graph is returned with the paths highlighted that have the
highest contribution to the marginal covariance between the specified
endpoints. The number of paths highlighted is indicated by <code>nrPaths</code>.
The edges of mediating paths are represented in green while the edges of
moderating paths are represented in red. When <code>all.edges = TRUE</code> the
edges other than those implied by the <code>nrPaths</code>-paths between
<code>node1</code> and node2 are also visualized (in lightgrey). When
<code>all.edges = FALSE</code> only the mediating and moderating paths implied by
<code>nrPaths</code> are visualized.
</p>
<p>The default layout gives a circular placement of the vertices. Most layout
functions supported by <code>igraph</code> are supported (the function is
partly a wrapper around certain <code>igraph</code> functions). The igraph
layouts can be invoked by a <code>character</code> that mimicks a call to a
<code>igraph</code> layout functions in the <code>lay</code> argument. When using
<code>lay = NULL</code> one can specify the placement of vertices with the
<code>coords</code> argument. The row dimension of this matrix should equal the
number of (pruned) vertices. The column dimension then should equal 2 (for
2D layouts) or 3 (for 3D layouts). The <code>coords</code> argument can also be
viewed as a convenience argument as it enables one, e.g., to layout a graph
according to the coordinates of a previous call to <code>Ugraph</code>. If both
the the lay and the coords arguments are not <code>NULL</code>, the lay argument
takes precedence
</p>
<p>The arguments <code>Lcex</code> and <code>PTcex</code> are only used when <code>legend =
TRUE</code>. If <code>prune = TRUE</code> the vertices of degree 0 (vertices not
implicated by any edge) are removed. For the colors supported by the
arguments <code>nodecol</code>, <code>Vcolor</code>, and <code>VBcolor</code>, see
<a href="https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf">https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf</a>.
</p>


<h3>Value</h3>

<p>An object of class list: </p>
<table>
<tr style="vertical-align: top;">
<td><code>pathStats</code></td>
<td>
<p>A <code>matrix</code> specifying
the paths, their respective lengths, and their respective contributions to
the marginal covariance between the endpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paths</code></td>
<td>
<p>A <code>list</code>
representing the respective paths as numeric vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Identifier</code></td>
<td>
<p>A
<code>data.frame</code> in which each numeric from <code>paths</code> is connected to an
identifier such as a variable name.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Eppstein (1998) describes a more sophisticated algorithm for finding
the top <em>k</em> shortest paths in a graph.
</p>


<h3>Author(s)</h3>

<p>Wessel N. van Wieringen, Carel F.W. Peeters &lt;carel.peeters@wur.nl&gt;
</p>


<h3>References</h3>

<p>Eppstein, D. (1998). Finding the k Shortest Paths. SIAM Journal
on computing 28: 652-673.
</p>
<p>Jones, B., and West, M. (2005). Covariance Decomposition in Undirected
Gaussian Graphical Models. Biometrika 92: 779-786.
</p>


<h3>See Also</h3>

<p><code>ridgeP</code>, <code>optPenalty.LOOCVauto</code>,
<code>sparsify</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Obtain some (high-dimensional) data
p &lt;- 25
n &lt;- 10
set.seed(333)
X &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
colnames(X) &lt;- letters[1:p]

## Obtain regularized precision under optimal penalty
OPT &lt;- optPenalty.LOOCVauto(X, lambdaMin = .5, lambdaMax = 30)

## Determine support regularized standardized precision under optimal penalty
PC0 &lt;- sparsify(OPT$optPrec, threshold = "localFDR")$sparseParCor

## Obtain information on mediating and moderating paths between nodes 14 and 23
pathStats &lt;- GGMpathStats(PC0, 14, 23, verbose = TRUE, prune = FALSE)
pathStats

</code></pre>


</div>