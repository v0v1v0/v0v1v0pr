<div class="container">

<table style="width: 100%;"><tr>
<td>Graph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>An undirected graph</h2>

<h3>Description</h3>

<p>An R6 class to represent a graph (from discrete mathematics).
</p>


<h3>Details</h3>

<p>Encapsulates and provides methods for computation and checking of
undirected graphs. Graphs are systems of vertices connected in pairs by
edges. A base class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Graph-new"><code>Graph$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-order"><code>Graph$order()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-size"><code>Graph$size()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertexes"><code>Graph$vertexes()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_along"><code>Graph$vertex_along()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_index"><code>Graph$vertex_index()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_at"><code>Graph$vertex_at()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-has_vertex"><code>Graph$has_vertex()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-vertex_label"><code>Graph$vertex_label()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edges"><code>Graph$edges()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_along"><code>Graph$edge_along()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_index"><code>Graph$edge_index()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_at"><code>Graph$edge_at()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-has_edge"><code>Graph$has_edge()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-edge_label"><code>Graph$edge_label()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-graph_adjacency_matrix"><code>Graph$graph_adjacency_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_simple"><code>Graph$is_simple()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_connected"><code>Graph$is_connected()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_acyclic"><code>Graph$is_acyclic()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-is_tree"><code>Graph$is_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-degree"><code>Graph$degree()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-neighbours"><code>Graph$neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-as_DOT"><code>Graph$as_DOT()</code></a>
</p>
</li>
<li> <p><a href="#method-Graph-clone"><code>Graph$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Graph-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>Graph</code> object from sets of nodes
and edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$new(V, E)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt>
<dd>
<p>An unordered set of Nodes, as a list.</p>
</dd>
<dt><code>E</code></dt>
<dd>
<p>An unordered set of Edges, as a list.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>Graph</code> object.
</p>


<hr>
<a id="method-Graph-order"></a>



<h4>Method <code>order()</code>
</h4>

<p>Return the order of the graph (number of vertices).
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$order()</pre></div>



<h5>Returns</h5>

<p>Order of the graph (integer).
</p>


<hr>
<a id="method-Graph-size"></a>



<h4>Method <code>size()</code>
</h4>

<p>Return the size of the graph (number of edges).
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$size()</pre></div>



<h5>Returns</h5>

<p>Size of the graph (integer).
</p>


<hr>
<a id="method-Graph-vertexes"></a>



<h4>Method <code>vertexes()</code>
</h4>

<p>A list of all the Node objects in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertexes()</pre></div>



<h5>Details</h5>

<p>The list of Node objects is returned in the same order as their
indexes understood by <code>vertex_index</code>, <code>vertex_at</code> and
<code>vertex_along</code>, which is not necessarily the same order in which
they were supplied in the <code>V</code> argument to <code>new</code>.
</p>


<hr>
<a id="method-Graph-vertex_along"></a>



<h4>Method <code>vertex_along()</code>
</h4>

<p>Sequence of vertex indices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_along()</pre></div>



<h5>Details</h5>

<p>Similar to <code>base::seq_along</code>, this function provides
the indices of the vertices in the graph. It is intended for use by
graph algorithms which iterate vertices.
</p>



<h5>Returns</h5>

<p>A numeric vector of indices from 1 to the order of the graph.
The vertex at index <code class="reqn">i</code> is not guaranteed to be the same vertex at
<code>V[[i]]</code> of the argument <code>V</code> to <code>new</code> (i.e., the order in
which the vertices are stored internally within the class may differ
from the order in which they were supplied).
</p>


<hr>
<a id="method-Graph-vertex_index"></a>



<h4>Method <code>vertex_index()</code>
</h4>

<p>Find the index of a vertex in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_index(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>A vertex, or list of vertexes.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Index of <var>v</var>. The index of vertex <code>v</code> is the one
used internally to the class object, which is not necessarily the same as
the order of vertices in the <code>V</code> argument of <code>new</code>. <code>NA</code>
if <var>v</var> is not a vertex, or is a vertex that is not in the graph.
</p>


<hr>
<a id="method-Graph-vertex_at"></a>



<h4>Method <code>vertex_at()</code>
</h4>

<p>Find the vertex at a given index.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_at(index, as_list = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt>
<dd>
<p>Index of vertex in the graph, as an integer, or vector of
integers.</p>
</dd>
<dt><code>as_list</code></dt>
<dd>
<p>Boolean. If TRUE the method returns list of Nodes,
even if the length of <code>index</code> is 1.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The inverse of function <code>vertex_index</code>. The function will
raise an abort signal if all the supplied indexes are not vertexes. The
function is vectorized, but for historical compatibility the return
object is a single <code>Node</code> if <code>index</code> is a scalar. The
return object can be guaranteed to be a list if <code>as_list</code> is set.
</p>



<h5>Returns</h5>

<p>Node at <code>index</code> if <code>index</code> is a scalar, a list of Nodes
at the values of <code>index</code> if <code>index</code> is a vector, or an empty
list if index is an empty array.
</p>


<hr>
<a id="method-Graph-has_vertex"></a>



<h4>Method <code>has_vertex()</code>
</h4>

<p>Test whether a vertex is an element of the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$has_vertex(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>Subject vertex.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>TRUE if v is an element of V(G).
</p>


<hr>
<a id="method-Graph-vertex_label"></a>



<h4>Method <code>vertex_label()</code>
</h4>

<p>Find label of vertexes at index i.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$vertex_label(iv)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iv</code></dt>
<dd>
<p>Index of vertex, or vector of indexes.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Label(s) of vertex at index i
</p>


<hr>
<a id="method-Graph-edges"></a>



<h4>Method <code>edges()</code>
</h4>

<p>A list of all the Edge objects in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edges()</pre></div>



<h5>Details</h5>

<p>The list of Edge objects is returned in the same order as their
indexes understood by <code>edge_index</code>, <code>edge_at</code> and
<code>edge_along</code>, which is not necessarily the same order in which they
were supplied in the <code>E</code> argument to <code>new</code>.
</p>


<hr>
<a id="method-Graph-edge_along"></a>



<h4>Method <code>edge_along()</code>
</h4>

<p>Sequence of edge indices.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_along()</pre></div>



<h5>Details</h5>

<p>Similar to <code>base::seq_along</code>, this function provides
the indices of the edges in the graph. It is intended for use by
graph algorithms which iterate edges. It is equivalent to
<code>seq_along(g$edges())</code>, where <code>g</code> is a graph.
</p>



<h5>Returns</h5>

<p>A numeric vector of indices from 1 to the size of the graph.
The edge at index <code class="reqn">i</code> is not guaranteed to be the same edge at
<code>E[[i]]</code> of the argument <code>E</code> to <code>new</code> (i.e., the order in
which the edges are stored internally within the class may differ
from the order in which they were supplied).
</p>


<hr>
<a id="method-Graph-edge_index"></a>



<h4>Method <code>edge_index()</code>
</h4>

<p>Find the index of an edge in a graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_index(e)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>e</code></dt>
<dd>
<p>An edge object, or list of edge objects.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The index of edge <code>e</code> is the one used internally to the
class object, which is not necessarily the same as the
order of edges in the <code>E</code> argument of <code>new</code>.
</p>



<h5>Returns</h5>

<p>Index of <code>e</code>. <code>NA</code> if <var>e</var> is not an edge, or is an
edge that is not in the graph.
</p>


<hr>
<a id="method-Graph-edge_at"></a>



<h4>Method <code>edge_at()</code>
</h4>

<p>Find the edge at a given index.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_at(index, as_list = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt>
<dd>
<p>Index of edge in the graph, as an integer, vector of
integers, or list of integers.</p>
</dd>
<dt><code>as_list</code></dt>
<dd>
<p>Boolean. If TRUE the method returns list of Edges,
even if the length of <code>index</code> is 1.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The inverse of function <code>edge_index</code>. The function will
raise an abort signal if the supplied index is not an edge. The
function is vectorized, but for historical compatibility the return
object is a single <code>Edge</code> if <code>index</code> is a scalar. The
return object can be guaranteed to be a list if <code>as_list</code> is set.
</p>



<h5>Returns</h5>

<p>The edge, or list of edges, with the specified index.
</p>


<hr>
<a id="method-Graph-has_edge"></a>



<h4>Method <code>has_edge()</code>
</h4>

<p>Test whether an edge is an element of the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$has_edge(e)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>e</code></dt>
<dd>
<p>Edge or list of edges.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Logical vector with each element <code>TRUE</code> if the corresponding
element of <code>e</code> is an element of <code class="reqn">E(G)</code>.
</p>


<hr>
<a id="method-Graph-edge_label"></a>



<h4>Method <code>edge_label()</code>
</h4>

<p>Find label of edge at index i
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$edge_label(ie)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ie</code></dt>
<dd>
<p>Index of edge, or vector of indexes.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Label of edge at index i, or character vector with the labels at
indexes <code>ie</code>.
</p>


<hr>
<a id="method-Graph-graph_adjacency_matrix"></a>



<h4>Method <code>graph_adjacency_matrix()</code>
</h4>

<p>Compute the adjacency matrix for the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$graph_adjacency_matrix(boolean = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>boolean</code></dt>
<dd>
<p>If <code>TRUE</code>, the adjacency matrix is logical, each
cell is {<code>FALSE</code>, <code>TRUE</code>}.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Each cell contains the
number of edges joining the two vertexes, with the convention of
self loops being counted twice, unless <code>binary</code> is <code>TRUE</code> when
cells are either 0 (not adjacent) or 1 (adjacent).
</p>



<h5>Returns</h5>

<p>A square integer matrix with the number of rows and columns
equal to the order of the graph. The rows and columns are labelled
with the node labels, if all the nodes in the graph have unique labels,
or the node indices if not.
</p>


<hr>
<a id="method-Graph-is_simple"></a>



<h4>Method <code>is_simple()</code>
</h4>

<p>Is this a simple graph?
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_simple()</pre></div>



<h5>Details</h5>

<p>A simple graph has no self loops or multi-edges.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if simple, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Graph-is_connected"></a>



<h4>Method <code>is_connected()</code>
</h4>

<p>Test whether the graph is connected.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_connected()</pre></div>



<h5>Details</h5>

<p>Graphs with no vertices are considered unconnected; graphs with
1 vertex are considered connected. Otherwise a graph is connected if all
nodes can be reached from an arbitrary starting point. Uses a depth first
search.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if connected, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Graph-is_acyclic"></a>



<h4>Method <code>is_acyclic()</code>
</h4>

<p>Checks for the presence of a cycle in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_acyclic()</pre></div>



<h5>Details</h5>

<p>Uses a depth-first search from each node to detect the
presence of back edges. A back edge is an edge from the current node
joining a previously detected (visited) node, that is not the parent
node of the current one.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if no cycles detected.
</p>


<hr>
<a id="method-Graph-is_tree"></a>



<h4>Method <code>is_tree()</code>
</h4>

<p>Compute whether the graph is connected and acyclic.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$is_tree()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the graph is a tree; <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Graph-degree"></a>



<h4>Method <code>degree()</code>
</h4>

<p>The degree of a vertex in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$degree(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>The subject node.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The number of incident edges.
</p>



<h5>Returns</h5>

<p>Degree of the vertex, integer.
</p>


<hr>
<a id="method-Graph-neighbours"></a>



<h4>Method <code>neighbours()</code>
</h4>

<p>Find the neighbours of a node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$neighbours(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>The subject node (scalar, not a list).</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>A property of the graph, not the node. Does not include self,
even in the case of a loop to self.
</p>



<h5>Returns</h5>

<p>A list of nodes which are joined to the subject.
</p>


<hr>
<a id="method-Graph-as_DOT"></a>



<h4>Method <code>as_DOT()</code>
</h4>

<p>Export a representation of the graph in DOT format.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$as_DOT()</pre></div>



<h5>Details</h5>

<p>Writes the representation in the <code>graphviz</code> DOT language
(<a href="https://graphviz.org/doc/info/lang.html">https://graphviz.org/doc/info/lang.html</a>) for drawing with one
of the <code>graphviz</code> tools including <code>dot</code> (Gansner, 1993).
</p>



<h5>Returns</h5>

<p>A character vector. Intended for passing to <code>writeLines</code>
for saving as a text file.
</p>


<hr>
<a id="method-Graph-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Graph$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Gansner ER, Koutsofios E, North SC, Vo K-P. A technique for drawing
directed graphs. <em>IEEE Transactions on Software Engineering</em>,
1993;<b>19</b>:214â€“30, <a href="https://doi.org/10.1109/32.221135">doi:10.1109/32.221135</a>.
</p>
<p>Gross JL, Yellen J, Zhang P. Handbook of Graph Theory. Second edition,
Chapman and Hall/CRC.; 2013, <a href="https://doi.org/10.1201/b16132">doi:10.1201/b16132</a>

</p>


</div>