<div class="container">

<table style="width: 100%;"><tr>
<td>margint.cl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Classic marginal integration procedures for additive models</h2>

<h3>Description</h3>

<p>This function computes the standard marginal integration procedures for additive models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">margint.cl(
  formula,
  data,
  subset,
  point = NULL,
  windows,
  epsilon = 1e-06,
  prob = NULL,
  type = "0",
  degree = NULL,
  qderivate = FALSE,
  orderkernel = 2,
  Qmeasure = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by as.data.frame to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>,  typically the environment from which the function was called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point</code></td>
<td>
<p>a matrix of points where predictions will be computed and returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>windows</code></td>
<td>
<p>a vector or a squared matrix of bandwidths for the smoothing estimation procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>convergence criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>a vector of probabilities of observing each response (n). Defaults to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>three different type of estimators can be selected: type <code>'0'</code> (local constant on all the covariates), type <code>'1'</code> (local linear smoother on all the covariates), type <code>'alpha'</code> (local polynomial smoother only on the direction of interest).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>degree of the local polynomial smoother in the direction of interest when using the estimator of type <code>'alpha'</code>. Defaults to <code>NULL</code> for the case when using estimators of type <code>'0'</code> or <code>'1'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qderivate</code></td>
<td>
<p>if TRUE, it calculates <code>g^(q+1)/(q+1)!</code> for each component only for the type <code>'alpha'</code> method. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orderkernel</code></td>
<td>
<p>order of the kernel used in the nuisance directions when using the estimator of type <code>'alpha'</code>. Defaults to <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qmeasure</code></td>
<td>
<p>a matrix of points where the integration procedure ocurrs. Defaults to <code>NULL</code> for calcuting the integrals over the sample.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes three types of classical marginal integration procedures for additive models, that is, considering a squared loss function.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Estimate for the intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.matrix</code></td>
<td>
<p>Matrix of estimated additive components (n by p).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction </code></td>
<td>
<p>Matrix of estimated additive components for the points listed in the argument point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mul</code></td>
<td>
<p>A vector of size p showing in each component the estimated intercept that considers only that direction of interest when using the type <code>'alpha'</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g.derivative </code></td>
<td>
<p>Matrix of estimated derivatives of the additive components (only when qderivate is <code>TRUE</code>) (n by p).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction.derivate </code></td>
<td>
<p>Matrix of estimated derivatives of the additive components for the points listed in the argument point (only when qderivate is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xp</code></td>
<td>
<p>Matrix of explanatory variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yp</code></td>
<td>
<p>Vector of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Model formula</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Alejandra Martinez, <a href="mailto:ale_m_martinez@hotmail.com">ale_m_martinez@hotmail.com</a>, Matias Salibian-Barrera
</p>


<h3>References</h3>

<p>Chen R., Hardle W., Linton O.B. and Severance-Lossin E. (1996). Nonparametric estimation of additive separable regression models. Physica-Verlag HD, Switzerland.
Linton O. and Nielsen J. (1995). A kernel method of estimating structured nonparametric regression based on marginal integration. Biometrika, 82(1), 93-101.
Severance-Lossin E. and Sperlich S. (1999). Estimation of derivatives for additive separable models. Statistics, 33(3), 241-265.
Tjostheim D. and Auestad B. (1994). Nonparametric identification of nonlinear time series: Selecting significant lags. Journal of the American Statistical Association, 89(428), 1410-1430.
</p>


<h3>Examples</h3>

<pre><code class="language-R">function.g1 &lt;- function(x1) 24*(x1-1/2)^2-2
function.g2 &lt;- function(x2) 2*pi*sin(pi*x2)-4
n &lt;- 150
x1 &lt;- runif(n)
x2 &lt;- runif(n)
X &lt;- cbind(x1, x2)
eps &lt;- rnorm(n,0,sd=0.15)
regresion &lt;- function.g1(x1) + function.g2(x2)
y &lt;- regresion + eps
bandw &lt;- matrix(0.25,2,2)
set.seed(8090)
nQ &lt;- 80 
Qmeasure &lt;- matrix(runif(nQ*2), nQ, 2)
fit.cl &lt;- margint.cl(y ~ X, windows=bandw, type='alpha', degree=1, Qmeasure=Qmeasure)

</code></pre>


</div>