<div class="container">

<table style="width: 100%;"><tr>
<td>primeFactorize</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Vectorized Prime Factorization
</h2>

<h3>Description</h3>

<p>Implementation of Pollard's rho algorithm for generating the prime factorization. The algorithm is based on the "factorize.c" source file from the gmp library found here <a href="https://gmplib.org">https://gmplib.org</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">primeFactorize(v, namedList = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Vector of integers or numeric values. Non-integral values will be cured to whole numbers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namedList</code></td>
<td>
<p>Logical flag. If <code>TRUE</code> and the <code>length(v) &gt; 1</code>, a named list is returned. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>As noted in the Description section above, this algorithm is based on the "factorize.c" source code from the gmp library. Much of the code in RcppAlgos::primeFactorize is a straightforward translation from multiple precision C data types to standard C++ data types. A crucial part of the algorithm's efficiency is based on quickly determining <a href="https://en.wikipedia.org/wiki/Primality_test">primality</a>, which is easily computed with gmp. However, with standard C++, this is quite challenging. Much of the research for RcppAlgos::primeFactorize was focused on developing an algorithm that could accurately and efficiently compute primality.
</p>
<p>For more details, see the documentation for <code>isPrimeRcpp</code>.
</p>


<h3>Value</h3>


<ul>
<li>
<p>Returns an unnamed vector if <code>length(v) == 1</code> regardless of the value of <code>namedList</code>. If <code class="reqn">v &lt; 2^{31}</code>, the class of the returned vector will be integer, otherwise the class will be numeric.
</p>
</li>
<li>
<p>If <code>length(v) &gt; 1</code>, a named/unnamed list of vectors will be returned. If <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, the class of each vector will be integer, otherwise the class will be numeric.
</p>
</li>
</ul>
<h3>Note</h3>

<p>The maximum value for each element in <code class="reqn">v</code> is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm">Pollard's rho algorithm</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Miller-Rabin_primality_test">Miller-Rabin primality test</a>
</p>
</li>
<li>
<p><a href="https://codereview.stackexchange.com/questions/186751/accurate-modular-arithmetic-with-double-precision">Accurate Modular Arithmetic with Double Precision</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>primeFactorizeSieve</code>, <code>factorize</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Get the prime factorization of a single number
primeFactorize(10^8)

## Or get the prime factorization of many numbers
set.seed(29)
myVec &lt;- sample(-1000000:1000000, 1000)
system.time(pFacs &lt;- primeFactorize(myVec))

## Return named list
pFacsWithNames &lt;- primeFactorize(myVec, namedList = TRUE)

## Using nThreads
system.time(primeFactorize(myVec, nThreads = 2))
</code></pre>


</div>