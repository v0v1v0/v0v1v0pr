<div class="container">

<table style="width: 100%;"><tr>
<td>build_table</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a table from a layout and data</h2>

<h3>Description</h3>

<p>Layouts are used to describe a table pre-data. <code>build_table</code> is used to create a table
using a layout and a dataset.
</p>


<h3>Usage</h3>

<pre><code class="language-R">build_table(
  lyt,
  df,
  alt_counts_df = NULL,
  col_counts = NULL,
  col_total = if (is.null(alt_counts_df)) nrow(df) else nrow(alt_counts_df),
  topleft = NULL,
  hsep = default_hsep(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lyt</code></td>
<td>
<p>(<code>PreDataTableLayouts</code>)<br> layout object pre-data used for tabulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>(<code>data.frame</code> or <code>tibble</code>)<br> dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt_counts_df</code></td>
<td>
<p>(<code>data.frame</code> or <code>tibble</code>)<br> alternative full dataset the rtables framework will use
<em>only</em> when calculating column counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_counts</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a> if non-<code>NULL</code>, column counts
<em>for leaf-columns only</em> which override those calculated automatically during tabulation. Must specify
"counts" for <em>all</em> leaf-columns if non-<code>NULL</code>. <code>NA</code> elements will be replaced with the automatically
calculated counts. Turns on display of leaf-column counts when non-<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_total</code></td>
<td>
<p>(<code>integer(1)</code>)<br> the total observations across all columns. Defaults to <code>nrow(df)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topleft</code></td>
<td>
<p>(<code>character</code>)<br> override values for the "top left" material to be displayed during printing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hsep</code></td>
<td>
<p>(<code>string</code>)<br> set of characters to be repeated as the separator between the header and body of
the table when rendered as text. Defaults to a connected horizontal line (unicode 2014) in locals that use a UTF
charset, and to <code>-</code> elsewhere (with a once per session warning). See <code>formatters::set_default_hsep()</code> for further
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>alt_counts_df</code> is specified, column counts are calculated by applying the exact column subsetting
expressions determined when applying column splitting to the main data (<code>df</code>) to <code>alt_counts_df</code> and
counting the observations in each resulting subset.
</p>
<p>In particular, this means that in the case of splitting based on cuts of the data, any dynamic cuts will have
been calculated based on <code>df</code> and simply re-used for the count calculation.
</p>


<h3>Value</h3>

<p>A <code>TableTree</code> or <code>ElementaryTable</code> object representing the table created by performing the tabulations
declared in <code>lyt</code> to the data <code>df</code>.
</p>


<h3>Note</h3>

<p>When overriding the column counts or totals care must be taken that, e.g., <code>length()</code> or <code>nrow()</code> are not called
within tabulation functions, because those will NOT give the overridden counts. Writing/using tabulation
functions which accept <code>.N_col</code> and <code>.N_total</code> or do not rely on column counts at all (even implicitly) is the
only way to ensure overridden counts are fully respected.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class="language-R">lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  analyze("Sepal.Length", afun = function(x) {
    list(
      "mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "range" = diff(range(x))
    )
  })
lyt

tbl &lt;- build_table(lyt, iris)
tbl

# analyze multiple variables
lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"), afun = function(x) {
    list(
      "mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "range" = diff(range(x))
    )
  })

tbl2 &lt;- build_table(lyt2, iris)
tbl2

# an example more relevant for clinical trials with column counts
lyt3 &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = function(x) {
    setNames(as.list(fivenum(x)), c(
      "minimum", "lower-hinge", "median",
      "upper-hinge", "maximum"
    ))
  })

tbl3 &lt;- build_table(lyt3, DM)
tbl3

tbl4 &lt;- build_table(lyt3, subset(DM, AGE &gt; 40))
tbl4

# with column counts calculated based on different data
miniDM &lt;- DM[sample(1:NROW(DM), 100), ]
tbl5 &lt;- build_table(lyt3, DM, alt_counts_df = miniDM)
tbl5

tbl6 &lt;- build_table(lyt3, DM, col_counts = 1:3)
tbl6

</code></pre>


</div>