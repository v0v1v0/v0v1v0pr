<div class="container">

<table style="width: 100%;"><tr>
<td>robest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Optimally robust estimation </h2>

<h3>Description</h3>

<p>Function to compute optimally robust estimates for L2-differentiable
parametric families via k-step construction.
</p>


<h3>Usage</h3>

<pre><code class="language-R">robest(x, L2Fam,  fsCor = 1, risk = asMSE(), steps = 1L,
        verbose = NULL, OptOrIter = "iterate", nbCtrl = gennbCtrl(),
        startCtrl = genstartCtrl(), startICCtrl = genstartICCtrl(),
        kStepCtrl = genkStepCtrl(), na.rm = TRUE, ..., debug = FALSE,
        withTimings = FALSE, diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> sample </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsCor</code></td>
<td>
<p> positive real: factor used to correct the neighborhood radius;
see details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>"RiskType"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p> positive integer: number of steps used for k-steps construction </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbCtrl</code></td>
<td>
<p>a list specifying input concerning the used neighborhood;
to be generated by a respective call to <code>gennbCtrl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startCtrl</code></td>
<td>
<p>a list specifying input concerning the used starting estimator;
to be generated by a respective call to <code>genstartCtrl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startICCtrl</code></td>
<td>
<p>a list specifying input concerning the call to
<code>getStartIC</code> which returns the starting influence curve;
to be generated by a respective call to <code>genstartICCtrl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kStepCtrl</code></td>
<td>
<p>a list specifying input concerning the used variant of
a kstepEstimator;
to be generated by a respective call to <code>genkStepCtrl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>logical: if <code>TRUE</code>, only the respective calls within the
function are generated for debugging purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withTimings</code></td>
<td>
<p>logical: if <code>TRUE</code>, separate (and aggregate)
timings for the three steps evaluating the starting value, finding
the starting influence curve, and evaluating the k-step estimator is
issued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as attributes <code>kStepDiagnostic</code> (for the kStepEstimator-step)
and <code>diagnostic</code> for the remaining steps of the return value
of <code>robest</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A new, more structured interface to the former function <code>roptest</code>.
For details, see this function.
</p>
<p>In some respects this functions allows for more granular arguments,
in the sense that the different steps (a) computation of the inital estimator,
resp. (a') in case <code>initial.est</code> is missing computation of the initial
MDE, (b) computation of the optimal IC and (c) computation of the k-step
estimator each can have individial arguments <code>E.arglist</code> to be
passed on to calls to expectation operator <code>E</code> within each step.
</p>
<p>These different arguments are passed through the input generating functions
<code>genstartCtrl</code>,
<code>genstartICCtrl</code>, and
<code>kStepCtrl</code>
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there are attributes <code>diagnostic</code>
and <code>kStepDiagnostic</code> attached to the return value, which may be inspected
and assessed through <code>showDiagnostic</code> and
<code>getDiagnostic</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>. In addition, it has
an attribute <code>"timings"</code> where computation time is stored.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br>
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P. (2010): R package distrMod: 
Object-Oriented Implementation of Probability Models. 
J. Statist. Softw.  <b>35</b>(10), 1–27. <a href="https://doi.org/10.18637/jss.v035.i10">doi:10.18637/jss.v035.i10</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333–354. 
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. Statistical Methods and Applications <b>17</b>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2001) The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>
</p>


<h3>See Also</h3>

 <p><code>roblox</code>, 
<code>L2ParamFamily-class</code>
<code>UncondNeighborhood-class</code>,
<code>RiskType-class</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## Don't test to reduce check time on CRAN

#############################
## 1. Binomial data
#############################
## generate a sample of contaminated data
set.seed(123)
ind &lt;- rbinom(100, size=1, prob=0.05)
x &lt;- rbinom(100, size=25, prob=(1-ind)*0.25 + ind*0.9)

## Family
BF &lt;- BinomFamily(size = 25)
## ML-estimate
MLest &lt;- MLEstimator(x, BF)
estimate(MLest)
confint(MLest)

## compute optimally robust estimator (known contamination)
nb &lt;- gennbCtrl(eps=0.05)
robest1 &lt;- robest(x, BF, nbCtrl = nb, steps = 3)
estimate(robest1)

confint(robest1, method = symmetricBias())
## neglecting bias
confint(robest1)
plot(pIC(robest1))
tmp &lt;- qqplot(x, robest1, cex.pch=1.5, exp.cex2.pch = -.25,
              exp.fadcol.pch = .55, jit.fac=.9)

## compute optimally robust estimator (unknown contamination)
nb2 &lt;- gennbCtrl(eps.lower = 0, eps.upper = 0.2)
robest2 &lt;- robest(x, BF, nbCtrl = nb2, steps = 3)
estimate(robest2)
confint(robest2, method = symmetricBias())
plot(pIC(robest2))

## total variation neighborhoods (known deviation)
nb3 &lt;- gennbCtrl(eps = 0.025, neighbor = TotalVarNeighborhood())
robest3 &lt;- robest(x, BF, nbCtrl = nb3, steps = 3)
estimate(robest3)
confint(robest3, method = symmetricBias())
plot(pIC(robest3))

## total variation neighborhoods (unknown deviation)
nb4 &lt;- gennbCtrl(eps.lower = 0, eps.upper = 0.1,
                 neighbor = TotalVarNeighborhood())
robest3 &lt;- robest(x, BF, nbCtrl = nb4, steps = 3)
robest4 &lt;- robest(x, BinomFamily(size = 25), nbCtrl = nb4, steps = 3)
estimate(robest4)
confint(robest4, method = symmetricBias())
plot(pIC(robest4))


#############################
## 2. Poisson data
#############################
## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
x &lt;- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
       rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
       rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))

## Family
PF &lt;- PoisFamily()

## ML-estimate
MLest &lt;- MLEstimator(x, PF)
estimate(MLest)
confint(MLest)

## compute optimally robust estimator (unknown contamination)
nb1 &lt;- gennbCtrl(eps.upper = 0.1)
robest &lt;- robest(x, PF, nbCtrl = nb1, steps = 3)
estimate(robest)

confint(robest, symmetricBias())
plot(pIC(robest))
tmp &lt;- qqplot(x, robest, cex.pch=1.5, exp.cex2.pch = -.25,
              exp.fadcol.pch = .55, jit.fac=.9)
 
## total variation neighborhoods (unknown deviation)
nb2 &lt;- gennbCtrl(eps.upper = 0.05, neighbor = TotalVarNeighborhood())
robest1 &lt;- robest(x, PF, nbCtrl = nb2, steps = 3)
estimate(robest1)
confint(robest1, symmetricBias())
plot(pIC(robest1))


#############################
## 3. Normal (Gaussian) location and scale
#############################

## this example of a two dimensional parameter
## to be estimated will need more time than 
## 5 seconds to run 
## you can find it in 
## system.file("scripts", "examples_taking_longer.R", 
##              package="ROptEst")

</code></pre>


</div>