<div class="container">

<table style="width: 100%;"><tr>
<td>ETagMiddleware</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates ETag middleware object</h2>

<h3>Description</h3>

<p>Adds ETag to an Application. <br></p>
<p>ETags are header information that enable the caching of content.
If enabled, RestRserve will return an ETag (eg a hash of a file) alongside
the last time it was modified.
When a request is sent, additional headers such as
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match"><code>If-None-Match</code></a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match"><code>If-Match</code></a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since"><code>If-Modified-Since</code></a>,
and
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-UnModified-Since"><code>If-Unmodified-Since</code></a>,
can be passed to the server as well.
</p>
<p>If the conditions are met (different hash in case of a <code>If-None-Match</code> header
or a later file modification in case of a given <code>If-Modified-Since</code> header),
the server does not send the requested file but returns a
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304">304</a> status
code, indicating, that the data on the requesting device is up-to-date.
</p>
<p>Note that if both headers are provided, the <code>If-None-Match</code> header takes
precedence.
</p>
<p>Furthermore, the middleware also supports the headers <code>If-Match</code>, which
returns the object if the hash matches (it also supports "*" to always return
the file), as well as <code>If-Unmodified-Since</code>, which returns the object if it
has not been modified since a certain time.
If the conditions are not met, a
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412">412</a> status
code is returned (Precondition Failed).
See examples below.
</p>


<h3>Super class</h3>

<p><code>RestRserve::Middleware</code> -&gt; <code>EtagMiddleware</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>hash_function</code></dt>
<dd>
<p>Function that takes an object or file and computes
the hash of it</p>
</dd>
<dt><code>last_modified_function</code></dt>
<dd>
<p>Function that takes an object or file and
computes the last time it was modified</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EtagMiddleware-new"><code>ETagMiddleware$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EtagMiddleware-clone"><code>ETagMiddleware$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-EtagMiddleware-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates ETag middleware object
</p>


<h5>Usage</h5>

<div class="r"><pre>ETagMiddleware$new(
  routes = "/",
  match = "partial",
  id = "ETagMiddleware",
  hash_function = function(body) {
     if ("file" %in% names(body)) {
        
    digest::digest(file = body[["file"]], algo = "crc32")
     }
     else {
        
    digest::digest(body, algo = "crc32")
     }
 },
  last_modified_function = function(body) {
     if ("file" %in% names(body)) {
       
     as.POSIXlt(file.info(body[["file"]])[["mtime"]], tz = "GMT")
     }
     else {
    
        as.POSIXlt(Sys.time(), tz = "GMT")
     }
 }
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>routes</code></dt>
<dd>
<p>Routes paths to protect.</p>
</dd>
<dt><code>match</code></dt>
<dd>
<p>How routes will be matched: exact or partial (as prefix).</p>
</dd>
<dt><code>id</code></dt>
<dd>
<p>Middleware id.</p>
</dd>
<dt><code>hash_function</code></dt>
<dd>
<p>a function that generates the ETag hash.
The function takes the body of the response and returns a single
character. Default is crc32 using digest::digest.</p>
</dd>
<dt><code>last_modified_function</code></dt>
<dd>
<p>a function that takes the body of the
response and returns the last time this was changed. The default is to
take the mtime (last time the file was modified) if its a file,
if the body does not contain a file, the current time is returned (
resulting in no caching)</p>
</dd>
</dl>
</div>


<hr>
<a id="method-EtagMiddleware-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ETagMiddleware$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p><a href="https://developer.mozilla.org/en/docs/Web/HTTP/Headers/ETag">MDN</a>
</p>


<h3>See Also</h3>

<p>Middleware Application
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################################
# setup a static directory with ETag caching

static_dir = file.path(tempdir(), "static")
if (!dir.exists(static_dir)) dir.create(static_dir)

file_path = file.path(static_dir, "example.txt")
writeLines("Hello World", file_path)

# get the time the file was last modified in UTC time
last_modified = as.POSIXlt(file.info(file_path)[["mtime"]], tz = "UTC")
file_hash = digest::digest(file = file_path, algo = "crc32")

time_fmt = "%a, %d %b %Y %H:%M:%S GMT"



#############################################################################
# setup the Application with the ETag Middleware
app = Application$new()
app$append_middleware(ETagMiddleware$new())
app$add_static(path = "/", static_dir)



#############################################################################
# Example Requests

# Request the file returns the file with ETag headers
req = Request$new(path = "/example.txt")
# note that it also returns the Last-Modified and ETag headers
app$process_request(req)


# provide matching hash of the file in the If-None-Match header to check Etag
# =&gt; 304 Not Modified (Can be cached)
req = Request$new(path = "/example.txt",
                  headers = list("If-None-Match" = file_hash))
# note status_code 304 Not Modified
app$process_request(req)


# provide a wrong hash, returns the file normally
req = Request$new(path = "/example.txt",
                  headers = list("If-None-Match" = "WRONG HASH"))
app$process_request(req)


# alternatively, you can provide a timestamp in the If-Modified-Since header
# =&gt; 304 Not Modified (Can be cached)
modified_since = format(last_modified + 1, time_fmt)
req = Request$new(path = "/example.txt",
                  headers = list("If-Modified-Since" = modified_since))
app$process_request(req)


# provide both headers: If-None-Match takes precedence
# in this case:
#  - if none match =&gt; modified (No cache)
#  - if modified since =&gt; NOT MODIFIED (cached)
# =&gt; Overall: modified = no cache
modified_since = format(last_modified + 1, time_fmt)
req = Request$new(path = "/example.txt",
                  headers = list("If-None-Match" = "CLEARLY WRONG",
                                 "If-Modified-Since" = modified_since))
app$process_request(req)


# provide matching hash of the file in the If-Match header to check Etag
# =&gt; 412 Precondition Failed
req = Request$new(path = "/example.txt",
                  headers = list("If-Match" = "OTHER HASH"))
# note status_code 412 Precondition Failed
app$process_request(req)


# Use If-Unmodified-Since
unmodified_since = format(last_modified - 1, time_fmt)
req = Request$new(path = "/example.txt",
                  headers = list("If-Unmodified-Since" = unmodified_since)
)
# note status_code 412 Precondition Failed
app$process_request(req)



#############################################################################

# use an alternative hash function (use name of the file)
hash_on_filename = function(x) x
# also use an alternate last_modified time function
always_1900 = function(x) as.POSIXlt("1900-01-01 12:34:56", tz = "GMT")


# setup the app again
app = Application$new(middleware = list(
  ETagMiddleware$new(hash_function = hash_on_filename,
                     last_modified_function = always_1900)
))
app$add_static(path = "/", file_path = static_dir)


# test the requests
req = Request$new(path = "/example.txt")
(res = app$process_request(req))

filename = res$body[["file"]]
req = Request$new(path = "/example.txt",
                  headers = list("If-None-Match" = filename))
app$process_request(req)
</code></pre>


</div>