<div class="container">

<table style="width: 100%;"><tr>
<td>covOGK</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Orthogonalized Gnanadesikan-Kettenring (OGK) Covariance Matrix Estimation</h2>

<h3>Description</h3>

<p>Computes the orthogonalized pairwise covariance matrix estimate described in
in Maronna and Zamar (2002).  The pairwise proposal goes back to
Gnanadesikan and Kettenring (1972).
</p>


<h3>Usage</h3>

<pre><code class="language-R">covOGK(X, n.iter = 2, sigmamu, rcov = covGK, weight.fn = hard.rejection,
       keep.data = FALSE, ...)

covGK (x, y, scalefn = scaleTau2, ...)
s_mad(x, mu.too = FALSE, na.rm = FALSE)
s_IQR(x, mu.too = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>data in something that can be coerced into a numeric matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>number of orthogonalization iterations.  Usually 1 or 2;
values greater than 2 are unlikely to have any significant effect on
the estimate (other than increasing the computing time).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmamu, scalefn</code></td>
<td>
<p>a function that computes univariate robust
location and scale estimates.  By default it should return a single
numeric value containing the robust scale (standard deviation)
estimate.  When <code>mu.too</code> is true, <code>sigmamu()</code> should
return a numeric vector of length 2 containing robust location and
scale estimates.  See <code>scaleTau2</code>, <code>s_Qn</code>,
<code>s_Sn</code>, <code>s_mad</code> or <code>s_IQR</code> for examples to be
used as <code>sigmamu</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rcov</code></td>
<td>
<p>function that computes a robust covariance estimate
between two vectors.  The default, Gnanadesikan-Kettenring's
<code>covGK</code>, is simply <code class="reqn">(s^2(X+Y) - s^2(X-Y))/4</code> where
<code class="reqn">s()</code> is the scale estimate <code>sigmamu()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.fn</code></td>
<td>
<p>a function of the robust distances and the number of
variables <code class="reqn">p</code> to compute the weights used in the reweighting step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.data</code></td>
<td>
<p>logical indicating if the (untransformed) data matrix
<code>X</code> should be kept as part of the result.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments; for <code>covOGK</code> to be passed to
<code>sigmamu()</code> and <code>weight.fn()</code>; for <code>covGK</code> passed to <code>scalefn</code>.</p>
</td>
</tr>
</table>
<table><tr style="vertical-align: top;">
<td><code>x,y</code></td>
<td>
<p>numeric vectors of the same length, the covariance of which
is sought in <code>covGK</code> (or the scale, in <code>s_mad</code> or
<code>s_IQR</code>).</p>
</td>
</tr></table>
<table>
<tr style="vertical-align: top;">
<td><code>mu.too</code></td>
<td>
<p>logical indicating if both location and scale should be
returned or just the scale (when <code>mu.too=FALSE</code> as by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>if <code>TRUE</code> then <code>NA</code> values are stripped
from <code>x</code> before computation takes place.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Typical default values for the <em>function</em> arguments
<code>sigmamu</code>, <code>rcov</code>, and <code>weight.fn</code>, are
available as well, see the <em>Examples</em> below,
<b>but</b> their names and calling sequences are
still subject to discussion and may be changed in the future.
</p>
<p>The current default, <code>weight.fn = hard.rejection</code> corresponds to
the proposition in the litterature, but Martin Maechler strongly
believes that the hard threshold currently in use is too arbitrary,
and further that <em>soft</em> thresholding should be used instead, anyway.
</p>


<h3>Value</h3>

<p><code>covOGK()</code> currently returns a list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>robust location: numeric vector of length <code class="reqn">p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>robust covariance matrix estimate: <code class="reqn">p\times p</code>
matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wcenter, wcov</code></td>
<td>
<p>re-<b>w</b>eighted versions of <code>center</code> and
<code>cov</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>the robustness weights used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distances</code></td>
<td>
<p>the mahalanobis distances computed using
<code>center</code> and <code>cov</code>.</p>
</td>
</tr>
</table>
<p>......
<br><b>but note that this might be radically changed to returning an
S4 classed object!</b>
</p>
<p><code>covGK()</code> is a trivial 1-line function returning the covariance
estimate
</p>
<p style="text-align: center;"><code class="reqn">\hat c(x,y) = \left(\hat \sigma(x+y)^2 - \hat \sigma(x-y)^2 \right)/4,%
        </code>
</p>

<p>where <code class="reqn">\hat \sigma(u)</code> is the scale estimate of <code class="reqn">u</code>
specified by <code>scalefn</code>.
</p>
<p><code>s_mad()</code>, and <code>s_IQR()</code> return the
scale estimates <code>mad</code> or <code>IQR</code>
respectively, where the <code>s_*</code> functions return a length-2 vector
(mu, sig) when <code>mu.too = TRUE</code>, see also <code>scaleTau2</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:konis@stats.ox.ac.uk">konis@stats.ox.ac.uk</a>, with modifications by
Martin Maechler.</p>


<h3>References</h3>

<p>Maronna, R.A. and Zamar, R.H. (2002)
Robust estimates of location and dispersion of high-dimensional datasets;
<em>Technometrics</em> <b>44</b>(4), 307–317.
</p>
<p>Gnanadesikan, R. and John R. Kettenring (1972)
Robust estimates, residuals, and outlier detection with multiresponse data.
<em>Biometrics</em> <b>28</b>, 81–124.
</p>


<h3>See Also</h3>

<p><code>scaleTau2</code>,
<code>covMcd</code>, <code>cov.rob</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(hbk)
hbk.x &lt;- data.matrix(hbk[, 1:3])

cO1 &lt;- covOGK(hbk.x, sigmamu = scaleTau2)
cO2 &lt;- covOGK(hbk.x, sigmamu = s_Qn)
cO3 &lt;- covOGK(hbk.x, sigmamu = s_Sn)
cO4 &lt;- covOGK(hbk.x, sigmamu = s_mad)
cO5 &lt;- covOGK(hbk.x, sigmamu = s_IQR)



data(toxicity)
cO1tox &lt;- covOGK(toxicity, sigmamu = scaleTau2)
cO2tox &lt;- covOGK(toxicity, sigmamu = s_Qn)

## nice formatting of correlation matrices:
as.dist(round(cov2cor(cO1tox$cov), 2))
as.dist(round(cov2cor(cO2tox$cov), 2))

## "graphical"
symnum(cov2cor(cO1tox$cov))
symnum(cov2cor(cO2tox$cov), legend=FALSE)
</code></pre>


</div>