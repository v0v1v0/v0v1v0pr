<div class="container">

<table style="width: 100%;"><tr>
<td>rem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit a Relational Event Model to Single or Multiple Sequence Data
</h2>

<h3>Description</h3>

<p>Fits a relational event model to general event sequence data, using either the ordinal or interval time likelihoods.  Maximum likelihood and posterior mode methods are supported, as are local (per sequence) parameters and sequences with exogenous events.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rem(eventlist, statslist, supplist = NULL, timing = c("ordinal", 
    "interval"), estimator = c("BPM", "MLE", "BMCMC", "BSIR"), 
    prior.param = list(mu = 0, sigma = 1000, nu = 4), mcmc.draws = 1500, 
    mcmc.thin = 25, mcmc.burn = 2000, mcmc.chains = 3, mcmc.sd = 0.05, 
    mcmc.ind.int = 50, mcmc.ind.sd = 10, sir.draws = 1000, 
    sir.expand = 10, sir.nu = 4, verbose = FALSE)
## S3 method for class 'rem'
print(x, ...)
## S3 method for class 'rem'
summary(object, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>eventlist</code></td>
<td>

<p>a two-column matrix (or list thereof) containing the observed event sequence and timing information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statslist</code></td>
<td>

<p>an event number by event type by statistic array (or list thereof) containing the sufficient statistics for the model to be estimated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>supplist</code></td>
<td>

<p>an event number by event type logical array (or list thereof) indicating which events were potentially observable at each point in the event history.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timing</code></td>
<td>

<p>the type of timing information to be used during estimation; <code>"ordinal"</code> indicates that only event order should be employed, while <code>"interval"</code> uses the exact inter-event times.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>

<p>the type of estimator to be used; <code>"MLE"</code> selects maximum likelihood estimation, <code>"BPM"</code> selects Bayesian posterior mode estimation, <code>"BMCMC"</code> selects Bayesian posterior mean estimation via MCMC, and <code>"BSIR"</code> selects Bayesian posterior mean estimation via simulated importance resampling. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.param</code></td>
<td>

<p>for the Bayesian methods, the prior parameters to be employed; currently, these are the location, scale, and degrees of freedom parameters for independent t priors, and may be given as vectors (to set different priors for each parameter).  (By default, a diffuse, heavy-tailed t distribution is used.)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.draws</code></td>
<td>

<p>total number of posterior draws to take when using the BMCMC method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.thin</code></td>
<td>

<p>thinning interval for MCMC draws (BMCMC method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.burn</code></td>
<td>

<p>number of burn-in iterations to use for each MCMC chain (BMCMC method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.chains</code></td>
<td>

<p>number of MCMC chains to use (BMCMC method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.sd</code></td>
<td>

<p>standard deviation for the random walk Metropolis sampler (BMCMC method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.ind.int</code></td>
<td>

<p>interval at which to take draws from the independence sampler (versus the random walk Metropolis sampler).  (BMCMC method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc.ind.sd</code></td>
<td>

<p>standard deviation for the MCMC independence sampler (BMCMC method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sir.draws</code></td>
<td>

<p>number of SIR draws to take (BSIR method).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sir.expand</code></td>
<td>

<p>expansion factor for the SIR sample; intitial sample size is <code>sir.draws</code> multiplied by <code>sir.expand</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sir.nu</code></td>
<td>

<p>degrees of freedom parameter for the SIR sampling distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>logical; should verbose progress information be displayed?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> an object of class <code>rem</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> an object of class <code>rem</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>rem</code> fits a general relational event model to one or more event sequences (or “histories”), using either full interval or ordinal timing information.  Although particularly applicable to “egocentric” relational event data, <code>rem</code> can be used to fit nearly any standard relational event model; the function depends heavily on user-supplied statistics, however, and thus lacks the built-in functionality of a routine like <code>rem.dyad</code>.  Four estimation methods are currently supported: maximum likelihood estimation, Bayesian posterior mode estimation, Bayesian posterior mean estimation via MCMC, and Bayesian posterior mean estimation via sampling importance resampling (SIR).  For the Bayesian methods, adjustable independent t priors are employed.  For both mode-based methods, estimates of uncertainty (standard errors or posterior standard deviations) are approximated using the appropriate inverse hessian matrix; for the two simulation-based methods, posterior standard deviations are estimated from the resulting sample.  
</p>
<p>Irrespective of whether Bayesian or frequentist methods are used, the relevant likelihood is either based entirely on the order of events (<code>timing="ordinal"</code>) or on the realized event times (<code>timing="interval"</code>).  In the latter case, all event times are understood to be relative to the onset of observation (i.e., observation starts at time 0), and the last event time given is taken to be the end of the observation period.  (This should generally be marked as exogenous – see below.)
</p>
<p>Event source/target/content are handled generically by <code>rem</code> via <em>event types</em>.  Each event must be of a given type, and any number of types may be employed (up to limits of time and memory).  Effects within the relational event model are associated with user-supplied statistics, of which any number may again be supplied (model identification notwithstanding).  At each point in the event history, it is possible that only particular types of events may be realized; this constraint can be specified by means of an optional user-supplied support structure.  Finally, it is also possible that an event sequence may be punctuated by <em>exogenous events,</em> which are unmodeled but which may affect the endogenous event dynamics.  These are supported by means of a tacit “exogenous” event type, which is handled by the estimation routine as appropriate for the specified likelihood.
</p>
<p>Observed event data is supplied to <code>rem</code> via the <code>eventlist</code> argument.  For each event history, the observed events are indicated by a two-column matrix, whose <code class="reqn">i</code>th row contains respectively the event type (as an integer ranging from 1 to the number of event types, inclusive) and the event time for the <code class="reqn">i</code>th event in the history.  (The second column may be omitted in the ordinal case, and will in any event be ignored.)  Events must be given in ascending temporal order; if multiple histories are being modeled simultaneously (e.g., as with egocentric relational event samples), then <code>eventlist</code> should be a list with one matrix per event history.  Exogenous events, if present, are indicated by specifying an event type of 0.  (Note that the “type” of an exogenous event is irrelevant, since any such properties of exogenous events are handled via the model statistics.)  If exact timing information is used, the hazard for the first event implicitly begins at time 0, and observation implicitly ends with the time of the last event (which should properly be coded as exogenous, unless the sampling design was based on observation of an endogenous terminal event).  Where applicable, censoring due to the sampling interval is accounted for in the data likelihood (assuming that the user has set the model statistics appropriately).
</p>
<p>Statistics for the relational event model are specified in a manner somewhat analogous to that of <code>eventlist</code>.  Like the latter, <code>statslist</code> is generally a list with one element per event history, or a single element where only a single history is to be examined.  Each element of <code>statslist</code> should be a list containing either one or two three-dimensional arrays, with the first dimension indexing event order (from first event to last, including exogenous events where applicable), the second indexing event type (in order corresponding to the integer values of <code>eventlist</code>), and the third indexing the model statistics.  The <code class="reqn">ijk</code>th cell of a <code>statslist</code> array is thus the value of the <code class="reqn">k</code>th statistic prospectively impacting the hazard of observing an event of type <code class="reqn">j</code> as the <code class="reqn">i</code>th event in the history (given the previous <code class="reqn">i-1</code> realized events).  Models estimated by <em>rem</em> are regular in the sense that one parameter is estimated per statistic; intuitively, a large value of a <code class="reqn">ijk</code>th <code>statslist</code> cell associatd with a large (positive) parameter represents an increased hazard of observing a type <code class="reqn">j</code> event at the <code class="reqn">i</code>th point in the respective history, while the same statistic associated with a highly negative parameter represents a correspondingly diminished hazard of observing said event.  (The total hazard of a given event type is equal to <code class="reqn">\exp(\theta^T s_{ij})</code>, where <code class="reqn">\theta</code> is the vector of model parameters and <code class="reqn">s_{ij}</code> is the corresponding vector of sufficient statistics for a type <code class="reqn">j</code> event given the <code class="reqn">i-1</code> previously realized events; see the reference below for details.)  It is up to the user to supply these statistics, and moreover to ensure that they are well-behaved (e.g., not linearly dependent).  An array within a <code>statslist</code> element may be designated as <em>global</em> or <em>local</em> by assigning it to the appropriately named list element.  Statistics belonging to a global array are assumed to correspond to parameters that are homogeneous across event histories, and are estimated in a pooled fashion; if global arrays are supplied, they must be given for every element of <code>statslist</code> (and must carry the same statistics and event types, although these statistics will not typically take the same values).  Statistics belonging to a local array, on the other hand, are taken as idiosyncratic to the event history in question, and their corresponding parameters are estimated locally.  Both local and global statistics may be employed simultaneously if desired, but at least one must be specified in any case.  <code>rem</code> will return an error if passed a <code>statslist</code> with obvious inconsistencies.
</p>
<p>If desired, support constraints for the event histories can be specified using <code>supplist</code>.  <code>supplist</code> should be a list with one element per history, each of which should be an event order by event type logical matrix.  The <code class="reqn">ij</code>th cell of this matrix should be <code>TRUE</code> if an event of type <code>j</code> was a possible next event given the preceding code <code class="reqn">i-1</code> events, and <code>FALSE</code> otherwise.  (By default, all events are assumed to be possible at all times.)  As with the model statistics, the elements of the support list must be user supplied, and will often be history-dependent.  (E.g., in a model for spell-based data, event types will come in onset/termination pairs, with terminal events necessarily being preceded by corresponding onset events.)
</p>
<p>Given the above structure, <code>rem</code> will attempt to find a maximum likelihood or posterior estimate for the model parameters, as appropriate given <code>estimator</code>.  In the latter case, the prior parameters for each parameter may be set using <code>prior.param</code>.  Each parameter is taken to be <em>a priori</em> t distributed, with the indicated location, scale, and degree of freedom parameters; by default, a fairly diffuse and heavy-tailed prior is used.  By specifying the elements of <code>prior.param</code> as vectors, it is possible to employ different priors for each model parameter.  In this case, the vector elements are used in the order of the statistics (first global, then each local in order by event history).  Standard errors or posterior standard deviation estimates are returned as appropriate, along with various goodness-of-fit indices.  (Bear in mind that the “p-values” shown in the summary method for the posterior mode case are based on posterior quantiles (under an assumption of asymptotic normality), and should be interpreted in this fashion.)
</p>
<p>For the MCMC sampling method, a combined independence and random walk Metropolis scheme is employed.  Proposals are multivariate Gaussian, with standard deviations as set via the appropriate arguments.  (These may be given as vectors, with one entry per parameter, if desired.)  Gewke and Gelman-Rubin MCMC diagnostics (produced by the <code>coda</code> package) are computed, and are stored as elements <code>geweke</code> and <code>gelman.rubin</code> within the model fit object.  The posterior draws themselves are stored as an element called <code>draws</code> within the model fit object, with corresponding log-posterior values <code>lp</code>.
</p>
<p>The SIR method initially seeks the posterior mode (identically to the BPM method), and obtains approximate scale information using the Hessian of the log-posterior surface.  This is used to generate a set of approximate posterior draws via a multivariate t distribution centered on the posterior mode, with degrees of freedom given by <code>sir.nu</code>.  This crude sample is then refined by importance resampling, the final result of which is stored as element <code>draws</code> (with log-posterior vector <code>lp</code>) in the model fit object.  As with the BMCMC procedure, posterior mean and standard deviations are estimated from the final sample, although the mode information is retained in elements <code>coef.mode</code> and <code>cov.hess</code>.
</p>
<p>As a general matter, the MLE and BPM methods are most dependent upon asymptotic assumptions, but are also (usually) the least computationally complex.  BMCMC requires no such assumptions, but can be extremely slow (and, like all MCMC methods, depends upon the quality of the MCMC sample).  The BSIR method is something of a compromise between BPM and BMCMC, starting with a mode approximation but refining it in the direction of the true posterior surface; as one might expect, its cost is also intermediate between these extremes.  For well-behaved models on large data sets, all methods are likely to produce nearly identical results.  The simulation-based methods (particularly BMCMC) may be safer in less salutary circumstances.  (Tests conducted by the author have so far obtained the best overall results from the BPM, particularly vis a vis estimates of uncertainty – this advice may or may not generalize, however.)
</p>


<h3>Value</h3>

<p>An object of class <code>rem</code>, for which <code>print</code> and <code>summary</code> methods currently exist.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C.T.  (2008).  “A Relational Event Framework for Social Action.”  <em>Sociological Methodology</em>, 38(1). 
</p>


<h3>See Also</h3>

<p><code>rem.dyad</code>
</p>


</div>