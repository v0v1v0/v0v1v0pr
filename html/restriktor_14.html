<div class="container">

<table style="width: 100%;"><tr>
<td>restriktor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimating linear regression models with (in)equality restrictions</h2>

<h3>Description</h3>

<p>Function <code>restriktor</code> estimates the parameters 
of an univariate and a multivariate linear model (<code>lm</code>), a 
robust estimation of the linear model (<code>rlm</code>) and a generalized 
linear model (<code>glm</code>) subject to linear equality and linear 
inequality restrictions. It is a convenience function. The real work 
horses are the <code>conLM</code>, <code>conMLM</code>, <code>conRLM</code> and 
the <code>conGLM</code> functions.</p>


<h3>Usage</h3>

<pre><code class="language-R">restriktor(object, constraints = NULL, ...)

## S3 method for class 'lm'
conLM(object, constraints = NULL, se = "standard", 
      B = 999, rhs = NULL, neq = 0L, mix_weights = "pmvnorm", 
      parallel = "no", ncpus = 1L, cl = NULL, seed = NULL, 
      control = list(), verbose = FALSE, debug = FALSE, ...)
      
## S3 method for class 'rlm'
conRLM(object, constraints = NULL, se = "standard", 
       B = 999, rhs = NULL, neq = 0L, mix_weights = "pmvnorm", 
       parallel = "no", ncpus = 1L, cl = NULL, seed = NULL, 
       control = list(), verbose = FALSE, debug = FALSE, ...)
       
## S3 method for class 'glm'
conGLM(object, constraints = NULL, se = "standard", 
       B = 999, rhs = NULL, neq = 0L, mix_weights = "pmvnorm", 
       parallel = "no", ncpus = 1L, cl = NULL, seed = NULL, 
       control = list(), verbose = FALSE, debug = FALSE, ...)

## S3 method for class 'mlm'
conMLM(object, constraints = NULL, se = "none", 
       B = 999, rhs = NULL, neq = 0L, mix_weights = "pmvnorm", 
       parallel = "no", ncpus = 1L, cl = NULL, seed = NULL, 
       control = list(), verbose = FALSE, debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted linear model object of class "lm", "mlm",
"rlm" or "glm". For class "rlm" only the loss function <code>bisquare</code> 
is supported for now, otherwise the function gives an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>there are two ways to constrain parameters. 
First, the constraint syntax consists of one or more text-based
descriptions, where the syntax can be specified as a literal 
string enclosed by single quotes. Only the names of <code>coef(model)</code>
can be used as names. See details for more information. Note that
objects of class "mlm" do not (yet) support this method. 
</p>
<p>Second, the constraint syntax consists of a matrix <code class="reqn">R</code> (or a vector in 
case of one constraint) and defines the left-hand side of the 
constraint <code class="reqn">R\theta \ge rhs</code>, where each row represents one 
constraint. The number of columns needs to correspond to the 
number of parameters estimated (<code class="reqn">\theta</code>) by model. The rows 
should be linear independent, otherwise the function gives an 
error. For more information about constructing the matrix <code class="reqn">R</code> and 
<code class="reqn">rhs</code> see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>if "<code>standard</code>" (default), conventional standard errors 
are computed based on inverting the observed augmented information 
matrix. If "const", homoskedastic standard errors are computed. 
If "<code>HC0</code>" or just "<code>HC</code>", heteroskedastic robust standard 
errors are computed (a.k.a Huber White). The options "<code>HC1</code>", 
"<code>HC2</code>", "<code>HC3</code>", "<code>HC4</code>", "<code>HC4m</code>", and 
"<code>HC5</code>" are refinements of "<code>HC0</code>". For more details about 
heteroskedastic robust standard errors see the <span class="pkg">sandwich</span> 
package. If "<code>boot.standard</code>", bootstrapped standard 
errors are computed using standard bootstrapping. If "<code>boot.model.based</code>" 
or "<code>boot.residual</code>", bootstrapped standard errors are computed 
using model-based bootstrapping. If "<code>none</code>", no standard errors 
are computed. Note that for objects of class "mlm" no standard errors 
are available (yet).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>integer; number of bootstrap draws for <code>se</code>. The 
default value is set to 999. Parallel support is available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs</code></td>
<td>
<p>vector on the right-hand side of the constraints; 
<code class="reqn">R\theta \ge rhs</code>. The length of this vector equals the 
number of rows of the constraints matrix <code class="reqn">R</code> and consists of 
zeros by default. Note: only used if constraints input is a 
matrix or vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neq</code></td>
<td>
<p>integer (default = 0) treating the number of 
constraints rows as equality constraints instead of inequality 
constraints. For example, if <code>neq = 2</code>, this means that the 
first two rows of the constraints matrix <code class="reqn">R</code> are treated as 
equality constraints. Note: only used if constraints input is a 
matrix or vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mix_weights</code></td>
<td>
<p>if <code>"pmvnorm"</code> (default), the chi-bar-square 
weights are computed based on the multivariate normal distribution 
function with additional Monte Carlo steps. If <code>"boot"</code>, the 
chi-bar-square weights are computed using parametric bootstrapping. 
If <code>"none"</code>, no chi-bar-square weights are computed. The 
weights are necessary in the <code>restriktor.summary</code> function 
for computing the GORIC. Moreover, the weights are re-used in the 
<code>iht</code> function for computing the p-value for the 
test-statistic, unless the p-value is computed directly via bootstrapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>the type of parallel operation to be used (if any). 
If missing, the default is set "no".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel 
operation: typically one would chose this to the number of 
available CPUs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>an optional parallel or snow cluster for use if 
parallel = "snow". If not supplied, a cluster on the local machine 
is created for the duration of the <code>restriktor</code> call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>seed value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control arguments: 
</p>

<ul>
<li> <p><code>absval</code> tolerance criterion for convergence 
(default = sqrt(.Machine$double.eps)). 
</p>
</li>
<li> <p><code>maxit</code> the maximum number of iterations for the 
optimizer (default = 10000). 
</p>
</li>
<li> <p><code>tol</code> numerical tolerance value. Estimates smaller 
than <code>tol</code> are set to 0.
</p>
</li>
</ul>
<p>Control options for calculating the chi-bar-square weights:
</p>

<ul>
<li> <p><code>chunk_size</code> integer; the chi-bar-square weights are computed for samples
of size <code>chunk_size = 5000L</code>. This process is repeated iteratively until the 
weights converges (see <code>convergenge_crit</code>) or the maximum is reached, i.e., 
<code>mix_weights_bootstrap_limit</code>.
</p>
</li>
<li> <p><code>mix_weights_bootstrap_limit</code> integer; maximum number of bootstrap draws.
The default value is set to 1e5.
</p>
</li>
<li> <p><code>convergence_crit</code> the convergence criterion for the iterative bootstrap
process. Default is 1e-03.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; if TRUE, information is shown at each bootstrap draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>if TRUE, debugging information about the constraints
is printed out.</p>
</td>
</tr>
</table>
<p><em>Options for calculating the chi-bar-square weights</em>:
</p>
<table><tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters passed to the truncated multivariate normal distribution.
By default, restriktor (i.e. <code>con_weights_boot</code> function) uses no 
truncation points for calculating the chi-bar-square weights, which renders 
to the multivariate normal distribution. See the manual page of the 
<code>rtmvnorm</code> function from the <span class="pkg">rtmvnorm</span> to see how to specify a 
truncated mvnorm distribution and the possible arguments.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The constraint syntax can be specified in two ways. First as a 
literal string enclosed by single quotes as shown below: 
</p>
<pre>myConstraints &lt;- '
    # 1. inequality constraints
      x1 &gt; 0
      x1 &lt; x2
    # or
      0 &lt; x1 &lt; x2
    
    ! 2. equality constraints  
      x3 == x4; x4 == x5 
    # or 
      x3 = x4; x4 = x5 
    # or
      x3 = x4 = x5'
  </pre>
<p>The variable names x1 to x5 refer to the corresponding regression
coefficient. Thus, constraints are impose on regression coefficients
and not on the data.
</p>
<p>Second, the above constraints syntax can also be written in 
matrix/vector notation as:
</p>
<p>(The first column refers to the intercept, the remaining five
columns refer to the regression coefficients x1 to x5.)
</p>
<pre>myConstraints &lt;-
    rbind(c(0, 0, 0,-1, 1, 0), #equality constraint x3 = x4
          c(0, 0, 0, 0,-1, 1), #equality constraint x4 = x5
          c(0, 1, 0, 0, 0, 0), #inequality constraint x1 &gt; rhs
          c(0,-1, 1, 0, 0, 0)) #inequality constraint x1 &lt; x2
  
# the length of rhs is equal to the number of myConstraints rows.      
myRhs &lt;- c(0,0,0,0) 
    
# the first two rows should be considered as equality constraints
myNeq &lt;- 2  
</pre>
<p>Blank lines and comments can be used in between the constraints, 
and constraints can be split over multiple lines. Both the 
hashtag (#) and the exclamation (!) characters can be used to 
start a comment. Multiple constraints can be placed on a single 
line if they are separated by a semicolon (;), a comma (,) or the "&amp;" sign. 
</p>
<p>In addition compound constraints can be stated via one or more longer equality 
or inequality sentences e.g., 'x1 &gt; x2 &gt; x3; x3 &lt; 4 &lt; x4' or 
'x1 == x2 == x3 &amp; x4 = 1'. Alternatively, the constrains can be specifies 
as '(x1, x2) &gt; (x3, x4)' which is equivalent to 'x1 &gt; x3; x1 &gt; x4; x2 &gt; x3; x2 &gt; x4'.
</p>
<p>There can be three types of text-based descriptions in the constraints 
syntax:
</p>

<ol>
<li>
<p> Equality constraints: The "<code>==</code>" or "<code>=</code>" operator can be 
used to define equality constraints (e.g., <code>x1 = 1</code> or 
<code>x1 = x2</code>).
</p>
</li>
<li>
<p> Inequality constraints: The "<code>&lt;</code>" or "<code>&gt;</code>" 
operator can be used to define inequality constraints 
(e.g., <code>x1 &gt; 1</code> or <code>x1 &lt; x2</code>).
</p>
</li>
<li>
<p> Newly defined parameters: The "<code>:=</code>" operator can 
be used to define new parameters, which take on values that 
are an arbitrary function of the original model parameters. 
The function must be specified in terms of the parameter names 
in <code>coef(model)</code> (e.g., <code>new := x1 + 2*x2</code>). By 
default, the standard errors for these defined parameters are 
computed by using the so-called Delta method.
</p>
</li>
</ol>
<p>Variable names of interaction effects in objects of class lm, 
rlm and glm contain a semi-colon (:) between the variables. To impose 
constraints on parameters of interaction effects, the semi-colon 
must be replaced by a dot (.) (e.g., <code>x3:x4</code> becomes 
<code>x3.x4</code>). In addition, the intercept variable names is shown 
as "<code>(Intercept)</code>". To impose restrictions on the intercept 
both parentheses must be replaced by a dot "<code>.Intercept.</code>" 
(e.g.,<code>.Intercept. &gt; 10</code>). Note: in most practical situations 
we do not impose restrictions on the intercept because we do not 
have prior knowledge about the intercept. Moreover, the sign of 
the intercept can be changed arbitrarily by shifting the response 
variable <code class="reqn">y</code>.
</p>
<p>Each element can be modified using arithmetic operators. For example, 
if <code>x2</code> is expected to be twice as large as <code>x1</code>, 
then "<code>2*x2 = x1</code>". 
</p>
<p>If <code>constraints = NULL</code>, the unrestricted model is fitted.
</p>
<p>### Note on not full row-rank ###
</p>
<p>If the restriction matrix is not of full row-rank, this means one of the following:
</p>

<ul>
<li>
<p> There is at least one redundant restriction. Then, either 
</p>

<ul>
<li>
<p>[a] Leave the redundant one out 
</p>
</li>
<li>
<p>[b] Use another (more time-consuming) way of obtaining the level probabilities 
for the penalty term (goric function does this by default): Bootstrapping, as discussed above.
</p>
</li>
</ul>
</li>
<li>
<p> There is at least one range restriction (e.g., -2 &lt; group1 &lt; 2). 
Such a restriction can be evaluated but there is a sensitivity (of a scaling 
factor in the covariance matrix, like with a prior in a Bayes factor) which 
currently cannot be checked for.
</p>
</li>
<li>
<p> There is at least one conflicting restriction (e.g., 2 &lt; group1 &lt; -2).
</p>
</li>
</ul>
<p>Such a restriction can evidently never hold and is thus impossible to evaluate. 
To prevent this type of error delete the one that is incorrect.
</p>


<h3>Value</h3>

<p>An object of class restriktor, for which a print and a summary method are available. 
More specifically, it is a list with the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>CON</code></td>
<td>
<p>a list with useful information about the restrictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timing</code></td>
<td>
<p>how much time several tasks take.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parTable</code></td>
<td>
<p>a parameter table with information about the 
observed variables in the model and the imposed restrictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.unrestr</code></td>
<td>
<p>unrestricted regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.restr</code></td>
<td>
<p>restricted regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>restricted residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wresid</code></td>
<td>
<p>a working residual, weighted for "inv.var" weights 
only (rlm only)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>restricted fitted mean values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>(only for weighted fits) the specified weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wgt</code></td>
<td>
<p>the weights used in the IWLS process (rlm only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>the robust scale estimate used (rlm only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stddev</code></td>
<td>
<p>a scale estimate used for the standard errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2.org</code></td>
<td>
<p>unrestricted R-squared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2.reduced</code></td>
<td>
<p>restricted R-squared.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2.unrestr</code></td>
<td>
<p>mean squared error of unrestricted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s2.restr</code></td>
<td>
<p>mean squared error of restricted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>restricted log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>variance-covariance matrix of unrestricted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>matrix with restrictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs</code></td>
<td>
<p>vector of right-hand side elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neq</code></td>
<td>
<p>number of equality restrictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt.bar</code></td>
<td>
<p>chi-bar-square mixing weights or a.k.a. level probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iact</code></td>
<td>
<p>active restrictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>did the IWLS converge (rlm only)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iteration needed for convergence (rlm only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootout</code></td>
<td>
<p>object of class boot. Only available if bootstrapped
standard errors are requested, else bootout = NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>list with control options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.org</code></td>
<td>
<p>original model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>as input. This information is needed in the summary 
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>information</code></td>
<td>
<p>observed information matrix with the inverted 
information matrix and the augmented information matrix as attributes.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Leonard Vanbrabant and Yves Rosseel</p>


<h3>References</h3>

<p>Schoenberg, R. (1997). Constrained Maximum Likelihood. <em>Computational 
Economics</em>, <b>10</b>, 251–266.
</p>
<p>Shapiro, A. (1988). Towards a unified theory of inequality-constrained 
testing in multivariate analysis. <em>International Statistical Review</em> 
<b>56</b>, 49–62.
</p>
<p>Silvapulle, M.J. and Sen, P.K. (2005). <em>Constrained Statistical Inference</em>. 
Wiley, New York
</p>


<h3>See Also</h3>

 
<p><code>iht</code>,
<code>goric</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## lm
## unrestricted linear model for ages (in months) at which an 
## infant starts to walk alone.

# prepare data
DATA1 &lt;- subset(ZelazoKolb1972, Group != "Control")

# fit unrestricted linear model
fit1.lm &lt;- lm(Age ~ -1 + Group, data = DATA1)

# the variable names can be used to impose restrictions on
# the corresponding regression parameters.
coef(fit1.lm)

# restricted linear model with restrictions that the walking 
# exercises would not have a negative effect of increasing the 
# mean age at which a child starts to walk. 
fit1.con &lt;- restriktor(fit1.lm, constraints = ' GroupActive  &lt; GroupPassive &lt; GroupNo ')
summary(fit1.con)

# Or in matrix notation.
myConstraints1 &lt;- rbind(c(-1, 1, 0),
                        c( 0,-1, 1))
myRhs1 &lt;- rep(0L, nrow(myConstraints1)) 
myNeq1 &lt;- 0

fit1.con &lt;- restriktor(fit1.lm, constraints = myConstraints1,
                       rhs = myRhs1, neq = myNeq1)
summary(fit1.con)

#########################
## Artificial examples ##
#########################
library(MASS)

## mlm
# generate data
n &lt;- 30
mu &lt;- rep(0, 4)
Sigma &lt;- matrix(5,4,4)
  diag(Sigma) &lt;- c(10,10,10,10)
# 4 Y's.
Y &lt;- mvrnorm(n, mu, Sigma)

# fit unrestricted multivariate linear model
fit.mlm &lt;- lm(Y ~ 1)

# constraints
myConstraints2 &lt;- diag(0,4)
  diag(myConstraints2) &lt;- 1

# fit restricted multivariate linear model
fit2.con &lt;- restriktor(fit.mlm, constraints = myConstraints2)

summary(fit2.con)


## rlm
# generate data
n &lt;- 10
means &lt;- c(1,2,1,3)
nm &lt;- length(means)
group &lt;- as.factor(rep(1:nm, each = n))
y &lt;- rnorm(n * nm, rep(means, each = n))
DATA2 &lt;- data.frame(y, group)

# fit unrestricted robust linear model
fit3.rlm &lt;- rlm(y ~ -1 + group, data = DATA2, method = "MM")
coef(fit3.rlm)

## increasing means
myConstraints3 &lt;- ' group1 &lt; group2 &lt; group3 &lt; group4 '

# fit restricted robust linear model and compute 
# Huber-White (robust) standard errors.
fit3.con &lt;- restriktor(fit3.rlm, constraints = myConstraints3, 
                       se = "HC0")
summary(fit3.con)


## increasing means in matrix notation.
myConstraints3 &lt;- rbind(c(-1, 1, 0, 0),
                        c( 0,-1, 1, 0),
                        c( 0, 0,-1, 1))
myRhs3 &lt;- rep(0L, nrow(myConstraints3)) 
myNeq3 &lt;- 0

fit3.con &lt;- restriktor(fit3.rlm, constraints = myConstraints3,
                       rhs = myRhs3, neq = myNeq3, se = "HC0")
summary(fit3.con)

## equality restrictions only.
myConstraints4 &lt;- ' group1 = group2 = group3 = group4 '
                    
fit4.con &lt;- restriktor(fit3.rlm, constraints = myConstraints4)
summary(fit4.con)


## combination of equality and inequality restrictions.
myConstraints5 &lt;- ' group1  = group2
                    group3  &lt; group4 '

# fit restricted model and compute model-based bootstrapped 
# standard errors. We only generate 9 bootstrap samples in this 
# example; in practice you may wish to use a much higher number.
fit5.con &lt;- restriktor(fit3.rlm, constraints = myConstraints4, 
                       se = "boot.model.based", B = 9)
# an error is probably thrown, due to a too low number of bootstrap draws.
summary(fit5.con)

# restriktor can also be used to define effects using the := operator 
# and impose restrictions on them. For example, compute the average 
# effect (AVE) and impose the restriction AVE &gt; 0.
# generate data
n &lt;- 30
b0 &lt;- 10; b1 = 0.5; b2 = 1; b3 = 1.5
X &lt;- c(rep(c(0), n/2), rep(c(1), n/2))
set.seed(90) 
Z &lt;- rnorm(n, 16, 5)
y &lt;- b0 + b1*X + b2*Z + b3*X*Z + rnorm(n, 0, sd = 10) 
DATA3 = data.frame(cbind(y, X, Z))

# fit linear model with interaction
fit6.lm &lt;- lm(y ~ X*Z, data = DATA3)

fit6.con &lt;- restriktor(fit6.lm, constraints = ' AVE := X + 16.86137*X.Z; 
                                                AVE &gt; 0 ')
summary(fit6.con)
</code></pre>


</div>