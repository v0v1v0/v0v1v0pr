<div class="container">

<table style="width: 100%;"><tr>
<td>get.norm.sd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting standard deviation of a normal distribution from one or more quantiles and known mean</h2>

<h3>Description</h3>

<p><code>get.norm.sd</code> returns the standard deviation of a normal distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get.norm.sd(p = c(0.025, 0.5, 0.975), q, show.output = TRUE, plot = TRUE,
                   fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>numeric, vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>numeric, vector of quantiles corresponding to p.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default vaule is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The number of probabilities and the number of quantiles must be identical and
should be at least two. <code>get.norm.sd</code> uses the central limit theorem and
the linear regression.
<br><br>
If <code>show.output = TRUE</code> the output of the function <code>lm</code> will be shown.
<br><br>
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br><br>
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br><br>
The function will be meaningful only if the quantile comes from a normal distribution.
</p>


<h3>Value</h3>

<p>Returns an estimated standard deviation or missing value
</p>


<h3>Note</h3>

<p>It should be noted that the data must be normally distributed, or the 
central limt theorem must hold for large (enough) samples sizes.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br>
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br>
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pnorm</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class="language-R">q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 0, sd = 2)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, scaleX = c(0.0001, 0.9999))
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 10, 1))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
get.norm.sd(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 176, sd = 15)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 10, 1))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
get.norm.sd(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

## The estimation model is not suitable for the following quantiles.
## Because the quantile is unsymmetrical, which could not be from a normally distributed data.
q &lt;- c(-2, 30, 31)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.0001, 0.9999))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
get.norm.sd(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.0001, 0.9999))
graphics::par(old.par)

## Estimating from actually exponentially distributed data
x.exp &lt;- rexp(n = 10, rate = 5)
mean(x.exp)
stats::sd(x.exp)
q &lt;- quantile(x.exp, c(0.025, 0.5, 0.975))
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, fit.weights = c(1, 10, 1))
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 100, 1))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
graphics::par(old.par)

## other examples
q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 1, sd = 1)
get.norm.sd(q = q)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 1, sd = 0.5)
get.norm.sd(q = q)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 0.01, sd = 0.1)
get.norm.sd(q = q)

</code></pre>


</div>