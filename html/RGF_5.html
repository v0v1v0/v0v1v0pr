<div class="container">

<table style="width: 100%;"><tr>
<td>RGF_Classifier</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularized Greedy Forest classifier</h2>

<h3>Description</h3>

<p>Regularized Greedy Forest classifier
</p>
<p>Regularized Greedy Forest classifier
</p>


<h3>Usage</h3>

<pre><code class="language-R"># init &lt;- RGF_Classifier$new(max_leaf = 1000, test_interval = 100,
#                                  algorithm = "RGF", loss = "Log", reg_depth = 1.0,
#                                  l2 = 0.1, sl2 = NULL, normalize = FALSE,
#                                  min_samples_leaf = 10, n_iter = NULL,
#                                  n_tree_search = 1, opt_interval = 100,
#                                  learning_rate = 0.5, calc_prob = "sigmoid",
#                                  n_jobs = 1, memory_policy = "generous",
#                                  verbose = 0, init_model = NULL)
</code></pre>


<h3>Details</h3>

<p>the <em>fit</em> function builds a classifier from the training set (x, y).
</p>
<p>the <em>predict</em> function predicts the class for x.
</p>
<p>the <em>predict_proba</em> function predicts class probabilities for x.
</p>
<p>the <em>cleanup</em> function removes tempfiles used by this model. See the issue <em>https://github.com/RGF-team/rgf/issues/75</em>, which explains in which cases the <em>cleanup</em> function applies.
</p>
<p>the <em>get_params</em> function returns the parameters of the model.
</p>
<p>the <em>score</em> function returns the mean accuracy on the given test data and labels.
</p>
<p>the <em>feature_importances</em> function returns the feature importances for the data.
</p>
<p>the <em>dump_model</em> function currently prints information about the fitted model in the console
</p>
<p>the <em>save_model</em> function saves a model to a file from which training can do warm-start in the future.
</p>


<h3>Methods</h3>


<dl>
<dt><code>RGF_Classifier$new(max_leaf = 1000, test_interval = 100,
                               algorithm = "RGF", loss = "Log", reg_depth = 1.0,
                               l2 = 0.1, sl2 = NULL, normalize = FALSE,
                               min_samples_leaf = 10, n_iter = NULL,
                               n_tree_search = 1, opt_interval = 100,
                               learning_rate = 0.5, calc_prob = "sigmoid",
                               n_jobs = 1, memory_policy = "generous",
                               verbose = 0, init_model = NULL)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>fit(x, y, sample_weight = NULL)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>predict(x)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>predict_proba(x)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>cleanup()</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>get_params(deep = TRUE)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>score(x, y, sample_weight = NULL)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>feature_importances()</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>dump_model()</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>save_model(filename)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
</dl>
<h3>Super class</h3>

<p><code>RGF::Internal_class</code> -&gt; <code>RGF_Classifier</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RGF_Classifier-new"><code>RGF_Classifier$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RGF_Classifier-clone"><code>RGF_Classifier$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="cleanup"><a href="../../RGF/html/Internal_class.html#method-Internal_class-cleanup"><code>RGF::Internal_class$cleanup()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="dump_model"><a href="../../RGF/html/Internal_class.html#method-Internal_class-dump_model"><code>RGF::Internal_class$dump_model()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="feature_importances"><a href="../../RGF/html/Internal_class.html#method-Internal_class-feature_importances"><code>RGF::Internal_class$feature_importances()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="fit"><a href="../../RGF/html/Internal_class.html#method-Internal_class-fit"><code>RGF::Internal_class$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="get_params"><a href="../../RGF/html/Internal_class.html#method-Internal_class-get_params"><code>RGF::Internal_class$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="predict"><a href="../../RGF/html/Internal_class.html#method-Internal_class-predict"><code>RGF::Internal_class$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="predict_proba"><a href="../../RGF/html/Internal_class.html#method-Internal_class-predict_proba"><code>RGF::Internal_class$predict_proba()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="save_model"><a href="../../RGF/html/Internal_class.html#method-Internal_class-save_model"><code>RGF::Internal_class$save_model()</code></a></span></li>
<li><span class="pkg-link" data-pkg="RGF" data-topic="Internal_class" data-id="score"><a href="../../RGF/html/Internal_class.html#method-Internal_class-score"><code>RGF::Internal_class$score()</code></a></span></li>
</ul></details><hr>
<a id="method-RGF_Classifier-new"></a>



<h4>Method <code>new()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>RGF_Classifier$new(
  max_leaf = 1000,
  test_interval = 100,
  algorithm = "RGF",
  loss = "Log",
  reg_depth = 1,
  l2 = 0.1,
  sl2 = NULL,
  normalize = FALSE,
  min_samples_leaf = 10,
  n_iter = NULL,
  n_tree_search = 1,
  opt_interval = 100,
  learning_rate = 0.5,
  calc_prob = "sigmoid",
  n_jobs = 1,
  memory_policy = "generous",
  verbose = 0,
  init_model = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_leaf</code></dt>
<dd>
<p>an integer. Training will be terminated when the number of leaf nodes in the forest reaches this value.</p>
</dd>
<dt><code>test_interval</code></dt>
<dd>
<p>an integer. Test interval in terms of the number of leaf nodes.</p>
</dd>
<dt><code>algorithm</code></dt>
<dd>
<p>a character string specifying the <em>Regularization algorithm</em>. One of <em>"RGF"</em> (RGF with L2 regularization on leaf-only models), <em>"RGF_Opt"</em> (RGF with min-penalty regularization) or <em>"RGF_Sib"</em> (RGF with min-penalty regularization with the sum-to-zero sibling constraints).</p>
</dd>
<dt><code>loss</code></dt>
<dd>
<p>a character string specifying the <em>Loss function</em>. One of <em>"LS"</em> (Square loss), <em>"Expo"</em> (Exponential loss) or <em>"Log"</em> (Logistic loss).</p>
</dd>
<dt><code>reg_depth</code></dt>
<dd>
<p>a float. Must be no smaller than 1.0. Meant for being used with the algorithm <em>RGF Opt</em> or <em>RGF Sib</em>. A larger value penalizes deeper nodes more severely.</p>
</dd>
<dt><code>l2</code></dt>
<dd>
<p>a float. Used to control the degree of L2 regularization.</p>
</dd>
<dt><code>sl2</code></dt>
<dd>
<p>a float or NULL. Override L2 regularization parameter l2 for the process of growing the forest. That is, if specified, the weight correction process uses l2 and the forest growing process uses sl2. If NULL, no override takes place and l2 is used throughout training.</p>
</dd>
<dt><code>normalize</code></dt>
<dd>
<p>a boolean. If True, training targets are normalized so that the average becomes zero.</p>
</dd>
<dt><code>min_samples_leaf</code></dt>
<dd>
<p>an integer or a float. Minimum number of training data points in each leaf node. If an integer, then consider <em>min_samples_leaf</em> as the minimum number. If a float, then <em>min_samples_leaf</em> is a percentage and ceil(min_samples_leaf * n_samples) are the minimum number of samples for each node.</p>
</dd>
<dt><code>n_iter</code></dt>
<dd>
<p>an integer or NULL. The number of iterations of coordinate descent to optimize weights. If NULL, 10 is used for loss = "LS" and 5 for loss = "Expo" or "Log".</p>
</dd>
<dt><code>n_tree_search</code></dt>
<dd>
<p>an integer. The number of trees to be searched for the nodes to split. The most recently grown trees are searched first.</p>
</dd>
<dt><code>opt_interval</code></dt>
<dd>
<p>an integer. Weight optimization interval in terms of the number of leaf nodes. For example, by default, weight optimization is performed every time approximately 100 leaf nodes are newly added to the forest.</p>
</dd>
<dt><code>learning_rate</code></dt>
<dd>
<p>a float. Step size of Newton updates used in coordinate descent to optimize weights.</p>
</dd>
<dt><code>calc_prob</code></dt>
<dd>
<p>a character string. One of <em>"sigmoid"</em> or <em>"softmax"</em>. Method of probability calculation.</p>
</dd>
<dt><code>n_jobs</code></dt>
<dd>
<p>an integer. The number of jobs (threads) to use for the computation. The substantial number of the jobs dependents on <em>classes_</em> (The number of classes when <em>fit</em> is performed). If classes_ = 2, the substantial max number of the jobs is one. If classes_ &gt; 2, the substantial max number of the jobs is the same as classes_. If n_jobs = 1, no parallel computing code is used at all regardless of classes_. If n_jobs = -1 and classes_ &gt;= number of CPU, all CPUs are used. For n_jobs = -2, all CPUs but one are used. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used.</p>
</dd>
<dt><code>memory_policy</code></dt>
<dd>
<p>a character string. One of <em>"conservative"</em> (it uses less memory at the expense of longer runtime. Try only when with default value it uses too much memory) or <em>"generous"</em> (it runs faster using more memory by keeping the sorted orders of the features on memory for reuse). Memory using policy.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>an integer. Controls the verbosity of the tree building process.</p>
</dd>
<dt><code>init_model</code></dt>
<dd>
<p>either NULL or a character string, optional (default=NULL). Filename of a previously saved model from which training should do warm-start. If model has been saved into multiple files, do not include numerical suffixes in the filename. <em>NOTE:</em> Make sure you haven't forgotten to increase the value of the max_leaf parameter regarding to the specified warm-start model because warm-start model trees are counted in the overall number of trees.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-RGF_Classifier-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RGF_Classifier$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p><em>https://github.com/RGF-team/rgf/tree/master/python-package</em>, <em>Rie Johnson and Tong Zhang, Learning Nonlinear Functions Using Regularized Greedy Forest</em>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
try({
    if (reticulate::py_available(initialize = FALSE)) {
        if (reticulate::py_module_available("rgf.sklearn")) {

            library(RGF)

            set.seed(1)
            x = matrix(runif(1000), nrow = 100, ncol = 10)

            y = sample(1:2, 100, replace = TRUE)

            RGF_class = RGF_Classifier$new(max_leaf = 50)

            RGF_class$fit(x, y)

            preds = RGF_class$predict_proba(x)
        }
    }
}, silent = TRUE)
</code></pre>


</div>