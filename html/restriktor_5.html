<div class="container">

<table style="width: 100%;"><tr>
<td>benchmark_functions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Benchmark Functions for GORIC(A) Analysis</h2>

<h3>Description</h3>

<p>The 'benchmark' functions perform benchmarking for models using the 
Generalized Order-Restricted Information Criterion (Approximation) (GORIC(A)). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">  benchmark(object, model_type = c("asymp", "means"), ...)
  
  benchmark_means(object, pop_es = NULL, ratio_pop_means = NULL, 
                  group_size = NULL, alt_group_size = NULL, 
                  quant = NULL, iter = 1000, 
                  control = list(convergence_crit = 1e-03, 
                                 chunk_size = 1e4), 
                  ncpus = 1, seed = NULL, ...)

  benchmark_asymp(object, pop_est = NULL, sample_size = NULL, 
                  alt_sample_size = NULL, quant = NULL, iter = 1000, 
                  control = list(convergence_crit = 1e-03, 
                                 chunk_size = 1e4), 
                  ncpus = 1, seed = NULL, ...)
  
  ## S3 method for class 'benchmark'
print(x, output_type = c("rgw", "gw", "rlw", "ld", "all"), 
                            color = TRUE, ...)
  
  ## S3 method for class 'benchmark'
plot(x, output_type = c("rgw", "rlw", "gw", "ld"), 
                           percentiles = NULL, x_lim = c(), log_scale = FALSE,
                           alpha = 0.50, nrow_grid = NULL, ncol_grid = 1, 
                           distr_grid = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>con_goric</code> (a GORIC(A) object from the <code>goric</code> function).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_type</code></td>
<td>
<p>If "means", the model parameters relect (adjusted) means, else
model_type = "asymp" (default). See details for more information about <code>asymp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>benchmark</code> or <code>benchmark</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop_es</code></td>
<td>
<p>A scalar or a vector of population Cohen's f (effect-size) values. 
By default, it benchmarks ES = 0 (no-effect) and the observed Cohen's f.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pop_est</code></td>
<td>
<p>A 1 x k vector or an n x k matrix of population 
estimates to benchmark. By default, all estimates are set to zero (no-effect) 
and the observed estimates from the sample are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio_pop_means</code></td>
<td>
<p>A 1 x k vector denoting the relative difference
between the k group means. Note that a ratio of <code>c(3, 2, 1)</code> gives the 
same as <code>c(1, 0, -1)</code>, as the consecutive relative differences are 1 in 
both ratios. By default, the relative differences from the data are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group_size</code></td>
<td>
<p>If the GORICA object is based on estimates and their covariance 
matrix (instead of on a model/fit object), this should be a 1 x k vector 
or a scalar to denote the group sizes. If a scalar is specified, it is assumed 
that each group is of that size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt_group_size</code></td>
<td>
<p>An 1 x k vector or a scalar to denote alternative 
group sizes, if you want to use sizes different from those in the data. This 
can be used, for example, to see the values to which the GORIC(A) weights will 
converge (and thus to see the maximum value of the weights). If a scalar is 
specified, it is assumed that each group is of that size. By default, the group 
sizes from the data are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_size</code></td>
<td>
<p>A scalar to denote the (total) sample sizes. Only used if 
the GORIC object is based on estimates and their covariance matrix (instead 
of on a model/fit object) or <code>alt_sample_size</code> is not <code>NULL</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alt_sample_size</code></td>
<td>
<p>A scalar to denote an alternative sample size if you 
want to use a different sample size from the one in the data. This can be used, 
for example, to see the values to which the GORIC(A) weights will converge 
(and thus to see the maximum value of the weights).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quant</code></td>
<td>
<p>Quantiles for benchmarking results. Defaults 5%, 35%, 50%, 65%, 95%.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The number of iterations for benchmarking. Defaults to <code>1000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters including <code>convergence_crit</code> 
and <code>chunk_size</code>. For more information, see goric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>Number of CPUs to use for parallel processing. Defaults to <code>1</code>.
See details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A seed for random number generation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_type</code></td>
<td>
<p>A character vector specifying the type of output to print 
or plot. Options are <code>"all"</code>, <code>"gw"</code> (goric(a) weights), 
<code>"rgw"</code> (ratio of goric(a) weights), <code>"rlw"</code> (ratio of likelihood values), 
and <code>"ld"</code> (likelihood difference). Defaults to <code>"rgw"</code> for print and <code>"rgw"</code> for plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>color</code></td>
<td>
<p>If TRUE, the output will include ANSI color coding. Set <code>color = FALSE</code> 
when using this function in R Markdown documents to avoid rendering issues with color codes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Alpha refers to the opacity of a geom. Values of alpha range from 0 to 1, with lower values corresponding to more transparent colors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrow_grid</code></td>
<td>
<p>An integer value representing the number of rows in the grid layout.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncol_grid</code></td>
<td>
<p>An integer value representing the number of columns in the grid layout.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr_grid</code></td>
<td>
<p>If TRUE, the facet_grid function is used to create a grid of separate plots for each effect-size (estimates).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>percentiles</code></td>
<td>
<p>A numeric vector specifying the percentiles to be shown. By default 
the percentiles are inherited from the quantiles used for benchmarking, see <code>quant</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_lim</code></td>
<td>
<p>A numeric vector of length 2 specifying the x-axis limits. Defaults to <code>c()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_scale</code></td>
<td>
<p>logical, If TRUE, The x-axis is transformed using a base-10 logarithmic scale.
This transformation adjusts the way the data is visualized on the x-axis, but does not 
alter the underlying data values themselves.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>See goric.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>benchmark_asymp</code> is named as such because it generates data from a 
multivariate normal distribution with means equal to the population parameter 
estimates and a covariance matrix derived from the original data. This is based 
on the assumption that parameter estimates are asymptotically normally distributed. 
This assumption is valid for many statistical models, including parameters from 
a generalized linear model (GLM). In such models, as the sample size increases, 
the distribution of the parameter estimates tends to a normal distribution, 
allowing us to utilize the multivariate normal distribution for benchmarking.
</p>
<p><code>benchmark_means</code> benchmarks the group means of a given GORIC(A) object 
by evaluating various population effect sizes and comparing the observed 
group means against these benchmarks.
<code>benchmark_asymp</code> benchmarks the population estimates of a given 
GORIC(A) object by evaluating various population estimates and comparing them 
against the observed estimates.
</p>
<p><code>print.benchmark</code> prints the results of benchmark analyses performed on 
objects of class <code>benchmark</code>.
</p>
<p><code>plot.benchmark</code> generates density plots for benchmark analyses of objects 
of class <code>benchmark</code>. 
</p>
<p>The benchmark function leverages the <span class="pkg">future</span> package for parallel processing, 
allowing users to speed up computations by distributing tasks across multiple 
cores or machines. If the user does not specify a parallelization plan using 
<code>future::plan()</code>, the package will choose an appropriate strategy based 
on the user's operating system. Specifically, on Windows, the package defaults 
to using <code>multisession</code>, which creates separate R sessions for each 
parallel task. On Unix-like systems (such as Linux and macOS), the package 
defaults to <code>multicore</code>, which uses forked R processes to avoid the 
overhead of setting up separate R sessions.
</p>
<p>The <code>plan()</code> must be specified before running the benchmark function, e.g.,
<code>future::plan(future::multisession, workers = ncpus)</code>
</p>


<h3>Value</h3>

<p><code>benchmark_means</code> and <code>benchmark_asymp</code> return a list of 
class <code>benchmark_means</code>, <code>benchmark</code>, and <code>list</code> or 
<code>benchmark_asymp</code>, <code>benchmark</code>, and <code>list</code> containing the 
results of the benchmark analysis.
</p>
<p><code>print.benchmark</code> does not return a value. It prints formatted benchmark 
analysis results to the console.
</p>
<p><code>plot.benchmark</code> returns a gtable object that can be displayed or further 
customized using various functions from the gridExtra and grid packages. This 
allows for flexible and detailed adjustments to the appearance and layout of the plot.
</p>


<h3>Author(s)</h3>

<p>Leonard Vanbrabant and Rebecca Kuiper</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1234)
# Generate data for 4 groups with different group sizes
group1 &lt;- rnorm(10, mean = 5, sd = 0.1)
group2 &lt;- rnorm(20, mean = 5.5, sd = 1)
group3 &lt;- rnorm(30, mean = 6, sd = 0.5)
group4 &lt;- rnorm(40, mean = 6.5, sd = 0.8)

# Combine data into a data frame
data &lt;- data.frame(
  value = c(group1, group2, group3, group4),
  group = factor(rep(1:4, times = c(10,20,30,40)))
)

# Perform ANOVA
anova_result &lt;- aov(value ~ -1 + group, data = data)

# model/hypothesis
h1 &lt;- 'group1 &lt; group2 &lt; group3 &lt; group4'
h2 &lt;- 'group1 &gt; group2 &lt; group3 &lt; group4'

# fit h1 and h2 model against the unconstrained model (i.e., failsafe to avoid
# selecting a weak hypothesis)
fit_goric &lt;- goric(anova_result, hypotheses = list(H1 = h1, H2 = h2), 
                   comparison = "unconstrained", type = "goric")

# by default: ES = 0 \&amp; ES = observed ES
# In practice you want to increase the number of iterations (default = 1000).

# multisession supports windows machines
# future::plan(future::multisession, workers = ncpus)
benchmark_results_mean &lt;- benchmark(fit_goric, iter = 10, model_type = "means")
print(benchmark_results_mean)


# by default the ratio of GORIC weights for the preferred hypothesis (here h1) is
# plotted against its competitors (i.e., h2 and the unconstrained). To improve
# the readability of the plot, the argument hypothesis_comparison can be used to
# focus on a specif competitor. Further readability can be achieved by setting
# the x_lim option. 
plot(benchmark_results_mean, output_type = "rgw")

# specify custom effect-sizes

benchmark_results_mean_es &lt;- benchmark(fit_goric, iter = 10,
                                       pop_es = c(0, 0.1),
                                       model_type = "means")
print(benchmark_results_mean_es)  
  

# Benchmark asymptotic estimates

fit_gorica &lt;- goric(anova_result, hypotheses = list(h1=h1), 
                    comparison = "complement", type = "gorica")

# by default: no-effect \&amp; estimates from the sample are used
benchmark_results_asymp &lt;- benchmark(fit_gorica, sample_size = 30, iter = 5,
                                     model_type = "asymp")
print(benchmark_results_asymp)



# specify custom population estimates
my_pop_est &lt;- rbind("no" = c(0,0,0,0), "observed"= coef(anova_result))

benchmark_results_asymp &lt;- benchmark(fit_gorica, sample_size = 30, 
                                     iter = 5, pop_est = my_pop_est,
                                     model_type = "asymp")
print(benchmark_results_asymp)
plot(benchmark_results_asymp, x_lim = c(0, 75))

</code></pre>


</div>