<div class="container">

<table style="width: 100%;"><tr>
<td>cniperCont</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Functions for Computation and Plot of Cniper Contamination
and Cniper Points. </h2>

<h3>Description</h3>

<p>These functions and their methods can be used to determine cniper
contamination as well as cniper points. That is, under which (Dirac) 
contamination is the risk of one procedure larger than the risk of some
other procedure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cniperCont(IC1, IC2, data = NULL, ...,
           neighbor, risk, lower=getdistrOption("DistrResolution"),
           upper=1-getdistrOption("DistrResolution"), n = 101,
           with.automatic.grid = TRUE, scaleX = FALSE, scaleX.fct,
           scaleX.inv, scaleY = FALSE, scaleY.fct = pnorm, scaleY.inv=qnorm,
           scaleN = 9, x.ticks = NULL, y.ticks = NULL, cex.pts = 1,
           cex.pts.fun = NULL, col.pts = par("col"), pch.pts = 19,
           cex.npts = 0.6, cex.npts.fun = NULL, col.npts = "red", pch.npts = 20,
           jit.fac = 1, jit.tol = .Machine$double.eps, with.lab = FALSE,
           lab.pts = NULL, lab.font = NULL, alpha.trsp = NA, which.lbs = NULL,
           which.Order  = NULL, which.nonlbs = NULL, attr.pre = FALSE,
           return.Order = FALSE, withSubst = TRUE)

cniperPoint(L2Fam, neighbor, risk, lower, upper)

cniperPointPlot(L2Fam, data=NULL, ..., neighbor, risk= asMSE(),
                        lower=getdistrOption("DistrResolution"),
                        upper=1-getdistrOption("DistrResolution"), n = 101,
                        withMaxRisk = TRUE, with.automatic.grid = TRUE,
                           scaleX = FALSE, scaleX.fct, scaleX.inv,
                           scaleY = FALSE, scaleY.fct = pnorm, scaleY.inv=qnorm,
                           scaleN = 9, x.ticks = NULL, y.ticks = NULL,
                           cex.pts = 1, cex.pts.fun = NULL, col.pts = par("col"),
                           pch.pts = 19,
                           cex.npts = 1, cex.npts.fun = NULL, col.npts = par("col"),
                           pch.npts = 19,
                           jit.fac = 1, jit.tol = .Machine$double.eps,
                           with.lab = FALSE,
                           lab.pts = NULL, lab.font = NULL, alpha.trsp = NA,
                           which.lbs = NULL, which.nonlbs = NULL,
                           which.Order  = NULL, attr.pre = FALSE, return.Order = FALSE,
                           withSubst = TRUE, withMakeIC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>IC1</code></td>
<td>
<p> object of class <code>IC</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC2</code></td>
<td>
<p> object of class <code>IC</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2Fam</code></td>
<td>
<p> object of class <code>L2ParamFamily</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>Neighborhood</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>RiskType</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional parameters (in particular to be passed on to <code>plot</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data to be plotted in</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p> the lower and upper end points of the 
contamination interval (in prob-scale). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> number of points between <code>lower</code> and <code>upper</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withMaxRisk</code></td>
<td>
<p>logical; if <code>TRUE</code>, for risk comparison
uses the maximal risk of the classically optimal IC <code class="reqn">\psi</code> in all
situations with contamination in Dirac points 'no larger' than
the respective evaluation point and the optimally-robust
IC <code class="reqn">\eta</code> at its least favorable contamination situation
('over all real Dirac contamination points'). This is the default and
was the  behavior prior to package version 0.9).
If <code>FALSE</code> it uses exactly the situation
with Dirac contamination in the evaluation point for both ICs
<code class="reqn">\psi</code> and <code class="reqn">\eta</code> which amounts to calling <code>cniperCont</code>
with <code>IC1=psi</code>, <code>IC2=eta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.automatic.grid</code></td>
<td>
<p>logical; should a grid be plotted alongside
with the ticks of the axes, automatically? If <code>TRUE</code> a respective
call to <code>grid</code> in argument <code>panel.first</code> is ignored. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled (by default according to a probit scale)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC(s)
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX.inv</code></td>
<td>
<p>the inverse function to <code>scale.fct</code>, i.e., an isotone,
vectorized function mapping [0,1] to the domain of the IC(s)
such that for any <code>x</code> in the domain,
<code>scaleX.inv(scaleX.fct(x))==x</code>; if <code>scaleX</code> is <code>TRUE</code>
and <code>scaleX.inv</code> is
missing, the quantile function of the underlying observation distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate the
range of the respective coordinate of the IC(s)
to [0,1]; defaulting to the cdf of <code class="reqn">{\cal N}(0,1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleY.inv</code></td>
<td>
<p>an isotone, vectorized function mapping for each coordinate
the range [0,1] into the range of the respective coordinate of the IC(s);
defaulting to the quantile function of  <code class="reqn">{\cal N}(0,1)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleN</code></td>
<td>
<p>integer; defaults to 9; on rescaled axes, number of x
and y ticks if drawn automatically;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given x-ticks (on original scale);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given y-ticks (on original scale);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.pts</code></td>
<td>
<p>size of the points of the second argument plotted (vectorized);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used for
the rescaling, or a function which is then used for the
rescaling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.pts</code></td>
<td>
<p>color of the points of the second argument plotted (vectorized);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch.pts</code></td>
<td>
<p>symbol of the points of the second argument plotted (vectorized);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted (vectorized);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (vectorized);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (vectorized);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.npts.fun</code></td>
<td>
<p>rescaling function for the size of the non-labelled points
to be plotted; either <code>NULL</code> (default), then <code>log(1+abs(x))</code>
is used for each of the rescalings, or a function which is then used
for each of the rescalings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.lab</code></td>
<td>
<p>logical; shall labels be plotted to the observations?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab.pts</code></td>
<td>
<p>character or NULL; labels to be plotted to the observations; if <code>NULL</code>
observation indices;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab.font</code></td>
<td>
<p>font to be used for labels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.lbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the data-symbols to be plotted.
Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jit.fac</code></td>
<td>
<p>jittering factor used in case of a <code>DiscreteDistribution</code>
for plotting points of the second argument in a jittered fashion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jit.tol</code></td>
<td>
<p>jittering tolerance used in case of a <code>DiscreteDistribution</code>
for plotting points of the second argument in a jittered fashion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.lbs</code></td>
<td>
<p>either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> — then no observation is excluded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> — then all non-labelled
observations are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.Order</code></td>
<td>
<p>we order the observations (descending) according to the norm given by
<code>normtype(object)</code>; then <code>which.Order</code>
either is an integer vector with the indices of the <em>ordered</em>
observations (remaining after a possible reduction by argument <code>which.lbs</code>)
to be plotted into graph or <code>NULL</code> — then no (further) observation
is excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.Order</code></td>
<td>
<p>logical; if <code>TRUE</code>, an order vector
is returned; more specifically, the order of the (remaining) observations
given by their original index is returned (remaining means: after a possible
reduction by argument <code>which.lbs</code>, and ordering is according to the norm given by
<code>normtype(object)</code>);
otherwise we return <code>invisible()</code> as usual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In case of <code>cniperCont</code> the difference between the risks of two ICs 
is plotted.
</p>
<p>The function <code>cniperPoint</code> can be used to determine cniper
points. That is, points such that the optimally robust estimator
has smaller minimax risk than the classical optimal estimator under 
contamination with Dirac measures at the cniper points. 
</p>
<p>As such points might be difficult to find, we provide the
function <code>cniperPointPlot</code> which can be used to obtain a plot
of the risk difference; in this function the usual arguments for
<code>plot</code> can be used. For arguments <code>col</code>, <code>lwd</code>,
vectors can be used; then the first coordinate is taken for the
curve, the second one for the balancing line. For argument <code>lty</code>,
a list can be used; its first component is then taken for the
curve, the second one for the balancing line.
</p>
<p>If argument <code>withSubst</code> is <code>TRUE</code>, in all title 
and axis lable arguments of <code>cniperCont</code> and <code>cniperPointPlot</code>, 
the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt>
<dd>
<p>class of argument <code>L2Fam</code> (for  <code>cniperPointPlot</code>)</p>
</dd>
<dt><code>"%A"</code></dt>
<dd>
<p>deparsed argument  <code>L2Fam</code> (for  <code>cniperPointPlot</code>)</p>
</dd>
<dt><code>"%C1"</code></dt>
<dd>
<p>class of argument <code>IC1</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%A1"</code></dt>
<dd>
<p>deparsed argument  <code>IC1</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%C2"</code></dt>
<dd>
<p>class of argument <code>IC2</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%A2"</code></dt>
<dd>
<p>deparsed argument  <code>IC2</code> (for  <code>cniperCont</code>)</p>
</dd>
<dt><code>"%D"</code></dt>
<dd>
<p>time/date-string when the plot was generated</p>
</dd>
</dl>
<p>For more details about cniper contamination and cniper points we refer 
to Section~3.5 of Kohl et al. (2008) as well as Ruckdeschel (2004) and 
the Introduction of Kohl (2005).
</p>


<h3>Value</h3>

<p>The cniper point is returned by <code>cniperPoint</code>.
In case of <code>cniperPointPlot</code>, we return
an S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>P. Ruckdeschel (2004). Higher Order Asymptotics for the MSE of M-Estimators
on Shrinking Neighborhoods. Unpublished Manuscript.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## cniper contamination
P &lt;- PoisFamily(lambda = 4)
RobP1 &lt;- InfRobModel(center = P, neighbor = ContNeighborhood(radius = 0.1))
IC1 &lt;- optIC(model=RobP1, risk=asMSE())
RobP2 &lt;- InfRobModel(center = P, neighbor = ContNeighborhood(radius = 1))
IC2 &lt;- optIC(model=RobP2, risk=asMSE())
cniperCont(IC1 = IC1, IC2 = IC2,
           neighbor = ContNeighborhood(radius = 0.5), 
           risk = asMSE(),
           lower = 0, upper = 8, n = 101)

## cniper point plot
cniperPointPlot(P, neighbor = ContNeighborhood(radius = 0.5), 
                risk = asMSE(), lower = 0, upper = 10)

## Don't run to reduce check time on CRAN

## cniper point
cniperPoint(P, neighbor = ContNeighborhood(radius = 0.5), 
            risk = asMSE(), lower = 0, upper = 4)
cniperPoint(P, neighbor = ContNeighborhood(radius = 0.5), 
            risk = asMSE(), lower = 4, upper = 8)

</code></pre>


</div>