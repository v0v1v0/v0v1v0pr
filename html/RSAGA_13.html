<div class="container">

<table style="width: 100%;"><tr>
<td>focal.function</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local and Focal Grid Functions</h2>

<h3>Description</h3>

<p><code>focal.function</code> cuts out square or circular moving windows from a grid (matrix) and applies a user-defined matrix function to calculate e.g. a terrain attribute or filter the grid. The function is suitable for large grid files as it can process them row by row. <code>local.function</code> represents the special case of a moving window of radius 1. Users can define their own functions operating on moving windows, or use simple functions such as <code>median</code> to define filters.
</p>


<h3>Usage</h3>

<pre><code class="language-R">focal.function(
  in.grid,
  in.factor.grid,
  out.grid.prefix,
  path = NULL,
  in.path = path,
  out.path = path,
  fun,
  varnames,
  radius = 0,
  is.pixel.radius = TRUE,
  na.strings = "NA",
  valid.range = c(-Inf, Inf),
  nodata.values = c(),
  out.nodata.value,
  search.mode = c("circle", "square"),
  digits = 4,
  hdr.digits = 10,
  dec = ".",
  quiet = TRUE,
  nlines = Inf,
  mw.to.vector = FALSE,
  mw.na.rm = FALSE,
  ...
)

gapply(in.grid, fun, varnames, mw.to.vector = TRUE, mw.na.rm = TRUE, ...)

local.function(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>in.grid</code></td>
<td>
<p>file name of input ASCII grid, relative to <code>in.path</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.factor.grid</code></td>
<td>
<p>optional file name giving a gridded categorical variables defining zones; zone boundaries are used as breaklines for the moving window (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.grid.prefix</code></td>
<td>
<p>character string (optional), defining a file name prefix to be used for the output file names; a dash (<code>-</code>) will separate the prefix and the <code>varnames</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>path in which to look for <code>in.grid</code> and write output grid files; see also <code>in.path</code> and <code>out.path</code>, which overwrite <code>path</code> if they are specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.path</code></td>
<td>
<p>path in which to look for <code>in.grid</code> (defaults to <code>path</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.path</code></td>
<td>
<p>path in which to write output grid files; defaults to <code>path</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>a function, or name of a function, to be applied on the moving window; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varnames</code></td>
<td>
<p>character vector specifying the names of the variable(s) returned by <code>fun</code>; if missing, <code>focal.function</code> will try to determine the varnames from <code>fun</code> itself, or from a call to <code>fun</code> if this is a function (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>numeric value specifying the (circular or square) radius  of the moving window; see <code>is.pixel.radius</code> and <code>search.mode</code>; note that all data within distance <code style="white-space: pre;">⁠&lt;=radius⁠</code> will be included in the moving window, not <code style="white-space: pre;">⁠&lt;radius⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.pixel.radius</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), the <code>radius</code> will be interpreted as a (possibly non-integer) number of pixels; if <code>FALSE</code>, it is interpreted as a radius measured in the grid (map) units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.strings</code></td>
<td>
<p>passed on to <code>scan()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valid.range</code></td>
<td>
<p>numeric vector of length 2, specifying minimum and maximum valid values read from input file; all values <code style="white-space: pre;">⁠&lt;valid.range[1]⁠</code> or <code style="white-space: pre;">⁠&gt;valid.range[1]⁠</code> will be converted to <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodata.values</code></td>
<td>
<p>numeric vector: any values from the input grid file that should be converted to <code>NA</code>, in addition to the nodata value specified in the grid header</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.nodata.value</code></td>
<td>
<p>numeric: value used for storing <code>NA</code>s in the output file(s); if missing, use the same nodata value as specified in the header of the input grid file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search.mode</code></td>
<td>
<p>character, either <code>"circle"</code> (default) for a circular search window, or <code>"square"</code> for a squared one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for output grid file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hdr.digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for the header of the output grid file (default: 10; see <code>write.ascii.grid.header()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dec</code></td>
<td>
<p>character, specifying the decimal mark to be used for input and output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>If <code>TRUE</code>, gives some output (<code>"*"</code>) after every 10th line of the grid file and when the job is done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlines</code></td>
<td>
<p>Number of lines to be processed; useful for testing purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mw.to.vector</code></td>
<td>
<p>logical: Should the content of the moving window be coerced (from a matrix) to a vector?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mw.na.rm</code></td>
<td>
<p>logical: Should <code>NA</code>s be removed from moving window prior to passing the data to <code>fun</code>? Only applicable when <code>mw.to.vector=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed to <code>fun</code>; <code>local.function</code>: arguments to be passed to  <code>focal.function</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>focal.function</code> passes a square matrix of size <code>2*radius+1</code> to the function <code>fun</code> if <code>mw.to.vector=FALSE</code> (default), or a vector of length <code style="white-space: pre;">⁠&lt;=(2*radius+1)^2⁠</code> if <code>mw.to.vector=TRUE</code>. This matrix or vector will contain the content of the moving window, which may possibly contain <code>NA</code>s even if the <code>in.grid</code> has no nodata values, e.g. due to edge effects. If <code>search.mode="circle"</code>, values more than <code>radius</code> units (pixels or grid units, depending on <code>is.pixel.radius</code>) away from the center pixel / matrix entry will be set to <code>NA</code>. In addition, <code>valid.range</code>, <code>nodata.values</code>, and the nodata values specified in the <code>in.grid</code> are checked to assign further <code>NA</code>s to pixels in the moving window. Finally, if <code>in.factor.grid</code> specifies zones, all pixels in the moving window that belong to a different zone than the center pixel are set to <code>NA</code>, or, in other words, zone boundaries are used as breaklines.
</p>
<p>The function <code>fun</code> should return a single numeric value or a numeric vector. As an example, the function <code>resid.minmedmax()</code> returns the minimum, median and maximum of the difference between the values in the moving window and the value in the center grid cell. In addition to the (first) argument receiving the moving window data, <code>fun</code> may have additional arguments; the <code>...</code> argument of <code>focal.function</code> is passed on to <code>fun</code>. <code>resid.quantile()</code> is a function that uses this feature.
</p>
<p>Optionally, <code>fun</code> should support the following feature: If no argument is passed to it, then it should return a character vector giving variable names to be used for naming the output grids. The call <code>resid.minmedmax()</code>, for example, returns <code>c("rmin","rmed","rmax")</code>; this vector must have the same length as the numeric vector returned when moving window data is passed to the function. This feature is only used if no <code>varnames</code> argument is provided. Note that the result is currently being <code>abbreviate()</code>d to a length of 6 characters.
</p>
<p>Input and output file names are built according to the following schemes:
</p>
<p>Input:   <code style="white-space: pre;">⁠[&lt;in.path&gt;/]&lt;in.grid&gt;⁠</code>
</p>
<p>Zones:   <code style="white-space: pre;">⁠[&lt;in.path&gt;/]&lt;in.factor.grid&gt;⁠</code> (if specified)
</p>
<p>Output:  <code style="white-space: pre;">⁠[&lt;out.path&gt;/][&lt;out.grid.prefix&gt;-]&lt;varnames&gt;.asc⁠</code>
</p>
<p>For the input files, <code>.asc</code> is used as the default file extension, if it is not specified by the user.
</p>


<h3>Value</h3>

<p><code>focal.function</code> and <code>local.function</code> return the character vector of output file names.
</p>


<h3>Note</h3>

<p>These functions are not very efficient ways of calculating e.g. (focal) terrain attributes compared to for example the SAGA modules, but the idea is that you can easily specify your own functions without starting to mess around with C code. For example try implementing a median filter as a SAGA module... or just use the code shown in the example!
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Brenning, A. (2008): Statistical geocomputing combining R and SAGA: The example of landslide susceptibility analysis with generalized additive models.  In: J. Boehner, T. Blaschke, L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger Beitraege zur Physischen Geographie und Landschaftsoekologie, 19), 23-32.
</p>


<h3>See Also</h3>

<p><code>multi.focal.function()</code>, <code>multi.local.function()</code>, <code>resid.median()</code>, <code>resid.minmedmax()</code>, <code>relative.position()</code>, <code>resid.quantile()</code>, <code>resid.quartiles()</code>, <code>relative.rank()</code>,  <code>wind.shelter()</code>, <code>create.variable.name()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# A simple median filter applied to dem.asc:
gapply("dem","median",radius=3)
# Same:
#focal.function("dem",fun="median",radius=3,mw.to.vector=TRUE,mw.na.rm=TRUE)
# See how the filter has changed the elevation data:
d1 = as.vector(read.ascii.grid("dem")$data)
d2 = as.vector(read.ascii.grid("median")$data)
hist(d1-d2,br=50)

## End(Not run)
# Wind shelter index used by Plattner et al. (2004):
## Not run: 
ctrl = wind.shelter.prep(6,-pi/4,pi/12,10)
focal.function("dem",fun=wind.shelter,control=ctrl,
    radius=6,search.mode="circle")

## End(Not run)
# Or how about this, if "aspect" is local terrain exposure:
## Not run: 
gapply("aspect","cos") # how "northerly-exposed" is a pixel?
gapply("aspect","sin") # how "easterly-exposed" is a pixel?
# Same result, but faster:
focal.function("aspect",fun=function(x) c(cos(x),sin(x)), varnames=c("cos","sin"))

## End(Not run)
</code></pre>


</div>