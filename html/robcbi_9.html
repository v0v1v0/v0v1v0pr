<div class="container">

<table style="width: 100%;"><tr>
<td>cubinf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Conditionally unbiased bounded influence estimates of discrete Generalized Linear Models
</h2>

<h3>Description</h3>

<p>Conditionally unbiased bounded influence estimates as described in Kuensch et al. 
(1989) in three special GLM cases: Bernoulli, Binomial, and Poisson distributed responses. 
The result is an object of class "cubinf". 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cubinf(x, y, weights = NULL,  start=NULL, etastart=NULL, mustart=NULL,
       offset = NULL, family = binomial(), control = cubinf.control(...),  
       intercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector or matrix of explanatory variable(s).
Columns represent variables and rows are observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of observed responses. 
In the case of Binomial responses, y is a two column matrix:
the 1st column contains the number of successes, 
the 2nd column the number of failures.
The Bernoulli case, is treated as a special Binomial case. 
However, the response y is a categorical variable (not a matrix with two colums) with two levels.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional weigths for weighted regression. Components must be non negative integers. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Starting values for the parameters in the linear predictor. 
Not used but required for compatibility with the glm function. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>Starting values for the linear predictor. 
Not used but required for compatibility with the glm function. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>Starting values for the vector of means. 
Not used but required for compatibility with the glm function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>Optional offset added to the linear predictor. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>A family object. Only two options are available for cubinf: 
'family=binomial()' and 'family=poisson()'. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters for the numerical algorithms. 
See cubinf.control for the possible control parameters and their defaults.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Logical flag: if TRUE, an intercept term is added to the model. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>... </code></td>
<td>
<p>Further named control arguments as singular.ok or qr.out used in the case 
where the x matrix is singular.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The initial values of the coefficients (theta), the matrix A and the bias correction c are 
computed using the ROBETH subroutine GINTAC (Marazzi, 1993). Then an initial covariance 
matrix (for the convergence criterion) is computed by means of the ROBETH subroutines 
GFEDCA and KTASKW. 
Finally, the main algorithm (subroutine GYMAIN) alternates between improving values of
- theta, for fixed A and c (theta-step, subroutine GYTSTP),
- c, for fixed theta and A (c-step, subroutine GYCSTP),
- A, for fixed theta and c (A-step, subroutine GYASTP).
</p>
<p>For the different available options see the function cubinf.control. 
</p>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>Coefficient estimates. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>Working residuals. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rsdev</code></td>
<td>
<p>Deviance residuals. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values </code></td>
<td>
<p>Fitted values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>Estimated covariance matrix of the coefficients. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank </code></td>
<td>
<p>Rank of the model matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residuals</code></td>
<td>
<p>Degrees of freedom in the residuals. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>Vector of final bias corrections. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Final value of the matrix A. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ai</code></td>
<td>
<p>Vector with components a_i=ufact/|Ax_i| (where x_i^T denotes the ith row of the model matrix) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>
<p>A logical value. FALSE if the maximum number of iterations was reached.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>Control parameters.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.weights</code></td>
<td>
<p>Input vector w (when some of its components are different from 1). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The family object used in the call to cubinf
'ics=1' for the Bernoulli case.
'ics=2' for the Binomial case.
'ics=3' for the Poisson case. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.predictors</code></td>
<td>
<p>Components of the linear predictor (the model matrix 
multiplied by the coefficient vector). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations required in the main algorithm.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y </code></td>
<td>
<p>Coded value of the response. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient </code></td>
<td>
<p>Vector of the final unscaled negative gradient of the objective 
function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inv.hessian </code></td>
<td>
<p>Vector of the final inverse of the Hessian matrix in compact 
storage mode. </p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Kuensch, H.R., Stefanski L.A., Carroll R.J. (1989).
Conditionally unbiased bounded-influence estimation in general regression models,
with application to generalized linear models. 
Journal of the American Statistical Association, 84, 460-466.
</p>
<p>Marazzi, A. (1993).
Algorithms, Routines, and S-functions for robust Statistics.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p>glm(..., method="cubinf"), <code>cubinf.control</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  library(robcbi)
  y &lt;- c(5,10,15,20,30,40,60,80,100)
  x &lt;- matrix(
	c(0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1),
    nrow=9,byrow=FALSE)
  z &lt;- cubinf(x,y, family=poisson, control=list(ufact=3.2), intercept=TRUE)
  z$iter
  z$coeff
  z &lt;- cubinf(x,y, family=poisson, control=list(ufact=30), intercept=TRUE)
  z$iter
  z$coeff
</code></pre>


</div>