<div class="container">

<table style="width: 100%;"><tr>
<td>OptSpace</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>OptSpace : an algorithm for matrix reconstruction from a partially revealed set</h2>

<h3>Description</h3>

<p>Let's assume an ideal matrix <code class="reqn">M</code> with <code class="reqn">(m\times n)</code> entries with rank <code class="reqn">r</code> and
we are given a partially observed matrix <code class="reqn">M\_E</code> which contains many missing entries.
Matrix reconstruction - or completion - is the task of filling in such entries.
OptSpace is an efficient algorithm that reconstructs <code class="reqn">M</code> from <code class="reqn">|E|=O(rn)</code> observed elements
with relative root mean square error (RMSE)
</p>
<p style="text-align: center;"><code class="reqn">RMSE \le C(\alpha)\sqrt{nr/|E|}</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">OptSpace(A, ropt = NA, niter = 50, tol = 1e-06, showprogress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>an <code class="reqn">(n\times m)</code> matrix whose missing entries should be flaged as NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ropt</code></td>
<td>
<p><code>NA</code> to guess the rank, or a positive integer as a pre-defined rank.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>stopping criterion for reconstruction in Frobenius norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showprogress</code></td>
<td>
<p>a logical value; <code>TRUE</code> to show progress, <code>FALSE</code> otherwise.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a named list containing
</p>

<dl>
<dt>X</dt>
<dd>
<p>an <code class="reqn">(n \times r)</code> matrix as left singular vectors.</p>
</dd>
<dt>S</dt>
<dd>
<p>an <code class="reqn">(r \times r)</code> matrix as singular values.</p>
</dd>
<dt>Y</dt>
<dd>
<p>an <code class="reqn">(m \times r)</code> matrix as right singular vectors.</p>
</dd>
<dt>dist</dt>
<dd>
<p>a vector containing reconstruction errors at each successive iteration.</p>
</dd>
</dl>
<h3>References</h3>

<p>Keshavan RH, Montanari A, Oh S (2010).
“Matrix Completion From a Few Entries.”
<em>IEEE Transactions on Information Theory</em>, <b>56</b>(6), 2980–2998.
ISSN 0018-9448.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Parameter Settings
n = 1000;
m = 100;
r = 3;
tolerance = 1e-7
eps = 10*r*log10(n)

## Generate a matrix with given data
U = matrix(rnorm(n*r),nrow=n)
V = matrix(rnorm(m*r),nrow=m)
Sig = diag(r)
M0 = U%*%Sig%*%t(V)

## Set some entries to be NA with probability eps/sqrt(m*n)
E = 1 - ceiling(matrix(rnorm(n*m),nrow=n) - eps/sqrt(m*n))
M_E = M0
M_E[(E==0)] = NA

## Create a noisy version
noiselevel = 0.1
M_E_noise  = M_E + matrix(rnorm(n*m),nrow=n)*noiselevel

## Use OptSpace for reconstruction
res1 = OptSpace(M_E,tol=tolerance)
res2 = OptSpace(M_E_noise,tol=tolerance)

## Compute errors for both cases using Frobenius norm
err_clean = norm(res1$X%*%res1$S%*%t(res1$Y)-M0,'f')/sqrt(m*n)
err_noise = norm(res2$X%*%res2$S%*%t(res2$Y)-M0,'f')/sqrt(m*n)

## print out the results
m1 = sprintf('RMSE without noise         : %e',err_clean)
m2 = sprintf('RMSE with noise of %.2f    : %e',noiselevel,err_noise)
print(m1)
print(m2)

</code></pre>


</div>