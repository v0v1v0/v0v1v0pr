<div class="container">

<table style="width: 100%;"><tr>
<td>vcgMetro</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>evaluate the difference between two triangular meshes.</h2>

<h3>Description</h3>

<p>Implementation of the command line tool "metro" to evaluate the difference between two triangular meshes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vcgMetro(
  mesh1,
  mesh2,
  nSamples = 0,
  nSamplesArea = 0,
  vertSamp = TRUE,
  edgeSamp = TRUE,
  faceSamp = TRUE,
  unrefVert = FALSE,
  samplingType = c("SS", "MC", "SD"),
  searchStruct = c("SGRID", "AABB", "OCTREE", "HGRID"),
  from = 0,
  to = 0,
  colormeshes = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mesh1</code></td>
<td>
<p>triangular mesh (object of class 'mesh3d').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mesh2</code></td>
<td>
<p>triangular mesh (object of class 'mesh3d').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nSamples</code></td>
<td>
<p>set the required number of samples if 0, this will be set to approx. 10x the face number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nSamplesArea</code></td>
<td>
<p>set the required number of samples per area unit, override nSamples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertSamp</code></td>
<td>
<p>logical: if FALSE, disable vertex sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edgeSamp</code></td>
<td>
<p>logical: if FALSE, disable edge sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>faceSamp</code></td>
<td>
<p>logical: if FALSE, disable face sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unrefVert</code></td>
<td>
<p>logical: if FALSE, ignore unreferred vertices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingType</code></td>
<td>
<p>set the face sampling mode. options are: SS (similar triangles sampling), SD (subdivision sampling), MC (montecarlo sampling).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>searchStruct</code></td>
<td>
<p>set search structures to use. options are: SGIRD (static Uniform Grid), OCTREE, AABB (AxisAligned Bounding Box Tree), HGRID (Hashed Uniform Grid).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>numeric: minimum value for color mapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>numeric: maximum value for color mapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colormeshes</code></td>
<td>
<p>if TRUE, meshes with vertices colored according to distance are returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>logical: if TRUE, output to console is suppressed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>ForwardSampling, BackwardSampling</code></td>
<td>
<p>lists containing information about forward (mesh1 to mesh2) and backward (mesh2 to mesh1) sampling with the following entries</p>
</td>
</tr></table>
<ul>
<li> <p><code>maxdist</code> maximal Hausdorff distance
</p>
</li>
<li> <p><code>meandist</code> mean Hausdorff distance
</p>
</li>
<li> <p><code>RMSdist</code> RMS of the Hausdorff distances
</p>
</li>
<li> <p><code>area</code> mesh area (of <code>mesh1</code> in <code>ForwardSampling</code> and  <code>mesh2</code> in  <code>BackwardSampling</code>)
</p>
</li>
<li> <p><code>RMSdist</code> RMS of the Hausdorff distances
</p>
</li>
<li> <p><code>nvbsamples</code> number of vertices sampled
</p>
</li>
<li> <p><code>nsamples</code> number of samples
</p>
</li>
</ul>
<table>
<tr style="vertical-align: top;">
<td><code>distances1, distances2</code></td>
<td>
<p>vectors containing vertex distances from mesh1 to mesh2 and mesh2 to mesh1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forward_hist, backward_hist</code></td>
<td>
<p>Matrices tracking the sampling results</p>
</td>
</tr>
</table>
<p>if colormeshes == TRUE
</p>
<table><tr style="vertical-align: top;">
<td><code>mesh1, mesh2</code></td>
<td>
<p>meshes with color coded distances and an additional entry called quality containing the sampled per-vertex distances</p>
</td>
</tr></table>
<h3>Note</h3>

<p>this is a straightforward implementation of the command line tool metro <a href="http://vcglib.net/metro.html">http://vcglib.net/metro.html</a>
</p>


<h3>References</h3>

<p>P. Cignoni, C. Rocchini and R. Scopigno. Metro: measuring error on simplified surfaces. Computer Graphics Forum, Blackwell Publishers, vol. 17(2), June 1998, pp 167-174
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if (requireNamespace("Morpho", quietly = TRUE)) {
require(Morpho)
data(humface)
data(dummyhead)
## align humface to dummyhead.mesh
humfalign &lt;- rotmesh.onto(humface,humface.lm,dummyhead.lm)
samp &lt;- vcgMetro(humfalign$mesh,dummyhead.mesh,faceSamp=FALSE,edgeSamp=FALSE)
## create heatmap using Morpho's meshDist function
}

## Not run: 
## create custom heatmaps based on distances
mD &lt;- meshDist(humfalign$mesh,distvec=samp$distances1)

## End(Not run)
</code></pre>


</div>