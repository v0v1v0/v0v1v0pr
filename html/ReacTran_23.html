<div class="container">

<table style="width: 100%;"><tr>
<td>tran.3D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
General Three-Dimensional Advective-Diffusive Transport
</h2>

<h3>Description</h3>

<p>Estimates the transport term (i.e. the rate of change of a concentration
due to diffusion and advection) in a three-dimensional rectangular
model domain.
</p>
<p>Do not use with too many boxes!
</p>


<h3>Usage</h3>

<pre><code class="language-R">tran.3D (C, C.x.up = C[1,,], C.x.down = C[dim(C)[1],,],
         C.y.up = C[ ,1, ],  C.y.down=C[ ,dim(C)[2], ],
         C.z.up = C[ , ,1],  C.z.down=C[ , ,dim(C)[3]],
         flux.x.up = NULL, flux.x.down = NULL,
         flux.y.up = NULL, flux.y.down = NULL,
         flux.z.up = NULL, flux.z.down = NULL,
         a.bl.x.up = NULL, a.bl.x.down = NULL, 
         a.bl.y.up = NULL, a.bl.y.down = NULL, 
         a.bl.z.up = NULL, a.bl.z.down = NULL, 
         D.grid = NULL, D.x = NULL, D.y = D.x, D.z = D.x,
         v.grid = NULL, v.x = 0, v.y = 0, v.z = 0,
         AFDW.grid = NULL, AFDW.x = 1, AFDW.y = AFDW.x, AFDW.z = AFDW.x,
         VF.grid = NULL, VF.x = 1, VF.y = VF.x, VF.z = VF.x,
         A.grid = NULL, A.x = 1, A.y = 1, A.z = 1,
         grid = NULL, dx = NULL, dy = NULL, dz = NULL,
         full.check = FALSE, full.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>C </code></td>
<td>
<p>concentration, expressed per unit volume, defined at the centre
of each grid cell; Nx*Ny*Nz array [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.x.up </code></td>
<td>
<p>concentration at upstream boundary in x-direction;
matrix of dimensions Ny*Nz [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.x.down </code></td>
<td>
<p>concentration at downstream boundary in x-direction;
matrix of dimensions Ny*Nz [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.y.up </code></td>
<td>
<p>concentration at upstream boundary in y-direction;
matrix of dimensions Nx*Nz [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.y.down </code></td>
<td>
<p>concentration at downstream boundary in y-direction;
matrix of dimensions Nx*Nz [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.z.up </code></td>
<td>
<p>concentration at upstream boundary in z-direction;
matrix of dimensions Nx*Ny [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.z.down </code></td>
<td>
<p>concentration at downstream boundary in z-direction;
matrix of dimensions Nx*Ny [M/L3].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.x.up </code></td>
<td>
<p>flux across the upstream boundary in x-direction,
positive = INTO model domain; matrix of dimensions Ny*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.x.down </code></td>
<td>
<p>flux across the downstream boundary in x-direction,
positive = OUT of model domain; matrix of dimensions Ny*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.y.up </code></td>
<td>
<p>flux across the upstream boundary in y-direction,
positive = INTO model domain; matrix of dimensions Nx*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.y.down </code></td>
<td>
<p>flux across the downstream boundary in y-direction,
positive = OUT of model domain; matrix of dimensions Nx*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.z.up </code></td>
<td>
<p>flux across the upstream boundary in z-direction,
positive = INTO model domain; matrix of dimensions Nx*Ny [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.z.down </code></td>
<td>
<p>flux across the downstream boundary in z-direction,
positive = OUT of model domain; matrix of dimensions Nx*Ny [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.bl.x.up </code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in x-direction
</p>
<p><code>Flux=a.bl.x.up*(C.x.up-C[1,,])</code>. One value [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.bl.x.down </code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in x-direction;
</p>
<p><code>Flux=a.bl.x.down*(C[Nx,,]-C.x.down)</code>.
One value [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.bl.y.up </code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in y-direction
</p>
<p><code>Flux=a.bl.y.up*(C.y.up-C[,1,])</code>. One value [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.bl.y.down </code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in y-direction;
</p>
<p><code>Flux=a.bl.y.down*(C[,Ny,]-C.y.down)</code>.
One value [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.bl.z.up </code></td>
<td>
<p>transfer coefficient across the upstream boundary layer.
in y-direction
</p>
<p><code>Flux=a.bl.y.up*(C.y.up-C[,,1])</code>. One value [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.bl.z.down </code></td>
<td>
<p>transfer coefficient across the downstream boundary
layer in z-direction;
</p>
<p><code>Flux=a.bl.z.down*(C[,,Nz]-C.z.down)</code>.
One value [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.grid </code></td>
<td>
<p>diffusion coefficient defined on all grid cell
interfaces.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.x </code></td>
<td>
<p>diffusion coefficient in x-direction, defined on grid cell
interfaces. One value, a vector of length (Nx+1),
or a (Nx+1)* Ny *Nz array [L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.y </code></td>
<td>
<p>diffusion coefficient in y-direction, defined on grid cell
interfaces. One value, a vector of length (Ny+1),
or a Nx*(Ny+1)*Nz array [L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D.z </code></td>
<td>
<p>diffusion coefficient in z-direction, defined on grid cell
interfaces. One value, a vector of length (Nz+1),
or a Nx*Ny*(Nz+1) array [L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.grid </code></td>
<td>
<p>advective velocity defined on all grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively.  [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.x </code></td>
<td>
<p>advective velocity in the x-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Nx+1),
or a (Nx+1)*Ny*Nz array [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.y </code></td>
<td>
<p>advective velocity in the y-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Ny+1),
or a Nx*(Ny+1)*Nz array [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.z </code></td>
<td>
<p>advective velocity in the z-direction, defined on grid cell
interfaces. Can be positive (downstream flow) or negative (upstream flow).
One value, a vector of length (Nz+1),
or a Nx*Ny*(Nz+1) array [L/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AFDW.grid </code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AFDW.x </code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the x-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a (Nx+1)*Ny*Nz array [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AFDW.y </code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the y-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a Nx*(Ny+1)*Nz array [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AFDW.z </code></td>
<td>
<p>weight used in the finite difference scheme for advection
in the z-direction, defined on grid cell interfaces; backward = 1,
centred = 0.5, forward = 0; default is backward.
One value, a vector of length (Nz+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a Nx*Ny*(Nz+1) array [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VF.grid </code></td>
<td>
<p>Volume fraction. A list.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VF.x </code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the x-direction.
One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a (Nx+1)*Ny*Nz array [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VF.y </code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the y-direction.
One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a Nx*(Ny+1)*Nz array [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VF.z </code></td>
<td>
<p>Volume fraction at the grid cell interfaces in the z-direction.
One value, a vector of length (Nz+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a Nx*Ny*(Nz+1) array [-].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.grid </code></td>
<td>
<p>Interface area, a list.
Should contain elements x.int, y.int, z.int, arrays with the values on the
interfaces in x, y and z-direction, and with dimensions
(Nx+1)*Ny*Nz, Nx*(Ny+1)*Nz and Nx*Ny*(Nz+1) respectively. [L2].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.x </code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the x-direction. One value, a vector of length (Nx+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a (Nx+1)*Ny*Nz array [L2].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.y </code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the y-direction. One value, a vector of length (Ny+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a Nx*(Ny+1)*Nz array [L2].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.z </code></td>
<td>
<p>Interface area defined at the grid cell interfaces in
the z-direction. One value, a vector of length (Nz+1),
a <code>prop.1D</code> list created by <code>setup.prop.1D</code>,
or a Nx*Ny*(Nz+1) array [L2].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx </code></td>
<td>
<p>distance between adjacent cell interfaces in the x-direction
(thickness of grid cells). One value or vector of length Nx [L].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dy </code></td>
<td>
<p>distance between adjacent cell interfaces in the y-direction
(thickness of grid cells). One value or vector of length Ny [L].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dz </code></td>
<td>
<p>distance between adjacent cell interfaces in the z-direction
(thickness of grid cells). One value or vector of length Nz [L].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid </code></td>
<td>
<p>discretization grid, a list containing at least elements
<code>dx</code>, <code>dx.aux</code>, <code>dy</code>, <code>dy.aux</code>, <code>dz</code>, <code>dz.aux</code>
(see <code>setup.grid.2D</code>) [L].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.check </code></td>
<td>
<p>logical flag enabling a full check of the consistency
of the arguments (default = <code>FALSE</code>; <code>TRUE</code> slows down
execution by 50 percent).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full.output </code></td>
<td>
<p>logical flag enabling a full return of the output
(default = <code>FALSE</code>; <code>TRUE</code> slows down execution by 20 percent).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Do not use this with too large grid.
</p>
<p>The <b>boundary conditions</b> are either
</p>

<ul>
<li>
<p> (1) zero-gradient
</p>
</li>
<li>
<p> (2) fixed concentration
</p>
</li>
<li>
<p> (3) convective boundary layer
</p>
</li>
<li>
<p> (4) fixed flux
</p>
</li>
</ul>
<p>This is also the order of priority. The zero gradient is the default,
the fixed flux overrules all other.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dC </code></td>
<td>
<p>the rate of change of the concentration C due to transport,
defined in the centre of each grid cell, an array with dimension
Nx*Ny*Nz [M/L3/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.x.up </code></td>
<td>
<p>concentration at the upstream interface in x-direction.
A matrix of dimension Ny*Nz [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.x.down </code></td>
<td>
<p>concentration at the downstream interface in x-direction.
A matrix of dimension Ny*Nz [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.y.up </code></td>
<td>
<p>concentration at the upstream interface in y-direction.
A matrix of dimension Nx*Nz [M/L3].  Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.y.down </code></td>
<td>
<p>concentration at the downstream interface in y-direction.
A matrix of dimension Nx*Nz [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.z.up </code></td>
<td>
<p>concentration at the upstream interface in z-direction.
A matrix of dimension Nx*Ny [M/L3].  Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C.z.down </code></td>
<td>
<p>concentration at the downstream interface in z-direction.
A matrix of dimension Nx*Ny [M/L3]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.flux </code></td>
<td>
<p>flux across the interfaces in x-direction of the grid cells.
A (Nx+1)*Ny*Nz array [M/L2/T]. Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.flux </code></td>
<td>
<p>flux across the interfaces in y-direction of the grid cells.
A Nx*(Ny+1)*Nz array [M/L2/T].  Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.flux </code></td>
<td>
<p>flux across the interfaces in z-direction of the grid cells.
A Nx*Ny*(Nz+1) array [M/L2/T].  Only when <code>full.output = TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.x.up </code></td>
<td>
<p>flux across the upstream boundary in x-direction,
positive = INTO model domain. A matrix of dimension Ny*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.x.down </code></td>
<td>
<p>flux across the downstream boundary in x-direction,
positive = OUT of model domain. A matrix of dimension Ny*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.y.up </code></td>
<td>
<p>flux across the upstream boundary in y-direction,
positive = INTO model domain. A matrix of dimension Nx*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.y.down </code></td>
<td>
<p>flux across the downstream boundary in y-direction,
positive = OUT of model domain. A matrix of dimension Nx*Nz [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.z.up </code></td>
<td>
<p>flux across the upstream boundary in z-direction,
positive = INTO model domain. A matrix of dimension Nx*Ny [M/L2/T].
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flux.z.down </code></td>
<td>
<p>flux across the downstream boundary in z-direction,
positive = OUT of model domain. A matrix of dimension Nx*Ny [M/L2/T].
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>Soetaert and Herman, a practical guide to ecological modelling - using R as
a simulation platform, 2009. Springer
</p>


<h3>See Also</h3>

<p><code>tran.cylindrical</code>, <code>tran.spherical</code> 
for a discretisation of 3-D transport equations in cylindrical and 
spherical coordinates
</p>
<p><code>tran.1D</code>,   <code>tran.2D</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## =============================================================================
## Diffusion in 3-D; imposed boundary conditions
## =============================================================================
diffusion3D &lt;- function(t, Y, par) {

  yy    &lt;- array(dim = c(n, n, n), data = Y)  # vector to 3-D array
  dY    &lt;- -r * yy                            # consumption
  BND   &lt;- matrix(nrow = n, ncol = n, 1)      # boundary concentration

  dY &lt;- dY + tran.3D(C = yy,
      C.x.up = BND, C.y.up = BND, C.z.up = BND,
      C.x.down = BND, C.y.down = BND, C.z.down = BND,
      D.x = Dx, D.y = Dy, D.z = Dz,
      dx = dx, dy = dy, dz = dz, full.check = TRUE)$dC
  return(list(dY))
}

# parameters
dy   &lt;- dx &lt;- dz &lt;- 1   # grid size
Dy   &lt;- Dx &lt;- Dz &lt;- 1   # diffusion coeff, X- and Y-direction
r    &lt;- 0.025     # consumption rate

n  &lt;- 10
y  &lt;- array(dim = c(n, n, n), data = 10.)

print(system.time(
  ST3 &lt;- steady.3D(y, func = diffusion3D, parms = NULL, 
                 pos = TRUE, dimens = c(n, n, n),
                 lrw = 2000000, verbose = TRUE)
))

pm &lt;- par(mfrow = c(1,1))
y &lt;- array(dim = c(n, n, n), data = ST3$y)
filled.contour(y[ , ,n/2], color.palette = terrain.colors)

# a selection in the x-direction
image(ST3, mfrow = c(2, 2), add.contour = TRUE, legend = TRUE,
      dimselect = list(x = c(1, 4, 8, 10)))

par(mfrow = pm)
</code></pre>


</div>