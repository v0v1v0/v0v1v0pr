<div class="container">

<table style="width: 100%;"><tr>
<td>collocationAnalysis,KorAPConnection-method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Collocation analysis</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>Performs a collocation analysis for the given node (or query)
in the given virtual corpus.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'KorAPConnection'
collocationAnalysis(
  kco,
  node,
  vc = "",
  lemmatizeNodeQuery = FALSE,
  minOccur = 5,
  leftContextSize = 5,
  rightContextSize = 5,
  topCollocatesLimit = 200,
  searchHitsSampleLimit = 20000,
  ignoreCollocateCase = FALSE,
  withinSpan = ifelse(exactFrequencies, "base/s=s", ""),
  exactFrequencies = TRUE,
  stopwords = append(RKorAPClient::synsemanticStopwords(), node),
  seed = 7,
  expand = length(vc) != length(node),
  maxRecurse = 0,
  addExamples = FALSE,
  thresholdScore = "logDice",
  threshold = 2,
  localStopwords = c(),
  collocateFilterRegex = "^[:alnum:]+-?[:alnum:]*$",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>kco</code></td>
<td>
<p><code>KorAPConnection()</code> object (obtained e.g. from <code>new("KorAPConnection")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node</code></td>
<td>
<p>target word</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vc</code></td>
<td>
<p>string describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lemmatizeNodeQuery</code></td>
<td>
<p>if TRUE, node query will be lemmatized, i.e. <code style="white-space: pre;">⁠x -&gt; [tt/l=x]⁠</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minOccur</code></td>
<td>
<p>minimum absolute number of observed co-occurrences to consider a collocate candidate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leftContextSize</code></td>
<td>
<p>size of the left context window</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rightContextSize</code></td>
<td>
<p>size of the right context window</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topCollocatesLimit</code></td>
<td>
<p>limit analysis to the n most frequent collocates in the search hits sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>searchHitsSampleLimit</code></td>
<td>
<p>limit the size of the search hits sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignoreCollocateCase</code></td>
<td>
<p>logical, set to TRUE if collocate case should be ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withinSpan</code></td>
<td>
<p>KorAP span specification for collocations to be searched within</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exactFrequencies</code></td>
<td>
<p>if FALSE, extrapolate observed co-occurrence frequencies from frequencies in search hits sample, otherwise retrieve exact co-occurrence frequencies</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopwords</code></td>
<td>
<p>vector of stopwords not to be considered as collocates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>seed for random page collecting order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>
<p>if TRUE, <code>node</code> and <code>vc</code> parameters are expanded to all of their combinations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxRecurse</code></td>
<td>
<p>apply collocation analysis recursively <code>maxRecurse</code> times</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addExamples</code></td>
<td>
<p>If TRUE, examples for instances of collocations will be added in a column <code>example</code>. This makes a difference in particular if <code>node</code> is given as a lemma query.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholdScore</code></td>
<td>
<p>association score function (see <code>association-score-functions</code>) to use for computing the threshold that is applied for recursive collocation analysis calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>minimum value of <code>thresholdScore</code> function call to apply collocation analysis recursively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localStopwords</code></td>
<td>
<p>vector of stopwords that will not be considered as collocates in the current function call, but that will not be passed to recursive calls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collocateFilterRegex</code></td>
<td>
<p>allow only collocates matching the regular expression</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>more arguments will be passed to <code>collocationScoreQuery()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The collocation analysis is currently implemented on the client side, as some of the
functionality is not yet provided by the KorAP backend. Mainly for this reason
it is very slow (several minutes, up to hours), but on the other hand very flexible.
You can, for example, perform the analysis in arbitrary virtual corpora, use complex node queries,
and look for expression-internal collocates using the focus function (see examples and demo).
</p>
<p>To increase speed at the cost of accuracy and possible false negatives,
you can decrease searchHitsSampleLimit and/or topCollocatesLimit and/or set exactFrequencies to FALSE.
</p>
<p>Note that currently not the tokenization provided by the backend, i.e. the corpus itself, is used, but a tinkered one.
This can also lead to false negatives and to frequencies that differ from corresponding ones acquired via the web
user interface.
</p>


<h3>Value</h3>

<p>Tibble with top collocates, association scores, corresponding URLs for web user interface queries, etc.
</p>


<h3>See Also</h3>

<p>Other collocation analysis functions: 
<code>association-score-functions</code>,
<code>collocationScoreQuery,KorAPConnection-method</code>,
<code>synsemanticStopwords()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

 # Find top collocates of "Packung" inside and outside the sports domain.
 new("KorAPConnection", verbose = TRUE) %&gt;%
  collocationAnalysis("Packung", vc=c("textClass=sport", "textClass!=sport"),
                      leftContextSize=1, rightContextSize=1, topCollocatesLimit=20) %&gt;%
  dplyr::filter(logDice &gt;= 5)

## End(Not run)

## Not run: 

# Identify the most prominent light verb construction with "in ... setzen".
# Note that, currently, the use of focus function disallows exactFrequencies.
new("KorAPConnection", verbose = TRUE) %&gt;%
  collocationAnalysis("focus(in [tt/p=NN] {[tt/l=setzen]})",
    leftContextSize=1, rightContextSize=0, exactFrequencies=FALSE, topCollocatesLimit=20)

## End(Not run)

</code></pre>


</div>