<div class="container">

<table style="width: 100%;"><tr>
<td>rankclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Model-based clustering for multivariate partial ranking</h2>

<h3>Description</h3>

<p>This functions estimates a clustering of ranking data, potentially multivariate, partial and containing tied,
based on a mixture of multivariate ISR model [2].
By specifying only one cluster, the function performs a modelling of the ranking data using the multivariate ISR model.
The estimation is performed thanks to a SEM-Gibbs algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rankclust(
  data,
  m = ncol(data),
  K = 1,
  criterion = "bic",
  Qsem = 100,
  Bsem = 20,
  RjSE = m * (m - 1)/2,
  RjM = m * (m - 1)/2,
  Ql = 500,
  Bl = 100,
  maxTry = 3,
  run = 1,
  detail = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a matrix in which each row is a ranking (partial or not; for partial ranking,
missing elements must be 0 or NA. Tied are replaced by the lowest position they share). For multivariate rankings,
the rankings of each dimension are placed end to end in each row. The data must be in ranking notation (see Details or
convertRank functions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a vector composed of the sizes of the rankings of each dimension (default value is the number of column of the
matrix data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>an integer or a vector of integer with the number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>criterion "bic" or "icl", criterion to minimize for selecting the number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qsem</code></td>
<td>
<p>the total number of iterations for the SEM algorithm (default value=40).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bsem</code></td>
<td>
<p>burn-in period for SEM algorithm (default value=10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RjSE</code></td>
<td>
<p>a vector containing, for each dimension, the number of iterations of the Gibbs sampler
used both in the SE step for partial rankings and for the presentation orders generation (default value=mj(mj-1)/2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RjM</code></td>
<td>
<p>a vector containing, for each dimension, the number of iterations of the Gibbs sampler used in the  M step
(default value=mj(mj-1)/2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ql</code></td>
<td>
<p>number of iterations of the Gibbs sampler
for estimation of log-likelihood (default value=100).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bl</code></td>
<td>
<p>burn-in period for estimation of log-likelihood (default value=50).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxTry</code></td>
<td>
<p>maximum number of restarts of the SEM-Gibbs algorithm in the case of non convergence (default value=3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>run</code></td>
<td>
<p>number of runs of the algorithm for each value of K.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detail</code></td>
<td>
<p>boolean, if TRUE, time and others information will be print during the process (default value FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ranks have to be given to the package in the ranking notation (see convertRank function), with the following
convention:
</p>
<p>- missing positions are replaced by 0
</p>
<p>- tied are replaced by the lowest position they share
</p>
<p>See the vignette dataFormat for mode details (<code>RShowDoc("dataFormat", package = "Rankcluster")</code>).
</p>
<p>The ranking representation r=(r_1,...,r_m) contains the
ranks assigned to the objects, and means that the ith
object is in r_ith position.
</p>
<p>The ordering representation o=(o_1,...,o_m) means that object
o_i is in the ith position.
</p>
<p>Let us consider the following example to illustrate both
notations: a judge, which has to rank three holidays
destinations according to its preferences, O1 =
Countryside, O2 =Mountain and O3 = Sea, ranks first Sea,
second Countryside, and last Mountain. The ordering
result of the judge is o = (3, 1, 2) whereas the ranking
result is r = (2, 3, 1).
</p>


<h3>Value</h3>

<p>An object of class Rankclust (See <code>Output-class</code> and <code>Rankclust-class</code>).
If the output object is named <code>res</code>. You can access the result by res[number of groups]@slotName where
<code>slotName</code> is an element of the class Output.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>References</h3>

<p>[1] C.Biernacki and J.Jacques (2013), A generative model for rank data based on sorting algorithm,
Computational Statistics and Data Analysis, 58, 162-176.
</p>
<p>[2] J.Jacques and C.Biernacki (2012), Model-based clustering for multivariate partial ranking data,
Inria Research Report n 8113.
</p>


<h3>See Also</h3>

<p>See <code>Output-class</code> and <code>Rankclust-class</code> for available output.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(big4)
result &lt;- rankclust(big4$data, K = 2, m = big4$m, Ql = 200, Bl = 100, maxTry = 2)

if(result@convergence) {
  summary(result)

  partition &lt;- result[2]@partition
  tik &lt;- result[2]@tik
}

</code></pre>


</div>