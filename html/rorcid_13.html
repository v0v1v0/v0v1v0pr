<div class="container">

<table style="width: 100%;"><tr>
<td>orcid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Search for ORCID ID's.</h2>

<h3>Description</h3>

<p>Search for ORCID ID's.
</p>


<h3>Usage</h3>

<pre><code class="language-R">orcid(
  query = NULL,
  start = NULL,
  rows = NULL,
  defType = NULL,
  q.alt = NULL,
  qf = NULL,
  mm = NULL,
  qs = NULL,
  pf = NULL,
  ps = NULL,
  pf2 = NULL,
  ps2 = NULL,
  pf3 = NULL,
  ps3 = NULL,
  tie = NULL,
  bq = NULL,
  bf = NULL,
  boost = NULL,
  uf = NULL,
  lowercaseOperators = NULL,
  fuzzy = FALSE,
  recursive = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>Search terms. You can do quite complicated queries using the
SOLR syntax. See examples below. For all possible fields to query, do
<code>data(fields)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Result number to start on. Keep in mind that pages start at 0.
Default: 0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>Numer of results to return. Default: 10. Max: 200</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defType</code></td>
<td>
<p>Query syntax. One of edismax or X. See Details for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.alt</code></td>
<td>
<p>If specified, this query will be used (and parsed by default
using standard query parsing syntax) when the main query string is not
specified or blank. This comes in handy when you need something like a
match-all-docs query (don't forget &amp;rows=0 for that one!) in order to get
collection-wise faceting counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qf</code></td>
<td>
<p>(Query Fields) List of fields and the "boosts" to associate with
each of them when building DisjunctionMaxQueries from the user's query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mm</code></td>
<td>
<p>(Minimum 'Should' Match).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qs</code></td>
<td>
<p>(Query Phrase Slop) Amount of slop on phrase queries explicitly
included in the user's query string (in qf fields; affects matching).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>
<p>(Phrase Fields) Once the list of matching documents has been
identified using the "fq" and "qf" params, the "pf" param can be used to
"boost" the score of documents in cases where all of the terms in the "q"
param appear in close proximity</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps</code></td>
<td>
<p>(Phrase Slop) Default amount of slop on phrase queries built with
"pf", "pf2" and/or "pf3" fields (affects boosting).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf2</code></td>
<td>
<p>(Phrase bigram fields) As with 'pf' but chops the input into
bi-grams, e.g. "the brown fox jumped" is queried as "the brown" "brown fox"
"fox jumped"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps2</code></td>
<td>
<p>(Phrase bigram slop) As with 'ps' but sets default slop factor for
'pf2'. If not specified, 'ps' will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf3</code></td>
<td>
<p>(Phrase trigram fields) As with 'pf' but chops the input into
tri-grams, e.g. "the brown fox jumped" is queried as "the brown fox"
"brown fox jumped"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps3</code></td>
<td>
<p>(Phrase trigram slop) As with 'ps' but sets default slop factor
for 'pf3'. If not specified, 'ps' will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tie</code></td>
<td>
<p>(Tie breaker) Float value to use as tiebreaker in
DisjunctionMaxQueries (should be something much less than 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bq</code></td>
<td>
<p>(Boost Query) A raw query string (in the SolrQuerySyntax) that will
be included with the user's query to influence the score. See references</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bf</code></td>
<td>
<p>(Boost Function, additive) Functions (with optional boosts) that
will be included in the user's query to influence the score. Any function
supported natively by Solr can be used, along with a boost value, e.g.:
recip(rord(myfield),1,2,3)^1.5</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boost</code></td>
<td>
<p>(Boost Function, multiplicative) As for 'bf' but multiplies the
boost into the  score</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uf</code></td>
<td>
<p>(User Fields) Specifies which schema fields the end user shall be
allowed to query for explicitly. This parameter supports wildcards.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowercaseOperators</code></td>
<td>
<p>This param controls whether to try to interpret
lowercase words as boolean operators such as "and", "not" and "or".
Set &amp;lowercaseOperators=true to allow this. Default is "false".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fuzzy</code></td>
<td>
<p>Use fuzzy matching on input DOIs. Defaults to FALSE. If FALSE,
we stick "digital-object-ids" before the DOI so that the search sent to
ORCID is for that exact DOI. If TRUE, we use some regex to find the DOI.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>DEFUNCT</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Curl options passed on to <code>crul::HttpClient()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>All query syntaxes available in SOLR 3.6 (
<a href="https://lucene.apache.org/solr/guide/8_7/the-standard-query-parser.html">https://lucene.apache.org/solr/guide/8_7/the-standard-query-parser.html</a>)
are supported, including Lucene with Solr extensions (default), DisMax,
and Extended Dismax.
</p>
<p>You can use any of the following within the query statement:
given-names, family-name, credit-name, other-names, email, grant-number,
patent-number, keyword, worktitle, digital-objectids, current-institution,
affiliation-name, current-primary-institution, text, past-institution,
peer-review-type, peer-review-role, peer-review-group-id, biography,
external-id-type-and-value
</p>
<p>For more complicated queries the ORCID API supports using ExtendedDisMax.
See the documentation on the web here:
<a href="https://lucene.apache.org/solr/guide/8_7/the-extended-dismax-query-parser.html">https://lucene.apache.org/solr/guide/8_7/the-extended-dismax-query-parser.html</a>
</p>
<p>Note that when constructing queries, you don't need to use syntax like
<code>+</code>, etc., <code>crul</code>, the http client we use internally, will do that
for you. For example, instead of writing <code>johnson+cardiology</code>, just
write <code style="white-space: pre;">⁠johnson cardiology⁠</code>, and instead of writing
<code>johnson+AND+cardiology</code>, write <code style="white-space: pre;">⁠johnson AND cardiology⁠</code>. Though,
you still need to use <code>AND</code>, <code>OR</code>, etc. to join term/queries
together.
</p>


<h3>Value</h3>

<p>a data.frame (tibble). You can access number of results found like
<code>attr(result, "found")</code>. Note that with ORCID API v2 and greater,
results here are only the identifiers. To get other metadata/data
you can take the identifiers and use other functions in this package.
</p>


<h3>References</h3>

<p><a href="https://members.orcid.org/api/tutorial/search-orcid-registry">https://members.orcid.org/api/tutorial/search-orcid-registry</a>
<a href="https://lucene.apache.org/solr/guide/8_7/the-extended-dismax-query-parser.html">https://lucene.apache.org/solr/guide/8_7/the-extended-dismax-query-parser.html</a>
</p>


<h3>See Also</h3>

<p><code>orcid_doi()</code> <code>orcid_id()</code> <code>orcid_search()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Get a list of names and Orcid IDs matching a name query
orcid(query="carl+boettiger")
orcid(query="given-names:carl AND family-name:boettiger")

# by email
orcid(query="email:cboettig@berkeley.edu")

# You can string together many search terms
orcid(query="johnson cardiology houston")

# peer review group id
orcid("peer-review-group-id:1996-3068")

# And use boolean operators
orcid("johnson AND(caltech OR 'California Institute of Technology')")

# And you can use start and rows arguments to do pagination
orcid("johnson cardiology houston", start = 2, rows = 3)

# Use search terms, here family name
orcid("family-name:Sanchez", start = 4, rows = 6)

# Use search terms, here...
orcid(query="Raymond", start=0, rows=10, defType="edismax")

# Search using keywords
orcid(query="keyword:ecology")

# Search by DOI
orcid(query="10.1087/20120404")

# Note the difference between the first wrt the second and third
## See also orcid_doi() function for searching by DOIs
orcid("10.1087/20120404")
orcid('"10.1087/20120404"')
## doi
orcid('digital-object-ids:"10.1087/20120404"')
## doi prefix
orcid('digital-object-ids:"10.1087/*"')

# search by work titles
orcid('work-titles:Modern developments in holography and its materials')
orcid('pmc:PMC3901677')

## Using more complicated SOLR queries

# Use the qf parameter to "boost" query fields so they are ranked higher
# 	See how it is different than the second query without using "qf"
orcid(defType = "edismax", query = "Raymond",
   qf = "given-names^1.0 family-name^2.0", start = 0, rows = 10)
orcid(query = "Raymond", start = 0, rows = 10)

# Use other SOLR parameters as well, here mm. Using the "mm" param, 1 and
# 2 word queries require that all of the optional clauses match, but for
# queries with three or more clauses one missing clause is allowed...
# See for more: http://bit.ly/1uyMLDQ
orcid(defType = "edismax",
      query="keyword:ecology OR evolution OR conservation",
      mm = 2, rows = 20)

## End(Not run)
</code></pre>


</div>