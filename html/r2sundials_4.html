<div class="container">

<table style="width: 100%;"><tr>
<td>r2cvodes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solving ODE System and Sensitivity Equations</h2>

<h3>Description</h3>

<p><code>r2cvodes</code> sets up necessary structures and calls <code>cvodes()</code> from SUNDIALS library to solve user defined ODE system <code class="reqn">y' = f(t, y, p)</code>, <code class="reqn">y(t0) = y0</code>, where <code class="reqn">p</code> is a constant parameter vector. If requested, corresponding forward sensitivity equations <code class="reqn">s'[i] = df/dy s[i] + df/dp[i]</code>, <code class="reqn">s[i](t0) = dy0(p)/dp[i]</code> (here <code class="reqn">s[i](t)=dy(t)/dp[i]</code>) can be solved simultaneously with the original ODE system. Root finding and proceeding can be defined as well.
</p>


<h3>Usage</h3>

<pre><code class="language-R">r2cvodes(
  yv,
  times,
  frhs,
  param = NULL,
  tstop = as.numeric(c()),
  abstol = 1e-08,
  reltol = 1e-08,
  integrator = as.integer(c()),
  maxord = 0L,
  maxsteps = 0L,
  hin = 0,
  hmax = 0,
  hmin = 0,
  constraints = as.numeric(c()),
  fjac = NULL,
  nz = 0L,
  rmumps_perm = as.integer(c()),
  nroot = 0L,
  froot = NULL,
  fevent = NULL,
  Ns = 0L,
  psens = as.numeric(c()),
  sens_init = as.numeric(c()),
  psens_bar = as.numeric(c()),
  psens_list = as.integer(c()),
  fsens = NULL,
  fsens1 = NULL,
  sens_method = as.integer(c()),
  errconS = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>yv</code></td>
<td>
<p>const numeric vector, initial values of state vector (<code class="reqn">y0</code>). Its length defines the number of equations in the ODE system and is refered hereafter as 'Neq'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>const numeric vector, time point values at which the solution is stored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frhs</code></td>
<td>
<p>R function or XPtr pointer to Rcpp function, defines rhs <code class="reqn">f(t, y, p)</code>, i.e. returns (or fills in place) first derivative vector of length <code>Neq</code> (cf. details for argument list)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>any R object (default <code>NULL</code>), parameter object (can be a vector, list, environment, ...) passed through to user defined functions namely to <code>frhs</code>. It can be useful to get the code more readable as named parameters are authorized. (Starting from this one, the following parameters are optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tstop</code></td>
<td>
<p>const numeric scalar (default <code>as.numeric(c())</code>) if non empty, defines a time point beyond which the calculation is not made (e.g. out of definition domain). If a vector is given, only the first value is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abstol</code></td>
<td>
<p>const numeric scalar (default <code>1.e-8</code>), absolute tolerance in ODE solving (used for values which are close to 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>const double (default <code>1.e-8</code>), relative tolerance in ODE solving (used for values which are not so close to 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integrator</code></td>
<td>
<p>integer scalar (default <code>as.integer(c())</code>), defines which integration scheme should be used by cvodes: implicit (<code>CV_BDF</code>) or explicit (<code>CV_ADAMS</code>). Default empty vector is equivalent to <code>CV_BDF</code>. Constants <code>CV_BDF</code> and <code>CV_ADAMS</code> (as other mentioned constants) are defined by the package and are available for user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxord</code></td>
<td>
<p>const integer scalar (default <code>0</code>), defines maximal order of time scheme. Default 0 values is equivalent to 5 for <code>integrator=CV_BDF</code> or to 12 for <code>integrator=CV_ADAMS</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxsteps</code></td>
<td>
<p>const integer scalar (default <code>0</code>), maximum of internal steps before reaching next time point from 'times'. Default 0 is equivalent to 500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hin</code></td>
<td>
<p>const numeric scalar (default <code>0</code>), value of the initial step size to be attempted. Default 0.0 corresponds to <code>cvodes</code>' default value which is internally estimated at <code class="reqn">t0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hmax</code></td>
<td>
<p>const numeric scalar (default <code>0</code>), maximum absolute value of the time step size (&gt;= 0.0). The default 0 value is equivalent to Inf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hmin</code></td>
<td>
<p>const numeric scalar (default <code>0</code>), minimum absolute step size (&gt;= 0.0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>const numeric vector (default <code>as.numeric(c())</code>), if non empty, defines constraint flags. <br> If constraints[i] is <br> 0 then no constraint is imposed on <code class="reqn">y[i]</code>; <br> 1.0 then <code class="reqn">y[i]</code> will be constrained to be <code class="reqn">y[i]</code> &gt;= 0.0; <br> -1.0 then <code class="reqn">y[i]</code> will be constrained to be <code class="reqn">y[i]</code> =&lt; 0.0.; <br> 2.0 then <code class="reqn">y[i]</code> will be constrained to be <code class="reqn">y[i]</code> &gt; 0.0.; <br> -2.0 then <code class="reqn">y[i]</code> will be constrained to be <code class="reqn">y[i]</code> &lt; 0.0. <br> If a time step respecting hmin and avoiding constraint violation cannot be found, an error is triggered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fjac</code></td>
<td>
<p>R function of XPtr pointer to Rcpp function (default <code>NULL</code>), users supplied function that calculates Jacobian matrix df/dy which can be dense or sparse (cf. details for parameter list). If <code>fjac</code> is not supplied, a SUNDIALS internal approximation to Jacobian is used when needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nz</code></td>
<td>
<p>const integer scalar (default <code>0</code>), number of non zero elements in Jacobian. If &gt; 0, this parameter triggers a sparse Jacobian usage. In this case, the previous parameter <code>fjac</code>, must be a function (or a pointer to a function) with appropriate parameter list (cf. details) filling a sparse matrix. It is advised to have <code>nz</code> accounting not only for non zeros in the Jacobian itself but also for diagonal terms even if they are zeros. In this case, a supplementary memory allocation can be avoided. If a sparse Jacobian is used, corresponding sparse linear system is solved with the help of <span class="pkg">rmumps</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmumps_perm</code></td>
<td>
<p>integer scalar (default <code>as.integer(c())</code>), defines permutation method that will be used by <span class="pkg">rmumps</span> during symbolic analysis before solving sparse linear systems. Default value is equivalent to <code>RMUMPS_PERM_AUTO</code>. Possible values (defined in <span class="pkg">rmumps</span> package) are <code>RMUMPS_PERM_AMF</code>, <code>RMUMPS_PERM_AMD</code>, <code>RMUMPS_PERM_AUTO</code>, <code>RMUMPS_PERM_QAMD</code>, <code>RMUMPS_PERM_PORD</code>, <code>RMUMPS_PERM_METIS</code>, <code>RMUMPS_PERM_SCOTCH</code>. An appropriate choice of permutation type can reduce memory requirements as well as calculation speed for sparse system solving. If a vector is supplied, only the first value is read. If <code>nz=0</code>, this parameter is not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nroot</code></td>
<td>
<p>const integer scalar (default <code>0</code>), defines number of roots that user wishes to track.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>froot</code></td>
<td>
<p>R function of XPtr pointer to Rcpp function (default <code>NULL</code>), user defined function calculating root vector of length <code>nroot</code>. When at least one component of this vector crosses 0, a root finding event is triggered and corresponding root handling function is called (cf. <code>fevent</code>). This defines a very flexible root tracking mechanism. User can define a root based both on time values and state vector (y).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fevent</code></td>
<td>
<p>R function of XPtr pointer to Rcpp function (default <code>NULL</code>), defines function for root proceeding. When a root is encountered, this function is called. Its return value defines what to do with this root. User's reaction (i.e. the return value of <code>fevent</code>) can be one of three types: 
<br><code>R2SUNDIALS_EVENT_IGNORE</code> - do nothing (can be helpful if, for example, 0 is crossed not in pertinent sens); <br><code>R2SUNDIALS_EVENT_HOLD</code> - the time point at which the root happened as well as the corresponding <code>rootsfound</code> vector are added to the root matrix delivered with output attributes (cf. details).
This time point is also added to the ODE solution which can lead to a new time point, originally absent in 'times' vector; <br><code>R2SUNDIALS_EVENT_STOP</code> - stops the ODE solving. If it happens before reaching the last value in 'times', the ODE solution can have less time points than initially defined in 'times' parameter.
<code>fevent</code> is allowed to modify the vector state y in an arbitrary way. It can be helpful for modeling some controlling events for example adding some compound to chemical mix or modifying speed vector if an obstacle is hitted. If such modification takes place, the ODE system is restarted to handle in appropriate way induced discontinuities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ns</code></td>
<td>
<p>const integer scalar (default <code>0</code>), number of parameters for which forward sensitivity system has to be solved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psens</code></td>
<td>
<p>numeric vector (default <code>as.numeric(c())</code>), if not empty, defines a vector of parameters for which (or for some components of which) forward sensitivity system has to be solved. If its length &gt; <code>Ns</code>, then vector <code>psens_list</code> of length <code>Ns</code> must define which are the <code>Ns</code> components of <code>psens</code> with respect to which sensitivities are to be computed. Note that parameters used in sensitivity calculations must be put in <code>psens</code> vector (and not somewhere in 'param' object) only if user wish to rely on SUNDIALS internal procedure for estimation of sensitivity rhs. If user provides its own function for sensitivity rhs, he is free to use either of 'param' or <code>psens</code> for passing and accessing sensitivity parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sens_init</code></td>
<td>
<p>numeric matrix (default <code>as.numeric(c())</code>), matrix with <code>Neq</code> rows and <code>Ns</code> columns defining initial condition for sensititivy system. Default value is equivalent to <code>Neq</code> x <code>Ns</code> zero matrix which means that <code class="reqn">y0</code> is not dependent on <code class="reqn">p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psens_bar</code></td>
<td>
<p>numeric vector (default <code>as.numeric(c())</code>), a vector of <code>Ns</code> positive scaling factors. The values provided in this vector, describe orders of magnitude for <code>psens</code> components. Having such estimations can help to increase the accuracy for sensitivity vector calculations or for the right-hand side calculation for the sensitivity systems based on the internal difference-quotient function. If not defined, it is equivalent to set all <code>psens_bar</code> components to 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psens_list</code></td>
<td>
<p>const integer vector (default <code>as.integer(c())</code>), if <code>length(psens) &gt; Ns</code>, this index vector can be used to indicate which are components of <code>psens</code> that are concerned with sensitivity calculations. Default value is valid only when <code>length(psens)==Ns</code>, i.e. <code>psens_list</code> is not used. Values in <code>psens_list</code> are 1-based (as regular integer indexes in R)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsens</code></td>
<td>
<p>R function of XPtr pointer to Rcpp function (default <code>NULL</code>), user defined sensitivity rhs for all <code>psens</code> at once.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsens1</code></td>
<td>
<p>R function of XPtr pointer to Rcpp function (default <code>NULL</code>), user defined sensitivity rhs for <code>is</code>-th <code>psens</code> component (<code>is</code> is passed as input parameter to <code>fsens1</code>, cf. details). Only one of <code>fsens</code> or <code>fsens1</code> can be supplied. If none of them is supplied, SUNDIALS' internal difference-quotient function is used. In this case, sensitivity parameters must be passed only through <code>psens</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sens_method</code></td>
<td>
<p>integer scalar (default <code>as.integer(c())</code>), constant defining the method used for solving sensitivity system. Allowed values are <code>CV_SIMULTANEOUS</code> or <code>CV_STAGGERED</code>. Default value is equivalent to <code>CV_SIMULTANEOUS</code>. </p>

<ul>
<li> <p><code>CV_SIMULTANEOUS</code> means that the state and sensitivity variables are corrected at the same time.
</p>
</li>
<li> <p><code>CV_STAGGERED</code> means that the correction step for the sensitivity variables takes place at the same time for all sensitivity equations, but only after the correction of the state variables has converged and the state variables have passed the local error test
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errconS</code></td>
<td>
<p>constant logical scalar (default <code>TRUE</code>), specifies whether sensitivity variables are to be included (<code>TRUE</code>) or not (<code>FALSE</code>) in the error control mechanism</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The package <span class="pkg">r2sundials</span> was designed to avoid as much as possible memory reallocation in callback functions (<code>frhs</code> and others). C++ variants of these functions are fully compliant with this design principle. While R counterparts are not (as per R design). Here, we define callback function interfaces that user has to abide to. Pointers to C++ variants to be passed to <code>r2cvodes()</code> can be obtained with the help of <span class="pkg">RcppXPtrUtils</span>. See examples for illustrations of such use.
<br> Right hand side function <code>frhs</code> provided by user calculates derivative vector <code class="reqn">y'</code>. This function can be defined as classical R function or a Rcpp/RcppArmadillo function. In the first case, it must have the following list of input arguments<br><code>frhs(t, y, param, psens)</code><br>
and return a derivative vector of length <code>Neq</code>. Here <code>t</code> is time point (numeric scalar), <code>y</code> current state vector (numeric vector of length <code>Neq</code>), <code>param</code> and <code>psens</code> are passed through from <code>r2cvodes()</code> arguments.
<br> In the C++ case, it is defined as<br><code>int (*frhs)(double t, const vec &amp;y, vec &amp;ydot, RObject &amp;param, NumericVector &amp;psens)</code><br>
and return an integer status flag, e.g. <code>CV_SUCCESS</code>. For other possible status flags see the original <a href="https://computing.llnl.gov/">SUNDIALS documentation</a> (search for cvs_guide.pdf). The derivatives are stored in-place in <code>ydot</code> vector. See examples section for a usage sample.
<br><code>fjac</code> is a function calculating Jacobian matrix. Its definition varies depending on 1) kind of used Jacobian: dense or sparse and 2) on programming language used: R or C++ (i.e. Rcpp/RcppArmadillo).
</p>

<ul>
<li>
<p>For dense Jacobian calculated in R, the arguments are:<br><code>fjac(t, y, ydot, param, psens)</code><br>
and the expected return value is <code>Neq</code> x <code>Neq</code> dense Jacobian matrix df/dy.
</p>
</li>
<li>
<p>For dense Jacobian calculated in C++ the definition is following:<br><code>int (*fjac)(double t, const vec &amp;y, const vec &amp;ydot, mat &amp;J, RObject &amp;param, NumericVector &amp;psens, vec &amp;tmp1, vec &amp;tmp2, vec &amp;tmp3)</code><br>
It must return a status flag. The resulting Jacobian is stored in-place in the the matrix <code>J</code>. Auxiliary vectors <code>tmp1</code> to <code>tmp3</code> are of length <code>Neq</code> and are made available for intermediate storage thus avoiding memory reallocation at each call to <code>fjac()</code>.
</p>
</li>
<li>
<p>For sparse Jacobian calculated in R, the arguments are:<br><code>fjac(t, yv, ydotv, param, psens)</code><br>
The return value is a list with fields <code>i</code> (row indices), <code>p</code> (column pointers) and <code>v</code> (matrix values) defining the content of sparse Jacobian in CSC (condensed sparse column) format. The values stored in i and p vectors are supposed to be 1-based, as it is common in R language.
</p>
</li>
<li>
<p>For sparse Jacobian calculated in C++ the definition is following:<br><code>int (*fjac)(double t, const vec &amp;y, const vec &amp;ydot, uvec &amp;i, uvec &amp;p, vec &amp;v, int n, int nz, RObject &amp;param, NumericVector &amp;psens, vec &amp;tmp1, vec &amp;tmp2, vec &amp;tmp3)</code><br>
here <code>n=Neq</code>, <code>nz</code> is passed through from r2cvodes() arguments. The resulting sparse Jacobian is stored in-place in vectors <code>i</code>, <code>p</code>, <code>v</code> corresponding to the CSC (Compressed Sparse Column) format. Their respective dimensions are <code>nz</code>, <code>n+1</code> and <code>nz</code>. The values stored in <code>i</code> and <code>p</code> must be 0 based as per usage in C++. The return value is a status flag.
</p>
</li>
</ul>
<p><code>froot</code> calculates a root vector, i.e. a vector whose components are tracked for 0 crossing during the time course in ODE solving. If written in R, its call follows the following pattern:<br><code>froot(t, y, param, psens)</code><br>
and it must return a numeric vector of length 'nroot'. If written in C++, it is defined as<br><code>int (*froot)(double t, const vec &amp;y, vec &amp;vroot, RObject &amp;param, NumericVector &amp;psens)</code><br>
The tracked values are stored in-place in <code>vroot</code>. The returned value is a status flag.
<br><code>fevent</code> handles the event of root finding. If written in R, the calling pattern is<br><code>fevent(t, yvec, Ns, ySm, rootsfound, param, psens)</code><br>
and the return value is a list with named component "ynew", "flag" and "sens_init". The last item is required only when <code>Ns &gt; 0</code>. Current value of sensitivity matrix <code class="reqn">dy/dp</code> can be found in parameter <code>ySm</code>. Integer vector 'rootsfound' of length 'nroot' provides information on <code>vroot</code> components that triggered the root event. If <code>rootsfound[i] != 0</code>, it means that <code>vroot[i]</code> is a root otherwise it is not. Moreover, the sign of <code>rootsfound[i]</code> is meaningful. If <code>rootsfound[i] &gt; 0</code> then <code>vroot[i]</code> is increasing at 0 crossing. Respectively, if <code>rootsfound[i] &lt; 0</code> then <code>vroot[i]</code> is decreasing. The vector 'ynew' in the output list can define a new state vector after event handling (for example, an abrupt change in velocity direction and/or magnitude after an obstacle hit). The field 'flag' in the output list is authorized to take only three values: <code>R2SUNDIALS_EVENT_IGNORE</code>, <code>R2SUNDIALS_EVENT_HOLD</code> and <code>R2SUNDIALS_EVENT_STOP</code> described here-before. The matrix <code>sens_init</code> is used for a possible restarting of sensitivity calculation. It must contain a derivative matrix <code class="reqn">dynew/dp</code> of size <code>Neq x Ns</code>. If this field is absent (NULL) then a zero matrix is assumed.
<br> If written in C++, this function is defined as<br><code>int (*fevent)(double t, const vec &amp;y, vec &amp;ynew, int Ns, std::vector&lt;vec&gt; &amp;ySv, const ivec &amp;rootsfound, RObject &amp;param, NumericVector &amp;psens)</code><br>
The new state vector can be stored in-place in <code>ynew</code> and the status flag indicating what to do with this event is the return value. If sensitivity calculation is going on (i.e. <code>Ns &gt; 0</code>), the current value of sensitivity vectors can be found in <code>ySv</code> and their new values can be stored in-place in the same parameter.
Note that if <code>ynew</code> is different from the vale of <code>y</code> when the root was found, the ODE is restarted from this time point to handle correctly the discontinuity. As a result, there will be two columns corresponding to the same time point: one with the state vector at root finding and one with <code>ynew</code> values. The same is true for sensitivity output, if it is part of the problem.
<br><code>fsens</code> calculates rhs for sensitivity system. If written in R, it must be defined as<br><code>fsens(Ns, t, y, ydot, ySm, param, psens)</code><br>
and return a dataframe in which i-th column correspond to <code class="reqn">s'[i]</code> sensitivity derivative vector. Among other parameters, it receives <code>ySm</code> which is a <code>Neq</code> x <code>Ns</code> matrix having the current values of sensitivity vector (i-th vector is in i-th column).
<br> If written in C++, it has to be defined as<br><code>int (*fsens)(int Ns, double t, const vec &amp;y, const vec &amp;ydot, const std::vector&lt;vec&gt; &amp;ySv, std::vector&lt;vec&gt; &amp;ySdotv, RObject &amp;param, NumericVector &amp;psens, const vec &amp;tmp1v, const vec &amp;tmp2v)</code><br>
Note a slight difference in the input parameters compared with the R counterpart. Here <code>ySv</code> plays the role of <code>ySm</code> and is not a matrix but a vector of Armadillo vectors. To access m-th component of <code class="reqn">s[i]</code>, one can simply do <code>ySv[i][m]</code> and the whole <code class="reqn">s[i]</code> is selected as <code>ySv[i]</code>. Such data structure was retained to keep as low as possible new memory reallocation. The resulting sensitivity derivatives are to be stored in-place in <code>ySdotv</code> according to the same data organization scheme as in <code>ySv</code>. This function returns a status flag.
<br><code>fsens1</code> does the same as <code>fsens</code> but provides derivatives of sensitivity vectors on one-by-one basis. This second form is provided for user's convenience as in some cases the code can become more readable if it calculates only one vector s'[i] at a time. If written in R, this function has to be defined as<br><code>fsens1(Ns, t, y, iS, ydot, yS, param, psens)</code><br>
here <code>iS</code> is the index of calculated vector <code class="reqn">s'[iS]</code> and <code>yS</code> contains the current value of <code class="reqn">s[iS]</code>.
If written in C++, this functions has to be defined as<br><code>int (*fsens1)(int Ns, double t, const vec &amp;yv, const vec &amp;ydotv, int iS, const vec &amp;ySv, vec &amp;ySdotv, RObject &amp;param, NumericVector &amp;psens, const vec &amp;tmp1v, const vec &amp;tmp2v)</code><br>
The result, i.e. <code class="reqn">s'[iS]</code> is to be stored in-place in <code>ySdotv</code> vector. This function returns a status flag.
</p>


<h3>Value</h3>

<p>numeric matrix, ODE solution where each column corresponds to a state vector at a given time point. The columns (their number is refered to as <code>Nt</code>) are named by time points while the rows heritates the names from <code>yv</code>. If no names are found in <code>yv</code>, the rows are simply named 'V1', 'V2' and so on. After a normal execution and without root handling, column number is equal to the length of <code>times</code>. However, if root handling is used, it can add or remove some time points from  <code>times</code>. So the user must not assume that column number of output matrix is equal to <code>length(times)</code>. Instead, actual number of time points for which the solution was calculated can be retrieved from an attribute named "times".
Moreover, several attributes are defined in the returned matrix. We have mentioned "times", the others are: </p>

<dl>
<dt>stats</dt>
<dd>
<p>Some statistics about various events that could happen during <code>cvodes</code> run like the number
of rhs calls, Jacobian calls, number of internal time steps, failure number and so on. Any component &lt;name&gt;
in stats vector corresponds to SUNDIALS function pattern CVodeGet&lt;name&gt;, e.g. "NumRhsEvals" was obtained with
CVodeGetNumRhsEvals() call. For detailed meaning of each statistics, user is invited to refer to
<a href="https://computing.llnl.gov/">SUNDIALS documentation</a> (search for cvs_guide.pdf);</p>
</dd>
<dt>roots</dt>
<dd>
<p>matrix with row number <code>nroot+1</code> and column number equal to number of roots found by the <code>cvodes()</code> and retained by the user. Each column is a composite vector made of time point and <code>rootsfound</code> vector described here-before.</p>
</dd>
<dt>sens</dt>
<dd>
<p>sensitivity 3D array with dimensions <code>Neq</code> x <code>Nt</code> x <code>Ns</code></p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R"># Ex.1. Solve a scalar ODE describing exponential transition form 0 to 1
# y'=-a*(y-1), y(0)=0, a is a parameter that we arbitrary choose to be 2.
# define rhs function (here in R).
frhs_exp=function(t, y, p, psens) -p$a*(y-1)
# define parameter list
p=list(a=2)
# define time grid from 0 to 5 (arbitrary units)
ti=seq(0, 5, length.out=101)
# define initial state vector
y0=0
# we are set for a very simple r2cvodes() call
res_exp=r2sundials::r2cvodes(y0, ti, frhs_exp, param=p)
# compare the result to theoretical values: 1-exp(-a*t)
stopifnot(diff(range(1-exp(-p$a*ti) - res_exp)) &lt; 1.e-6)

# Ex. 2. Same problem but frhs is written in C++
library(RcppXPtrUtils)
ptr_exp=cppXPtr(code='
int rhs_exp(double t, const vec &amp;y, vec &amp;ydot, RObject &amp;param, NumericVector &amp;psens) {
  NumericVector p(param);
  ydot[0] = -p["a"]*(y[0]-1);
  return(CV_SUCCESS);
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes=c("// [[Rcpp::plugins(cpp14)]]", "using namespace arma;", "#include &lt;r2sundials.h&gt;"), 
 verbose=FALSE) # use 'cacheDir="&lt;yourdir&gt;"' to keep compilation results between R sessions.
# For ease of use in C++, we convert param to a numeric vector instead of a list.
pv=c(a=p$a)
# new call to r2cvodes() with XPtr pointer ptr_exp.
res_exp2=r2sundials::r2cvodes(y0, ti, ptr_exp, param=pv)
stopifnot(diff(range(res_exp2 - res_exp)) &lt; 1.e-14)

# Ex.3. Bouncing ball simulation.
# A ball falls from a height y=5 m with initial vertical speed vy=0 m/s
# and horizontal speed vx=1 m/s. The forces acting on the ball are 1) the gravity
# (g=9.81 m/s^2) and 2) air resistance f=-k_r*v (k_r=0.1 N*s/m).
# When the ball hits the ground, it bounces instantly retaining k=0.9 part
# of its vertical and horizontal speed. At the bounce, the vertical speed
# changes its sign to the opposite while horizontal speed keeps the original sign.
# Simulation should stop after the 5-th bounce or at tmax=10 s which ever comes first.
# This example illustrates usage of root finding and handling.
# We give here an example of callback functions for root handling in C++.
yv=c(x=0, y=5, vx=1, vy=0) # initial state vector
pv=c(g=9.81, k_r=0.1, k=0.9, nbounce=5, tmax=10) # parameter vector
ti=seq(0, 20, length.out=201L) # time grid

# rhs
ptr_ball=cppXPtr(code='
int rhs_ball(double t, const vec &amp;y, vec &amp;ydot, RObject &amp;param, NumericVector &amp;psens) {
  NumericVector p(param);
  ydot[0] = y[2]; // dx/dt=vx
  ydot[1] = y[3]; // dy/dt=vy
  ydot[2] = -p["k_r"]*y[2]; // dvx/dt= -k_r*vx
  ydot[3] = -p["g"] - p["k_r"]*y[3]; // dvy/dt=-g -k_r*vy
  return(CV_SUCCESS);
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes=c("// [[Rcpp::plugins(cpp14)]]", "using namespace arma;", "#include &lt;r2sundials.h&gt;"), 
 verbose=FALSE) # use 'cacheDir="&lt;yourdir&gt;"' to keep compilation results between R sessions.

# root function
ptr_ball_root=cppXPtr(code='
int root_ball(double t, const vec &amp;y, vec &amp;vroot, RObject &amp;param, NumericVector &amp;psens) {
  NumericVector p(param);
  vroot[0] = y[1]; // y==0
  vroot[1] = t-p["tmax"]; // t==p["tmax"]
  return(0);
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes=c("// [[Rcpp::plugins(cpp14)]]", "using namespace arma;", "#include &lt;r2sundials.h&gt;"), 
 verbose=FALSE) # use 'cacheDir="&lt;yourdir&gt;"' to keep compilation results between R sessions.

# event handler function
ptr_ball_event=cppXPtr(code='
int event_ball(double t, const vec &amp;y, vec &amp;ynew, int Ns, std::vector&lt;vec&gt; &amp;ySv,
          const ivec &amp;rootsfound, RObject &amp;param, NumericVector &amp;psens) {
  NumericVector p(param);
  static int nbounce=0;
  if (rootsfound[1] != 0) // time is out
     return(R2SUNDIALS_EVENT_STOP);
  if (rootsfound[0] &gt; 0)
    // cross 0 in ascending sens, can happen when y &lt; 0 in limits of abstol
    return(R2SUNDIALS_EVENT_IGNORE);
  ynew=y;
  if (++nbounce &lt; p["nbounce"]) {
    // here nbounce=1:4
    ynew[2] *= p["k"]; // horizontal speed is lowered
    ynew[3] *= -p["k"]; // vertical speed is lowered and reflected
    return(R2SUNDIALS_EVENT_HOLD);
  } else {
    // here nbounce=5
    nbounce=0; // reinit counter for possible next calls to r2cvodes
    return(R2SUNDIALS_EVENT_STOP);
  }
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes=c("// [[Rcpp::plugins(cpp14)]]", "using namespace arma;", "#include &lt;r2sundials.h&gt;"), 
 verbose=FALSE) # use 'cacheDir="&lt;yourdir&gt;"' to keep compilation results between R sessions.

# ODE solving and plotting
res_ball &lt;- r2sundials::r2cvodes(yv, ti, ptr_ball, param=pv, nroot=2L,
  froot=ptr_ball_root, fevent=ptr_ball_event)
plot(res_ball["x",], res_ball["y",], xlab="X [m]", ylab="Y [m]",
  t="l", main="Bouncing ball simulation")

# Ex.4. Robertson chemical reactions
# This example is often used as an illustration and a benchmark for stiff ODE.
# We will demonstrate here:
# • how to use sparse Jacobian (not really meaningful for 3x3 sytem but just to give a hint);
# • how to make sensitivity calculations with user provided rhs.
#
# Let simulate the following chemical system of 3 compounds y1, y2 and y3
#  y1' = -k1*y1 + k3*y2*y3
#  y2' =  k1*y1 - k2*y2*y2 - k3*y2*y3
#  y3' =  k2*y2*y2
# Jacobian df/dy is
# 
# | -k1 |      k3*y3       |  k3*y2 |
# |-----+------------------+--------|
# |  k1 | -2*k2*y2 - k3*y3 | -k3*y2 |
# |-----+------------------+--------|
# |  0  |     2*k2*y2      |   0    |


yv &lt;- c(y1=1, y2=0, y3=0) # initial values
pv &lt;- c(k1 = 0.04, k2 = 3e7, k3 = 1e4) # parameter vector
ti=10^(seq(from = -5, to = 11, by = 0.1)) # exponential time grid

# pointer to rhs function
ptr_rob=cppXPtr(code='
int rhs_rob(double t, const vec &amp;y, vec &amp;ydot, RObject &amp;param, NumericVector &amp;psens) {
  NumericVector p(param);
  ydot[0] = -p["k1"]*y[0] + p["k3"]*y[1]*y[2];
  ydot[2] = p["k2"]*y[1]*y[1];
  ydot[1] = -ydot[0] - ydot[2];
  return(CV_SUCCESS);
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes=c("// [[Rcpp::plugins(cpp14)]]", "using namespace arma;", "#include &lt;r2sundials.h&gt;"), 
 verbose=FALSE) 
# pointer to sparse jacobian function
ptr_rob_jacsp=cppXPtr(code='
int spjac_rob(double t, const vec &amp;y, const vec &amp;ydot, uvec &amp;ir, uvec &amp;pj, vec &amp;v, int n, int nz,
              RObject &amp;param, NumericVector &amp;psens, vec &amp;tmp1, vec &amp;tmp2, vec &amp;tmp3) {
  if (nz &lt; 8)
    stop("spjac_rob: not enough room for non zeros, must have at least 8, instead got %d", nz);
  NumericVector p(param);
  int i=0;
  pj[0] = 0; // init pj
  // first column
  ir[i] = 0;
  v[i++] = -p["k1"];
  ir[i] = 1;
  v[i++] = p["k1"]; 
  pj[1] = i;
  // second column
  ir[i] = 0;
  v[i++] = p["k3"]*y[2];
  ir[i] = 1;
  v[i++] = -p["k3"]*y[2]-2*p["k2"]*y[1];
  ir[i] = 2;
  v[i++] = 2*p["k2"]*y[1];
  pj[2] = i;
  // third column
  ir[i] = 0;
  v[i++] = p["k3"]*y[1];
  ir[i] = 1;
  v[i++] = -p["k3"]*y[1];
  ir[i] = 2;
  v[i++] = 0; // just to have the main diagonal fully in Jacobian
  pj[3] = i;
  return(0);
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes=c("// [[Rcpp::plugins(cpp14)]]", "using namespace arma;", "#include &lt;r2sundials.h&gt;"), 
 verbose=FALSE) # use 'cacheDir="&lt;yourdir&gt;"' to keep compilation results between R sessions.
# pointer to sensitivity rhs function
ptr_rob_sens1=cppXPtr(code='
int sens_rob1(int Ns, double t, const vec &amp;y, const vec &amp;ydot, int iS, const vec &amp;yS, vec &amp;ySdot,
              RObject &amp;param, NumericVector &amp;psens, vec &amp;tmp1, vec &amp;tmp2) {
  // calculate (df /dy)s_i(t) + (df /dp_i) for i = iS
  NumericVector p(param);
  // (df/dy)s_i(t)
  ySdot[0] = -p["k1"]*yS[0] + p["k3"]*y[2]*yS[1] + p["k3"]*y[1]*yS[2];
  ySdot[1] = p["k1"]*yS[0] - (p["k3"]*y[2]+2*p["k2"]*y[1])*yS[1] - p["k3"]*y[1]*yS[2]; 
  ySdot[2] = 2*p["k2"]*y[1]*yS[1];
  // + (df/dp_i)
  switch(iS) {
    case 0:
      ySdot[0] -= y[0];
      ySdot[1] += y[0];
      break;
    case 1:
      ySdot[1] -= y[1]*y[1];
      ySdot[2] += y[1]*y[1];
      break;
    case 2:
      ySdot[0] += y[1]*y[2];
      ySdot[1] -= y[1]*y[2];
  }
  return(CV_SUCCESS);
}
', depends=c("RcppArmadillo","r2sundials","rmumps"),
 includes=c("// [[Rcpp::plugins(cpp14)]]", "using namespace arma;", "#include &lt;r2sundials.h&gt;"), 
 verbose=FALSE) # use 'cacheDir="&lt;yourdir&gt;"' to keep compilation results between R sessions.
# Note that we don't use psens param for sensitivity calculations as we provide our own fsens1.
res_rob &lt;- r2sundials::r2cvodes(yv, ti, ptr_rob, param=pv, nz=8, fjac=ptr_rob_jacsp, Ns=3,
                              fsens1=ptr_rob_sens1)
# plot ODE solution
layout(t(1:3)) # three sublots in a row
for (i in 1:3)
   plot(ti, res_rob[i,], log="x", t="l", xlab="Time", ylab=names(yv)[i])
# plot sensitivities
layout(matrix(1:9, nrow=3)) # 9 subplots in a square
for (j in 1:3) # run through pv
   for (i in 1:3) # run through y
      plot(ti, attr(res_rob, "sens")[i,,j], log="x", t="l", xlab="Time",
           ylab=parse(text=paste0("partialdiff*y[", i, "]/partialdiff*k[", j, "]")))

</code></pre>


</div>