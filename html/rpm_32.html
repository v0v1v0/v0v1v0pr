<div class="container">

<table style="width: 100%;"><tr>
<td>microsimulate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Micro simulate a population from a Revealed Preference Matchings Model</h2>

<h3>Description</h3>

<p><code>microsimulate</code> simulates a population of the pairs and singles
from a Revealed Preference Matchings Model. It is typically based on the estimate from a <code>rpm()</code> call.
</p>


<h3>Usage</h3>

<pre><code class="language-R">microsimulate(
  object,
  nsim = 1,
  seed = NULL,
  pmfW_N = NULL,
  pmfM_N = NULL,
  large.population = TRUE,
  bootstrap = FALSE,
  control = control.rpm(),
  counts.only = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>list; an object of class<code>rpm</code> that is typically the result of a call to <code>rpm()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>Number of matchings to be randomly drawn from the given
model on the set of all matchings / singles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer; (Optional) random number seed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmfW_N</code></td>
<td>
<p>vector; The population count of the number of women of each type. 
This should be compatible with the type in the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmfM_N</code></td>
<td>
<p>vector; The population count of the number of men of each type. 
This should be compatible with the type in the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>large.population</code></td>
<td>
<p>logical; If TRUE a large population approximation is used to generate
the matchings (rather than the individual level generation of utilities). This is much faster and
uses a lot less memory. It is TRUE by default. If used, a sample is drawn rather than the
population being returned. The sample size is controlled by <code>pmfW_N</code> and <code>pmfM_N</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap</code></td>
<td>
<p>logical; If TRUE the original population is sampled from. If FALSE the
population underlying the fitted model is sampled from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control parameters for algorithm tuning. Constructed using
<code>control.rpm</code>, which should be consulted for specifics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts.only</code></td>
<td>
<p>logical; If TRUE only the matrices of counts and the PMF of the population of households is returned.
If FALSE 
It is FALSE by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; Should verbose messages be printed out.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function requites the numbers of women of each type and the number of men of each type to be specified. 
</p>
<p>The function <code>rpm</code> is used to fit a revealed preference model
for men and women of certain
characteristics (or shared characteristics) of people of the opposite sex.
The model assumes a one-to-one stable matching using an observed set of
matchings and a set of (possibly dyadic) covariates to 
estimate the parameters for
linear equations of utilities.
It does this using an large-population likelihood based on ideas from Dagsvik (2000), Menzel (2015) and Goyal et al (2023).
</p>
<p>The model represents the dyadic utility functions as deterministic linear utility functions of
dyadic variables. These utility functions are functions of observed characteristics of the women
and men.
These functions are entered as terms in the function call
to <code>rpm</code>. This function simulates a population from such a model.
</p>


<h3>Value</h3>

<p>A list of lists, each a simulation from the population. Each of the simulation lists contains
components <code>population</code> being a list with components <code>Xdata</code> and <code>Zdata</code> (for use with <code>rpm()</code>).
</p>


<h3>References</h3>

<p>Goyal, Shuchi; Handcock, Mark S.; Jackson, Heide M.; Rendall, Michael S. and Yeung, Fiona C. (2023).
<em>A Practical Revealed Preference Model for Separating Preferences and Availability Effects in Marriage Formation</em>,
<em>Journal of the Royal Statistical Society</em>, A. <a href="https://doi.org/10.1093/jrsssa/qnad031">doi:10.1093/jrsssa/qnad031</a> 
</p>
<p>Dagsvik, John K. (2000) <em>Aggregation in Matching Markets</em> <em>International Economic Review</em>, Vol. 41, 27-57.
JSTOR: https://www.jstor.org/stable/2648822, <a href="https://doi.org/10.1111/1468-2354.00054">doi:10.1111/1468-2354.00054</a>
</p>
<p>Menzel, Konrad (2015).
<em>Large Matching Markets as Two-Sided Demand Systems</em>
Econometrica, Vol. 83, No. 3 (May, 2015), 897-941. <a href="https://doi.org/10.3982/ECTA12299">doi:10.3982/ECTA12299</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(rpm)

data(fauxmatching)
fit &lt;- rpm(~match("edu") + WtoM_diff("edu",3),
          Xdata=fauxmatching$Xdata, Zdata=fauxmatching$Zdata,
          X_w="X_w", Z_w="Z_w",
          pair_w="pair_w", pair_id="pair_id", Xid="pid", Zid="pid",
          sampled="sampled")
num_women = fit$N*exp(fit$gw)
num_men   = fit$N*exp(fit$gm)
pmfW_N &lt;- round(fit$pmfW * num_women)
pmfM_N &lt;- round(fit$pmfM * num_men)
a &lt;- microsimulate(fit, pmfW_N=pmfW_N, pmfM_N=pmfM_N)

</code></pre>


</div>