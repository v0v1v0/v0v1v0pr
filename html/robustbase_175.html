<div class="container">

<table style="width: 100%;"><tr>
<td>Qn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Robust Location-Free Scale Estimate More Efficient than MAD</h2>

<h3>Description</h3>

<p>Compute the robust scale estimator <code class="reqn">Q_n</code>, an efficient
alternative to the MAD.
</p>
<p>By default, <code class="reqn">Q_n(x_1, \ldots, x_n)</code> is the <code class="reqn">k</code>-th
order statistic (a quantile) of the <code>choose(n, 2)</code> absolute
differences <code class="reqn">|x_i - x_j|</code>,
(for <code class="reqn">1 \le i &lt; j \le n</code>),
where by default (originally only possible value) <code class="reqn">k = choose(n\%/\% 2 + 1, 2)</code>
which is about the first quartile (25% quantile) of these
pairwise differences.  See the references for more.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Qn(x, constant = NULL, finite.corr = is.null(constant) &amp;&amp; missing(k),
   na.rm = FALSE, k = choose(n %/% 2 + 1, 2), warn.finite.corr = TRUE)

s_Qn(x, mu.too = FALSE, ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constant</code></td>
<td>
<p>number by which the result is multiplied; the default
achieves consistency for normally distributed data.  Note that until
Nov. 2010, “thanks” to a typo in the very first papers, a slightly
wrong default constant, 2.2219, was used instead of the correct one
which is equal to <code>1 / (sqrt(2) * qnorm(5/8))</code> (as mentioned
already on p.1277, after (3.7) in Rousseeuw and Croux (1993)).
</p>
<p>If you need the old slightly off version for historical
reproducibility, you can use <code>Qn.old()</code>.
</p>
<p>Note that the relative difference is only about 1 in 1000, and that
the correction should not affect the finite sample corrections for
<code class="reqn">n \le 9</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>finite.corr</code></td>
<td>
<p>logical indicating if the finite sample bias
correction factor should be applied.  Defaults to <code>TRUE</code> unless
<code>constant</code> is specified.  Note the for non-default <code>k</code>, the
consistency <code>constant</code> already depends on <code>n</code> leading to
<em>some</em> finite sample correction, but no simulation-based
small-<code>n</code> correction factors are available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical specifying if missing values (<code>NA</code>)
should be removed from <code>x</code> before further computation.  If false
as by default, and if there are <code>NA</code>s, i.e., <code>if(anyNA(x))</code>,
the result will be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer, typically half of n, specifying the “quantile”, i.e., rather the
order statistic that <code>Qn()</code> should return; for the Qn() proper,
this has been hard wired to <code>choose(n%/%2 +1, 2)</code>, i.e.,
<code class="reqn">\lfloor\frac{n}{2}\rfloor +1</code>.  Choosing a large <code>k</code> is less robust but
allows to get non-zero results in case the default <code>Qn()</code> is zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.finite.corr</code></td>
<td>
<p>logical indicating if a <code>warning</code>
should be signalled when <code>k</code> is non-default, in which case specific
small-<code class="reqn">n</code> correction is not yet provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu.too</code></td>
<td>
<p>logical indicating if the <code>median(x)</code> should
also be returned for <code>s_Qn()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>potentially further arguments for <code>s_Qn()</code> passed to
<code>Qn()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>As the (default, consistency) constant needed to be corrected,
the finite sample correction has been based on a much more extensive
simulation, and on a 3rd or 4th degree polynomial model in <code class="reqn">1/n</code>
for odd or even n, respectively.
</p>


<h3>Value</h3>

<p><code>Qn()</code> returns a number, the <code class="reqn">Q_n</code> robust scale
estimator, scaled to be consistent for <code class="reqn">\sigma^2</code> and
i.i.d. Gaussian observations, optionally bias corrected for finite
samples.
</p>
<p><code>s_Qn(x, mu.too=TRUE)</code> returns a length-2 vector with location
(<code class="reqn">\mu</code>) and scale; this is typically only useful for
<code>covOGK(*, sigmamu = s_Qn)</code>.
</p>


<h3>Author(s)</h3>

<p>Original Fortran code:
Christophe Croux and Peter Rousseeuw <a href="mailto:rousse@wins.uia.ac.be">rousse@wins.uia.ac.be</a>.
<br>
Port to C and R: Martin Maechler, <a href="mailto:maechler@R-project.org">maechler@R-project.org</a>
</p>


<h3>References</h3>

<p>Rousseeuw, P.J. and Croux, C. (1993)
Alternatives to the Median Absolute Deviation,
<em>Journal of the American Statistical Association</em> <b>88</b>, 1273–1283.
<a href="https://doi.org/10.2307/2291267">doi:10.2307/2291267</a>

</p>
<p>Christophe Croux and Peter J. Rousseeuw (1992)
A class of high-breakdown scale estimators based on subranges ,
<em>Communications in Statistics - Theory and Methods</em> <b>21</b>, 1935–1951;
<a href="https://doi.org/10.1080/03610929208830889">doi:10.1080/03610929208830889</a>
</p>
<p>Christophe Croux and Peter J. Rousseeuw (1992)
Time-Efficient Algorithms for Two Highly Robust Estimators of Scale,
<em>Computational Statistics, Vol. 1</em>, ed. Dodge and Whittaker,
Physica-Verlag Heidelberg, 411–428; available via Springer Link.


</p>
<p>About the typo in the <code>constant</code>:<br>
Christophe Croux (2010)
Private e-mail, Fri Jul 16, w/ Subject
<em>Re: Slight inaccuracy of Qn implementation ......</em>.
</p>


<h3>See Also</h3>

<p><code>mad</code> for the ‘most robust’ but much less efficient
scale estimator; <code>Sn</code> for a similar faster but less
efficient alternative.  Finally, <code>scaleTau2</code> which some
consider “uniformly” better than Qn or competitors.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(153)
x &lt;- sort(c(rnorm(80), rt(20, df = 1)))
s_Qn(x, mu.too = TRUE)
Qn(x, finite.corr = FALSE)

## A simple pure-R version of Qn() -- slow and memory-rich for large n: O(n^2)
Qn0R &lt;- function(x, k = choose(n %/% 2 + 1, 2)) { 
    n &lt;- length(x &lt;- sort(x))
    if(n == 0) return(NA) else if(n == 1) return(0.)
    stopifnot(is.numeric(k), k == as.integer(k), 1 &lt;= k, k &lt;= n*(n-1)/2)
    m &lt;- outer(x,x,"-")# abs not needed as x[] is sorted
    sort(m[lower.tri(m)], partial = k)[k]
}
(Qx1 &lt;- Qn(x, constant=1)) # 0.5498463
## the C-algorithm "rounds" to 'float' single precision ..
stopifnot(all.equal(Qx1, Qn0R(x), tol = 1e-6))


(qn &lt;- Qn(c(1:4, 10, Inf, NA), na.rm=TRUE))
stopifnot(is.finite(qn), all.equal(4.075672524, qn, tol=1e-10))

## -- compute for different 'k' :

n &lt;- length(x) # = 100 here
(k0 &lt;- choose(floor(n/2) + 1, 2)) # 51*50/2 == 1275
stopifnot(identical(Qx1, Qn(x, constant=1, k=k0)))
nn2 &lt;- n*(n-1)/2
all.k &lt;- 1:nn2
system.time(Qss &lt;- sapply(all.k, function(k) Qn(x, 1, k=k)))
system.time(Qs  &lt;- Qn  (x, 1, k = all.k))
system.time(Qs0 &lt;- Qn0R(x,    k = all.k) )
stopifnot(exprs = {
   Qs[1]   == min(diff(x))
   Qs[nn2] == diff(range(x))
   all.equal(Qs,  Qss, tol = 1e-15) # even exactly
   all.equal(Qs0, Qs, tol = 1e-7) # see 2.68e-8, as Qn() C-code rounds to (float)
})

plot(2:nn2, Qs[-1], type="b", log="y", main = "Qn(*, k),  k = 2..n(n-1)/2")
</code></pre>


</div>