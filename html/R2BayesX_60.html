<div class="container">

<table style="width: 100%;"><tr>
<td>plot3d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
3D Effect Plot 
</h2>

<h3>Description</h3>

<p>Function to plot 3D graphics or image and/or contour plots for bivariate effects/functions, 
typically used for objects of class <code>"sm.bayesx"</code> and <code>"geo.bayesx"</code> returned from 
function <code>bayesx</code> and <code>read.bayesx.output</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plot3d(x, residuals = FALSE, col.surface = NULL, 
  ncol = 99L, swap = FALSE, col.residuals = NULL, col.contour = NULL, 
  c.select = NULL, grid = 30L, image = FALSE, contour = FALSE, 
  legend = TRUE, cex.legend = 1, breaks = NULL, range = NULL, 
  digits = 2L, d.persp = 1L, r.persp = sqrt(3), outscale = 0,
  data = NULL, sep = "", shift = NULL, trans = NULL,
  type = "interp", linear = FALSE, extrap = FALSE,
  k = 40, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect, typically 
the structure for bivariate functions returned within <code>bayesx</code> and 
<code>read.bayesx.output</code> model term objects is used, also see 
<code>fitted.bayesx</code>. Another possibility is to specify the plot via a <code>formula</code>, 
e.g. for simple plotting of bivariate surfaces <code>z ~ x + y</code>, also see the example.
<code>x</code> may also be a character file path to the data to be used for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>if set to <code>TRUE</code>, partial residuals may also be plotted if available.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.surface</code></td>
<td>
<p>the color of the surface, may also be a function, e.g. 
<code>col.surface = heat.colors</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncol</code></td>
<td>
<p>the number of different colors that should be generated, if <code>col.surface</code> is a 
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swap</code></td>
<td>
<p>if set to <code>TRUE</code> colors will be represented in reverse order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.residuals</code></td>
<td>
<p>the color of the partial residuals, or if <code>contour = TRUE</code> the color of the
contour lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.contour</code></td>
<td>
<p>the color of the contour lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p><code>integer</code> vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. 
If <code>c.select = 95</code> or <code>c.select = 80</code>, function <code>plot3d</code> will search for the
corresponding columns to plot a 95<code class="reqn">\%</code> or 80<code class="reqn">\%</code> confidence surfaces respectively. Note
that if e.g. <code>c.select = c(1, 2)</code>, <code>plot3d</code> will use columns 1 + 2 and 2 + 2 for 
plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>the grid size of the surface(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>image</code></td>
<td>
<p>if set to <code>TRUE</code>, an <code>image.plot</code> is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour</code></td>
<td>
<p>if set to <code>TRUE</code>, a <code>contour</code> plot is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>if <code>image = TRUE</code> an additional legend may be added to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.legend</code></td>
<td>
<p>the expansion factor for the legend text, see <code>text</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>a set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>specifies a certain range values should be plotted for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>specifies the legend decimal places.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.persp</code></td>
<td>
<p>see argument <code>d</code> in function <code>persp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r.persp</code></td>
<td>
<p>see argument <code>r</code> in function <code>persp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outscale</code></td>
<td>
<p>scales the outer ranges of <code>x</code> and <code>z</code> limits used for interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>if <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called. Note that <code>data</code> may also be a character file path to the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>the field separator character when <code>x</code> or <code>data</code> is a character, see function
<code>read.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>numeric. Constant to be added to the smooth before plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character. Which type of interpolation metjod should be used. The default is
<code>type = "interp"</code>, see function <code>interp</code>. The two other options are
<code>type = "mba"</code>, which calls function <code>mba.surf</code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear</code></td>
<td>
<p>logical. Should linear interpolation be used withing function
<code>interp</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrap</code></td>
<td>
<p>logical. Should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer. The number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters passed to <code>colorlegend</code> if an image plot with legend is drawn,
also other graphical parameters, please see the details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For 3D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: specify the size of partial residuals,
</p>
</li>
<li> <p><code>col</code>: it is possible to specify the color for the surfaces if <code>se &gt; 0</code>, then 
e.g. <code>col = c("green", "black", "red")</code>,
</p>
</li>
<li> <p><code>pch</code>: the plotting character of the partial residuals,
</p>
</li>
<li> <p><code>...</code>: other graphical parameters passed functions <code>persp</code>,
<code>image.plot</code> and <code>contour</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code>plot.bayesx</code>, <code>bayesx</code>, <code>read.bayesx.output</code>,
<code>fitted.bayesx</code>, <code>colorlegend</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## response
dat$y &lt;- with(dat, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(z, w, bs = "te", knots = 5), data = dat, method = "REML")
summary(b)

## plot estimated effect
plot(b, term = "sx(z,w)")

## extract fitted effects
f &lt;- fitted(b, term = "sx(z,w)")

## now use plot3d
plot3d(f)
plot3d(f, swap = TRUE)
plot3d(f, residuals = TRUE)
plot3d(f, resid = TRUE, cex.resid = 0.1)
plot3d(f, resid = TRUE, pch = 2, col.resid = "green3")
plot3d(f, resid = TRUE, c.select = 95, cex.resid = 0.1)
plot3d(f, resid = TRUE, c.select = 80, cex.resid = 0.1)
plot3d(f, grid = 100, border = NA)
plot3d(f, c.select = 95, border = c("red", NA, "green"),
  col.surface = c(1, NA, 1), resid = TRUE, cex.resid = 0.2)

## now some image and contour
plot3d(f, image = TRUE, legend = FALSE)
plot3d(f, image = TRUE, legend = TRUE)
plot3d(f, image = TRUE, contour = TRUE)
plot3d(f, image = TRUE, contour = TRUE, swap = TRUE)
plot3d(f, image = TRUE, contour = TRUE, col.contour = "white")
plot3d(f, contour = TRUE)
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 3))
plot3d(f, image = TRUE, contour = TRUE, c.select = 3)
plot3d(f, image = TRUE, contour = TRUE, c.select = "Estimate")
plot3d(f, image = TRUE, contour = TRUE, c.select = "97.5
par(op)

## End(Not run)

## another variation
dat$f1 &lt;- with(dat, sin(z) * cos(w))
with(dat, plot3d(cbind(z, w, f1)))

## same with formula 
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = dat)
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = dat, 
  ticktype = "detailed")

## play with palettes
plot3d(sin(z) * cos(w) ~ z + w, col.surface = heat.colors, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = topo.colors, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = cm.colors, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = terrain.colors, data = dat)

plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow_hcl, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = diverge_hcl, data = dat)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = sequential_hcl, data = dat)

plot3d(sin(z) * cos(w) ~ z + w, 
  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
  data = dat)
plot3d(sin(z) * cos(w) ~ z + w, 
  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
  image = TRUE, grid = 200, data = dat)
</code></pre>


</div>