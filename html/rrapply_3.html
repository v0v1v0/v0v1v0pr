<div class="container">

<table style="width: 100%;"><tr>
<td>rrapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reimplementation of base-R's rapply</h2>

<h3>Description</h3>

<p><code>rrapply</code> is a reimplemented and extended version of <code>rapply</code> to recursively apply a function <code>f</code> to 
a set of elements of a list and deciding <em>how</em> the result is structured.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rrapply(
  object,
  condition,
  f,
  classes = "ANY",
  deflt = NULL,
  how = c("replace", "list", "unlist", "prune", "flatten", "melt", "bind", "recurse",
    "unmelt", "names"),
  options,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a <code>list</code>, <code>expression</code> vector, or <code>call</code> object, i.e., “list-like”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>a condition <code>function</code> of one “principal” argument and optional special arguments <code>.xname</code>, <code>.xpos</code>, 
<code>.xparents</code> and/or <code>.xsiblings</code> (see ‘Details’), passing further arguments via <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>a <code>function</code> of one “principal” argument and optional special arguments <code>.xname</code>, <code>.xpos</code>, <code>.xparents</code> 
and/or <code>.xsiblings</code> (see ‘Details’), passing further arguments via <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>character vector of <code>class</code> names, or <code>"ANY"</code> to match the class of any terminal node. Include <code>"list"</code> or <code>"data.frame"</code>
to match the class of non-terminal nodes as well.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deflt</code></td>
<td>
<p>the default result (only used if <code>how = "list"</code> or <code>how = "unlist"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>how</code></td>
<td>
<p>character string partially matching the ten possibilities given: see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>a named <code>list</code> with additional options <code>namesep</code>, <code>simplify</code>, <code>namecols</code> and/or <code>coldepth</code> 
that only apply to certain choices of <code>how</code>: see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to the call to <code>f</code> and <code>condition</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>how = "unlist"</code>, a vector as in <code>rapply</code>. If <code>how = "list"</code>, <code>how = "replace"</code>, <code>how = "recurse"</code> or <code>how = "names"</code>, 
“list-like” of similar structure as <code>object</code> as in <code>rapply</code>. If <code>how = "prune"</code>, a pruned “list-like” object 
of similar structure as <code>object</code> with pruned list elements based on <code>classes</code> and <code>condition</code>. If <code>how = "flatten"</code>, a flattened
pruned vector or list with pruned elements based on <code>classes</code> and <code>condition</code>. If <code>how = "melt"</code>, a melted data.frame containing the node paths 
and values of the pruned list elements based on <code>classes</code> and <code>condition</code>. If <code>how = "bind"</code>, a wide data.frame with repeated list elements
expanded as single data.frame rows and aligned by identical list names using the same coercion rules as <code>how = "unlist"</code>. The repeated list elements 
are subject to pruning based on <code>classes</code> and <code>condition</code>. If <code>how = "unmelt"</code>, a nested list with list names and values defined 
in the data.frame <code>object</code>.
</p>


<h3>How to structure result</h3>

<p>In addition to <code>rapply</code>'s modes to set <code>how</code> equal to <code>"replace"</code>, <code>"list"</code> or <code>"unlist"</code>, 
seven choices <code>"prune"</code>, <code>"flatten"</code>, <code>"melt"</code>, <code>"bind"</code>, <code>"unmelt"</code>, <code>"recurse"</code>  and <code>"names"</code> are available:
</p>

<ul>
<li> <p><code>how = "prune"</code> filters all list elements not subject to application of <code>f</code> from the list <code>object</code>. The original 
list structure is retained, similar to the non-pruned options <code>how = "replace"</code> or <code>how = "list"</code>.
</p>
</li>
<li> <p><code>how = "flatten"</code> is an efficient way to return a flattened unnested version of the pruned list. By default <code>how = "flatten"</code> 
uses similar coercion rules as <code>how = "unlist"</code>, this can be disabled with <code>simplify = FALSE</code> in the <code>options</code> argument.
</p>
</li>
<li> <p><code>how = "melt"</code> returns a melted data.frame of the pruned list, each row contains the path of a single 
terminal node in the pruned list at depth layers <code>L1</code>, <code>L2</code>, and so on. The column <code>"value"</code> contains the 
possibly coerced values at the terminal nodes and is equivalent to the result of <code>how = "flatten"</code>. If no list names are present, 
the node names in the data.frame default to the indices of the list elements <code>"1"</code>, <code>"2"</code>, etc.
</p>
</li>
<li> <p><code>how = "bind"</code> is used to unnest a nested list containing repeated sublists into a wide data.frame. Each repeated sublist is expanded 
as a single row in the data.frame and identical sublist component names are aligned as individual columns. By default, the list layer 
containing repeated sublists is identified based on the minimal depth detected across leaf nodes, this can be set manually with <code>coldepth</code> 
in the <code>options</code> argument.
</p>
</li>
<li> <p><code>how = "unmelt"</code> is a special case that reconstructs a nested list from a melted data.frame. For this reason, <code>how = "unmelt"</code> 
only applies to data.frames in the same format as returned by <code>how = "melt"</code>. Internally, <code>how = "unmelt"</code> first reconstructs 
a nested list from the melted data.frame and second uses the same functional framework as <code>how = "replace"</code>.
</p>
</li>
<li> <p><code>how = "recurse"</code> is a specialized option that is only useful in combination with e.g. <code>classes = "list"</code> to recurse further 
into updated “list-like” elements. This is explained in more detail below.
</p>
</li>
<li> <p><code>how = "names"</code> modifies the <em>names</em> of the nested list elements instead of the list content. <code>how = "names"</code> internally works  
similar to <code>how = "list"</code>, except that the value of <code>f</code> is used to replace the name of the list element under evaluation 
instead of its content. 
</p>
</li>
</ul>
<h3>Condition function</h3>

<p>Both <code>rapply</code> and <code>rrapply</code> allow to apply <code>f</code> to list elements of certain classes via the <code>classes</code> argument. 
<code>rrapply</code> generalizes this concept via an additional <code>condition</code> argument, which accepts any function to use as a condition 
or predicate to select list elements to which <code>f</code> is applied. Conceptually, the <code>f</code> function is applied to all list elements for 
which the <code>condition</code> function exactly evaluates to <code>TRUE</code> similar to <code>isTRUE</code>. If the condition function is missing, 
<code>f</code> is applied to all list elements.
Since the <code>condition</code> function generalizes the <code>classes</code> argument, it is allowed to use the <code>deflt</code> argument 
together with <code>how = "list"</code> or <code>how = "unlist"</code> to set a default value to all list elements for which the <code>condition</code> does 
not evaluate to <code>TRUE</code>.
</p>


<h3>Correct use of <code>...</code>
</h3>

<p>The principal argument of the <code>f</code> and <code>condition</code> functions evaluates to the content of the list element. Any further arguments to 
<code>f</code> and <code>condition</code> (besides the special arguments <code>.xname</code>, <code>.xpos</code>, etc. discussed below) supplied via the dots <code>...</code> 
argument need to be defined as function arguments in <em>both</em> the <code>f</code> and <code>condition</code> function (if existing), even if they are not
used in the function itself. See also the ‘Examples’ section.
</p>


<h3>Special arguments <code>.xname</code>, <code>.xpos</code>, <code>.xparents</code> and <code>.xsiblings</code>
</h3>

<p>The <code>f</code> and <code>condition</code> functions accept four special arguments <code>.xname</code>, <code>.xpos</code>, <code>.xparents</code> and <code>.xsiblings</code> in
addition to the first principal argument. The <code>.xname</code> argument evaluates to the name of the list element. The <code>.xpos</code> argument evaluates 
to the position of the element in the nested list structured as an integer vector. That is, if <code>x = list(list("y", "z"))</code>, then an <code>.xpos</code> 
location of <code>c(1, 2)</code> corresponds to the list element <code>x[[c(1, 2)]]</code>. The <code>.xparents</code> argument evaluates to a vector of all parent 
node names in the path to the list element. The <code>.xsiblings</code> argument evaluates to the complete (sub)list that includes the list element as a direct child.
The names <code>.xname</code>, <code>.xpos</code>, <code>.xparents</code> or <code>.xsiblings</code> need to be explicitly included as function arguments in <code>f</code> and 
<code>condition</code> (in addition to the principal argument). See also the ‘Examples’ section.
</p>


<h3>Avoid recursing into list nodes</h3>

<p>By default, <code>rrapply</code> recurses into any “list-like” element. If <code>classes = "list"</code>, this behavior is overridden and the 
<code>f</code> function is also applied to any list element of <code>object</code> that satisfies <code>condition</code>. For expression objects, use 
<code>classes = "language"</code>, <code>classes = "expression"</code> or <code>classes = "pairlist"</code> to avoid recursing into branches of the abstract 
syntax tree of <code>object</code>. If the <code>condition</code> or <code>classes</code> arguments are not satisfied for a “list-like” element, 
<code>rrapply</code> will recurse further into the sublist, apply the <code>f</code> function to the nodes that satisfy <code>condition</code> and <code>classes</code>, 
and so on. Note that this behavior can only be triggered using the <code>classes</code> argument and not the <code>condition</code> argument.
</p>


<h3>Recursive list node updating</h3>

<p>If <code>classes = "list"</code> and <code>how = "recurse"</code>, <code>rrapply</code> applies the <code>f</code> function to any list element of <code>object</code> that satisfies 
<code>condition</code> similar to the previous section using <code>how = "replace"</code>, but recurses further into the <em>updated</em> list-like element 
after application of the <code>f</code> function. A primary use of <code>how = "recurse"</code> in combination with <code>classes = "list"</code> is to 
recursively update for instance the class or other attributes of all nodes in a nested list.
</p>


<h3>Avoid recursing into data.frames</h3>

<p>If <code>classes = "ANY"</code> (default), <code>rrapply</code> recurses into all “list-like” objects equivalent to <code>rapply</code>. 
Since data.frames are “list-like” objects, the <code>f</code> function will descend into the individual columns of a data.frame. 
To avoid this behavior, set <code>classes = "data.frame"</code>, in which case the <code>f</code> and <code>condition</code> functions are applied directly to 
the data.frame and not its columns. Note that this behavior can only be triggered using the <code>classes</code> argument and not the <code>condition</code> argument.
</p>


<h3>List attributes</h3>

<p>In <code>rapply</code> intermediate list attributes (not located at terminal nodes) are kept when <code>how = "replace"</code>, but are dropped when 
<code>how = "list"</code>. To avoid unexpected behavior, <code>rrapply</code> always preserves intermediate list attributes when using <code>how = "replace"</code>, 
<code>how = "list"</code>, <code>how = "prune"</code> or <code>how = "names"</code>. If <code>how = "unlist"</code>, <code>how = "flatten"</code>, <code>how = "melt"</code> or <code>how = "bind"</code> 
intermediate list attributes cannot be preserved as the result is no longer a nested list.
</p>


<h3>Expressions</h3>

<p>Call objects and expression vectors are also accepted as <code>object</code> argument, which are treated as nested lists based on their internal abstract
syntax trees. As such, all functionality that applies to nested lists extends directly to call objects and expression vectors. If <code>object</code> is a 
call object or expression vector, <code>how = "replace"</code> always maintains the type of <code>object</code>, whereas <code>how = "list"</code> returns the result 
structured as a nested list. <code>how = "prune"</code>, <code>how = "flatten"</code> and <code>how = "melt"</code> return the pruned abstract syntax tree as: a nested list, 
a flattened list and a melted data.frame respectively. This is identical to application of <code>rrapply</code> to the abstract syntax tree formatted as a nested list.
</p>


<h3>Additional options</h3>

<p>The <code>options</code> argument accepts a named list to configure several default options that only apply to certain choices of <code>how</code>. The <code>options</code> 
list can contain (any of) the named components <code>namesep</code>, <code>simplify</code>, <code>namecols</code> and/or <code>coldepth</code>:
</p>

<ul>
<li> <p><code>namesep</code>, a character separator used to combine parent and child list names in <code>how = "flatten"</code> and <code>how = "bind"</code>. If <code>namesep = NA</code> (default), 
no parent names are included in <code>how = "flatten"</code> and the default separator <code>"."</code> is used in <code>how = "bind"</code>. Note that <code>namesep</code> cannot be used with 
<code>how = "unlist"</code> for which the name separator always defaults to <code>"."</code>. 
</p>
</li>
<li> <p><code>simplify</code>, a logical value indicating whether the flattened unnested list in <code>how = "flatten"</code> and <code>how = "melt"</code> is simplified 
according to standard coercion rules similar to <code>how = "unlist"</code>. The default is <code>simplify = TRUE</code>. If <code>simplify = FALSE</code>, 
<code>object</code> is flattened to a single-layer list and returned as is.
</p>
</li>
<li> <p><code>namecols</code>, a logical value that only applies to <code>how = "bind"</code> indicating whether the parent node names associated to the each expanded sublist 
should be included as columns <code>L1</code>, <code>L2</code>, etc. in the wide data.frame returned by <code>how = "bind"</code>. 
</p>
</li>
<li> <p><code>coldepth</code>, an integer value indicating the depth (starting from depth 1) at which list elements should be mapped to individual columns 
in the wide data.frame returned by <code>how = "bind"</code>. If <code>coldepth = 0</code> (default), this depth layer is identified automatically based on the 
minimal depth detected across all leaf nodes. This option only applies to <code>how = "bind"</code>.
</p>
</li>
</ul>
<h3>Note</h3>

<p><code>rrapply</code> allows the <code>f</code> function argument to be missing, in which case no function is applied to the list 
elements.
</p>
<p><code>how = "unmelt"</code> requires as input a data.frame as returned by <code>how = "melt"</code> with character columns to name the nested list components
and a final list- or vector-column containing the values of the nested list elements.
</p>


<h3>See Also</h3>

<p><code>rapply</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example data

## Renewable energy shares per country (% of total consumption) in 2016
data("renewable_energy_by_country")

## Renewable energy shares in Oceania
renewable_oceania &lt;- renewable_energy_by_country[["World"]]["Oceania"]

## Pokemon properties in Pokemon GO
data("pokedex")

# List pruning and unnesting

## Drop logical NA's while preserving list structure 
na_drop_oceania &lt;- rrapply(
  renewable_oceania,
  f = function(x) x,
  classes = "numeric",
  how = "prune"
)
str(na_drop_oceania, list.len = 3, give.attr = FALSE)

## Drop logical NA's and return unnested list
na_drop_oceania2 &lt;- rrapply(
  renewable_oceania,
  classes = "numeric",
  how = "flatten"
)
head(na_drop_oceania2, n = 10)

## Flatten to simple list with full names
na_drop_oceania3 &lt;- rrapply(
  renewable_oceania,
  classes = "numeric",
  how = "flatten",
  options = list(namesep = ".", simplify = FALSE)
) 
str(na_drop_oceania3, list.len = 10, give.attr = FALSE)

## Drop logical NA's and return melted data.frame
na_drop_oceania4 &lt;- rrapply(
  renewable_oceania,
  classes = "numeric",
  how = "melt"
)
head(na_drop_oceania4)

## Reconstruct nested list from melted data.frame
na_drop_oceania5 &lt;- rrapply(
  na_drop_oceania4,
  how = "unmelt"
)
str(na_drop_oceania5, list.len = 3, give.attr = FALSE)

## Unnest list to wide data.frame
pokedex_wide &lt;- rrapply(pokedex, how = "bind")
head(pokedex_wide)

## Unnest to data.frame including parent columns
pokemon_evolutions &lt;- rrapply(
  pokedex, 
  how = "bind", 
  options = list(namecols = TRUE, coldepth = 5)
) 
head(pokemon_evolutions, n = 10)

# Condition function

## Drop all NA elements using condition function
na_drop_oceania6 &lt;- rrapply(
  renewable_oceania,
  condition = Negate(is.na),
  how = "prune"
)
str(na_drop_oceania6, list.len = 3, give.attr = FALSE)

## Replace NA elements by a new value via the ... argument
## NB: the 'newvalue' argument should be present as function 
## argument in both 'f' and 'condition', even if unused.
na_zero_oceania &lt;- rrapply(
  renewable_oceania,
  condition = function(x, newvalue) is.na(x),
  f = function(x, newvalue) newvalue,
  newvalue = 0,
  how = "replace"
)
str(na_zero_oceania, list.len = 3, give.attr = FALSE)

## Filter all countries with values above 85%
renewable_energy_above_85 &lt;- rrapply(
  renewable_energy_by_country,
  condition = function(x) x &gt; 85,
  how = "prune"
)
str(renewable_energy_above_85, give.attr = FALSE)

# Special arguments .xname, .xpos, .xparents and .xsiblings

## Apply a function using the name of the node
renewable_oceania_text &lt;- rrapply(
  renewable_oceania,
  condition = Negate(is.na),
  f = function(x, .xname) sprintf("Renewable energy in %s: %.2f%%", .xname, x),
  how = "flatten"
)
head(renewable_oceania_text, n = 10)

## Extract values based on country names
renewable_benelux &lt;- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xname) .xname %in% c("Belgium", "Netherlands", "Luxembourg"),
  how = "prune"
)
str(renewable_benelux, give.attr = FALSE)

## Filter European countries with value above 50%
renewable_europe_above_50 &lt;- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xpos) identical(.xpos[c(1, 2)], c(1L, 5L)) &amp; x &gt; 50,
  how = "prune"
)
str(renewable_europe_above_50, give.attr = FALSE)

## Filter European countries with value above 50%
renewable_europe_above_50 &lt;- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xparents) "Europe" %in% .xparents &amp; x &gt; 50,
  how = "prune"
)
str(renewable_europe_above_50, give.attr = FALSE)

## Return position of Sweden in list
(xpos_sweden &lt;- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xname) identical(.xname, "Sweden"),
  f = function(x, .xpos) .xpos,
  how = "flatten"
))
renewable_energy_by_country[[xpos_sweden$Sweden]]

## Return neighbors of Sweden in list
siblings_sweden &lt;- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xsiblings) "Sweden" %in% names(.xsiblings),
  how = "flatten"
)
head(siblings_sweden, n = 10)

## Unnest selected columns in Pokedex list 
pokedex_small &lt;- rrapply(
   pokedex,
   condition = function(x, .xpos, .xname) length(.xpos) &lt; 4 &amp; .xname %in% c("num", "name", "type"),
   how = "bind"
)  
head(pokedex_small)

# Modifying list elements

## Calculate mean value of Europe
rrapply(
  renewable_energy_by_country,  
  condition = function(x, .xname) .xname == "Europe",
  f = function(x) mean(unlist(x), na.rm = TRUE),
  classes = "list",
  how = "flatten"
)

## Calculate mean value for each continent
## (Antarctica's value is missing)
renewable_continent_summary &lt;- rrapply(
  renewable_energy_by_country,  
  condition = function(x, .xpos) length(.xpos) == 2,
  f = function(x) mean(unlist(x), na.rm = TRUE),
  classes = "list"
)
str(renewable_continent_summary, give.attr = FALSE)

## Filter country or region by M49-code
rrapply(
  renewable_energy_by_country,
  condition = function(x) attr(x, "M49-code") == "155",
  f = function(x, .xname) .xname,
  classes = c("list", "ANY"), 
  how = "unlist"
)

# Recursive list updating

## Recursively remove list attributes
renewable_no_attrs &lt;- rrapply(
  renewable_oceania,
  f = function(x) c(x),
  classes = c("list", "ANY"),
  how = "recurse"
) 
str(renewable_no_attrs, list.len = 3, give.attr = TRUE)

## recursively replace all names by M49-codes
renewable_m49_names &lt;- rrapply(
  renewable_oceania,
  f = function(x) attr(x, "M49-code"),
  how = "names"
) 
str(renewable_m49_names, list.len = 3, give.attr = FALSE)

# List attributes

## how = "list" preserves all list attributes
na_drop_oceania_attr &lt;- rrapply(
  renewable_oceania,
  f = function(x) replace(x, is.na(x), 0),
  how = "list"
)
str(na_drop_oceania_attr, max.level = 2)

## how = "prune" also preserves list attributes
na_drop_oceania_attr2 &lt;- rrapply(
  renewable_oceania,
  condition = Negate(is.na),
  how = "prune"
)
str(na_drop_oceania_attr2, max.level = 2)

# Expressions

## Replace logicals by integers
call_old &lt;- quote(y &lt;- x &lt;- 1 + TRUE)
call_new &lt;- rrapply(call_old, 
  f = as.numeric, 
  how = "replace",
  classes = "logical"
)
str(call_new)

## Update and decompose call object
call_ast &lt;- rrapply(call_old, 
  f = function(x) ifelse(is.logical(x), as.numeric(x), x), 
  how = "list"
)
str(call_ast)

## Prune and decompose expression
expr &lt;- expression(y &lt;- x &lt;- 1, f(g(2 * pi)))
is_new_name &lt;- function(x) !exists(as.character(x), envir = baseenv())
expr_prune &lt;- rrapply(expr, 
  classes = "name", 
  condition = is_new_name, 
  how = "prune"
)
str(expr_prune)

## Prune and flatten expression
expr_flatten &lt;- rrapply(expr, 
  classes = "name", 
  condition = is_new_name, 
  how = "flatten"
)
str(expr_flatten)

## Prune and melt expression
rrapply(expr, 
  classes = "name", 
  condition = is_new_name, 
  f = as.character,
  how = "melt"
)

## Avoid recursing into call objects
rrapply(
  expr, 
  classes = "language", 
  condition = function(x) !any(sapply(x, is.call)),
  how = "flatten"
)

</code></pre>


</div>