<div class="container">

<table style="width: 100%;"><tr>
<td>augment_quantile</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Augment data with randomized quantile residuals</h2>

<h3>Description</h3>

<p>Generates a data frame containing a model's predictors, the residuals, and
the randomized quantile residuals as additional columns.
</p>


<h3>Usage</h3>

<pre><code class="language-R">augment_quantile(x, ...)

augment_quantile_longer(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Fitted model to obtain randomized quantile residuals from</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to pass to <code>broom::augment()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Randomized quantile residuals provide more interpretable residuals for
generalized linear models (GLMs), such as logistic regression. See Dunn and
Smyth (1996) for details, or review the examples provided in
<code>vignette("DHARMa", package="DHARMa")</code>.
</p>
<p>Let <code class="reqn">F_Y(y; x, \beta)</code> be the predicted cumulative distribution function
for <code class="reqn">Y</code> when <code class="reqn">X = x</code>, using the fitted GLM. When the response is
continuous, the randomized quantile residual for observation <code class="reqn">i</code> is
</p>
<p style="text-align: center;"><code class="reqn">r_{q,i} = F_Y(y_i; x_i, \hat \beta).</code>
</p>

<p>When the response is discrete, let
</p>
<p style="text-align: center;"><code class="reqn">a_i = \lim_{y \uparrow y_i} F_Y(y; x_i, \hat \beta)</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">b_i = F_Y(y_i; x_i, \hat \beta),</code>
</p>

<p>then draw the randomized quantile residual as
</p>
<p style="text-align: center;"><code class="reqn">r_{q,i} \sim \text{Uniform}(a_i, b_i).</code>
</p>

<p>As cumulative distributions are left-continuous, this "jitters" the values
between the discrete steps, resulting in a residual that is uniformly
distributed when the model is correct.
</p>
<p>Some definitions of randomized quantile residuals transform the resulting
values using the standard normal inverse cdf, so they are normally
distributed. That step is omitted here, as uniform residuals are easy to work
with.
</p>


<h3>Value</h3>

<p>Data frame with one row per observation used to fit <code>x</code>, including a
<code>.quantile.resid</code> column containing the quantile residuals. See
<code>broom::augment()</code> and its methods for details of other columns.
</p>
<p>For <code>augment_quantile_longer()</code>, the output is in "long" format with one row
per predictor per observation. Columns <code>.predictor_name</code> and
<code>.predictor_value</code> identify the predictor and its value. An additional column
<code>.obs</code> records the original observation numbers so results can be matched to
observations in the original model data. See Limitations in
<code>augment_longer()</code> for limitations on factor predictors.
</p>


<h3>Implementation details</h3>

<p>Uses <code>broom::augment()</code> to generate the data frame, then uses the <a href="https://cran.r-project.org/package=DHARMa">DHARMa package</a> to generate randomized
quantile residuals for the model.
</p>


<h3>References</h3>

<p>Dunn, Peter K., and Gordon K. Smyth (1996).
"Randomized Quantile Residuals." <em>Journal of Computational and Graphical
Statistics</em> 5 (3): 236â€“44. <a href="https://doi.org/10.2307/1390802">doi:10.2307/1390802</a>
</p>


<h3>See Also</h3>

<p><code>vignette("logistic-regression-diagnostics")</code> and
<code>vignette("other-glm-diagnostics")</code> for examples of plotting and
interpreting randomized quantile residuals; <code>augment_longer()</code>;
<code>broom::augment()</code>
</p>


</div>