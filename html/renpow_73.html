<div class="container">

<table style="width: 100%;"><tr>
<td>AC power</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>AC power in the time and frequency domain</h2>

<h3>Description</h3>

<p>Calculates and plots AC power in the domain and phasors. Includes complex number calculations.</p>


<h3>Usage</h3>

<pre><code class="language-R">inst.pow.calc(x, freq = 60, nc = 2)
inst.pow.plot(x, rms = FALSE, freq = 60, nc = 2)
inst.pow.leg(ang, lab, ym, w, units, pf)
complex.pow.calc(xc, dig = 2, res = TRUE)
complex.pow.plot(cp)
complex.pow.tri(cp)
pf.corr(P, V, pf, pfc, w = 377, dig = 2)
pf.corr.tri(xpfc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>list of voltage and current phasors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>frequency in Hz</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>number of cycles to calculate and/or plot</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rms</code></td>
<td>
<p>logical to decide to plot the rms value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ang</code></td>
<td>
<p>angles for legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab</code></td>
<td>
<p>label for legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ym</code></td>
<td>
<p>magnitude for legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>angular frequency for legend and for pf correction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>units</code></td>
<td>
<p>units for legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>
<p>power factor for legend of inst.pow.leg or to be corrected by pf.corr</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xc</code></td>
<td>
<p>list with voltage, current, and phase angle</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dig</code></td>
<td>
<p>number of digits to round complex power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>logical to print results of complex power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cp</code></td>
<td>
<p>output of complex power; a list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>real power for pf correction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>voltage for pf correction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pfc</code></td>
<td>
<p>target power factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xpfc</code></td>
<td>
<p>output of pf.corr; a list</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>inst.pow.calc calculates time domain isntantaneous power given current and voltage phasors. Its output is passed to inst.pow.plot.
inst.pow.plot produces time domain plots given current and voltage phasors. It uses inst.pow.leg to display legend
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>angular frequency in rad/s</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vm</code></td>
<td>
<p>array of magnitude</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ang</code></td>
<td>
<p>array of angle</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>
<p>power factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pavg</code></td>
<td>
<p>average power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>time sequence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v.i</code></td>
<td>
<p>matrix with voltage and current as a function of time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>instantaneous power or power as a function of time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>units</code></td>
<td>
<p>units for complex power result</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>apparent power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>phase angle</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>real power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>reactive power</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>
<p>power factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prnt</code></td>
<td>
<p>string to print results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cp</code></td>
<td>
<p>complex power output of pf.corr</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpc</code></td>
<td>
<p>complex power after correction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Voltage,current, and corrected params</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Functions used in Chapter Chapter 8 of Acevedo (2018)</p>


<h3>Author(s)</h3>

<p>Miguel F. Acevedo <a href="mailto:acevedo@unt.edu">acevedo@unt.edu</a></p>


<h3>References</h3>

<p>Acevedo, M.F. 2018. Introduction to Renewable Electric Power Systems and the Environment with R. Boca Raton, FL: CRC Press. (ISBN 9781138197343)
</p>
<p>Irwin, J.D. and R.M. Nelms. 2011. Basic Engineering Circuit Analysis. 11th edition. 2011: Wiley.
</p>


<h3>See Also</h3>

<p>Power electronics functions <code>ac.plot.rect</code>, <code>rectifier</code>, <code>inverter</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
# power resistor
vm=170; R=10
x &lt;- list(c(vm,0),c(vm/R,0))
inst.pow.plot(x)

# power capacitor
w &lt;- 377; v.s &lt;- c(170,0)
C=1000*10^-6
# current response
i.res &lt;- c(v.s[1]*(w*C),v.s[2]+90)
x &lt;- list(v.s,i.res)
inst.pow.plot(x)

# calc complex power
V.s=c(170,10); Z.p=c(10,20)
I.p &lt;- div.polar(V.s,Z.p)
V &lt;- V.s[1]/sqrt(2); I &lt;- I.p[1]/sqrt(2)
theta &lt;- V.s[2]-I.p[2] 
cp &lt;- complex.pow.calc(list(V,I,theta))

# pf correction
P=5; V=240; I=40; pfc=0.9
pf &lt;- P*1000/(V*I)
# call pf correction function
pfcorr &lt;- pf.corr(P,V,pf,pfc)
# visualize
pf.corr.tri(pfcorr)

</code></pre>


</div>