<div class="container">

<table style="width: 100%;"><tr>
<td>rerun.mark</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Runs a previous MARK model with new starting values</h2>

<h3>Description</h3>

<p>Runs a previous MARK model with new starting values but without specifying
the model parameter formulas.  This function is most useful with
<code>mark.wrapper</code> in which a list of models is analyzed and the set of
formulas are not specified for each model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rerun.mark(
  model,
  data,
  ddl,
  initial,
  output = TRUE,
  title = "",
  invisible = TRUE,
  adjust = TRUE,
  se = FALSE,
  filename = NULL,
  prefix = "mark",
  default.fixed = TRUE,
  silent = FALSE,
  retry = 0,
  realvcv = FALSE,
  external = FALSE,
  threads = -1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>previously run MARK model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>processed dataframe used with model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ddl</code></td>
<td>
<p>design data list used with model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>vector of initial values for beta parameters or previously
run model object of similar structure</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>If TRUE produces summary of model input and model output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>Optional title for the MARK analysis output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invisible</code></td>
<td>
<p>if TRUE, exectution of MARK.EXE is hidden from view</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>if TRUE, adjusts number of parameters (npar) to number of
columns in design matrix, modifies AIC and records both</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>if TRUE, se and confidence intervals are shown in summary sent to
screen</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>base filename for files created by MARK.EXE. Files are named
filename.*.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>base filename prefix for files created by MARK.EXE; the files
are named prefixnnn.*</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default.fixed</code></td>
<td>
<p>if TRUE, real parameters for which the design data have
been deleted are fixed to default values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>if TRUE, errors that are encountered are suppressed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retry</code></td>
<td>
<p>number of reanalyses to perform with new starting values when
one or more parameters are singular</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>realvcv</code></td>
<td>
<p>if TRUE the vcv matrix of the real parameters is extracted
and stored in the model results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>external</code></td>
<td>
<p>if TRUE the mark object is saved externally rather than in
the workspace; the filename is kept in its place</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>number of cpus to use with mark.exe if positive or number of cpus to remain idle if negative</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>argument values like nodes etc for call to make.mark.model</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a simple function that restarts an analysis with MARK typically
using another model for initial values of the beta parameters.  The
processed dataframe (<code>data</code>) and design data list (<code>ddl</code>) must be
specified but the <code>model.parameters</code> are extracted from <code>model</code>.
<code>initial</code> values are not optional otherwise this would be no different
than the original call to <code>mark</code>. More complete definitions of the
arguments can be found in <code>mark</code> or <code>run.mark.model</code>
or <code>make.mark.model</code>.
</p>


<h3>Value</h3>

<p>model: MARK model object with the base filename stored in
<code>output</code> and the extracted <code>results</code> from the output file appended
onto list; see <code>mark</code> for a detailed description of a
<code>mark</code> object.
</p>


<h3>Author(s)</h3>

<p>Jeff Laake
</p>


<h3>See Also</h3>

<p><code>make.mark.model</code>, <code>run.models</code>,
<code>extract.mark.output</code>, <code>adjust.parameter.count</code>,
<code>mark</code>, <code>cleanup</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# The following example will not run because the data are not included in the
# examples.  It illustrates the use of rerun.mark with mark.wrapper.  With this
# particular data set the POPAN models were having difficulty converging.  After
# running the set of models using mark.wrapper and looking at the results it
# was clear that in several instances the model did not converge.  This is easiest
# to discern by comparing nested models in the model.table.  If one model 
# is nested within another,then the deviance of the model with more
# parameters should be as good or better than the smaller model.  If that 
# is not the case then the model that converged can be used for initial 
# values in a call to rerun.mark for the model that did not converge.
#

do.nat=function()
{
Phi.ageclass=list(formula=~ageclass)
Phi.dot=list(formula=~1)
p.area=list(formula=~area)
p.timebin.plus.area=list(formula=~timebin+area)
p.timebin.x.area=list(formula=~-1+timebin:area)
pent.ageclass=list(formula=~ageclass)
pent.ageclass.plus.EN=list(formula=~ageclass+EN)
pent.ageclass.plus.diffEN=list(formula=~ageclass+EN92+EN97+EN02)
cml=create.model.list("POPAN")
nat=mark.wrapper(cml,data=zc.proc,ddl=zc.ddl,
  invisible=FALSE,initial=1,retry=2,delete=TRUE)
return(nat)
}
nat=do.nat()
# model list
#            Phi                   p                      pent
#1  Phi.ageclass              p.area             pent.ageclass
#2  Phi.ageclass              p.area pent.ageclass.plus.diffEN
#3  Phi.ageclass              p.area     pent.ageclass.plus.EN
#4  Phi.ageclass p.timebin.plus.area             pent.ageclass
#5  Phi.ageclass p.timebin.plus.area pent.ageclass.plus.diffEN
#6  Phi.ageclass p.timebin.plus.area     pent.ageclass.plus.EN
#7  Phi.ageclass    p.timebin.x.area             pent.ageclass
#8  Phi.ageclass    p.timebin.x.area pent.ageclass.plus.diffEN
#9  Phi.ageclass    p.timebin.x.area     pent.ageclass.plus.EN
#10      Phi.dot              p.area             pent.ageclass
#11      Phi.dot              p.area pent.ageclass.plus.diffEN
#12      Phi.dot              p.area     pent.ageclass.plus.EN
#13      Phi.dot p.timebin.plus.area             pent.ageclass
#14      Phi.dot p.timebin.plus.area pent.ageclass.plus.diffEN
#15      Phi.dot p.timebin.plus.area     pent.ageclass.plus.EN
#16      Phi.dot    p.timebin.x.area             pent.ageclass
#17      Phi.dot    p.timebin.x.area pent.ageclass.plus.diffEN
#18      Phi.dot    p.timebin.x.area     pent.ageclass.plus.EN
#
# use model 9 as starting values for model 7
nat[[7]]= rerun.mark(nat[[7]],data=zc.proc,ddl=zc.ddl,initial=nat[[9]],delete=TRUE)
# use model 3 as starting values for model 1
nat[[1]]= rerun.mark(nat[[1]],data=zc.proc,ddl=zc.ddl,initial=nat[[3]],delete=TRUE)
# use model 14 as starting values for model 15
nat[[15]]= rerun.mark(nat[[15]],data=zc.proc,ddl=zc.ddl,initial=nat[[14]],delete=TRUE)
# use model 5 as starting values for model 6
nat[[6]]= rerun.mark(nat[[6]],data=zc.proc,ddl=zc.ddl,initial=nat[[5]],delete=TRUE)
# use model 10 as starting values for model 11
nat[[11]]= rerun.mark(nat[[11]],data=zc.proc,ddl=zc.ddl,initial=nat[[10]],delete=TRUE)
# use model 10 as starting values for model 12
nat[[12]]= rerun.mark(nat[[12]],data=zc.proc,ddl=zc.ddl,initial=nat[[10]],delete=TRUE)
# reconstruct model table with new results
nat$model.table=model.table(nat[1:18])
# show new model table
nat

## End(Not run)
</code></pre>


</div>