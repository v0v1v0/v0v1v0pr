<div class="container">

<table style="width: 100%;"><tr>
<td>gainstable.default</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gains Table for Binary Classifier</h2>

<h3>Description</h3>

<p>Default S3 method to create gains table from a vector of
diagnostic score and the class of observations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## Default S3 method:
gainstable(score, class, negref = NULL, ngroup = 10, breaks = NULL, ... = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>An numeric array of diagnostic score. Same as in
<code>rocit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p>An array of equal length of score,
containing the class of the observations. Same as in <code>rocit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negref</code></td>
<td>
<p>The reference value, same as the
<code>reference</code> in <code>convertclass</code>.
Depending on the class of <code>x</code>,
it can be numeric or character type. If specified, this value
is converted to 0 and other is converted to 1. If NULL, reference is
set alphabetically. Same as in <code>rocit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ngroup</code></td>
<td>
<p>Number of desired groups in gains table. Ignored if
<code>breaks</code> is specified.
See "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>Percentiles (in percentage) at which observations
should be separated to
form groups. If specified, <code>ngroup</code> is ignored. See "Details".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><code>NULL</code>. Used for S3 generic/method consistency.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gainstable</code> function creates gains table containing
<code>ngroup</code> number of groups or buckets. The algorithm first orders
the score variable with respect to score variable. In case of tie,
it class becomes the ordering variable, keeping the positive responses first.
The algorithm calculates the ending index in each bucket as
<code class="reqn">round((length(score) / ngroup) * (1:ngroup))</code>. Each bucket should have
at least 5 observations.
</p>
<p>If buckets' end index are to be ended at desired level of
population, then <code>breaks</code> should be specified.
If specified, it overrides <code>ngroup</code> and <code>ngroup</code> is ignored.
<code>breaks</code> by default always includes 100. If whole number does not exist
at specified population, nearest integers are considered.
</p>


<h3>Value</h3>

<p>A list of class <code>"gainstable"</code>. It has the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Bucket</code></td>
<td>
<p>The serial number of buckets or groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Obs</code></td>
<td>
<p>Number of observation in the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CObs</code></td>
<td>
<p>Cumulative number of observations up to the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Depth</code></td>
<td>
<p>Cumulative population depth up to the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Resp</code></td>
<td>
<p>Number of (positive) responses in the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CResp</code></td>
<td>
<p>Cumulative number of (positive) responses up to the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RespRate</code></td>
<td>
<p>(Positive) response rate in the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CRespRate</code></td>
<td>
<p>Cumulative (positive) response rate up to the group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CCapRate</code></td>
<td>
<p>Cumulative overall capture rate of (positive) responses
up to the group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lift</code></td>
<td>
<p>Lift index in the group. Calculated as
<code class="reqn">GroupResponseRate / OverallResponseRate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CLift</code></td>
<td>
<p>Cumulative lift index up to the group.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The algorithm is designed for complete cases. If NA(s) found in
either <code>score</code> or <code>class</code>, then removed.
</p>


<h3>See Also</h3>

<p><code>gainstable.rocit</code>, <code>plot.gainstable</code>,
<code>rocit</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("Loan")
class &lt;- Loan$Status
score &lt;- Loan$Score
# ----------------------------------------------------------------
gtable15 &lt;- gainstable(score = score, class = class,
                       negref = "FP", ngroup = 15)
gtable_custom &lt;- gainstable(score = score, class = class,
                            negref = "FP", breaks = seq(1,100,15))
# ----------------------------------------------------------------
print(gtable15)
print(gtable_custom)
# ----------------------------------------------------------------
plot(gtable15)
plot(gtable_custom)
plot(gtable_custom, type = 2)
plot(gtable_custom, type = 3)

</code></pre>


</div>