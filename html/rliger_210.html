<div class="container">

<table style="width: 100%;"><tr>
<td>quantileAlignSNF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Quantile align (normalize) factor loadings</h2>

<h3>Description</h3>

<p>This is a deprecated function. Calling 'quantileNorm' instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">quantileAlignSNF(
  object,
  knn_k = 20,
  k2 = 500,
  prune.thresh = 0.2,
  ref_dataset = NULL,
  min_cells = 20,
  quantiles = 50,
  nstart = 10,
  resolution = 1,
  dims.use = 1:ncol(x = object@H[[1]]),
  dist.use = "CR",
  center = FALSE,
  small.clust.thresh = 0,
  id.number = NULL,
  print.mod = FALSE,
  print.align.summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>liger</code> object. Should run optimizeALS before calling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knn_k</code></td>
<td>
<p>Number of nearest neighbors for within-dataset knn graph (default 20).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2</code></td>
<td>
<p>Horizon parameter for shared nearest factor graph. Distances to all but the k2 nearest
neighbors are set to 0 (cuts down on memory usage for very large graphs). (default 500)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prune.thresh</code></td>
<td>
<p>Minimum allowed edge weight. Any edges below this are removed (given weight
0) (default 0.2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref_dataset</code></td>
<td>
<p>Name of dataset to use as a "reference" for normalization. By default,
the dataset with the largest number of cells is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_cells</code></td>
<td>
<p>Minimum number of cells to consider a cluster shared across datasets (default 2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>Number of quantiles to use for quantile normalization (default 50).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nstart</code></td>
<td>
<p>Number of times to perform Louvain community detection with different random
starts (default 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolution</code></td>
<td>
<p>Controls the number of communities detected. Higher resolution -&gt; more
communities. (default 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims.use</code></td>
<td>
<p>Indices of factors to use for shared nearest factor determination (default
1:ncol(H[[1]])).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.use</code></td>
<td>
<p>Distance metric to use in calculating nearest neighbors (default "CR").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>Centers the data when scaling factors (useful for less sparse modalities like
methylation data). (default FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>small.clust.thresh</code></td>
<td>
<p>Extracts small clusters loading highly on single factor with fewer
cells than this before regular alignment (default 0 â€“ no small cluster extraction).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id.number</code></td>
<td>
<p>Number to use for identifying edge file (when running in parallel)
(generates random value by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.mod</code></td>
<td>
<p>Print modularity output from clustering algorithm (default FALSE).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.align.summary</code></td>
<td>
<p>Print summary of clusters which did not align normally (default FALSE).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This process builds a shared factor neighborhood graph to jointly cluster cells, then quantile
normalizes corresponding clusters.
</p>
<p>The first step, building the shared factor neighborhood graph, is performed in SNF(), and
produces a graph representation where edge weights between cells (across all datasets)
correspond to their similarity in the shared factor neighborhood space. An important parameter
here is knn_k, the number of neighbors used to build the shared factor space (see SNF()). Afterwards,
modularity-based community detection is performed on this graph (Louvain clustering) in order
to identify shared clusters across datasets. The method was first developed by Waltman and van Eck
(2013) and source code is available at http://www.ludowaltman.nl/slm/. The most important parameter
here is resolution, which corresponds to the number of communities detected.
</p>
<p>Next we perform quantile alignment for each dataset, factor, and cluster (by
stretching/compressing datasets' quantiles to better match those of the reference dataset). These
aligned factor loadings are combined into a single matrix and returned as H.norm.
</p>


<h3>Value</h3>

<p><code>liger</code> object with H.norm and cluster slots set.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# liger object, factorization complete
ligerex
# do basic quantile alignment
ligerex &lt;- quantileAlignSNF(ligerex)
# higher resolution for more clusters (note that SNF is conserved)
ligerex &lt;- quantileAlignSNF(ligerex, resolution = 1.2)
# change knn_k for more fine-grained local clustering
ligerex &lt;- quantileAlignSNF(ligerex, knn_k = 15, resolution = 1.2)

## End(Not run)

</code></pre>


</div>