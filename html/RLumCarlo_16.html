<div class="container">

<table style="width: 100%;"><tr>
<td>run_MC_TL_DELOC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run Monte-Carlo Simulation for TL (delocalized transitions)</h2>

<h3>Description</h3>

<p>Runs a Monte-Carlo (MC) simulation of thermoluminescence (TL)
using the one trap one recombination centre (OTOR) model.
Delocalised refers to involvement of the conduction band. The heating rate in this function
is assumed to be 1 K/s.
</p>


<h3>Usage</h3>

<pre><code class="language-R">run_MC_TL_DELOC(
  s,
  E,
  times,
  b = 1,
  clusters = 10,
  N_e = 200,
  n_filled = N_e,
  R = 1,
  method = "par",
  output = "signal",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>numeric (<strong>required</strong>): The frequency factor of the trap (s^-1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E</code></td>
<td>
<p>numeric (<strong>required</strong>): Thermal activation energy of the trap (eV)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>numeric (<strong>required</strong>): The sequence of temperature steps within the simulation (s).
The default heating rate is set to 1 K/s. The final temperature is <code>max(times) * b</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>numeric (<em>with default</em>): the heating rate in K/s</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>numeric (<em>with default</em>): The number of created clusters for the MC runs. The input can be the output of create_ClusterSystem. In that case <code>n_filled</code> indicate absolute numbers of a system.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_e</code></td>
<td>
<p>integer (<em>with default</em>): The total number of electron traps available (dimensionless). Can be a vector of <code>length(clusters)</code>, shorter values are recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_filled</code></td>
<td>
<p>integer (<em>with default</em>): The number of filled electron traps at the beginning
of the simulation (dimensionless). Can be a vector of <code>length(clusters)</code>, shorter values are recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>numeric (<em>with default</em>): Re-trapping ratio for delocalized transitions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character (<em>with default</em>): Sequential <code>'seq'</code> or parallel <code>'par'</code>processing. In
the parallel mode the function tries to run the simulation on multiple CPU cores (if available) with
a positive effect on the computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>character (<em>with default</em>): output is either the <code>'signal'</code> (the default) or
<code>'remaining_e'</code> (the remaining charges/electrons in the trap)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments, such as <code>cores</code> to control the number of used CPU cores or <code>verbose</code> to silence the terminal</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>The model</strong>
</p>
<p style="text-align: center;"><code class="reqn">
I_{DELOC}(t) = -dn/dt = (s*exp(-E/(k_{B}*T))) * (n^2 / (N * R + n(1-R))))
</code>
</p>

<p>Where in the function: <br>
E := the thermal activation energy (eV) <br>
s := the frequency factor in (s^-1) <br>
t := time (s) <br><code class="reqn">k_{B}</code> := Boltzmann constant (8.617 x 10^-5 eV K^-1)<br>
T := temperature (°C) <br>
R := Delocalised retrapping ratio<br>
n := <code>n_filled</code>, the instantaneous number of electrons <br>
N := <code>N_e</code>, the total number of electron traps available (dimensionless) <br></p>
<p><strong>Why <code>times</code> and <code>b</code> instead of temperature?</strong>
</p>
<p>The parameter to control the temperature is a function of the stimulation
times (the parameter <code>times</code>) and the heating rate (<code>b</code>). Thus, the final temperature
is <code>max(times) * b</code>. For a heating rate (<code>b = 1</code>) the final temperature is <code>max(times)</code>.
While this might be a little bit confusing, it also allows you to control the
time resolution of the simulation, i.e. you can simulate more points per second.
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>RLumCarlo_Model_Output</code> which
is a list consisting of an array with dimension length(times) x clusters
and a numeric time vector.
</p>


<h3>Function version</h3>

<p>0.1.0
</p>


<h3>How to cite</h3>

<p>Kreutzer, S., 2022. run_MC_TL_DELOC(): Run Monte-Carlo Simulation for TL (delocalized transitions). Function version 0.1.0. In: Friedrich, J., Kreutzer, S., Pagonis, V., Schmidt, C., 2022. RLumCarlo: Monte-Carlo Methods for Simulating Luminescence Phenomena. R package version 0.1.9. https://CRAN.R-project.org/package=RLumCarlo
</p>


<h3>Author(s)</h3>

<p>Sebastian Kreutzer, Institute of Geography, Heidelberg University (Germany)
</p>


<h3>References</h3>

<p>Pagonis, V., Friedrich, J., Discher, M., Müller-Kirschbaum, A., Schlosser, V., Kreutzer, S.,
Chen, R. and Schmidt, C., 2019. Excited state luminescence signals from a random distribution
of defects: A new Monte Carlo simulation approach for feldspar.
Journal of Luminescence 207, 266–272. <a href="https://doi.org/10.1016/j.jlumin.2018.11.024">doi:10.1016/j.jlumin.2018.11.024</a>
</p>
<p><strong>Further reading</strong>
</p>
<p>Chen, R., McKeever, S.W.S., 1997. Theory of Thermoluminescence and Related Phenomena.
WORLD SCIENTIFIC. <a href="https://doi.org/10.1142/2781">doi:10.1142/2781</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## the short example
run_MC_TL_DELOC(
 s = 3.5e12,
 E = 1.45,
 R = 0.1,
 method = 'seq',
 clusters = 100,
 times = 150:350) %&gt;%
plot_RLumCarlo(legend = TRUE)

## Not run: 
## the long (meaningful) example
# define your parameters
times &lt;- seq(100, 450, 1)
s &lt;- rep(3.5e12, 4)
E &lt;- rep(1.45, 4)
R &lt;- c(0.7e-6, 1e-6, 0.01, 0.1)
clusters &lt;- 300
N_e &lt;- c(400, 500, 700, 400)
n_filled &lt;- c(400, 500, 300, 70)
method &lt;- "par"
output &lt;- "signal"
col &lt;- c(1, 2, 3, 4) # different colours for the individual curves
plot_uncertainty &lt;- c(TRUE, TRUE, TRUE, TRUE)  # do you want to see the uncertainty?
add_TF &lt;- c(FALSE, rep(TRUE, (length(R) - 1)))

# loop to plot different curves into one plot
for (u in 1:length(R)){
 results &lt;- run_MC_TL_DELOC(
  times=times,
  s = s[u],
  E = E[u],
  clusters = clusters,
  N_e = N_e[u],
  n_filled = n_filled[u],
  R = R[u],
  method = method,
  output = output)

plot_RLumCarlo(
 results,
 add = add_TF[u],
 legend = FALSE,
 col=col[u],
 main = " your plot",
 ylim=c(0,20))
}
#add your legend with your parameters
legend("topright",
  ncol = 5,
  cex = 0.55,
  bty = "n",
  title = "parameters",
  legend = c(
   paste0("E = ", E),
   paste0("s = ", s),
   paste0("n_filled = ", n_filled),
   paste0("N_e = ", N_e), paste0("R = ", R)),
   text.col = col)

## End(Not run)

</code></pre>


</div>