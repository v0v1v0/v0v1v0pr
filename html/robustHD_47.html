<div class="container">

<table style="width: 100%;"><tr>
<td>fitted.seqModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract fitted values from a sequence of regression models</h2>

<h3>Description</h3>

<p>Extract fitted values from a sequence of regression models, such as submodels
along a robust or groupwise least angle regression sequence, or sparse least
trimmed squares regression models for a grid of values for the penalty
parameter.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'seqModel'
fitted(object, s = NA, drop = !is.null(s), ...)

## S3 method for class 'tslars'
fitted(object, p, ...)

## S3 method for class 'perrySeqModel'
fitted(object, ...)

## S3 method for class 'sparseLTS'
fitted(
  object,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>the model fit from which to extract fitted values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels for which to extract the fitted values (the default
is to use the optimal submodel).  For the <code>"sparseLTS"</code> method, an
integer vector giving the indices of the models for which to extract fitted
values.  If <code>fit</code> is <code>"both"</code>, this can be a list with two
components, with the first component giving the indices of the reweighted
fits and the second the indices of the raw fits.  The default is to use the
optimal model for each of the requested estimators.  Note that the optimal
models may not correspond to the same value of the penalty parameter for the
reweighted and the raw estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"seqModel"</code> method.  For the other methods,
additional arguments are currently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an integer giving the lag length for which to extract fitted
values (the default is to use the optimal lag length).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>a character string specifying which fitted values to extract.
Possible values are <code>"reweighted"</code> (the default) for the fitted values
from the reweighted estimator, <code>"raw"</code> for the fitted values from the
raw estimator, or <code>"both"</code> for the fitted values from both estimators.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector or matrix containing the requested fitted values.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code>fitted</code>, <code>rlars</code>,
<code>grplars</code>, <code>rgrplars</code>, <code>tslarsP</code>,
<code>rtslarsP</code>, <code>tslars</code>, <code>rtslars</code>,
<code>sparseLTS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract fitted values
fitted(fitRlars)
head(fitted(fitRlars, s = 1:5))


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract fitted values
fitted(fitSparseLTS)
head(fitted(fitSparseLTS, fit = "both"))
head(fitted(fitSparseLTS, s = NULL))
head(fitted(fitSparseLTS, fit = "both", s = NULL))
</code></pre>


</div>