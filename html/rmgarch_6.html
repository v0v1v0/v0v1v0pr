<div class="container">

<table style="width: 100%;"><tr>
<td>goGARCHfit-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>class: GO-GARCH Fit Class</h2>

<h3>Description</h3>

<p>Class for the GO-GARCH fitted object.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code>gogarchfit</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>mfit</code>:</dt>
<dd>
<p>Multivariate fit object.</p>
</dd>
<dt>
<code>model</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code> containing details of the
GO-GARCH model specification.</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"mGARCHfit"</code>, directly.
Class <code>"GARCHfit"</code>, by class "mGARCHfit", distance 2.
Class <code>"rGARCH"</code>, by class "mGARCHfit", distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>as.matrix</dt>
<dd>
<p><code>signature(x = "goGARCHfit")</code>:
function:<br><b>as.matrix(x, which = "A")</b><br>
This returns four types of matrices relating to the estimation of the
independent components in the GO-GARCH model. Valid choices are “A”
for the mixing matrix, “W” for the unmixing matrix, “U” for the
rotational matrix and “K” for the whitening matrix, “Kinv” for
the de-whitening matrix.</p>
</dd>
<dt>coef</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:  extraction of independent
factor GARCH model coefficients.</p>
</dd>
<dt>convolution</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:<br>
function:<br><b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c("user", "adaptive"), use.ff = TRUE,
cluster = NULL, trace = 0,...)</b><br>
The convolution method takes a goGARCHfit object and a weights vector or
matrix and calculates the weighted density. If a vector is given, it must be
the same length as the number of assets, otherwise a matrix with row
dimension equal to the row dimension of the filtered dataset (i.e. less any
lags). In the case of the multivariate normal distribution, this simply
returns the linear and quadratic transformation of the mean and covariance
matrix, while in the multivariate affine NIG distribution this is based on
the numerical inversion by FFT of the characteristic function. In that case,
the “fft.step” option determines the stepsize for tuning the
characteristic function inversion, “fft.by” determines the resolution
for the equally spaced support given by “fft.support”, while the use
of the “ff” package is recommended to avoid memory problems on some
systems and is turned on via the “use.ff” option.
The “support.method” option allows either a fixed support range to be
given (option ‘user’), else an adaptive method is used based on the
min and max of the assets at each point in time at the 0.00001 and 1-0.00001
quantiles. The range is equally spaced subject to the “fft.by” value
but the returned object no longer makes of the “ff” package returning
instead a list. Finally, the option for parallel computation is available via
the use of a cluster object as elsewhere in this package.</p>
</dd>
<dt>fitted</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
Extracts the conditional mean equation fitted values.</p>
</dd>
<dt>residuals</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
Extracts the conditional mean equation residuals.</p>
</dd>
<dt>likelihood</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
The quasi log-likelihood of the model, which being an independent factor model
is the sum of the univariate GARCH log-likelihoods plus a term for the mixing
matrix. For a dimensionality reduced system, this is NA.</p>
</dd>
<dt>nisurface</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:<br>
function:<br><b>nisurface(object, type = "cov", pair = c(1, 2), factor = c(1,2),
plot = TRUE)</b><br>
Creates the covariance or correlation (determined by “type” being
either “cov” or “cor”) news impact surface for a pair of
assets and factors. Since the shocks impact the factors independently,
the news impact surface is a combination of the independent news impact
curves of the factors which when combined via the mixing matrix A, create
the dynamics for the underlying asset-factor surface function.</p>
</dd>
<dt>gportmoments</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:<br>
function:<br><b>gportmoments(object, weights)</b><br>
Calculates the first 4 portfolio moments using the geometric properties of
the model, given a vector or matrix of asset weights. If a matrix is given
it must have row dimension equal to the row dimension of the filtered
dataset (i.e. less any lags), else if a vector is given it will be replicated
for all time points.</p>
</dd>
<dt>rcoskew</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>
function:<br><b>rcoskew(object, standardize = TRUE, from = 1, to = 1)</b><br>
Returns the 'time-varying'  NxN^2 coskewness tensor in array format. The
“from” and “to” options indicate the time indices for which
to return the arrays. Because of memory issues, this is limited to 100
indices per call.</p>
</dd>
<dt>rcokurt</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>
function:<br><b>rcokurt(object, standardize = TRUE, from = 1, to = 1)</b><br>
Returns the 'time-varying'  NxN^3 cokurtosis tensor in array format. The
“from” and “to” options indicate the time indices for which
to return the arrays. Because of memory issues, this is limited to models
with less than 100 assets.</p>
</dd>
<dt>rcov</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
Returns the time-varying NxN covariance matrix in array format unless
‘output’ is set to “matrix” in which case the array
is flattened and the lower and main diagonal time varying values are
returned (and if a date exists, then the returned object is of class xts).
</p>
</dd>
<dt>rcor</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
Returns the time-varying NxN correlation matrix in array format unless
‘output’ is set to “matrix” in which case the array
is flattened and the lower and main diagonal time varying values are
returned (and if a date exists, then the returned object is of class xts).
</p>
</dd>
<dt>betacovar</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
function:<br><b>betacovar(object, weights, asset = 1, cluster = NULL)</b><br>
Returns the covariance beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>betacoskew</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
function:<br><b>betacoskew(object, weights, asset = 1, cluster = NULL)</b><br>
Returns the coskewness beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>betacokurt</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>:
function:<br><b>betacokurt(object, weights, asset = 1, cluster = NULL)</b><br>
Returns the cokurtosis beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>show</dt>
<dd>
<p><code>signature(object = "goGARCHfit")</code>: Summary method.</p>
</dd>
</dl>
<h3>Note</h3>

<p>The reference by Paolella (2007) contains more details on the algorithm for the
characteristic function inversion via FFT. The application of this method in a
related model can be found in Chen (2007). The de Athayde and Flores (2002)
paper is the basis for the geometric properties of the higher moment tensors in
finance.<br></p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>de Athayde, G.M. and Flores Jr, R.G. 2002, On Certain Geometric Aspects of
Portfolio Optimisation with Higher Moments, <em>mimeo</em>.<br>
Broda, S.A. and Paolella, M.S. 2009, CHICAGO: A Fast and Accurate Method for
Portfolio Risk Calculation, <em>Journal of Financial Econometrics</em> <b>7(4)</b>,
412–436 .<br>
Paolella, M.S. 2007, Intermediate Probability - A Computational Approach,
<em>Wiley-Interscience</em>.<br>
Schmidt, R., Hrycej, T. and Stutzle 2006, Multivariate distribution models with
generalized hyperbolic margins, <em>Computational Statistics \&amp; Data Analysis</em>
<b>50(8)</b>, 2065-2096.<br></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(dji30ret)
spec = gogarchspec(mean.model = list(demean = "constant"),
variance.model = list(model = "sGARCH", garchOrder = c(1,1), submodel = NULL),
distribution.model = list(distribution = "manig"), ica = "fastica")
fit = gogarchfit(spec = spec, data  = dji30ret[,1:4, drop = FALSE],
out.sample = 50, gfun = "tanh")
# The likelihood of the model
likelihood(fit)
# the GARCH coefficients of the independent factors
coef(fit)
# a news-impact surface plot
#ni = nisurface(fit, type = "cov", pair = c(1, 2), factor = c(1,2), plot = TRUE)
# the time varying correlation array
mc = rcor(fit)
# plot(mc[1,2,], type = "l")
# The moments of an equally weighted portfolio (subtract the out.sample from dimension)
gm = gportmoments(fit, weights = matrix(1/4, ncol = 4,
nrow = dim(dji30ret)[1]-50), debug = TRUE)

## End(Not run)</code></pre>


</div>