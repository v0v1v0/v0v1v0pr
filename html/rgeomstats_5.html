<div class="container">

<table style="width: 100%;"><tr>
<td>Manifold</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Abstract Class for Manifolds</h2>

<h3>Description</h3>

<p>An R6::R6Class object implementing the base <code>Manifold</code>
class. In other words, a topological space that locally resembles Euclidean
space near each point.
</p>


<h3>Super class</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code>Manifold</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>dim</code></dt>
<dd>
<p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt>
<dd>
<p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>metric</code></dt>
<dd>
<p>A RiemannianMetric object specifying the metric to use on
the manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt>
<dd>
<p>A string specifying the coordinate type.
Choices are <code>extrensic</code> or <code>intrinsic</code>. Dedaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>default_point_type</code></dt>
<dd>
<p>A string specifying the point type. Choices are
<code>vector</code> or <code>matrix</code>. It is automatically determined depending on the
manifold.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Manifold-new"><code>Manifold$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-belongs"><code>Manifold$belongs()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-is_tangent"><code>Manifold$is_tangent()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-to_tangent"><code>Manifold$to_tangent()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-random_point"><code>Manifold$random_point()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-regularize"><code>Manifold$regularize()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-set_metric"><code>Manifold$set_metric()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-random_tangent_vec"><code>Manifold$random_tangent_vec()</code></a>
</p>
</li>
<li> <p><a href="#method-Manifold-clone"><code>Manifold$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href="../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class"><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href="../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class"><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
</ul></details><hr>
<a id="method-Manifold-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>The <code>Manifold</code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$new(
  dim,
  shape = NULL,
  metric = NULL,
  default_coords_type = "intrinsic",
  py_cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt>
<dd>
<p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt>
<dd>
<p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>metric</code></dt>
<dd>
<p>A <code>RiemannianMetric</code> object specifying the metric to use
on the manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt>
<dd>
<p>A string specifying the coordinate type.
Choices are <code>extrinsic</code> or <code>intrinsic</code>. Defaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>py_cls</code></dt>
<dd>
<p>A Python object of class <code>Manifold</code>. Defaults to <code>NULL</code> in
which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An object of class <code>Manifold</code>.
</p>


<hr>
<a id="method-Manifold-belongs"></a>



<h4>Method <code>belongs()</code>
</h4>

<p>Evaluates if a point belongs to the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$belongs(point, atol = gs$backend$atol)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt>
<dd>
<p>A numeric array of shape <code class="reqn">[\dots \times
\{\mathrm{dim}\}]</code> specifying one or more points to be checked.</p>
</dd>
<dt><code>atol</code></dt>
<dd>
<p>A numeric value specifying the absolute tolerance for
checking. Defaults to <code>gs$backend$atol</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A boolean value or vector storing whether the corresponding
points belong to the manifold.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$belongs(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-is_tangent"></a>



<h4>Method <code>is_tangent()</code>
</h4>

<p>Checks whether a vector is tangent at a base point.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$is_tangent(vector, base_point = NULL, atol = gs$backend$atol)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector</code></dt>
<dd>
<p>A numeric array of shape <code class="reqn">[\dots \times
[\mathrm{dim}]]</code> specifying one or more vectors to be checked.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code class="reqn">[\dots \times
  [\mathrm{dim}]]</code> specifying one or more base points on the manifold.
Defaults to <code>NULL</code> in which case the identity is used.</p>
</dd>
<dt><code>atol</code></dt>
<dd>
<p>A numeric value specifying the absolute tolerance for
checking. Defaults to <code>gs$backend$atol</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A boolean value or vector storing whether the corresponding
points are tangent to the manifold at corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$is_tangent(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-to_tangent"></a>



<h4>Method <code>to_tangent()</code>
</h4>

<p>Projects a vector to a tangent space of the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$to_tangent(vector, base_point = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector</code></dt>
<dd>
<p>A numeric array of shape <code class="reqn">[\dots \times
  [\mathrm{dim}]]</code> specifying one or more vectors to project on the
manifold.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code class="reqn">[\dots \times
  [\mathrm{dim}]]</code> specifying one or more base points on the manifold.
Defaults to <code>NULL</code> in which case the identity is used.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{\mathrm{dim}\}]</code>
storing the corresponding projections onto the manifold at
corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$to_tangent(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-random_point"></a>



<h4>Method <code>random_point()</code>
</h4>

<p>Samples random points on the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$random_point(n_samples = 1, bound = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_samples</code></dt>
<dd>
<p>An integer value specifying the number of samples to be
drawn. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>bound</code></dt>
<dd>
<p>A numeric value specifying the bound of the interval in
which to sample for non-compact manifolds. Defaults to <code>1L</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>If the manifold is compact, a uniform distribution is used.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{\mathrm{dim}\}]</code>
storing a sample of points on the manifold.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  # spd3$random_point(10) # TO DO: uncomment when bug fixed in gs
}
</pre>
</div>


<hr>
<a id="method-Manifold-regularize"></a>



<h4>Method <code>regularize()</code>
</h4>

<p>Regularizes a point to the canonical representation for the
manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$regularize(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt>
<dd>
<p>A numeric array of shape <code class="reqn">[\dots \times
[\mathrm{dim}]]</code> specifying one or more points on the manifold.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric array of the same shape storing the corresponding
regularized points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$regularize(diag(1, 3))
}
</pre>
</div>


<hr>
<a id="method-Manifold-set_metric"></a>



<h4>Method <code>set_metric()</code>
</h4>

<p>Sets the Riemannian Metric associated to the manifold.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$set_metric(metric)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>metric</code></dt>
<dd>
<p>An object of class <code>RiemannianMetric</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The Manifold class itself invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$metric
  spd3$set_metric(SPDMetricBuresWasserstein$new(n = 3))
  spd3$metric
}
</pre>
</div>


<hr>
<a id="method-Manifold-random_tangent_vec"></a>



<h4>Method <code>random_tangent_vec()</code>
</h4>

<p>Generates a random tangent vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$random_tangent_vec(base_point, n_samples = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code class="reqn">[\dots \times
\{\mathrm{dim}\}]</code> specifying one or more base points on the manifold.</p>
</dd>
<dt><code>n_samples</code></dt>
<dd>
<p>An integer value specifying the number of samples to be
drawn. Defaults to <code>1L</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric array of shape <code class="reqn">[\dots \times \{\mathrm{dim}\}]</code>
storing a sample of vectors that are tangent to the manifold at
corresponding base points.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$random_tangent_vec(diag(1, 3), 10)
}
</pre>
</div>


<hr>
<a id="method-Manifold-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Manifold$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Author(s)</h3>

<p>Nina Miolane
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## ------------------------------------------------
## Method `Manifold$belongs`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$belongs(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$is_tangent`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$is_tangent(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$to_tangent`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$to_tangent(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$random_point`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  # spd3$random_point(10) # TO DO: uncomment when bug fixed in gs
}

## ------------------------------------------------
## Method `Manifold$regularize`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  A &lt;- diag(1, 3)
  spd3$regularize(diag(1, 3))
}

## ------------------------------------------------
## Method `Manifold$set_metric`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$metric
  spd3$set_metric(SPDMetricBuresWasserstein$new(n = 3))
  spd3$metric
}

## ------------------------------------------------
## Method `Manifold$random_tangent_vec`
## ------------------------------------------------

if (reticulate::py_module_available("geomstats")) {
  spd3 &lt;- SPDMatrix(n = 3)
  spd3$random_tangent_vec(diag(1, 3), 10)
}
</code></pre>


</div>