<div class="container">

<table style="width: 100%;"><tr>
<td>bayesx.control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Control Parameters for BayesX
</h2>

<h3>Description</h3>

<p>Various parameters that control fitting of regression models
using <code>bayesx</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayesx.control(model.name = "bayesx.estim", 
  family = "gaussian", method = "MCMC", verbose = FALSE, 
  dir.rm = TRUE, outfile = NULL, replace = FALSE, iterations = 12000L,
  burnin = 2000L, maxint = NULL, step = 10L, predict = TRUE,
  seed = NULL, hyp.prior = NULL, distopt = NULL, reference = NULL,
  zipdistopt = NULL, begin = NULL, level = NULL, eps = 1e-05,
  lowerlim = 0.001, maxit = 400L, maxchange = 1e+06, leftint = NULL,
  lefttrunc = NULL, state = NULL, algorithm = NULL, criterion = NULL, 
  proportion = NULL, startmodel = NULL, trace = NULL, 
  steps = NULL, CI = NULL, bootstrapsamples = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model.name</code></td>
<td>
<p>character, specify a base name model output files are named 
with in <code>outfile</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>character, specify the distribution used for the model, options 
for all methods, <code>"MCMC"</code>, <code>"REML"</code> and <code>"STEP"</code> are: <code>"binomial"</code>,
<code>"binomialprobit"</code>, <code>"gamma"</code>, <code>"gaussian"</code>, <code>"multinomial"</code>,
<code>"poisson"</code>. For <code>"MCMC"</code> and <code>"REML"</code> only: <code>"cox"</code>, <code>"cumprobit"</code> and
<code>"multistate"</code>. For <code>"REML"</code> only use:
<code>"binomialcomploglog"</code>, <code>"cumlogit"</code>, <code>"multinomialcatsp"</code>,
<code>"multinomialprobit"</code>, <code>"seqlogit"</code>, <code>"seqprobit"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character, which method should be used for estimation, options 
are <code>"MCMC"</code>, <code>"HMCMC"</code> (hierarchical MCMC), <code>"REML"</code> and <code>"STEP"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical, should output be printed to the <code>R</code> console 
during runtime of <code>bayesx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dir.rm</code></td>
<td>
<p>logical, should the the <code>output</code> files and directory 
removed after estimation?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outfile</code></td>
<td>
<p>character, specify a directory where <code>bayesx</code> 
should store all output files, all output files will be named with <code>model.name</code> as the 
base name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>if set to <code>TRUE</code>, the files in the output directory specified in argument
<code>outfile</code> will be replaced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>integer, sets the number of iterations for the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>integer, sets the burn-in period of the sampler.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxint</code></td>
<td>
<p>integer, if first or second order random walk priors are 
specified, in some cases the data will be slightly grouped: The range between the minimal and 
maximal observed covariate values will be divided into (small) intervals, and for each interval 
one parameter will be estimated. The grouping has almost no effect on estimation results as long 
as the number of intervals is large enough. With the <code>maxint</code> option the amount of grouping 
can be determined by the user. integer is the maximum number of intervals allowed. for 
equidistant data, the default <code>maxint = 150</code> for example, means that no grouping will be 
done as long as the number of different observations is equal to or below 150. for non 
equidistant data some grouping may be done even if the number of different observations is below 
150.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>integer, defines the thinning parameter for MCMC simulation.  
E.g., <code>step = 50</code> means, that only every 50th sampled parameter will be stored and used to 
compute characteristics of the posterior distribution as means, standard deviations or 
quantiles. The aim of thinning is to reach a considerable reduction of disk storing and 
autocorrelations between sampled parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predict</code></td>
<td>
<p>logical, option <code>predict</code> may be specified to compute 
samples of the deviance <code>D</code>, the effective number of parameters <code>pD</code> and the deviance 
information criterion <code>DIC</code> of the model. In addition, if <code>predict = FALSE</code>, only
output files of estimated effects will be returned, otherwise an expanded dataset using all
observations would be written in the output directory, also containing the data used for
estimation. Hence, this option is useful when dealing with large data sets, that might cause
memory problems if <code>predict</code> is set to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer, set the seed of the random number generator in 
<span class="pkg">BayesX</span>, usually set using function <code>set.seed</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hyp.prior</code></td>
<td>
<p>numeric, defines the value of the hyper-parameters <code>a</code> 
and <code>b</code> for the inverse gamma prior of the overall variance parameter <code class="reqn">\sigma^2</code>, if 
the response distribution is Gaussian. <code>numeric</code>, must be a positive real valued number.
The default is <code>hyp.prior = c(1, 0.005)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distopt</code></td>
<td>
<p>character, defines the implemented formulation for the negative 
binomial model if the response distribution is negative binomial. The two possibilities are to 
work with a negative binomial likelihood (<code>distopt = "nb"</code>) or to work with the Poisson 
likelihood and the multiplicative random effects (<code>distopt = "poga"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>character, option <code>reference</code> is meaningful only if 
either <code>family = "multinomial"</code> or <code>family = "multinomialprobit"</code> is specified as the 
response distribution. In this case <code>reference</code> defines the <code>reference</code> category to be 
chosen. Suppose, for instance, that the response is three categorical with categories 1, 2 and 
3. Then <code>reference = 2</code> defines the value 2 to be the <code>reference</code> category.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zipdistopt</code></td>
<td>
<p>character, defines the zero inflated distribution for the 
regression analysis. The two possibilities are to work with a zero infated Poisson distribution 
(<code>zipdistopt = "zip"</code>) or to work with the zero inflated negative binomial likelihood 
(<code>zipdistopt = "zinb"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>begin</code></td>
<td>
<p>character, option <code>begin</code> is meaningful only if 
<code>family = "cox"</code> is specified as the response distribution. In this case begin specifies 
the variable that records when the observation became at risk. This option can be used to handle 
left truncation and time-varying covariates. If <code>begin</code> is not specified, all observations 
are assumed to have become at risk at time 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>integer, besides the posterior means and medians, <span class="pkg">BayesX</span> 
provides point-wise posterior credible intervals for every effect in the model. In a Bayesian 
approach based on MCMC simulation techniques credible intervals are estimated by computing the 
respective quantiles of the sampled effects. By default, <span class="pkg">BayesX</span> computes (point-wise) 
credible intervals for nominal levels of 80<code class="reqn">\%</code> and 95<code class="reqn">\%</code>. The option <code>level[1]</code> 
allows to redefine one of the nominal levels (95<code class="reqn">\%</code>). Adding, for instance, 
<code>level[1] = 99</code> to the options list computes credible intervals for a nominal level of 
99<code class="reqn">\%</code> rather than 95<code class="reqn">\%</code>. Similar to argument <code>level[1]</code> the option 
<code>level[2]</code> allows to redefine one of the nominal levels (80<code class="reqn">\%</code>). Adding, for instance, 
<code>level[2] = 70</code> to the options list computes credible intervals for a nominal level of 
70<code class="reqn">\%</code> rather than 80<code class="reqn">\%</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>numeric, defines the termination criterion of the estimation 
process. If both the relative changes in the regression coefficients and the variance parameters 
are less than <code>eps</code>, the estimation process is assumed to have converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowerlim</code></td>
<td>
<p>numeric, since small variances are close to the boundary of 
their parameter space, the usual fisher-scoring algorithm for their determination has to be 
modified. If the fraction of the penalized part of an effect relative to the total effect is 
less than <code>lowerlim</code>, the estimation of the corresponding variance is stopped and the 
estimator is defined to be the current value of the variance (see section 6.2 of the BayesX 
methodology manual for details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>integer, defines the maximum number of iterations to be used in 
estimation. Since the estimation process will not necessarily converge, it may be useful to 
define an upper bound for the number of iterations. Note, that <span class="pkg">BayesX</span> returns results 
based on the current values of all parameters even if no convergence could be achieved within 
<code>maxit</code> iterations, but a warning message will be printed in the output window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxchange</code></td>
<td>
<p>numeric, defines the maximum value that is allowed for 
relative changes in parameters in one iteration to prevent the program from crashing because of 
numerical problems. Note, that <span class="pkg">BayesX</span> produces results based on the current values of all 
parameters even if the estimation procedure is stopped due to numerical problems, but an error 
message will be printed in the output window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leftint</code></td>
<td>
<p>character, gives the name of the variable that contains the 
lower (left) boundary <code class="reqn">T_{lo}</code> of the interval <code class="reqn">[T_{lo}, T_{up}]</code> for an interval 
censored observation. for right censored or uncensored observations we have to specify 
<code class="reqn">T_{lo} = T_{up}</code> . If leftint is missing, all observations are assumed to be right censored 
or uncensored, depending on the corresponding value of the censoring indicator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lefttrunc</code></td>
<td>
<p>character, option <code>lefttrunc</code> specifies the name of the 
variable containing the left truncation time <code class="reqn">T_{tr}</code>. For observations that are not 
truncated, we have to specify <code class="reqn">T_{tr} = 0</code>. If <code>lefttrunc</code> is missing, all observations 
are assumed to be not truncated. for multi-state models variable <code>lefttrunc</code> specifies the 
left endpoint of the corresponding time interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>character, for multi-state models, <code>state</code> specifies the 
current state variable of the process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>character, specifies the selection algorithm. Possible values 
are <code>"cdescent1"</code> (adaptive algorithms in the methodology manual, see subsection 6.3), 
<code>"cdescent2"</code> (adaptive algorithms 1 and 2 with backfitting, see remarks 1 and 2 of section 
3 in Belitz and Lang (2008)), <code>"cdescent3"</code> (search according to cdescent1 followed by 
cdescent2 using the selected model in the first step as the start model) and <code>"stepwise"</code> 
(stepwise algorithm implemented in the <code>gam</code> routine of S-plus, see Chambers and 
Hastie, 1992). This option will rarely be specified by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>character, specifies the goodness of fit criterion. If 
<code>criterion = "MSEP"</code> is specified the data are randomly divided into a test- and validation 
data set. The test data set is used to estimate the models and the validation data set is used 
to estimate the mean squared prediction error (MSEP) which serves as the goodness of fit 
criterion to compare different models. The proportion of data used for the test and validation 
sample can be specified using option proportion, see below. The default is to use 75<em>%</em> of 
the data for the training sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proportion</code></td>
<td>
<p>numeric, this option may be used in combination with option 
<code>criterion = "MSEP"</code>, see above. In this case the data are randomly divided into a training 
and a validation sample. proportion defines the fraction (between 0 and 1) of the original data 
used as training sample.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startmodel</code></td>
<td>
<p>character, defines the start model for variable selection. 
Options are <code>"linear"</code>, <code>"empty"</code>, <code>"full"</code> and <code>"userdefined"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>character, specifies how detailed the output in the output window 
will be. Options are <code>"trace_on"</code>, <code>"trace_half"</code> and <code>"trace_off"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>integer, defines the maximum number of iterations. If the 
selection process has not converged after <code>steps</code> iterations the algorithm terminates and a 
warning is raised. Setting <code>steps = 0</code> allows the user to estimate a certain model without 
any model choice. This option will rarely be specified by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI</code></td>
<td>
<p>character, compute confidence intervals for linear and nonlinear 
terms. Option <code>CI</code> allows to compute confidence intervals. Options are <code>CI = "none"</code>, 
confidence intervals conditional on the selected model <code>CI = "MCMCselect"</code> and 
unconditional confidence intervals where model uncertainty is taken into account 
<code>CI = "MCMCbootstrap"</code>. Both alternatives are computer intensive. Conditional confidence 
intervals take much less computing time than unconditional intervals. The advantage of 
unconditional confidence intervals is that sampling distributions for the degrees of freedom or 
smoothing parameters are obtained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrapsamples</code></td>
<td>
<p>integer, defines the number of bootstrap samples used 
for <code>"CI = MCMCbootstrap"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the arguments specified is returned.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>References</h3>

<p>For methodological and reference details see the <span class="pkg">BayesX</span> manuals available at:  
<a href="https://www.uni-goettingen.de/de/bayesx/550513.html">https://www.uni-goettingen.de/de/bayesx/550513.html</a>.
</p>
<p>Belitz C, Lang S (2008). Simultaneous selection of variables and smoothing parameters in 
structured additive regression models. <em>Computational Statistics &amp; Data Analysis</em>, 
<b>53</b>, 61–81.
</p>
<p>Chambers JM, Hastie TJ (eds.) (1992). <em>Statistical Models in S</em>. Chapman &amp; Hall, 
London.
</p>
<p>Umlauf N, Adler D, Kneib T, Lang S, Zeileis A (2015).
Structured Additive Regression Models: An R Interface to BayesX.
<em>Journal of Statistical Software</em>, <b>63</b>(21), 1–46.
<a href="https://www.jstatsoft.org/v63/i21/">https://www.jstatsoft.org/v63/i21/</a>
</p>


<h3>See Also</h3>

<p><code>bayesx</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">bayesx.control()

## Not run: 
set.seed(111)
n &lt;- 500
## regressors
dat &lt;- data.frame(x = runif(n, -3, 3))
## response
dat$y &lt;- with(dat, 10 + sin(x) + rnorm(n, sd = 0.6))

## estimate models with
## bayesx MCMC and REML
b1 &lt;- bayesx(y ~ sx(x), method = "MCMC", data = dat)
b2 &lt;- bayesx(y ~ sx(x), method = "REML", data = dat)

## compare reported output
summary(b1)
summary(b2)

## End(Not run)
</code></pre>


</div>