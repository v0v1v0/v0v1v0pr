<div class="container">

<table style="width: 100%;"><tr>
<td>trainr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Recurrent Neural Network</h2>

<h3>Description</h3>

<p>Trains a Recurrent Neural Network.
</p>


<h3>Usage</h3>

<pre><code class="language-R">trainr(
  Y,
  X,
  model = NULL,
  learningrate,
  learningrate_decay = 1,
  momentum = 0,
  hidden_dim = c(10),
  network_type = "rnn",
  numepochs = 1,
  sigmoid = c("logistic", "Gompertz", "tanh"),
  use_bias = F,
  batch_size = 1,
  seq_to_seq_unsync = F,
  update_rule = "sgd",
  epoch_function = c(epoch_print, epoch_annealing),
  loss_function = loss_L1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>array of output values, dim 1: samples (must be equal to dim 1 of X), dim 2: time (must be equal to dim 2 of X), dim 3: variables (could be 1 or more, if a matrix, will be coerce to array)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>array of input values, dim 1: samples, dim 2: time, dim 3: variables (could be 1 or more, if a matrix, will be coerce to array)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a model trained before, used for retraining purpose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learningrate</code></td>
<td>
<p>learning rate to be applied for weight iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learningrate_decay</code></td>
<td>
<p>coefficient to apply to the learning rate at each epoch, via the epoch_annealing function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momentum</code></td>
<td>
<p>coefficient of the last weight iteration to keep for faster learning</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hidden_dim</code></td>
<td>
<p>dimension(s) of hidden layer(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>network_type</code></td>
<td>
<p>type of network, could be rnn, gru or lstm. gru and lstm are experimentale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numepochs</code></td>
<td>
<p>number of iteration, i.e. number of time the whole dataset is presented to the network</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmoid</code></td>
<td>
<p>method to be passed to the sigmoid function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_bias</code></td>
<td>
<p>should the network use bias</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_size</code></td>
<td>
<p>batch size: number of samples used at each weight iteration, only 1 supported for the moment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seq_to_seq_unsync</code></td>
<td>
<p>if TRUE, the network will be trained to backpropagate only the second half of the output error. If many to one is the target, just make Y have a time dim of 1. The X and Y data are modify at first to fit a classic learning, error are set to 0 during back propagation, input for the second part is also set to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>update_rule</code></td>
<td>
<p>rule to update the weight, "sgd", the default, is stochastic gradient descent, other available options are "adagrad" (experimentale, do not learn yet)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epoch_function</code></td>
<td>
<p>vector of functions to applied at each epoch loop. Use it to intereact with the objects inside the list model or to print and plot at each epoch. Should return the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss_function</code></td>
<td>
<p>loss function, applied in each sample loop, vocabulary to verify.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed to methods, to be used in user defined functions</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a model to be used by the predictr function
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# create training numbers
X1 = sample(0:127, 10000, replace=TRUE)
X2 = sample(0:127, 10000, replace=TRUE)

# create training response numbers
Y &lt;- X1 + X2

# convert to binary
X1 &lt;- int2bin(X1, length=8)
X2 &lt;- int2bin(X2, length=8)
Y  &lt;- int2bin(Y,  length=8)

# create 3d array: dim 1: samples; dim 2: time; dim 3: variables
X &lt;- array( c(X1,X2), dim=c(dim(X1),2) )

# train the model
model &lt;- trainr(Y=Y,
                X=X,
                learningrate   =  1,
                hidden_dim     = 16  )

## End(Not run)
    
</code></pre>


</div>