<div class="container">

<table style="width: 100%;"><tr>
<td>generate.ff.data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate functional data for the function-on-function regression model</h2>

<h3>Description</h3>

<p>This function provides a unified simulation structure for the function-on-function regression model </p>
<p style="text-align: center;"><code class="reqn">
Y(t) = \sum_{m=1}^M \int X_m(s) \beta_m(s,t) ds + \epsilon(t),</code>
</p>
<p> where <code class="reqn">Y(t)</code> denotes the functional response, <code class="reqn">X_m(s)</code> denotes the <code class="reqn">m</code>-th functional predictor, <code class="reqn">\beta_m(s,t)</code> denotes the <code class="reqn">m</code>-th bivariate regression coefficient function, and <code class="reqn">\epsilon(t)</code> is the error function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">generate.ff.data(n.pred, n.curve, n.gp, out.p = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n.pred</code></td>
<td>
<p>An integer, denoting the number of functional predictors to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.curve</code></td>
<td>
<p>An integer, specifying the number of observations for each functional variable to be generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.gp</code></td>
<td>
<p>An integer, denoting the number of grid points, i.e., a fine grid on the interval [0, 1].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.p</code></td>
<td>
<p>An integer between 0 and 1, denoting the outlier percentage in the generated data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the data generation process, first, the functional predictors are simulated based on the following process: </p>
<p style="text-align: center;"><code class="reqn">
X_m(s) = \sum_{j=1}^5 \kappa_j v_j(s),</code>
</p>
<p> where <code class="reqn"> \kappa_j </code> is a vector generated from a Normal distribution with mean one and variance <code class="reqn">\sqrt{a} j^{-1/2}</code>, <code class="reqn">a</code> is a uniformly generated random number between 1 and 4, and </p>
<p style="text-align: center;"><code class="reqn">v_j(s) = \sin(j \pi s) - \cos(j \pi s).</code>
</p>
<p> The bivariate regression coefficient functions are generated from a coefficient space that includes ten different functions such as: </p>
<p style="text-align: center;"><code class="reqn">b \sin(2 \pi s) \sin(\pi t)</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">b e^{-3 (s - 0.5)^2} e^{-4 (t - 1)^2},</code>
</p>
<p> where <code class="reqn">b</code> is generated from a uniform distribution between 1 and 3. The error function <code class="reqn">\epsilon(t)</code>, on the other hand, is generated from the Ornstein-Uhlenbeck process: </p>
<p style="text-align: center;"><code class="reqn">\epsilon(t) = l + [\epsilon_0(t) - l] e^{-\theta t} + \sigma \int_0^t e^{-\theta (t-u)} d W_u,</code>
</p>
<p> where <code class="reqn">l, \theta &gt; 0, \sigma &gt; 0</code> are constants, <code class="reqn">\epsilon_0(t)</code> is the initial value of <code class="reqn">\epsilon(t)</code> taken from <code class="reqn">W_u</code>, and
<code class="reqn">W_u</code> is the Wiener process. If outliers are allowed in the generated data, i.e., <code class="reqn">out.p &gt; 0</code>, then, the randomly selected <code class="reqn">n.curve \times out.p</code> of the data are generated in a different way from the aforementioned process. In more detail, if <code class="reqn">out.p &gt; 0</code>, the bivariate regression coefficient functions (possibly different from the previously generated coefficient functions) generated from the coefficient space with <code class="reqn">b^*</code> (instead of <code class="reqn">b</code>), where <code class="reqn">b^*</code> is generated from a uniform distribution between 1 and 2, are used to generate the outlying observations. In addition, in this case, the following process is used to generate functional predictors: </p>
<p style="text-align: center;"><code class="reqn">
X_m^*(s) = \sum_{j=1}^5 \kappa_j^* v_j^*(s),</code>
</p>
<p> where <code class="reqn"> \kappa_j^* </code> is a vector generated from a Normal distribution with mean one and variance <code class="reqn">\sqrt{a} j^{-3/2}</code> and </p>
<p style="text-align: center;"><code class="reqn">v_j^*(s) = 2 \sin(j \pi s) - \cos(j \pi s).</code>
</p>
<p> All the functions are generated equally spaced point in the interval <code class="reqn">[0, 1]</code>.
</p>


<h3>Value</h3>

<p>A list object with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>An <code class="reqn">n.curve \times n.gp</code>-dimensional matrix containing the observations of simulated functional response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A list with length n.pred. The elements are the <code class="reqn">n.curve \times n.gp</code>-dimensional matrices containing the observations of simulated functional predictor variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.coef</code></td>
<td>
<p>A list with length n.pred. Each element is a matrix and contains the generated bivariate regression coefficient function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.indx</code></td>
<td>
<p>A vector with length <code class="reqn">n.curve \times out.p</code> denoting the indices of outlying observations.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ufuk Beyaztas and Han Lin Shang</p>


<h3>References</h3>

<p>E. Garcia-Portugues and J. Alvarez-Liebana J and G. Alvarez-Perez G and W. Gonzalez-Manteiga W (2021)  "A goodness-of-fit test for the functional linear model with functional response",  <em>Scandinavian Journal of Statistics</em>, <b>48</b>(2), 502-528.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(fda)
library(fda.usc)
set.seed(2022)
sim.data &lt;- generate.ff.data(n.pred = 5, n.curve = 200, n.gp = 101, out.p = 0.1)
Y &lt;- sim.data$Y
X &lt;- sim.data$X
coeffs &lt;- sim.data$f.coef
out.indx &lt;- sim.data$out.indx
fY &lt;- fdata(Y, argvals = seq(0, 1, length.out = 101))
plot(fY[-out.indx,], lty = 1, ylab = "", xlab = "Grid point", 
     main = "Response", mgp = c(2, 0.5, 0), ylim = range(fY))
lines(fY[out.indx,], lty = 1, col = "black") # Outlying functions
</code></pre>


</div>