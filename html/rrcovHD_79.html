<div class="container">

<table style="width: 100%;"><tr>
<td>SPcaGrid</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse Robust Principal Components based on Projection Pursuit (PP): GRID search Algorithm </h2>

<h3>Description</h3>

<p>Computes an approximation of the PP-estimators for sparse and robust PCA using the grid search algorithm in the plane.
</p>


<h3>Usage</h3>

<pre><code class="language-R">    SPcaGrid(x, ...)
    ## Default S3 method:
SPcaGrid(x, k = 0, kmax = ncol(x), method = c ("mad", "sd", "qn", "Qn"), 
    lambda = 1, scale=FALSE, na.action = na.fail, trace=FALSE, ...)
    ## S3 method for class 'formula'
SPcaGrid(formula, data = NULL, subset, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula with no response variable, referring only to
numeric variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame (or similar: see
<code>model.frame</code>) containing the variables in the
formula <code>formula</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector used to select rows (observations) of the
data matrix <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code>options</code>, and is
<code>na.fail</code> if that is unset. The default is <code>na.omit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of principal components to compute. If <code>k</code> is missing, 
or <code>k = 0</code>, the algorithm itself will determine the number of 
components by finding such <code>k</code> that <code class="reqn">l_k/l_1 &gt;= 10.E-3</code> and 
<code class="reqn">\Sigma_{j=1}^k l_j/\Sigma_{j=1}^r l_j &gt;= 0.8</code>. 
It is preferable to investigate the scree plot in order to choose the number 
of components and then run again. Default is <code>k=0</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmax</code></td>
<td>
<p>maximal number of principal components to compute.
Default is <code>kmax=10</code>. If <code>k</code> is provided, <code>kmax</code> 
does not need to be specified, unless <code>k</code> is larger than 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> the scale estimator used to detect the direction with the 
largest variance. Possible values are <code>"sd"</code>, <code>"mad"</code> and 
<code>"Qn"</code>. <code>"mad"</code> is the 
default value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p> the sparseness constraint's strength(<code>sPCAgrid</code> only).
A single value for all components, or a vector of length <code>k</code> with 
different values for each component can be specified.
See <code>opt.TPO</code> for the choice of this argument. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a value indicating whether and how the variables should be 
scaled. If <code>scale = FALSE</code> (default) or <code>scale = NULL</code> no scaling is 
performed (a vector of 1s is returned in the <code>scale</code> slot). 
If <code>scale = TRUE</code> the data are scaled to have unit variance. Alternatively it can 
be a function like <code>sd</code> or <code>mad</code> or a vector of length equal 
the number of columns of <code>x</code>. The value is passed to the underlying function
and the result returned is stored in the <code>scale</code> slot. 
Default is <code>scale = FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>whether to print intermediate results. Default is <code>trace = FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>SPcaGrid</code>, serving as a constructor for objects of class <code>SPcaGrid-class</code> 
is a generic function with "formula" and "default" methods. For details see 
<code>sPCAgrid</code> and the relevant references.
</p>


<h3>Value</h3>

<p>An S4 object of class <code>SPcaGrid-class</code> which is a subclass of <code>PcaGrid-class</code> which in turn is a subclass of the 
virtual class <code>PcaRobust-class</code>. 
</p>


<h3>Author(s)</h3>

<p> Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> 
</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>
<p>C. Croux, P. Filzmoser, H. Fritz (2013).
Robust Sparse Principal Component Analysis,
<em>Technometrics</em> <b>55</b>(2), pp. 202–2014,
<a href="https://doi.org/10.1080/00401706.2012.727746">doi:10.1080/00401706.2012.727746</a>.   
</p>
<p>V. Todorov, P. Filzmoser (2013). Comparing classical and robust sparse PCA.
In R Kruse, M Berthold, C Moewes, M Gil, P Grzegorzewski, O Hryniewicz (eds.), 
<em>Synergies of Soft Computing and Statistics for Intelligent Data Analysis</em>, 
volume 190 of <em>Advances in Intelligent Systems and Computing</em>, pp. 283–291. 
Springer, Berlin; New York. ISBN 978-3-642-33041-4,
<a href="https://doi.org/10.1007/978-3-642-33042-1_31">doi:10.1007/978-3-642-33042-1_31</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(bus)
bus &lt;- as.matrix(bus)

## calculate MADN for each variable
xmad &lt;- apply(bus, 2, mad)
cat("\nMin, Max of MADN: ", min(xmad), max(xmad), "\n")

## calculate MADN for each variable
xqn &lt;- apply(bus, 2, Qn)
cat("\nMin, Max of Qn: ", min(xqn), max(xqn), "\n")


## MADN vary between 0 (for variable 9) and 34. Therefore exclude
##  variable 9 and divide the remaining variables by their MADNs.
bus1 &lt;- bus[, -c(9)]
p &lt;- ncol(bus1)

madbus &lt;- apply(bus1, 2, mad)
bus2 &lt;- sweep(bus1, 2, madbus, "/", check.margin = FALSE)

xsd &lt;- apply(bus1, 2, sd)
bus.sd &lt;- sweep(bus1, 2, xsd, "/", check.margin = FALSE)

xqn &lt;- apply(bus1, 2, Qn)
bus.qn &lt;- sweep(bus1, 2, xqn, "/", check.margin = FALSE)

## Not run: 
spc &lt;- SPcaGrid(bus2, lambda=0, method="sd", k=p, kmax=p)
rspc &lt;- SPcaGrid(bus2, lambda=0, method="Qn", k=p, kmax=p)
summary(spc)
summary(rspc)
screeplot(spc, type="line", main="Classical PCA", sub="PC", cex.main=2)
screeplot(rspc, type="line", main="Robust PCA", sub="PC", cex.main=2)

##  find lambda

K &lt;- 4
lambda.sd &lt;- 1.64
    to.sd &lt;- .tradeoff(bus2, k=K, lambda.max=2.5, lambda.n=100, method="sd")
    plot(to.sd, type="b", xlab="lambda", ylab="Explained Variance (percent)")
    abline(v=lambda.sd, lty="dotted")
 
spc.sd.p &lt;- SPcaGrid(bus2, lambda=lambda.sd, method="sd", k=p)
.CPEV(spc.sd.p, k=K)
spc.sd &lt;- SPcaGrid(bus2, lambda=lambda.sd, method="sd", k=K)
getLoadings(spc.sd)[,1:K]
plot(spc.sd)

lambda.qn &lt;- 2.06
    to.qn &lt;- .tradeoff(bus2, k=K, lambda.max=2.5, lambda.n=100, method="Qn")
    plot(to.qn, type="b", xlab="lambda", ylab="Explained Variance (percent)")
    abline(v=lambda.qn, lty="dotted")

spc.qn.p &lt;- SPcaGrid(bus2, lambda=lambda.qn, method="Qn", k=p)
.CPEV(spc.qn.p, k=K)
spc.qn &lt;- SPcaGrid(bus2, lambda=lambda.qn, method="Qn", k=K)
getLoadings(spc.qn)[,1:K]
plot(spc.qn)

## End(Not run)

## DD-plots
##
## Not run:
## Not run: 
usr &lt;- par(mfrow=c(2,2))
plot(SPcaGrid(bus2, lambda=0, method="sd", k=4), id.n.sd=0, main="Standard PCA")
plot(SPcaGrid(bus2, lambda=0, method="Qn", k=4), id.n.sd=0, ylim=c(0,20))

plot(SPcaGrid(bus2, lambda=1.64, method="sd", k=4), id.n.sd=0, main="Stdandard sparse PCA")
plot(SPcaGrid(bus2, lambda=3.07, method="Qn", k=4), id.n.sd=0, main="Robust sparse PCA")

par(usr)
## End (Not run)

## End(Not run)
</code></pre>


</div>