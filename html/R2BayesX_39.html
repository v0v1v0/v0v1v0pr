<div class="container">

<table style="width: 100%;"><tr>
<td>plotmap</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot Maps
</h2>

<h3>Description</h3>

<p>The function takes a <code>list</code> polygons and draws the corresponding map. Different 
colors for each polygon can be used. Typically used for objects of class <code>"mrf.bayesx"</code> and
<code>"random.bayesx"</code> returned from function <code>bayesx</code> and 
<code>read.bayesx.output</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">plotmap(map, x = NULL, id = NULL, c.select = NULL, legend = TRUE,
  missing = TRUE, swap = FALSE, range = NULL, names = FALSE,
  values = FALSE, col = NULL, ncol = 100, breaks = NULL,
  cex.legend = 1, cex.names = 1, cex.values = cex.names, digits = 2L,
  mar.min = 2, add = FALSE, interp = FALSE, grid = 200,
  land.only = FALSE, extrap = FALSE, outside = FALSE, type = "interp",
  linear = FALSE, k = 40, p.pch = 15, p.cex = 1, shift = NULL,
  trans = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>the map to be plotted, the map object must be a <code>list</code> of matrices 
with first column indicating the <code>x</code> coordinate and second column the <code>y</code> coordinate
each, also see <code>polygon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix or data frame with two columns, first column indicates the region and 
second column the the values which will define the background colors of the polygons, e.g. 
fitted values from <code>bayesx</code>. More columns are possible, e.g. quantiles, which can 
accessed with argument <code>se</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>if argument <code>x</code> is a vector, argument <code>id</code> should contain a character vector 
of the same length of <code>x</code> with entries indicating the polygon the <code class="reqn">i</code>-th value of 
<code>x</code> belongs to, i.e. <code>id</code> must contain the same names as polygon names in <code>map</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p>select the column of the data in <code>x</code> which should be used for plotting, may
be an integer or character with the corresponding column name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>if set to <code>TRUE</code>, a legend will be shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>should polygons be plotted for which no data is available in <code>x</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swap</code></td>
<td>
<p>if set to <code>TRUE</code>, colors will be represented in reverse order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>specify the range of values in <code>x</code> which should enter the plot, e.g. only 
values between -2 and 2 are of interest then <code>range = c(-2, 2)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>if set to <code>TRUE</code> the name for each polygon will also be plotted at the centroids
of the corresponding polygons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>if set to <code>TRUE</code> the corresponding values for each polygon will also be plotted 
at the centroids of the polygons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>the color of the surface, may also be a function, e.g. 
<code>col.surface = heat.colors</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncol</code></td>
<td>
<p>the number of different colors that should be generated if <code>col</code> is a function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>a set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.legend</code></td>
<td>
<p>text size of the numbers in the legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.names</code></td>
<td>
<p>text size of the names if <code>names = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.values</code></td>
<td>
<p>text size of the names if <code>values = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>specifies the legend decimal places.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mar.min</code></td>
<td>
<p>Controls the definition of boundaries. Could be either <code>NULL</code> for individual 
settings of <code>mar</code> or a value which defines <code>mar</code> as follows: The boundaries will be 
calculated according to the height to width ratio of the map with minimal boundary 
<code>mar.min</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>if set to <code>TRUE</code>, the map will be added to an existing plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interp</code></td>
<td>
<p>logical. Should the values provided in argument <code>x</code> be interpolated to obtain
a smooth colored map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>integer. Defines the number of grid cells to be used for interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>land.only</code></td>
<td>
<p>if set to <code>TRUE</code>, only interpoltated pixels that cover land are drawn,
see also function <code>map.where</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrap</code></td>
<td>
<p>logical. Should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outside</code></td>
<td>
<p>logical. Should interpolated values outside the boundaries of the map be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character. Which type of interpolation metjod should be used. The default is
<code>type = "interp"</code>, see function <code>interp</code>. The two other options are
<code>type = "mba"</code>, which calls function <code>mba.surf</code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear</code></td>
<td>
<p>logical. Should linear interpolation be used withing function
<code>interp</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer. The number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.pch</code></td>
<td>
<p>numeric. The point size of the grid cells when using interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.cex</code></td>
<td>
<p>numeric. The size of the grid cell points whein using interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>numeric. Constant to be added to the smooth before plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters to be passed to <code>colorlegend</code> and others, e.g. change the 
<code>border</code> of the polygons and <code>density</code>, see <code>polygon</code>. Please 
see the exmaples.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code>plot.bayesx</code>, <code>read.bnd</code>, <code>colorlegend</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## load a sample map
data("FantasyBnd")

## plot the map 
op &lt;- par(no.readonly = TRUE)
plotmap(FantasyBnd, main = "Example of a plain map")
plotmap(FantasyBnd, lwd = 1, main = "Example of a plain map")
plotmap(FantasyBnd, lwd = 1, lty = 2)
plotmap(FantasyBnd, lwd = 1, lty = 2, border = "green3")
plotmap(FantasyBnd, lwd = 1, lty = 2, border = "green3",
  density = 50)
plotmap(FantasyBnd, lwd = 1, lty = 2, 
  border = c("red", "green3"),
  density = c(10, 20), angle = c(5, 45))
plotmap(FantasyBnd, lwd = 1, lty = 2, 
  border = c("red", "green3"),
  density = c(10, 20), angle = c(5, 45),
  col = c("blue", "yellow"))
plotmap(FantasyBnd, col = gray.colors(length(FantasyBnd)))

## add some values to the corresponding polygon areas
## note that the first column in matrix val contains
## the region identification index
x &lt;- cbind(as.integer(names(FantasyBnd)), runif(length(FantasyBnd), -2, 2))
plotmap(FantasyBnd, x = x)
        
## now only plot values for some certain regions
set.seed(432)
samps &lt;- sample(x[,1], 4)
nx &lt;- x[samps,]
plotmap(FantasyBnd, x = nx, density = 20)

## play with legend
plotmap(FantasyBnd, x = x, names = TRUE, legend = FALSE)
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 1))
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 0.8),
  side.legend = 2)
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 0.8),
  side.legend = 2, side.tick = 2)
plotmap(FantasyBnd, x = nx, density = 20, pos = c(0, 0.8),
  side.legend = 2, side.tick = 2, cex.legend = 0.5)
plotmap(FantasyBnd, x = x, values = TRUE, 
  pos = c(-0.15, -0.12))
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20)
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE)
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE, range = c(-5, 5))
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE, lrange = c(-5, 5))
plotmap(FantasyBnd, x = nx, values = TRUE, 
  pos = c(-0.07, -0.22), width = 2, 
  at = nx[,2], side.legend = 2, distance.labels = 3,
  density = 20, symmetric = FALSE, 
  col = heat_hcl, swap = TRUE, 
  ncol = 4, breaks = seq(-2, 2, length = 5))

## more position options
plotmap(FantasyBnd, x = nx, density = 20, pos = "bottomleft")
plotmap(FantasyBnd, x = nx, density = 20, pos = "topleft")
plotmap(FantasyBnd, x = nx, density = 20, pos = "topright")
plotmap(FantasyBnd, x = nx, density = 20, pos = "bottomright")
plotmap(FantasyBnd, x = nx, density = 20, pos = "right")
par(op)

# load and plot a map from GermanyBnd
op &lt;- par(no.readonly = TRUE)
data("GermanyBnd")
plotmap(GermanyBnd, main = "Map of GermanyBnd")
n &lt;- length(GermanyBnd)

# add some colors
plotmap(GermanyBnd, col = rainbow(n))
plotmap(GermanyBnd, col = heat.colors(n))
plotmap(GermanyBnd, col = topo.colors(n))
plotmap(GermanyBnd, col = cm.colors(n))
plotmap(GermanyBnd, col = gray.colors(n))
plotmap(GermanyBnd, col = c("green", "green3"))
par(op)


## now with bayesx
set.seed(333)

## simulate some geographical data
data("MunichBnd")
N &lt;- length(MunichBnd); names(MunichBnd) &lt;- 1:N
n &lt;- N*5

## regressors
dat &lt;- data.frame(id = rep(1:N, n/N))
dat$sp &lt;- with(dat, sort(runif(N, -2, 2), decreasing = TRUE)[id])

## response
dat$y &lt;- with(dat, 1.5 + sp + rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(id, bs = "mrf", map = MunichBnd),
  method = "MCMC", data = dat)

## summary statistics
summary(b)

## plot spatial effect
op &lt;- par(no.readonly = TRUE)
plot(b, map = MunichBnd)
plot(b, map = MunichBnd, c.select = "97.5
plot(b, map = MunichBnd, c.select = "2.5
plot(b, map = MunichBnd, c.select = "50
plot(b, map = MunichBnd, names = TRUE, 
  cex.names = 0.5, cex.legend = 0.8)
plot(b, map = MunichBnd, range = c(-0.5, 0.5))
plot(b, map = MunichBnd, range = c(-5, 5))
plot(b, map = MunichBnd, col = heat_hcl, 
  swap = TRUE, symmetric = FALSE)
par(op)

## End(Not run)
</code></pre>


</div>