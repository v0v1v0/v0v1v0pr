<div class="container">

<table style="width: 100%;"><tr>
<td>robservableProxy</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Send commands to a Proxy instance in a Shiny app</h2>

<h3>Description</h3>

<p>Creates a robservable-like object that can be used to customize and control a robservable
that has already been rendered. For use in Shiny apps and Shiny docs only.
</p>


<h3>Usage</h3>

<pre><code class="language-R">robservableProxy(
  id,
  session = shiny::getDefaultReactiveDomain(),
  deferUntilFlush = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>single-element character vector indicating the output ID of the
robservable to modify (if invoked from a Shiny module, the namespace will be added
automatically)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session</code></td>
<td>
<p>the Shiny session object to which the robservable belongs; usually the
default value will suffice</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deferUntilFlush</code></td>
<td>
<p>indicates whether actions performed against this
instance should be carried out right away, or whether they should be held
until after the next time all of the outputs are updated; defaults to
<code>TRUE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Normally, you create a robservable instance using the <code>robservable</code> function.
This creates an in-memory representation of a robservable that you can customize,
print at the R console, include in an R Markdown document, or render as a Shiny output.
</p>
<p>In the case of Shiny, you may want to further customize a robservable, even after it
is rendered to an output. At this point, the in-memory representation of the
robservable is long gone, and the user's web browser has already realized the
robservable instance.
</p>
<p>This is where <code>robservableProxy</code> comes in. It returns an object that can
stand in for the usual robservable object. The usual robservable functions
can be called, and instead of customizing an in-memory representation,
these commands will execute on the already created robservable instance in
the browser.
</p>


<h3>Value</h3>

<p>A proxy object which allows to update an already created robservable instance.
</p>


</div>