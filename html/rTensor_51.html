<div class="container">

<table style="width: 100%;"><tr>
<td>pvd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Population Value Decomposition</h2>

<h3>Description</h3>

<p>The default Population Value Decomposition (PVD) of a series of 2D images. Constructs population-level matrices P, V, and D to account for variances within as well as across the images. Structurally similar to Tucker (<code>tucker</code>) and GLRAM (<code>mpca</code>), but retains crucial differences. Requires <code>2*n3 + 2</code> parameters to specified the final ranks of P, V, and D, where n3 is the third mode (how many images are in the set). Consult Crainiceanu et al. (2013) for the construction and rationale behind the PVD model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pvd(tnsr, uranks = NULL, wranks = NULL, a = NULL, b = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tnsr</code></td>
<td>
<p>3-Tensor with the third mode being the measurement mode</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uranks</code></td>
<td>
<p>ranks of the U matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wranks</code></td>
<td>
<p>ranks of the W matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>rank of <code>P = U%*%t(U)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>rank of <code>D = W%*%t(W)</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The PVD is not an iterative method, but instead relies on <code>n3 + 2</code>separate PCA decompositions. The third mode is for how many images are in the set.
</p>


<h3>Value</h3>

<p>a list containing the following:</p>

<dl>
<dt><code>P</code></dt>
<dd>
<p>population-level matrix <code>P = U%*%t(U)</code>, where U is constructed by stacking the truncated left eigenvectors of slicewise PCA along the third mode</p>
</dd>
<dt><code>V</code></dt>
<dd>
<p>a list of image-level core matrices</p>
</dd>
<dt><code>D</code></dt>
<dd>
<p>population-leve matrix <code>D = W%*%t(W)</code>, where W is constructed by stacking the truncated right eigenvectors of slicewise PCA along the third mode</p>
</dd>
<dt><code>est</code></dt>
<dd>
<p>estimate of <code>tnsr</code> after compression</p>
</dd>
<dt><code>norm_percent</code></dt>
<dd>
<p>the percent of Frobenius norm explained by the approximation</p>
</dd>
<dt><code>fnorm_resid</code></dt>
<dd>
<p>the Frobenius norm of the error <code>fnorm(est-tnsr)</code></p>
</dd>
</dl>
<h3>References</h3>

<p>C. Crainiceanu, B. Caffo, S. Luo, V. Zipunnikov, N. Punjabi, "Population value decomposition: a framework for the analysis of image populations". Journal of the American Statistical Association, 2013.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### How to retrieve faces_tnsr from figshare
# faces_tnsr &lt;- load_orl()
# subject &lt;- faces_tnsr[,,8,]
dummy_faces_tnsr &lt;- rand_tensor(c(92,112,40,10))
subject &lt;- dummy_faces_tnsr[,,8,]
pvdD &lt;- pvd(subject, uranks=rep(46,10), wranks=rep(56,10), a=46, b=56)
plot(pvdD$fnorm_resid)
</code></pre>


</div>