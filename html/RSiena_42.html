<div class="container">

<table style="width: 100%;"><tr>
<td>iwlsm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to fit an iterated weighted least squares model.
</h2>

<h3>Description</h3>

<p>Fits an iterated weighted least squares model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">iwlsm(x, ...)

## S3 method for class 'formula'
iwlsm(formula, data, weights, ses, ..., subset, na.action,
    method = c("M", "MM", "model.frame"),
    wt.method = c("inv.var", "case"),
    model = TRUE, x.ret = TRUE, y.ret = FALSE, contrasts = NULL)

## Default S3 method:
iwlsm(x, y, weights, ses, ..., w = rep(1/nrow(x), nrow(x)),
    init = "ls", psi = psi.iwlsm,
    scale.est = c("MAD", "Huber", "proposal 2"), k2 = 1.345,
    method = c("M", "MM"), wt.method = c("inv.var", "case"),
    maxit = 20, acc = 1e-4, test.vec = "resid", lqs.control = NULL)

psi.iwlsm(u, k, deriv = 0, w, sj2, hh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p>a formula of the form <code>y ~ x1 + x2 + ...</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>data frame from which variables specified in <code>formula</code> are
preferentially to be taken.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>

<p>a vector of prior weights for each case.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>

<p>An index vector specifying the cases to be used in fitting.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ses</code></td>
<td>
<p>Estimated variance of the responses. Will be paseed to
<code>psi</code> as sj2
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>

<p>A function to specify the action to be taken if <code>NA</code>s are found.
The ‘factory-fresh’ default action in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is
<code>na.omit</code>, and can be changed by
<code>options(na.action=)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a matrix or data frame containing the explanatory variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>the response: a vector of length the number of rows of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Must be "M". (argument not used here).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt.method</code></td>
<td>

<p>are the weights case weights (giving the relative importance of case,
so a weight of 2 means there are two of these) or the inverse of the
variances, so a weight of two means this error is half as variable?
This will not work at present.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>should the model frame be returned in the object?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.ret</code></td>
<td>

<p>should the model matrix be returned in the object?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.ret</code></td>
<td>

<p>should the response be returned in the object?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>

<p>optional contrast specifications: se <code>lm</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>(optional) initial down-weighting for each case. Will not work at present.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>

<p>(optional) initial values for the coefficients OR a method to find
initial values OR the result of a fit with a <code>coef</code> component.  Known
methods are <code>"ls"</code> (the default) for an initial least-squares fit
using weights <code>w*weights</code>, and <code>"lts"</code> for an unweighted
least-trimmed squares fit with 200 samples. Probably not functioning.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>

<p>the psi function is specified by this argument.  It must give
(possibly by name) a function <code>g(x, ..., deriv, w)</code> that for
<code>deriv=0</code> returns psi(x)/x and for <code>deriv=1</code> returns
some value.  Extra arguments may be passed in via <code>...</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.est</code></td>
<td>

<p>method of scale estimation: re-scaled MAD of the residuals (default)
or Huber"s proposal 2 (which can be selected by either <code>"Huber"</code>
or <code>"proposal 2"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k2</code></td>
<td>

<p>tuning constant used for Huber proposal 2 scale estimation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>the limit on the number of IWLS iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acc</code></td>
<td>

<p>the accuracy for the stopping criterion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.vec</code></td>
<td>

<p>the stopping criterion is based on changes in this vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments to be passed to <code>iwlsm.default</code> or to the <code>psi</code>
function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lqs.control</code></td>
<td>

<p>An optional list of control values for <code>lqs</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>

<p>numeric vector of evaluation points.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>    tuning constant. Not used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv</code></td>
<td>

<p><code>0</code> or <code>1</code>: compute values of the psi function or of its
first derivative. (Latter not used).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sj2</code></td>
<td>
<p>Estimated variance of the responses</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hh</code></td>
<td>
<p>Diagonal values of the hat matrix</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is very slightly adapted from <code>rlm</code> in
packages <code>MASS</code>. It alternates between weighted
least squares and estimation of variance on the basis of a common
variance. The function <code>psi.iwlsm</code> calculates the weights
for the next iteration. Used by <code>siena08</code> to combine estimates
from different <code>sienaFits</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"iwlsm"</code> inheriting from <code>"lm"</code>.
Note that the <code>df.residual</code> component is deliberately set to
<code>NA</code> to avoid inappropriate estimation of the residual scale from
the residual mean square by <code>"lm"</code> methods.
</p>
<p>The additional components not in an <code>lm</code> object are
</p>
<table>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>the robust scale estimate used
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>

<p>the weights used in the IWLS process
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi</code></td>
<td>

<p>the psi function with parameters substituted
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>the convergence criteria at each iteration
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converged</code></td>
<td>

<p>did the IWLS converge?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wresid</code></td>
<td>

<p>a working residual, weighted for <code>"inv.var"</code> weights only.
</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The function has been changed as little as possible, but
has only been used with default arguments. The other options have
been retained just in
case they may prove useful.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S.</em>  Fourth edition.  Springer.
See also <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code>siena08</code>, <code>sienaMeta</code>, <code>sienaFit</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
##not enough data here for a sensible example, but shows the idea.
myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=100)
mynet1 &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mynet2 &lt;- sienaDependent(array(c(s502, s503), dim=c(50, 50, 2)))
mydata1 &lt;- sienaDataCreate(mynet1)
mydata2 &lt;- sienaDataCreate(mynet2)
myeff1 &lt;- getEffects(mydata1)
myeff2 &lt;- getEffects(mydata2)
myeff1 &lt;- setEffect(myeff1, transTrip, fix=TRUE, test=TRUE)
myeff2 &lt;- setEffect(myeff2, transTrip, fix=TRUE, test=TRUE)
myeff1 &lt;- setEffect(myeff1, cycle3, fix=TRUE, test=TRUE)
myeff2 &lt;- setEffect(myeff2, cycle3, fix=TRUE, test=TRUE)
ans1 &lt;- siena07(myalgorithm, data=mydata1, effects=myeff1, batch=TRUE)
ans2 &lt;- siena07(myalgorithm, data=mydata2, effects=myeff2, batch=TRUE)
meta &lt;- siena08(ans1, ans2)
metadf &lt;- split(meta$thetadf, meta$thetadf$effects)[[1]]
metalm &lt;- iwlsm(theta ~ tconv, metadf, ses=se^2)

## End(Not run)
</code></pre>


</div>