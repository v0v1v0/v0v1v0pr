<div class="container">

<table style="width: 100%;"><tr>
<td>robloxbioc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Function for Preprocessing Biological Data</h2>

<h3>Description</h3>

<p>Generic function for preprocessing biological data using optimally robust
(rmx) estimators; confer Rieder (1994), Kohl (2005), Rieder et al (2008).
</p>


<h3>Usage</h3>

<pre><code class="language-R">robloxbioc(x, ...)

## S4 method for signature 'matrix'
robloxbioc(x, eps = NULL, eps.lower = 0, eps.upper = 0.05, steps = 3L, 
           fsCor = TRUE, mad0 = 1e-4)

## S4 method for signature 'AffyBatch'
robloxbioc(x, bg.correct = TRUE, pmcorrect = TRUE, normalize = FALSE, 
           add.constant = 32, verbose = TRUE, eps = NULL, 
           eps.lower = 0, eps.upper = 0.05, steps = 3L, fsCor = TRUE, 
           mad0 = 1e-4, contrast.tau = 0.03, scale.tau = 10, 
           delta = 2^(-20), sc = 500)

## S4 method for signature 'beadLevelData'
robloxbioc(x, channelList = list(greenChannel), probeIDs = NULL, 
           useSampleFac = FALSE, sampleFac = NULL, weightNames = "wts", 
           removeUnMappedProbes = TRUE, eps = NULL, eps.lower = 0, 
           eps.upper = 0.05, steps = 3L, fsCor = TRUE, mad0 = 1e-4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> biological data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional parameters. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors. 
See details below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.lower</code></td>
<td>
<p> positive real (0 &lt;= <code>eps.lower</code> &lt;= <code>eps.upper</code>): 
lower bound for the amount of gross errors. See details below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps.upper</code></td>
<td>
<p> positive real (<code>eps.lower</code> &lt;= <code>eps.upper</code> &lt;= 0.5): 
upper bound for the amount of gross errors. See details below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p> positive integer. k-step is used to compute the optimally robust estimator. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsCor</code></td>
<td>
<p> logical: perform finite-sample correction. See function <code>finiteSampleCorrection</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mad0</code></td>
<td>
<p> scale estimate used if computed MAD is equal to zero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bg.correct</code></td>
<td>
<p> if <code>TRUE</code> MAS 5.0 background correction is performed;
confer <code>bg.correct.mas</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmcorrect</code></td>
<td>
<p> method used for PM correction; <code>TRUE</code> calls an algorithm which is 
comparable to the algorithm of MAS 5.0; confer <code>pmcorrect.mas</code>. 
If <code>FALSE</code> only the PM intensities are used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p> logical: if <code>TRUE</code>, Affymetrix scale normalization is performed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.constant</code></td>
<td>
<p> constant added to the MAS 5.0 expression values before the normalization
step. Improves the variance of the measure one no longer devides by numbers close to 0
when computing fold-changes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast.tau</code></td>
<td>
<p> a number denoting the contrast tau parameter; confer the MAS 5.0 
PM correction algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.tau</code></td>
<td>
<p> a number denoting the scale tau parameter; confer the MAS 5.0 
PM correction algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p> a number denoting the delta parameter; confer the MAS 5.0 
PM correction algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sc</code></td>
<td>
<p> value at which all arrays will be scaled to. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>channelList</code></td>
<td>
<p> List of objects of class illuminaChannel that defines the
summarisation to be performed where in our setup only the slots <code>transFun</code>
and <code>name</code> have an effect on the computations. Setting the slots 
<code>outlierFun</code>, <code>exprFun</code>, and <code>varFun</code> has no effect. In any 
case rmx estimators are applied. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probeIDs</code></td>
<td>
<p> Vector of ArrayAddressIDs to be included in the summarized object. 
The default is to summarize all probes. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useSampleFac</code></td>
<td>
<p>if <code>TRUE</code> sections belonging to the same biological sample
will be combined. The default is to summarize each section separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleFac</code></td>
<td>
<p> optional character vector giving which a sample identifer for each section</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weightNames</code></td>
<td>
<p> name of column in the <code>beadLevelData</code> to take extract weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeUnMappedProbes</code></td>
<td>
<p> if TRUE and annotation information is stored in the 
<code>beadLevelData</code> object, any ArrayAddressIDs that cannot be mapped to ILMN IDs 
will be removed. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The optimally-robust resp. the radius-minimax (rmx) estimator for normal location 
and scale is used to preprocess biological data. The computation uses a k-step 
construction with median and MAD as starting estimators; cf. Rieder (1994) and 
Kohl (2005).
</p>
<p>If the amount of gross errors (contamination) is known, it can be 
specified by <code>eps</code>. The radius of the corresponding infinitesimal 
contamination neighborhood (infinitesimal version of Tukey's gross error model) 
is obtained by multiplying <code>eps</code> by the square root of the sample size. 
</p>
<p>If the amount of gross errors (contamination) is unknown, which is typically
the case, try to find a rough estimate for the amount of gross errors, such that 
it lies between <code>eps.lower</code> and <code>eps.upper</code>.
</p>
<p>If <code>eps</code> is <code>NULL</code>, the radius-minimax (rmx) estimator in sense of 
Rieder et al. (2001, 2008), respectively Section 2.2 of Kohl (2005) is used.
</p>
<p>The algorithm used for Affymetrix data is similar to MAS 5.0 (cf. Affymetrix (2002)).
The main difference is the substitution of the Tukey one-step estimator by our rmx 
k-step (k &gt;= 1) estimator in the PM/MM correction step. The optional scale normalization 
is performed as given in Affymetrix (2002).
</p>
<p>In case of Illumina data, the rmx estimator is used to summarize the bead types. 
The implementation for the most part copies <code>summarize</code>
from <span class="pkg">beadarray</span>.
</p>
<p>For sample size &lt;= 2, median and MAD are used for estimation.
</p>
<p>If <code>eps = 0</code>, mean and sd are computed.
</p>


<h3>Value</h3>

<p> Return value depends on the class of <code>x</code>. 
In case of <code>"matrix"</code> a matrix with columns "mean" and "sd" is returned.
In case of <code>"AffyBatch"</code> an object of class <code>"ExpressionSet"</code> is returned. 
In case of <code>"BeadLevelData"</code> an object of class <code>"ExpressionSetIllumina"</code> is returned. 
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
</p>
<p>update for beadarray versions &gt;= 2.0.0 with support by Mark Dunnings and Andy Lynch</p>


<h3>References</h3>

<p>Affymetrix, Inc. (2002). <em>Statistical Algorithms Description Document</em>.
Affymetrix, Santa Clara.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>
<p>Kohl M. and Deigner H.P. (2010). Preprocessing of gene expression data by optimally 
robust estimators. <em>BMC Bioinformatics</em>, 11:583. 
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation 
in General Smoothly Parametrized Models. <em>Statistical Methods and Application</em>, 
<b>19</b>(3):333-354. 
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. <em>Statistical Methods and Applications</em> <b>17</b>(1) 13-40.
Extended version: <a href="http://r-kurs.de/RRlong.pdf">http://r-kurs.de/RRlong.pdf</a>
</p>


<h3>See Also</h3>

<p><code>roblox</code>, <code>rowRoblox</code>,
<code>AffyBatch-class</code>, 
<code>generateExprVal.method.mas</code>,
<code>ExpressionSet-class</code>,
<code>summarize</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(123) # to have reproducible results for package checking

## similar to rowRoblox of package RobLox
ind &lt;- rbinom(200, size=1, prob=0.05)
X &lt;- matrix(rnorm(200, mean=ind*3, sd=(1-ind) + ind*9), nrow = 2)
robloxbioc(X)
robloxbioc(X, steps = 5)
robloxbioc(X, eps = 0.05)
robloxbioc(X, eps = 0.05, steps = 5)


## \donttest to reduce check time
## the function is designed for large scale problems
X &lt;- matrix(rnorm(50000*20, mean = 1), nrow = 50000)
system.time(robloxbioc(X))

## using Affymetrix data
## confer example to generateExprVal.method.mas
## A more worked out example can be found in the scripts folder
## of the package.
data(SpikeIn)
probes &lt;- pm(SpikeIn) 
mas &lt;- generateExprVal.method.mas(probes)
rl &lt;- 2^robloxbioc(log2(t(probes)))
concentrations &lt;- as.numeric(colnames(SpikeIn))
plot(concentrations, mas$exprs, log="xy", ylim=c(50,10000), type="b",
     ylab = "expression measures")
points(concentrations, rl[,1], pch = 20, col="orange", type="b")
legend("topleft", c("MAS", "roblox"), pch = c(1, 20))

## Affymetrix dilution data
library(affydata)
data(Dilution)
eset &lt;- robloxbioc(Dilution)
## Affymetrix scale normalization
eset1 &lt;- robloxbioc(Dilution, normalize = TRUE)

## Illumina bead level data
library(beadarrayExampleData)
data(exampleBLData)
res &lt;- robloxbioc(exampleBLData, eps.upper = 0.5)
res

</code></pre>


</div>