<div class="container">

<table style="width: 100%;"><tr>
<td>BC.discernibility.mat.FRST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The decision-relative discernibility matrix based on fuzzy rough set theory</h2>

<h3>Description</h3>

<p>This is a function that is used to build the decision-relative discernibility matrix based on FRST.
It is a matrix whose elements contain discernible attributes among pairs of objects. 
By means of this matrix, we are able to produce all decision reducts of the given decision system.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BC.discernibility.mat.FRST(
  decision.table,
  type.discernibility = "standard.red",
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decision.table</code></td>
<td>
<p>a <code>"DecisionTable"</code> class representing the decision table. See <code>SF.asDecisionTable</code>. 
It should be noted that this case only supports the nominal/symbolic decision attribute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.discernibility</code></td>
<td>
<p>a string representing a type of discernibility. See in Section <code>Details</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of other parameters.
</p>

<ul>
<li> <p><code>type.relation</code>: a type of fuzzy indiscernibility relation. The default value is <code>type.relation = c("tolerance", "eq.1")</code>.
</p>
<p>See <code>BC.IND.relation.FRST</code>.
</p>
</li>
<li> <p><code>type.aggregation</code>: a type of aggregation operator. The default value is <code>type.aggregation = c("t.tnorm", "lukasiewicz")</code>.
</p>
<p>See <code>BC.IND.relation.FRST</code>.
</p>
</li>
<li> <p><code>t.implicator</code>: a type of implicator operator. The default value is <code>"lukasiewicz"</code>.
</p>
<p>See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>type.LU</code>: a type of method of lower and upper approximations. The default value is <code>"implicator.tnorm"</code>.
</p>
<p>See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>alpha.precision</code>: a numeric value representing a precision variable. It is used when using <code>"alpha.red"</code> as <code>type.discernibility</code>.
The default value is 0.05.
</p>
<p>See <code>BC.LU.approximation.FRST</code>.  
</p>
</li>
<li> <p><code>show.discernibilityMatrix</code>: a boolean value determining whether the discernibility matrix will be shown or not (NULL). The default value is <code>FALSE</code>.
</p>
</li>
<li> <p><code>epsilon</code>: a numeric between 0 and 1 representing the <code class="reqn">\epsilon</code> value on 
</p>
<p><code>type.discernibility = "gaussian.red"</code>. It should be noted that when having nominal values on all attributes then <code class="reqn">\epsilon</code> should be 0. 
The default value is 0.
</p>
</li>
<li> <p><code>delta</code>: a numeric representing the <code class="reqn">\delta</code> value on <code>"gaussian"</code> equations 
</p>
<p>(see <code>BC.IND.relation.FRST</code>). The default value is 2.
</p>
</li>
<li> <p><code>range.object</code>: a vector representing considered objects to construct the <code>k</code>-relative discernibility matrix. 
The default value is <code>NULL</code> which means that we are using all objects in the decision table.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In this function, we provide several approaches in order to generate the decision-relative discernibility matrix. 
Theoretically, all reducts are found by constructing 
the matrix that contains elements showing discernible attributes among objects. 
The discernible attributes are determined by a specific condition which depends on the selected algorithm. A particular approach can be executed by selecting
a value of the parameter <code>type.discernibility</code>. The following shows the different 
values of the parameter <code>type.discernibility</code> corresponding approaches considered in this function.
</p>

<ul>
<li> <p><code>"standard.red"</code>: It is adopted from (Tsang et al, 2008)'s approach. 
The concept has been explained briefly in <code>Introduction-FuzzyRoughSets</code>. 
In order to use this algorithm, we assign the <code>control</code> parameter
with the following components:
</p>
<p><code>control = list(type.aggregation, type.relation, type.LU, t.implicator)</code>
</p>
<p>The detailed description of the components can be seen in <code>BC.IND.relation.FRST</code> and 
</p>
<p><code>BC.LU.approximation.FRST</code>. Furthermore, in this case the authors suggest to use the "min" t-norm  
(i.e., <code>type.aggregation = c("t.tnorm", "min")</code>) and the implicator operator "kleene_dienes" (i.e., <code>t.implicator = "kleene_dienes"</code>).
</p>
</li>
<li> <p><code>"alpha.red"</code>: It is based on (Zhao et al, 2009)'s approach where all reductions will 
be found by building an <code class="reqn">\alpha</code>-discernibility matrix. This matrix contains elements which are defined by
</p>
<p>1) if <code class="reqn">x_i</code> and <code class="reqn">x_j</code> belong to different decision concept,
</p>
<p><code class="reqn">c_{ij} = \{R : \mathcal{T}(R(x_i, x_j), \lambda) \le \alpha \}</code>,
</p>
<p>where <code class="reqn">\lambda = (R_{\alpha} \downarrow A)(u)</code> which is lower approximation 
of FVPRS (See <code>BC.LU.approximation.FRST</code>). 
</p>
<p>2) <code class="reqn">c_{ij}={\oslash}</code>, otherwise.
</p>
<p>To generate the discernibility matrix based on this approach, we use the <code>control</code> parameter
with the following components:
</p>
<p><code>control = list(type.aggregation, type.relation, t.implicator, alpha.precision)</code> 
</p>
<p>where the lower approximation <code class="reqn">\lambda</code> is fixed to <code>type.LU = "fvprs"</code>. The detailed
description of the components can be seen in <code>BC.IND.relation.FRST</code> and <code>BC.LU.approximation.FRST</code>.
Furthermore, in this case the authors suggest to use <code class="reqn">\mathcal{T}</code>-similarity relation 
</p>
<p>e.g., <code>type.relation = c("transitive.closure", "eq.3")</code>,
</p>
<p>the "lukasiewicz" t-norm  (i.e., <code>type.aggregation = c("t.tnorm", "lukasiewicz")</code>), and <code>alpha.precision</code> from 0 to 0.5.
</p>
</li>
<li> <p><code>"gaussian.red"</code>: It is based on (Chen et al, 2011)'s approach. The discernibility matrix contains elements which are defined by: 
</p>
<p>1) if <code class="reqn">x_i</code> and <code class="reqn">x_j</code> belong to different decision concept, 
</p>
<p><code class="reqn">c_{ij}= \{R : R(x_i, x_j) \le \sqrt{1 - \lambda^2(x_i)}\}</code>,
</p>
<p>where <code class="reqn">\lambda = inf_{u \in U}\mathcal{I}_{cos}(R(x_i, u), A(u)) - \epsilon</code>. To generate fuzzy relation <code class="reqn">R</code> , we use the fixed parameters as follows:
</p>
<p><code>t.tnorm = "t.cos"</code> and <code>type.relation = c("transitive.kernel", "gaussian")</code>. 
</p>
<p>2) <code class="reqn">c_{ij}={\oslash}</code>, otherwise.
</p>
<p>In this case, we need to define <code>control</code> parameter as follows.
</p>
<p><code>control &lt;- list(epsilon)</code>
</p>
<p>It should be noted that when having nominal values on all attributes then <code>epsilon</code> (<code class="reqn">\epsilon</code>) should be 0. 
</p>
</li>
<li> <p><code>"min.element"</code>: It is based on (Chen et al, 2012)'s approach where we only consider finding 
the minimal element of the discernibility matrix by introducing the binary relation <code class="reqn">DIS(R)</code> the relative discernibility relation 
of conditional attribute <code class="reqn">R</code> with respect to decision attribute <code class="reqn">d</code>, which is computed as
</p>
<p><code class="reqn">DIS(R) = \{(x_i, x_j) \in U \times U: 1 - R(x_i, x_j) &gt; \lambda_i, x_j \notin [x_i]_d\}</code>,
</p>
<p>where <code class="reqn">\lambda_i = (Sim(R) \downarrow [x_i]_d)(x_i)</code> with <code class="reqn">Sim(R)</code> a fuzzy equivalence relation. 
In other words, this algorithm does not need to build the discernibility matrix. 
To generate the fuzzy relation <code class="reqn">R</code> and lower approximation <code class="reqn">\lambda</code>, we use the <code>control</code> parameter
with the following components:
</p>
<p><code>control = list(type.aggregation, type.relation, type.LU, t.implicator)</code>. 
</p>
<p>The detailed description of the components can be seen in <code>BC.IND.relation.FRST</code> and 
</p>
<p><code>BC.LU.approximation.FRST</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A class <code>"DiscernibilityMatrix"</code> containing the following components: 
</p>

<ul>
<li> <p><code>disc.mat</code>: a matrix showing the decision-relative discernibility matrix <code class="reqn">M(\mathcal{A})</code> 
which contains <code class="reqn">n \times n</code> where <code class="reqn">n</code> is the number of objects. It will be printed when choosing 
</p>
<p><code>show.discernibilityMatrix = TRUE</code>.
</p>
</li>
<li> <p><code>disc.list</code>: the decision-relative discernibility represented in a list.
</p>
</li>
<li> <p><code>discernibility.type</code>: a string showing the chosen type of discernibility methods.
</p>
</li>
<li> <p><code>type.model</code>: in this case, it is <code>"FRST"</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Lala Septem Riza
</p>


<h3>References</h3>

<p>D. Chen, L. Zhang, S. Zhao, Q. Hu, and P. Zhu, "A Novel Algorithm for Finding Reducts 
with Fuzzy Rough Sets", IEEE Trans. on Fuzzy Systems, vol. 20, no. 2, p. 385 - 389 (2012). 
</p>
<p>D. G. Chen, Q. H. Hu, and Y. P. Yang, "Parameterized Attribute Reduction with
Gaussian Kernel Based Fuzzy Rough Sets", Information Sciences, vol. 181, no. 23, 
p. 5169 - 5179 (2011).
</p>
<p>E. C. C. Tsang, D. G. Chen, D. S. Yeung, X. Z. Wang, and J. W. T. Lee, 
"Attributes Reduction Using Fuzzy Rough Sets", IEEE Trans. Fuzzy Syst., 
vol. 16, no. 5, p. 1130 - 1141 (2008).
</p>
<p>S. Zhao, E. C. C. Tsang, and D. Chen, "The Model of Fuzzy Variable Precision Rough Sets",
IEEE Trans. on Fuzzy Systems, vol. 17, no. 2, p. 451 - 467 (2009).
</p>


<h3>See Also</h3>

<p><code>BC.discernibility.mat.RST</code>, <code>BC.LU.approximation.RST</code>, and <code>BC.LU.approximation.FRST</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#######################################################################
## Example 1: Constructing the decision-relative discernibility matrix
## In this case, we are using The simple Pima dataset containing 7 rows. 
#######################################################################
data(RoughSetData)
decision.table &lt;- RoughSetData$pima7.dt 

## using "standard.red"
control.1 &lt;- list(type.relation = c("tolerance", "eq.1"), 
                type.aggregation = c("t.tnorm", "min"), 
                t.implicator = "kleene_dienes", type.LU = "implicator.tnorm")
res.1 &lt;- BC.discernibility.mat.FRST(decision.table, type.discernibility = "standard.red", 
                                    control = control.1)

## using "gaussian.red"
control.2 &lt;- list(epsilon = 0)
res.2 &lt;- BC.discernibility.mat.FRST(decision.table, type.discernibility = "gaussian.red",
                                    control = control.2)

## using "alpha.red"
control.3 &lt;- list(type.relation = c("tolerance", "eq.1"), 
                type.aggregation = c("t.tnorm", "min"),
                t.implicator = "lukasiewicz", alpha.precision = 0.05)
res.3 &lt;- BC.discernibility.mat.FRST(decision.table, type.discernibility = "alpha.red", 
                                    control = control.3)

## using "min.element"
control.4 &lt;- list(type.relation = c("tolerance", "eq.1"), 
                type.aggregation = c("t.tnorm", "lukasiewicz"),
                t.implicator = "lukasiewicz", type.LU = "implicator.tnorm")
res.4 &lt;- BC.discernibility.mat.FRST(decision.table, type.discernibility = "min.element", 
                                    control = control.4)

#######################################################################
## Example 2: Constructing the decision-relative discernibility matrix
## In this case, we are using the Hiring dataset containing nominal values
#######################################################################
## Not run: data(RoughSetData)
decision.table &lt;- RoughSetData$hiring.dt 

control.1 &lt;- list(type.relation = c("crisp"), 
                type.aggregation = c("crisp"),
                t.implicator = "lukasiewicz", type.LU = "implicator.tnorm")
res.1 &lt;- BC.discernibility.mat.FRST(decision.table, type.discernibility = "standard.red", 
                                    control = control.1)

control.2 &lt;- list(epsilon = 0)
res.2 &lt;- BC.discernibility.mat.FRST(decision.table, type.discernibility = "gaussian.red",
                                    control = control.2)
## End(Not run)
</code></pre>


</div>