<div class="container">

<table style="width: 100%;"><tr>
<td>re2_regexp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compile regular expression pattern</h2>

<h3>Description</h3>

<p><code>re2_regexp</code> compiles a character string containing a regular
expression and returns a pointer to the object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">re2_regexp(pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>Character string containing a
regular expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Options, which are (defaults in parentheses):
</p>

<table>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠encoding⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠"UTF8"⁠</code>) String and pattern are UTF-8; Otherwise <code style="white-space: pre;">⁠"Latin1"⁠</code>.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠posix_syntax⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Restrict regexps to POSIX egrep syntax.</td>
</tr>
<tr>
<td style="text-align: left;"> 
  <code style="white-space: pre;">⁠longest_match⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Search for longest match, not first match.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠max_mem⁠</code> </td>
<td style="text-align: left;"> (see below) Approx. max memory footprint of RE2 C++ object.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠literal⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Interpret pattern as literal, not regexp.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠never_nl⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Never match \n, even if it is in regexp.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠dot_nl⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Dot matches everything including new line.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠never_capture⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Parse all parens as non-capturing.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠case_sensitive⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠TRUE⁠</code>) Match is case-sensitive (regexp can 
                                     override with (?i) unless in posix_syntax mode).</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>The following options are only consulted when <code style="white-space: pre;">⁠posix_syntax=TRUE⁠</code>.
When <code style="white-space: pre;">⁠posix_syntax=FALSE⁠</code>, these features are always enabled and
cannot be turned off; to perform multi-line matching in that case,
begin the regexp with (?m). 
</p>

<table>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠perl_classes⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Allow Perl's <code style="white-space: pre;">⁠\d \s \w \D \S \W⁠</code>.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠word_boundary⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) Allow Perl's <code style="white-space: pre;">⁠\b \B⁠</code> (word boundary and not).</td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠one_line⁠</code> </td>
<td style="text-align: left;"> (<code style="white-space: pre;">⁠FALSE⁠</code>) <code style="white-space: pre;">⁠^⁠</code> and <code style="white-space: pre;">⁠$⁠</code> only match beginning and end of text.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>The <code style="white-space: pre;">⁠max_mem⁠</code> option controls how much memory can be used to
hold the compiled form of the regexp and its cached DFA
graphs (DFA: The execution engine that implements Deterministic
Finite Automaton search). Default is 8MB.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Compiled regular expression.
</p>


<h3>Regexp Syntax</h3>

<p>RE2 regular expression syntax is similar to Perl's with some of
the more complicated things thrown away. In particular,
backreferences and generalized assertions are not available, nor
is <code style="white-space: pre;">⁠\Z⁠</code>.
</p>
<p>See re2_syntax for the syntax
supported by RE2, and a comparison with PCRE and PERL regexps.
</p>
<p>For those not familiar with Perl's regular expressions, here are
some examples of the most commonly used extensions:
</p>

<table>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠"hello (\w+) world"⁠</code> </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \w matches a "word" character. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠"version (\d+)"⁠</code>     </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \d matches a digit. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠"hello\s+world"⁠</code>     </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \s matches any whitespace character. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠"\b(\w+)\b"⁠</code>       </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \b matches non-empty string at word boundary. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠"(?i)hello"⁠</code>        </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> (?i) turns on case-insensitive matching. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠"/\*(.*?)\*/"⁠</code>      </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> <code style="white-space: pre;">⁠.*?⁠</code> matches . minimum no. of times possible.
</td>
</tr>
</table>
<p>The double backslashes are needed when writing R string literals.
However, they should NOT be used when writing raw string literals:
</p>

<table>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠r"(hello (\w+) world)"⁠</code> </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \w matches a "word" character. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠r"(version (\d+))"⁠</code>     </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \d matches a digit. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠r"(hello\s+world)"⁠</code>     </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \s matches any whitespace character. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠r"(\b(\w+)\b)"⁠</code>       </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> \b matches non-empty string at word boundary. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠r"((?i)hello)"⁠</code>        </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> (?i) turns on case-insensitive matching. </td>
</tr>
<tr>
<td style="text-align: left;">
  <code style="white-space: pre;">⁠r"(/\*(.*?)\*/)"⁠</code>      </td>
<td style="text-align: left;"> -- </td>
<td style="text-align: left;"> <code style="white-space: pre;">⁠.*?⁠</code> matches . minimum no. of times possible.
</td>
</tr>
</table>
<p>When using UTF-8 encoding, case-insensitive matching will perform
simple case folding, not full case folding.
</p>


<h3>See Also</h3>

<p>re2_syntax has regular expression syntax.
</p>


<h3>Examples</h3>

<pre><code class="language-R">re2p &lt;- re2_regexp("hello world")
stopifnot(mode(re2p) == "externalptr")

## UTF-8 and matching interface
# By default, pattern and input text are interpreted as UTF-8.
# The Latin1 option causes them to be interpreted as Latin-1.
x &lt;- "fa\xE7ile"
Encoding(x) &lt;- "latin1"
re2_detect(x, re2_regexp("fa\xE7", encoding = "Latin1"))

## Case insensitive
re2_detect("fOobar ", re2_regexp("Foo", case_sensitive = FALSE))

## Literal string (as opposed to regular expression)
## Matches only when 'literal' option is TRUE
re2_detect("foo\\$bar", re2_regexp("foo\\$b", literal = TRUE))
re2_detect("foo\\$bar", re2_regexp("foo\\$b", literal = FALSE))

## Use of never_nl
re &lt;- re2_regexp("(abc(.|\n)*def)", never_nl = FALSE)
re2_match("abc\ndef\n", re)
re &lt;- re2_regexp("(abc(.|\n)*def)", never_nl = TRUE)
re2_match("abc\ndef\n", re)
</code></pre>


</div>