<div class="container">

<table style="width: 100%;"><tr>
<td>nnd_knn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find nearest neighbors using nearest neighbor descent</h2>

<h3>Description</h3>

<p>Uses the Nearest Neighbor Descent method due to Dong and co-workers (2011)
to optimize an approximate nearest neighbor graph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nnd_knn(
  data,
  k = NULL,
  metric = "euclidean",
  init = "rand",
  init_args = NULL,
  n_iters = NULL,
  max_candidates = NULL,
  delta = 0.001,
  low_memory = TRUE,
  weight_by_degree = FALSE,
  use_alt_metric = TRUE,
  n_threads = 0,
  verbose = FALSE,
  progress = "bar",
  obs = "R",
  ret_forest = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Matrix of <code>n</code> items to generate neighbors for, with observations
in the rows and features in the columns. Optionally, input can be passed
with observations in the columns, by setting <code>obs = "C"</code>, which should be
more efficient. Possible formats are <code>base::data.frame()</code>, <code>base::matrix()</code>
or <code>Matrix::sparseMatrix()</code>. Sparse matrices should be in <code>dgCMatrix</code>
format. Dataframes will be converted to <code>numerical</code> matrix format
internally, so if your data columns are <code>logical</code> and intended to be used
with the specialized binary <code>metric</code>s, you should convert it to a logical
matrix first (otherwise you will get the slower dense numerical version).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of nearest neighbors to return. Optional if <code>init</code> is
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>Type of distance calculation to use. One of:
</p>

<ul>
<li> <p><code>"braycurtis"</code>
</p>
</li>
<li> <p><code>"canberra"</code>
</p>
</li>
<li> <p><code>"chebyshev"</code>
</p>
</li>
<li> <p><code>"correlation"</code> (1 minus the Pearson correlation)
</p>
</li>
<li> <p><code>"cosine"</code>
</p>
</li>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"euclidean"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"hellinger"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"jensenshannon"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"sqeuclidean"</code> (squared Euclidean)
</p>
</li>
<li> <p><code>"manhattan"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"spearmanr"</code> (1 minus the Spearman rank correlation)
</p>
</li>
<li> <p><code>"symmetrickl"</code> (symmetric Kullback-Leibler divergence)
</p>
</li>
<li> <p><code>"tsss"</code> (Triangle Area Similarity-Sector Area Similarity or TS-SS
metric)
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li>
</ul>
<p>For non-sparse data, the following variants are available with
preprocessing: this trades memory for a potential speed up during the
distance calculation. Some minor numerical differences should be expected
compared to the non-preprocessed versions:
</p>

<ul>
<li> <p><code>"cosine-preprocess"</code>: <code>cosine</code> with preprocessing.
</p>
</li>
<li> <p><code>"correlation-preprocess"</code>: <code>correlation</code> with preprocessing.
</p>
</li>
</ul>
<p>For non-sparse binary data passed as a <code>logical</code> matrix, the following
metrics have specialized variants which should be substantially faster than
the non-binary variants (in other cases the logical data will be treated as
a dense numeric vector of 0s and 1s):
</p>

<ul>
<li> <p><code>"dice"</code>
</p>
</li>
<li> <p><code>"hamming"</code>
</p>
</li>
<li> <p><code>"jaccard"</code>
</p>
</li>
<li> <p><code>"kulsinski"</code>
</p>
</li>
<li> <p><code>"matching"</code>
</p>
</li>
<li> <p><code>"rogerstanimoto"</code>
</p>
</li>
<li> <p><code>"russellrao"</code>
</p>
</li>
<li> <p><code>"sokalmichener"</code>
</p>
</li>
<li> <p><code>"sokalsneath"</code>
</p>
</li>
<li> <p><code>"yule"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>Name of the initialization strategy or initial <code>data</code> neighbor
graph to optimize. One of:
</p>

<ul>
<li> <p><code>"rand"</code> random initialization (the default).
</p>
</li>
<li> <p><code>"tree"</code> use the random projection tree method of Dasgupta and Freund
(2008).
</p>
</li>
<li>
<p> a pre-calculated neighbor graph. A list containing:
</p>

<ul>
<li> <p><code>idx</code> an <code>n</code> by <code>k</code> matrix containing the nearest neighbor indices.
</p>
</li>
<li> <p><code>dist</code> (optional) an <code>n</code> by <code>k</code> matrix containing the nearest
neighbor distances. If the input distances are omitted, they will be
calculated for you.'
</p>
</li>
</ul>
</li>
</ul>
<p>If <code>k</code> and <code>init</code> are specified as arguments to this function, and the
number of neighbors provided in <code>init</code> is not equal to <code>k</code> then:
</p>

<ul>
<li>
<p> if <code>k</code> is smaller, only the <code>k</code> closest values in <code>init</code> are retained.
</p>
</li>
<li>
<p> if <code>k</code> is larger, then random neighbors will be chosen to fill <code>init</code> to
the size of <code>k</code>. Note that there is no checking if any of the random
neighbors are duplicates of what is already in <code>init</code> so effectively fewer
than <code>k</code> neighbors may be chosen for some observations under these
circumstances.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_args</code></td>
<td>
<p>a list containing arguments to pass to the random partition
forest initialization. See <code>rpf_knn()</code> for possible arguments. To avoid
inconsistences with the tree calculation and subsequent nearest neighbor
descent optimization, if you attempt to provide a <code>metric</code> or
<code>use_alt_metric</code> option in this list it will be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_iters</code></td>
<td>
<p>Number of iterations of nearest neighbor descent to carry out.
By default, this will be chosen based on the number of observations in
<code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_candidates</code></td>
<td>
<p>Maximum number of candidate neighbors to try for each
item in each iteration. Use relative to <code>k</code> to emulate the "rho"
sampling parameter in the nearest neighbor descent paper. By default, this
is set to <code>k</code> or <code>60</code>, whichever is smaller.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>The minimum relative change in the neighbor graph allowed before
early stopping. Should be a value between 0 and 1. The smaller the value,
the smaller the amount of progress between iterations is allowed. Default
value of <code>0.001</code> means that at least 0.1% of the neighbor graph must
be updated at each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low_memory</code></td>
<td>
<p>If <code>TRUE</code>, use a lower memory, but more
computationally expensive approach to index construction. If set to
<code>FALSE</code>, you should see a noticeable speed improvement, especially
when using a smaller number of threads, so this is worth trying if you have
the memory to spare.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_by_degree</code></td>
<td>
<p>If <code>TRUE</code>, then candidates for the local join are
weighted according to their in-degree, so that if there are more than
<code>max_candidates</code> in a candidate list, candidates with a smaller degree are
favored for retention. This prevents items with large numbers of edges
crowding out other items and for high-dimensional data is likely to provide
a small improvement in accuracy. Because this incurs a small extra cost of
counting the degree of each node, and because it tends to delay early
convergence, by default this is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_alt_metric</code></td>
<td>
<p>If <code>TRUE</code>, use faster metrics that maintain the
ordering of distances internally (e.g. squared Euclidean distances if using
<code>metric = "euclidean"</code>), then apply a correction at the end. Probably
the only reason to set this to <code>FALSE</code> is if you suspect that some
sort of numeric issue is occurring with your data in the alternative code
path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>
<p>Number of threads to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, log information to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>Determines the type of progress information logged if
<code>verbose = TRUE</code>. Options are:
</p>

<ul>
<li> <p><code>"bar"</code>: a simple text progress bar.
</p>
</li>
<li> <p><code>"dist"</code>: the sum of the distances in the approximate knn graph at the
end of each iteration.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs</code></td>
<td>
<p>set to <code>"C"</code> to indicate that the input <code>data</code> orientation stores
each observation as a column. The default <code>"R"</code> means that observations are
stored in each row. Storing the data by row is usually more convenient, but
internally your data will be converted to column storage. Passing it
already column-oriented will save some memory and (a small amount of) CPU
usage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret_forest</code></td>
<td>
<p>If <code>TRUE</code> and <code>init = "tree"</code> then the RP forest used to
initialize the nearest neighbors will be returned with the nearest neighbor
data. See the <code>Value</code> section for details. The returned forest can be used
as part of initializing the search for new data: see <code>rpf_knn_query()</code> and
<code>rpf_filter()</code> for more details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If no initial graph is provided, a random graph is generated, or you may also
specify the use of a graph generated from a forest of random projection
trees, using the method of Dasgupta and Freund (2008).
</p>


<h3>Value</h3>

<p>the approximate nearest neighbor graph as a list containing:
</p>

<ul>
<li> <p><code>idx</code> an n by k matrix containing the nearest neighbor indices.
</p>
</li>
<li> <p><code>dist</code> an n by k matrix containing the nearest neighbor distances.
</p>
</li>
<li> <p><code>forest</code> (if <code>init = "tree"</code> and <code>ret_forest = TRUE</code> only): the RP forest
used to initialize the neighbor data.
</p>
</li>
</ul>
<h3>References</h3>

<p>Dasgupta, S., &amp; Freund, Y. (2008, May).
Random projection trees and low dimensional manifolds.
In <em>Proceedings of the fortieth annual ACM symposium on Theory of computing</em>
(pp. 537-546).
<a href="https://doi.org/10.1145/1374376.1374452">doi:10.1145/1374376.1374452</a>.
</p>
<p>Dong, W., Moses, C., &amp; Li, K. (2011, March).
Efficient k-nearest neighbor graph construction for generic similarity measures.
In <em>Proceedings of the 20th international conference on World Wide Web</em>
(pp. 577-586).
ACM.
<a href="https://doi.org/10.1145/1963405.1963487">doi:10.1145/1963405.1963487</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Find 4 (approximate) nearest neighbors using Euclidean distance
# If you pass a data frame, non-numeric columns are removed
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "euclidean")

# Manhattan (l1) distance
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "manhattan")

# Multi-threading: you can choose the number of threads to use: in real
# usage, you will want to set n_threads to at least 2
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "manhattan", n_threads = 1)

# Use verbose flag to see information about progress
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "euclidean", verbose = TRUE)

# Nearest neighbor descent uses random initialization, but you can pass any
# approximation using the init argument (as long as the metrics used to
# calculate the initialization are compatible with the metric options used
# by nnd_knn).
iris_nn &lt;- random_knn(iris, k = 4, metric = "euclidean")
iris_nn &lt;- nnd_knn(iris, init = iris_nn, metric = "euclidean", verbose = TRUE)

# Number of iterations controls how much optimization is attempted. A smaller
# value will run faster but give poorer results
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "euclidean", n_iters = 2)

# You can also control the amount of work done within an iteration by
# setting max_candidates
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "euclidean", max_candidates = 50)

# Optimization may also stop early if not much progress is being made. This
# convergence criterion can be controlled via delta. A larger value will
# stop progress earlier. The verbose flag will provide some information if
# convergence is occurring before all iterations are carried out.
set.seed(1337)
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "euclidean", n_iters = 5, delta = 0.5)

# To ensure that descent only stops if no improvements are made, set delta = 0
set.seed(1337)
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "euclidean", n_iters = 5, delta = 0)

# A faster version of the algorithm is available that avoids repeated
# distance calculations at the cost of using more RAM. Set low_memory to
# FALSE to try it.
set.seed(1337)
iris_nn &lt;- nnd_knn(iris, k = 4, metric = "euclidean", low_memory = FALSE)

# Using init = "tree" is usually more efficient than random initialization.
# arguments to the tree initialization method can be passed via the init_args
# list
set.seed(1337)
iris_nn &lt;- nnd_knn(iris, k = 4, init = "tree", init_args = list(n_trees = 5))
</code></pre>


</div>