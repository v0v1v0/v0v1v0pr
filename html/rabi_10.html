<div class="container">

<table style="width: 100%;"><tr>
<td>tweaked_IDs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tweakable brute force color coding scheme generator</h2>

<h3>Description</h3>

<p>Generates "color" coding schemes used to mark and identify individual animals, given a list of numeric sequences. The codes are robust to an arbitrary number of partial code erasures. This method uses a sloppy, slow, stochastic brute force method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tweaked_IDs(combos, redundancy, num.tries = 10, available.colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>combos</code></td>
<td>
<p>a list of numeric sequences or a matrix where each row is a unique sequence. The length of the sequences or the width matrix corresponds to the <code>total.length</code> variable seen in <code>rs_IDs</code>. The numeric elements should ideally be between zero and one less than the alphabet size (<code>0:(alphabet - 1)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redundancy</code></td>
<td>
<p>the number of erasures that can occur without disrupting surety of unique identification. This value determines how robust the scheme is to erasures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.tries</code></td>
<td>
<p>the number of iterations that will be run before choosing the best option. Increasing this number increases the running time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>available.colors</code></td>
<td>
<p>an optional list of strings that contains the names of the unique markings which compose the given 'alphabet' (e.g. "blue", "red", "yellow", etc.). If left blank, the mapping can be done at any later time using <code>codes_to_colors</code>. Additionally, the length of this list must match the 'alphabet size' given above.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>tweaked_IDs</code> runs pretty much the same as <code>brute_IDs</code>. However, unlike <code>brute_IDs</code>, <code>tweaked_IDs</code> must be first given a list or matrix of acceptable ID sequences. Instead of randomly pruning down a list of ALL possible ID sequences, we can specify our constraints first and then generate the final ID scheme. This allows the user, in the face of some constraints, to potentially generate more unique IDs that otherwise available.
</p>
<p>However, the iterative pruning is done randomly, so it is likely that resulting list of codes does not contain the maximum possible number of robust codes. Thus, the process is repeated multiple times (<code>num.tries</code>) and the list that contains the largest number of robust codes is kept and returned.
</p>


<h3>Value</h3>

<p>a list of unique ID codes that fit the provided parameters.
</p>
<p>If an appropriate argument for <code>available.colors</code> is provided, each code will be a sequence of strings, otherwise, each code will be a sequence of numeric values.
</p>


<h3>Note</h3>

<p>This function is aimed at more advanced users. We would suggest using other functions to generate ID lists unless you are familiar with how the <code>rabi</code> package works.
</p>


<h3>Author(s)</h3>

<p>Andrew Burchill, <a href="mailto:andrew.burchill@asu.edu">andrew.burchill@asu.edu</a>
</p>


<h3>References</h3>

<p>Burchill, A. T., &amp; Pavlic, T. P. (2019). Dude, where's my mark? Creating robust animal identification schemes informed by communication theory. <em>Animal Behaviour</em>, 154, 203-208. <a href="https://doi.org/10.1016/j.anbehav.2019.05.013">doi:10.1016/j.anbehav.2019.05.013</a>
</p>


<h3>See Also</h3>

<p><code>brute_IDs</code>. Also see the vignette <a href="../doc/loosebirdtag.html"><code>loosebirdtag</code></a> for demonstrations and additional uses.
</p>


<h3>Examples</h3>

<pre><code class="language-R">alphabet &lt;- 8      # the number of colors or symbols we have
total.length &lt;- 5  # the number of positions we want mark
redundancy &lt;- 2    # how many marks we can lose but still ID perfectly

  #Create a function for determining odd or even
 odd &lt;- function(x){ x %% 2 == 1 }

  #Create a matrix of all possible sequences
perms &lt;- rep(list(seq_len(alphabet)),total.length)
combos &lt;- as.matrix(expand.grid(perms)) - 1
  #Only keep sequences that fit our constraints.
  #We want the first position to only be odd numbers
  #and the second position to only be even.
combos &lt;- combos[which(odd(combos[,1]) &amp; !odd(combos[,2])), ]
## Not run: 
codes &lt;- tweaked_IDs(combos, redundancy, num.tries = 1)


print(paste0("The 'tweaked' list contains ", length(codes), " unique IDs."))

## End(Not run)
</code></pre>


</div>