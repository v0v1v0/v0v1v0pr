<div class="container">

<table style="width: 100%;"><tr>
<td>RGWAS.normal.interaction</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform normal GWAS including interaction (test each single SNP)</h2>

<h3>Description</h3>

<p>This function performs single-SNP GWAS (genome-wide association studies), including the interaction between SNP and genetic background (or other environmental factors). 
The model of GWAS is quite similar to the one in the 'RGWAS.normal' function:
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + S _ {i} \alpha _ {i} + Q v +  Z u + \epsilon,</code>
</p>

<p>where <code class="reqn">y</code> is the vector of phenotypic values,
<code class="reqn">X \beta</code>, <code class="reqn">S _ {i} \alpha _ {i}</code>, <code class="reqn">Q v</code> are the terms of fixed effects,
<code class="reqn">Z u</code> is the term of random effects and <code class="reqn">e</code> is the vector of residuals.
<code class="reqn">X \beta</code> indicates all of the fixed effects other than the effect of SNPs
to be tested and of population structure, and often this term also plays
a role as an intercept. For <code class="reqn">S _ {i} \alpha _ {i}</code>, this term is only the difference 
compared to the model for normal single-SNP GWAS. Here, <code class="reqn">S _ {i}</code>
includes the ith marker of genotype data and the interaction variables between
the ith marker of genotype data and the matrix representing the genetic back ground 
(or some environmental factors). <code class="reqn">\alpha _ {i}</code> is the cooresponding effects
of that marker and the interaction term.
<code class="reqn">Q v</code> is the term to correct the effect of population structure.
<code class="reqn">Z u</code> is the term of polygenetic effects, and suppose that <code class="reqn">u</code>
follows the multivariate normal distribution whose variance-covariance
matrix is the genetic covariance matrix. <code class="reqn">u \sim MVN (0, K \sigma_{u}^{2})</code>.
Finally, the residual term is assumed to identically and independently follow
a normal distribution as shown in the following equation.
<code class="reqn">e \sim MVN (0, I \sigma_{e}^{2})</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RGWAS.normal.interaction(
  pheno,
  geno,
  ZETA = NULL,
  package.MM = "gaston",
  covariate = NULL,
  covariate.factor = NULL,
  structure.matrix = NULL,
  interaction.with.SNPs = NULL,
  interaction.mat.method = "PCA",
  n.interaction.element = 1,
  interaction.group = NULL,
  n.interaction.group = 3,
  interaction.group.method = "find.clusters",
  n.PC.dapc = 1,
  test.method.interaction = "simultaneous",
  n.PC = 0,
  min.MAF = 0.02,
  P3D = TRUE,
  n.core = 1,
  parallel.method = "mclapply",
  sig.level = 0.05,
  method.thres = "BH",
  plot.qq = TRUE,
  plot.Manhattan = TRUE,
  plot.method = 1,
  plot.col1 = c("dark blue", "cornflowerblue"),
  plot.col2 = 1,
  plot.type = "p",
  plot.pch = 16,
  saveName = NULL,
  main.qq = NULL,
  main.man = NULL,
  plot.add.last = FALSE,
  return.EMM.res = FALSE,
  optimizer = "nlminb",
  thres = TRUE,
  skip.check = FALSE,
  verbose = TRUE,
  verbose2 = FALSE,
  count = TRUE,
  time = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pheno</code></td>
<td>
<p>Data frame where the first column is the line name (gid). The remaining columns should be a phenotype to test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geno</code></td>
<td>
<p>Data frame with the marker names in the first column. The second and third columns contain the chromosome and map position.
Columns 4 and higher contain the marker scores for each line, coded as [-1, 0, 1] = [aa, Aa, AA].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZETA</code></td>
<td>
<p>A list of covariance (relationship) matrix (K: <code class="reqn">m \times m</code>) and its design matrix (Z: <code class="reqn">n \times m</code>) of random effects.
Please set names of list "Z" and "K"! You can use more than one kernel matrix.
For example,
</p>
<p>ZETA = list(A = list(Z = Z.A, K = K.A), D = list(Z = Z.D, K = K.D))
</p>

<dl>
<dt>Z.A, Z.D</dt>
<dd>
<p>Design matrix (<code class="reqn">n \times m</code>) for the random effects. So, in many cases, you can use the identity matrix.</p>
</dd>
<dt>K.A, K.D</dt>
<dd>
<p>Different kernels which express some relationships between lines.</p>
</dd>
</dl>
<p>For example, K.A is additive relationship matrix for the covariance between lines, and K.D is dominance relationship matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>package.MM</code></td>
<td>
<p>The package name to be used when solving mixed-effects model. We only offer the following three packages: 
"RAINBOWR", "MM4LMM" and "gaston". Default package is 'gaston'.
See more details at <code>EM3.general</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector or a <code class="reqn">n \times p _ 1</code> matrix. You can insert continuous values, such as other traits or genotype score for special markers.
This argument is regarded as one of the fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate.factor</code></td>
<td>
<p>A <code class="reqn">n \times p _ 2</code> dataframe. You should assign a factor vector for each column.
Then RGWAS changes this argument into model matrix, and this model matrix will be included in the model as fixed effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>structure.matrix</code></td>
<td>
<p>You can use structure matrix calculated by structure analysis when there are population structure.
You should not use this argument with n.PC &gt; 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.with.SNPs</code></td>
<td>
<p>A <code class="reqn">m \times q</code> matrix. Interaction between each SNP and this matrix will also be tested.
For example, principal components of genomic relationship matrix can be used as this matrix to test the interaction between SNPs and the genetic background.
Or you can test the interaction with some environmental factors by inputting some omics data that represent the environment. (Test inluding GxE effects.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.mat.method</code></td>
<td>
<p>Method to compute 'interaction.with.SNPs' when 'interaction.with.SNPs' is NULL.
We offer the following four different methods:
</p>
<p>"PCA": Principal component analysis for genomic relationship matrix ('K' in 'ZETA') using 'prcomp' function
</p>
<p>"LDA": Linear discriminant analysis with independent variables as genomic relationship matrix ('K' in 'ZETA') 
and dependent variables as some group information ('interaction.group') using 'lda' function
</p>
<p>"GROUP": Dummy variables for some group information ('interaction.group')
</p>
<p>"DAPC": Perform LDA to the principal components of PCAfor genomic relationship matrix ('K' in 'ZETA')
using 'dapc' function in 'adgenet' package. See Jombart et al., 2010 and <code>dapc</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.interaction.element</code></td>
<td>
<p>Number of elements (variables) that are included in the model as interaction term for 'interaction.with.SNPs'.
If 'interaction.with.SNPs = NULL' and 'n.interaction.element = 0', then the standard SNP-based GWAS will be performed by 'RGWAS.normal' function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.group</code></td>
<td>
<p>When you use "LDA", "GROUP", or "DAPC", the information on groups (e.g., subgroups for the population) will be required.
You can set a vector of group names (or clustering ids) for each genotype as this argument. This vector should be factor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.interaction.group</code></td>
<td>
<p>When 'interaction.group = NULL', 'interaction.group' will be automatically determined by using k-medoids method ('pam' function in 'cluster' package).
You should specify the number of groups by this argument to decide 'interaction.group'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interaction.group.method</code></td>
<td>
<p>The method to perform clustering when 'interaction.group = NULL'. 
We offer the following two methods "find.clusters" and "pam".
"find.clusters" performs 'adegenet::find.clusters' functions to conduct successive K-means clustering,
"pam" performs 'cluster::pam' functions to conduct k-medoids clustering. 
See <code>find.clusters</code> and <code>pam</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.PC.dapc</code></td>
<td>
<p>Number of principal components to be used for 'adegenet::find.clusters' or 'adegenet::dapc' functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.method.interaction</code></td>
<td>
<p>Method for how to test SNPs and the interactions between SNPs and the genetic background.
We offer three methods as follows:
</p>
<p>"simultaneous": All effects (including SNP efects) are tested simultanously.
</p>
<p>"snpSeparate": SNP effects are tested as one effect, and the other interaction effects are simulateneously.
</p>
<p>"oneByOne": All efects are tested separately, one by one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P3D</code></td>
<td>
<p>When P3D = TRUE, variance components are estimated by REML only once, without any markers in the model.
When P3D = FALSE, variance components are estimated by REML for each marker separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores. 
This argument is not valid when 'parallel.method = "furrr"'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, "mclapply", "furrr", and "foreach". 
</p>
<p>When 'parallel.method = "mclapply"', we utilize <code>pbmclapply</code> function in the 'pbmcapply' package 
with 'count = TRUE' and <code>mclapply</code> function in the 'parallel' package with 'count = FALSE'. 
</p>
<p>When 'parallel.method = "furrr"', we utilize <code>future_map</code> function in the 'furrr' package. 
With 'count = TRUE', we also utilize <code>progressor</code> function in the 'progressr' package to show the progress bar, 
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>). 
For 'parallel.method = "furrr"', you can perform multi-thread parallelization by 
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = "mclapply"'.
</p>
<p>When 'parallel.method = "foreach"', we utilize <code>foreach</code> function in the 'foreach' package 
with the utilization of <code>makeCluster</code> function in 'parallel' package, 
and <code>registerDoParallel</code> function in 'doParallel' package. 
With 'count = TRUE', we also utilize <code>setTxtProgressBar</code> and 
<code>txtProgressBar</code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = "mclapply"', but for Windows users, 
this parallelization method is not supported. So, if you are Windows user, 
we recommend that you use the option 'parallel.method = "foreach"'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig.level</code></td>
<td>
<p>Significance level for the threshold. The default is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.thres</code></td>
<td>
<p>Method for detemining threshold of significance. "BH" and "Bonferroni are offered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.qq</code></td>
<td>
<p>If TRUE, draw qq plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.Manhattan</code></td>
<td>
<p>If TRUE, draw manhattan plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.method</code></td>
<td>
<p>If this argument = 1, the default manhattan plot will be drawn.
If this argument = 2, the manhattan plot with axis based on Position (bp) will be drawn.
Also, this plot's color is changed by all chromosomes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.col1</code></td>
<td>
<p>This argument determines the color of the manhattan plot.
You should substitute this argument as color vector whose length is 2.
plot.col1[1] for odd chromosomes and plot.col1[2] for even chromosomes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.col2</code></td>
<td>
<p>Color of the manhattan plot. color changes with chromosome and it starts from plot.col2 + 1
(so plot.col2 = 1 means color starts from red.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.type</code></td>
<td>
<p>This argument determines the type of the manhattan plot. See the help page of "plot".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.pch</code></td>
<td>
<p>This argument determines the shape of the dot of the manhattan plot. See the help page of "plot".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveName</code></td>
<td>
<p>When drawing any plot, you can save plots in png format. In saveName, you should substitute the name you want to save.
When saveName = NULL, the plot is not saved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main.qq</code></td>
<td>
<p>The title of qq plot. If this argument is NULL, trait name is set as the title.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main.man</code></td>
<td>
<p>The title of manhattan plot. If this argument is NULL, trait name is set as the title.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.add.last</code></td>
<td>
<p>If saveName is not NULL and this argument is TRUE, then you can add lines or dots to manhattan plots.
However, you should also write "dev.off()" after adding something.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.EMM.res</code></td>
<td>
<p>When return.EMM.res = TRUE, the results of equation of mixed models are included in the result of RGWAS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>The function used in the optimization process. 
We offer "optim", "optimx", and "nlminb" functions. 
This argument is only valid when ‘package.MM = ’RAINBOWR''.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thres</code></td>
<td>
<p>If thres = TRUE, the threshold of the manhattan plot is included in the result of RGWAS.
When return.EMM.res or thres is TRUE, the results will be "list" class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.check</code></td>
<td>
<p>As default, RAINBOWR checks the type of input data and modifies it into the correct format. 
However, it will take some time, so if you prepare the correct format of input data, you can skip this procedure 
by setting 'skip.check = TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If this argument is TRUE, messages for the current steps will be shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose2</code></td>
<td>
<p>If this argument is TRUE, welcome message will be shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>When time is TRUE, you can know how much time it took to perform RGWAS.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>P-value for each marker is calculated by performing F-test
against the F-value as follows (Kennedy et al., 1992).
</p>
<p style="text-align: center;"><code class="reqn">F = \frac { ( L' \hat { b } )' [ L' ( X' H ^ { - 1 } X ) ^ { - 1 }
L ] ^ { - 1 } ( L' \hat { b } ) } { f \hat { \sigma }_ { u } ^ { 2 } },</code>
</p>

<p>where <code class="reqn">b</code> is the vector of coefficients of the fixed effects, which combines
<code class="reqn">\beta</code>, <code class="reqn">\alpha _ {i}</code>, <code class="reqn">v</code> in the horizontal direction and <code class="reqn">L</code>
is a matrix to indicate which effects in <code class="reqn">b</code> are tested.
<code class="reqn">H</code> is calculated by dividing the estimated variance-covariance
matrix for the phenotypic values by <code class="reqn">\sigma _ { u } ^ { 2 }</code>,
and is calculated by <code class="reqn">H = Z K Z' + \hat{\lambda} I</code>.
<code class="reqn">\hat{\lambda}</code> is the maximum likelihood estimator
of the ratio between the residual variance and the additive genetic variance.
<code class="reqn">\hat{b}</code> is the maximum likelihood estimator of <code class="reqn">b</code>
and is calculated by <code class="reqn">\hat { b } = ( X' H ^ { - 1 } X ) ^ { - 1 } X' H ^ { - 1 } y </code>.
<code class="reqn">f</code> is the number of the fixed effects to be tested, and
<code class="reqn">\hat { \sigma }_ { u } ^ { 2 }</code> is estimated by the following formula.
</p>
<p style="text-align: center;"><code class="reqn">\hat { \sigma }_ { u } ^ { 2 } = \frac { ( y - X  \hat { b } )' H ^ { - 1 } ( y - X  \hat { b } ) } { n - p },</code>
</p>

<p>where <code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the number of the all fixed effects.
We calculated each p-value using the fact that the above F-value follows
the F distribution with the degree of freedom (<code class="reqn">f</code>,<code class="reqn">n - p</code>).
</p>


<h3>Value</h3>


<dl>
<dt>$D</dt>
<dd>
<p>List of data.frame which contains the information of the map you input and the results of RGWAS (-log10(p)) which correspond to the map for each tested effect.</p>
</dd>
<dt>$thres</dt>
<dd>
<p>A matrix which contains the information of threshold determined by FDR = 0.05. (each trait x each tested effect)</p>
</dd>
<dt>$EMM.res</dt>
<dd>
<p>This output is a list which contains the information about the results of "EMM" perfomed at first in regular GWAS.
If you want to know details, see the description for the function "EMM1" or "EMM2".</p>
</dd>
</dl>
<h3>References</h3>

<p>Kennedy, B.W., Quinton, M. and van Arendonk, J.A. (1992) Estimation of effects of single genes on quantitative traits. J Anim Sci. 70(7): 2000-2012.
</p>
<p>Storey, J.D. and Tibshirani, R. (2003) Statistical significance for genomewide studies. Proc Natl Acad Sci. 100(16): 9440-9445.
</p>
<p>Yu, J. et al. (2006) A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Nat Genet. 38(2): 203-208.
</p>
<p>Kang, H.M. et al. (2008) Efficient Control of Population Structure in Model Organism Association Mapping. Genetics. 178(3): 1709-1723.
</p>
<p>Kang, H.M. et al. (2010) Variance component model to account for sample structure in genome-wide association studies. Nat Genet. 42(4): 348-354.
</p>
<p>Zhang, Z. et al. (2010) Mixed linear model approach adapted for genome-wide association studies. Nat Genet. 42(4): 355-360.
</p>
<p>Endelman, J.B. (2011) Ridge Regression and Other Kernels for Genomic Selection with R Package rrBLUP. Plant Genome J. 4(3): 250.
</p>
<p>Endelman, J.B. and Jannink, J.L. (2012) Shrinkage Estimation of the Realized Relationship Matrix. G3 Genes, Genomes, Genet. 2(11): 1405-1413.
</p>
<p>Zhou, X. and Stephens, M. (2012) Genome-wide efficient mixed-model analysis for association studies. Nat Genet. 44(7): 821-824.
</p>
<p>Jombart, T., Devillard, S. and Balloux, F. (2010) Discriminant analysis of principal components: a new method for the analysis of genetically structured populations. BMC Genet 11(1), 94.
</p>


<h3>Examples</h3>

<pre><code class="language-R">



  ### Import RAINBOWR
  require(RAINBOWR)

  ### Load example datasets
  data("Rice_Zhao_etal")
  Rice_geno_score &lt;- Rice_Zhao_etal$genoScore
  Rice_geno_map &lt;- Rice_Zhao_etal$genoMap
  Rice_pheno &lt;- Rice_Zhao_etal$pheno

  ### View each dataset
  See(Rice_geno_score)
  See(Rice_geno_map)
  See(Rice_pheno)

  ### Select one trait for example
  trait.name &lt;- "Flowering.time.at.Arkansas"
  y &lt;- as.matrix(Rice_pheno[, trait.name, drop = FALSE])

  ### Remove SNPs whose MAF &lt;= 0.05
  x.0 &lt;- t(Rice_geno_score)
  MAF.cut.res &lt;- MAF.cut(x.0 = x.0, map.0 = Rice_geno_map)
  x &lt;- MAF.cut.res$x
  map &lt;- MAF.cut.res$map


  ### Estimate genomic relationship matrix (GRM)
  K.A &lt;- calcGRM(genoMat = x)


  ### Modify data
  modify.data.res &lt;-
    modify.data(
      pheno.mat = y,
      geno.mat = x,
      map = map,
      return.ZETA = TRUE,
      return.GWAS.format = TRUE
    )
  pheno.GWAS &lt;- modify.data.res$pheno.GWAS
  geno.GWAS &lt;- modify.data.res$geno.GWAS
  ZETA &lt;- modify.data.res$ZETA


  ### View each data for RAINBOWR
  See(pheno.GWAS)
  See(geno.GWAS)
  str(ZETA)



  ### Perform single-SNP GWAS with interaction
  ### by testing all effects (including SNP effects) simultaneously
  normal.res.int &lt;-
    RGWAS.normal.interaction(
      pheno = pheno.GWAS,
      geno = geno.GWAS,
      ZETA = ZETA,
      interaction.with.SNPs = NULL,
      interaction.mat.method = "PCA",
      n.interaction.element = 3,
      interaction.group = NULL,
      n.interaction.group = 3,
      interaction.group.method = "find.clusters",
      n.PC.dapc = 3,
      test.method.interaction = "simultaneous",
      n.PC = 3,
      P3D = TRUE,
      plot.qq = TRUE,
      plot.Manhattan = TRUE,
      verbose = TRUE,
      verbose2 = FALSE,
      count = TRUE,
      time = TRUE,
      package.MM = "gaston",
      parallel.method = "mclapply",
      skip.check = TRUE,
      n.core = 2
    )
  See(normal.res.int$D[[1]])  ### Column 4 contains -log10(p) values
                              ### for all effects (including SNP effects)

</code></pre>


</div>