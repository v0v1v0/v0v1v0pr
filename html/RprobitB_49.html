<div class="container">

<table style="width: 100%;"><tr>
<td>RprobitB_latent_classes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create object of class <code>RprobitB_latent_classes</code>
</h2>

<h3>Description</h3>

<p>This function creates an object of class <code>RprobitB_latent_classes</code> which
defines the number of latent classes and their updating scheme.
The <code>RprobitB_latent_classes</code> object generated
by this function is only of relevance if the model possesses at least one
random coefficient, i.e. if <code>P_r&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RprobitB_latent_classes(latent_classes = NULL)

## S3 method for class 'RprobitB_latent_classes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>latent_classes</code></td>
<td>
<p>Either <code>NULL</code> (for no latent classes) or a list of parameters specifying
the number of latent classes and their updating scheme:
</p>

<ul>
<li> <p><code>C</code>: The fixed number (greater or equal 1) of latent classes,
which is set to 1 per default. If either <code>weight_update = TRUE</code>
or <code>dp_update = TRUE</code> (i.e. if classes are updated), <code>C</code>
equals the initial number of latent classes.
</p>
</li>
<li> <p><code>weight_update</code>: A boolean, set to <code>TRUE</code> to weight-based
update the latent classes. See ... for details.
</p>
</li>
<li> <p><code>dp_update</code>: A boolean, set to <code>TRUE</code> to update the latent
classes based on a Dirichlet process. See ... for details.
</p>
</li>
<li> <p><code>Cmax</code>: The maximum number of latent classes.
</p>
</li>
<li> <p><code>buffer</code>: The number of iterations to wait before a next
weight-based update of the latent classes.
</p>
</li>
<li> <p><code>epsmin</code>: The threshold weight (between 0 and 1) for removing
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>epsmax</code>: The threshold weight (between 0 and 1) for splitting
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>distmin</code>: The (non-negative) threshold in class mean difference
for joining two latent classes in the weight-based updating scheme.
</p>
</li>
</ul>
</td>
</tr></table>
<h3>Details</h3>



<h4>Why update latent classes?</h4>

<p>In order not to have to specify the number of latent classes before
estimation.
</p>



<h4>What options to update latent classes exist?</h4>

<p>Currently two updating schemes are implemented, weight-based and
via a Dirichlet process, see
<a href="https://loelschlaeger.de/RprobitB/articles/v04_modeling_heterogeneity.html">the vignette on modeling heterogeneity</a>.
</p>



<h4>What is the default behavior?</h4>

<p>One latent class without updates is specified per default. Print an
<code>RprobitB_latent_classes</code>-object to see a summary of all relevant
(default) parameter settings.
</p>



<h4>Why is <code>Cmax</code> required?</h4>

<p>The implementation requires an upper bound on the number of latent classes
for saving the Gibbs samples. However, this is not a restriction since the
number of latent classes is bounded by the number of deciders in any case.
A plot method for visualizing the sequence of class numbers after estimation
and can be used to check if <code>Cmax</code> was reached, see
<code>plot.RprobitB_fit</code>.
</p>



<h3>Value</h3>

<p>An object of class <code>RprobitB_latent_classes</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### default setting
RprobitB:::RprobitB_latent_classes()

### setting for a fixed number of two latent classes
RprobitB:::RprobitB_latent_classes(list(C = 2))

### setting for weight-based on Dirichlet process-based updates
RprobitB:::RprobitB_latent_classes(
  list("weight_update" = TRUE, "dp_update" = TRUE)
)

</code></pre>


</div>