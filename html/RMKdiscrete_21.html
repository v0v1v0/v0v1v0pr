<div class="container">

<table style="width: 100%;"><tr>
<td>binegbin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The bivariate negative binomial distribution</h2>

<h3>Description</h3>

<p>Functions for the bivariate negative binomial distribution, as generated via trivariate reduction: density, random-number generation, and moments of the log-transformed distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dbinegbin(y, nu, p, log=FALSE, add.carefully=FALSE)
binegbin.logMV(nu,p,const.add=1,tol=1e-14,add.carefully=FALSE)
rbinegbin(n, nu, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Numeric vector or two-column matrix of bivariate data.  If matrix, each row corresponds to an observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Numeric vector or three-column matrix of non-negative values for index parameters <code class="reqn">\nu _0</code>, <code class="reqn">\nu _1</code>, and <code class="reqn">\nu _2</code>, in that order.  If matrix, is read by row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Numeric vector or three-column matrix of values for Bernoulli parameters <code class="reqn">p_0</code>, <code class="reqn">p_1</code>, and <code class="reqn">p_2</code>, in that order.  If matrix, is read by row.  Values must be on the interval (0,1].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>Logical; should the natural log of the probability be returned?  Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.carefully</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the program takes extra steps to try to prevent round-off error during the addition of probabilities.  Defaults to <code>FALSE</code>, which is recommended, since using <code>TRUE</code> is slower and rarely makes a noticeable difference in practice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const.add</code></td>
<td>
<p>Numeric vector of positive constants to add to the non-negative integers before taking their natural logarithm.  Defaults to 1, for the typical <code class="reqn">\log (y+1)</code> transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numeric; must be positive.  When <code>binegbin.logMV()</code> is calculating the second moment of the log-transformed distribution, it stops when the next term in the series is smaller than <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer; number of observations to be randomly generated.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This bivariate negative binomial distribution is constructed from three independent latent variables, in the same manner as the bivariate Lagrangian Poisson distribution.
</p>
<p>Function <code>dbinegbin()</code> is the bivariate negative binomial density (PMF).  Function <code>rbinegbin()</code> generates random draws from the bivariate negative binomial distribution, via calls to <code>rnbinom()</code>.  Function <code>binegbin.logMV()</code> numerically computes the means, variances, and covariance of a bivariate LGP distribution, after it has been log transformed following addition of a positive constant.
</p>
<p>Vectors of numeric arguments other than <code>tol</code> are cycled, whereas only the first element of logical and integer arguments is used.
</p>


<h3>Value</h3>

<p><code>dbinegbin()</code> returns a numeric vector of probabilities.  <code>rbinegbin()</code> returns a matrix of random draws, which is of type 'numeric' (rather than 'integer', even though the negative binomial only has support on the non-negative integers).  <code>binegbin.logMV()</code> returns a numeric matrix with the following five named columns:
</p>

<ol>
<li> <p><code>EY1</code>: Post-tranformation expectation of <code class="reqn">Y_1</code>.
</p>
</li>
<li> <p><code>EY2</code>: Post-tranformation expectation of <code class="reqn">Y_2</code>.
</p>
</li>
<li> <p><code>VY1</code>: Post-tranformation variance of <code class="reqn">Y_1</code>.
</p>
</li>
<li> <p><code>VY2</code>: Post-tranformation variance of <code class="reqn">Y_2</code>.
</p>
</li>
<li> <p><code>COV</code>: Post-tranformation covariance of <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code>.
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>
</p>


<h3>See Also</h3>

<p><code>dbiLGP</code>, <code>dnbinom()</code>,  <code>rnbinom()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## The following two lines do the same thing:
dbinegbin(y=1,nu=1,p=0.9)
dbinegbin(y=c(1,1),nu=c(1,1,1),p=c(0.9,0.9,0.9))

dbinegbin(y=c(1,1,2,2,3,5),nu=c(1,1,1,2,2,2),p=0.9)
## Due to argument cycling, the above line is doing the following three steps:
dbinegbin(y=c(1,1),nu=c(1,1,1),p=c(0.9,0.9,0.9))
dbinegbin(y=c(2,2),nu=c(2,2,2),p=c(0.9,0.9,0.9))
dbinegbin(y=c(3,5),nu=c(1,1,1),p=c(0.9,0.9,0.9))

## Inputs to dbinegbin() can be matrices, too:
dbinegbin(y=matrix(c(1,1,2,2,3,5),ncol=2,byrow=TRUE),
  nu=matrix(c(1,1,1,2,2,2,1,1,1),ncol=3,byrow=TRUE),
  p=0.9)
  
## nu0 = 0 implies independence:
a &lt;- dbinegbin(y=c(1,3),nu=c(0,1,2),p=c(0.1,0.5,0.9))
b &lt;- dnegbin(x=1,nu=1,p=0.5) * dnegbin(x=3,nu=2,p=0.9)
a-b #&lt;--near zero.

( y &lt;- rbinegbin(10,nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90)) )
dbinegbin(y=y,nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90))
( mv &lt;- negbinMVP(nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90)) )
mv[1,2] #&lt;--Covariance of this distribution
mv[1,2]+mv[2,2] #&lt;--Marginal variance of Y1
mv[1,2]+mv[3,2] #&lt;--Marginal variance of Y2
mv[1,2]/(sqrt(mv[1,2]+mv[2,2])*sqrt(mv[1,2]+mv[3,2])) #&lt;--Correlation
logmv &lt;- binegbin.logMV(nu=c(1.1,0.87,5.5),p=c(0.87,0.89,0.90))
## Log transformation nearly cuts the correlation in half:
logmv[1,5]/sqrt(logmv[1,3]*logmv[1,4])
</code></pre>


</div>