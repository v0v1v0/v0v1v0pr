<div class="container">

<table style="width: 100%;"><tr>
<td>analyze</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate rows analyzing variables across columns</h2>

<h3>Description</h3>

<p>Adding <em>analyzed variables</em> to our table layout defines the primary tabulation to be performed. We do this by
adding calls to <code>analyze</code> and/or <code>analyze_colvars()</code> into our layout pipeline. As with adding further splitting,
the tabulation will occur at the current/next level of nesting by default.
</p>


<h3>Usage</h3>

<pre><code class="language-R">analyze(
  lyt,
  vars,
  afun = simple_analysis,
  var_labels = vars,
  table_names = vars,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  inclNAs = FALSE,
  extra_args = list(),
  show_labels = c("default", "visible", "hidden"),
  indent_mod = 0L,
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lyt</code></td>
<td>
<p>(<code>PreDataTableLayouts</code>)<br> layout object pre-data used for tabulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>(<code>character</code>)<br> vector of variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>afun</code></td>
<td>
<p>(<code>function</code>)<br> analysis function. Must accept <code>x</code> or <code>df</code> as its first parameter. Can optionally take
other parameters which will be populated by the tabulation framework. See Details in <code>analyze()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_labels</code></td>
<td>
<p>(<code>character</code>)<br> vector of labels for one or more variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table_names</code></td>
<td>
<p>(<code>character</code>)<br> names for the tables representing each atomic analysis. Defaults to <code>var</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>(<code>string</code>, <code>function</code>, or <code>list</code>)<br> format associated with this split. Formats can be declared via
strings (<code>"xx.x"</code>) or function. In cases such as <code>analyze</code> calls, they can be character vectors or lists of
functions. See <code>formatters::list_valid_format_labels()</code> for a list of all available format strings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_str</code></td>
<td>
<p>(<code>string</code>)<br> string that should be displayed when the value of <code>x</code> is missing. Defaults to <code>"NA"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested</code></td>
<td>
<p>(<code>logical</code>)<br> whether this layout instruction should be applied within the existing layout structure
<em>if possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split
underneath analyses, which is not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inclNAs</code></td>
<td>
<p>(<code>logical</code>)<br> whether NA observations in the <code>var</code> variable(s) should be included when performing
the analysis. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extra_args</code></td>
<td>
<p>(<code>list</code>)<br> extra arguments to be passed to the tabulation function. Element position in the list
corresponds to the children of this split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show_labels</code></td>
<td>
<p>(<code>string</code>)<br> whether the variable labels corresponding to the variable(s) in <code>vars</code>
should be visible in the resulting table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indent_mod</code></td>
<td>
<p>(<code>numeric</code>)<br> modifier for the default indent position for the structure created by this
function (subtable, content table, or row) <em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>section_div</code></td>
<td>
<p>(<code>string</code>)<br> string which should be repeated as a section divider after each group defined
by this split instruction, or <code>NA_character_</code> (the default) for no section divider.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When non-<code>NULL</code>, <code>format</code> is used to specify formats for all generated rows, and can be a character vector, a
function, or a list of functions. It will be repped out to the number of rows once this is calculated during the
tabulation process, but will be overridden by formats specified within <code>rcell</code> calls in <code>afun</code>.
</p>
<p>The analysis function (<code>afun</code>) should take as its first parameter either <code>x</code> or <code>df</code>. Whichever of these the
function accepts will change the behavior when tabulation is performed as follows:
</p>

<ul>
<li>
<p> If <code>afun</code>'s first parameter is <code>x</code>, it will receive the corresponding subset <em>vector</em> of data from the relevant
column (from <code>var</code> here) of the raw data being used to build the table.
</p>
</li>
<li>
<p> If <code>afun</code>'s first parameter is <code>df</code>, it will receive the corresponding subset <em>data frame</em> (i.e. all columns) of
the raw data being tabulated.
</p>
</li>
</ul>
<p>In addition to differentiation on the first argument, the analysis function can optionally accept a number of
other parameters which, <em>if and only if</em> present in the formals, will be passed to the function by the tabulation
machinery. These are listed and described in additional_fun_params.
</p>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further layouting functions, and to <code>build_table()</code>.
</p>


<h3>Note</h3>

<p>None of the arguments described in the Details section can be overridden via <code>extra_args</code> or when calling
<code>make_afun()</code>. <code>.N_col</code> and <code>.N_total</code> can be overridden via the <code>col_counts</code> argument to <code>build_table()</code>.
Alternative values for the others must be calculated within <code>afun</code> based on a combination of extra arguments and
the unmodified values provided by the tabulation framework.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class="language-R">lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = list_wrap_x(summary), format = "xx.xx")
lyt

tbl &lt;- build_table(lyt, DM)
tbl

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  analyze(head(names(iris), -1), afun = function(x) {
    list(
      "mean / sd" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "range" = rcell(diff(range(x)), format = "xx.xx")
    )
  })
lyt2

tbl2 &lt;- build_table(lyt2, iris)
tbl2

</code></pre>


</div>