<div class="container">

<table style="width: 100%;"><tr>
<td>spde.matern.loglike</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parameter-based log-likelihood for a latent Gaussian Matern SPDE model
using a rational SPDE approximation</h2>

<h3>Description</h3>

<p>This function evaluates the log-likelihood function for observations
of a Gaussian process defined as the solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">spde.matern.loglike(
  object,
  Y,
  A,
  sigma.e,
  mu = 0,
  user_nu = NULL,
  user_kappa = NULL,
  user_tau = NULL,
  user_theta = NULL,
  user_m = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>The rational SPDE approximation,
computed using <code>spde.matern.operators()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The observations, either a vector or a matrix where
the columns correspond to independent replicates of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>An observation matrix that links the measurement location to the
finite element basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.e</code></td>
<td>
<p>IF non-null, the standard deviation of the measurement noise will be kept fixed in
the returned likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Expectation vector of the latent field (default = 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_nu</code></td>
<td>
<p>If non-null, the shape parameter will be kept fixed in the returned likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_kappa</code></td>
<td>
<p>If non-null, updates the range parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_tau</code></td>
<td>
<p>If non-null, updates the parameter tau.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_theta</code></td>
<td>
<p>If non-null, updates the parameter theta (that connects tau and kappa to the model matrices in <code>object</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_m</code></td>
<td>
<p>If non-null, update the order of the rational approximation,
which needs to be a positive integer.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The observations are assumed to be generated as
<code class="reqn">Y_i = u(s_i) + \epsilon_i</code>, where
<code class="reqn">\epsilon_i</code> are
iid mean-zero Gaussian variables. The latent model is approximated using a
rational approximation of the fractional SPDE model.
</p>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>See Also</h3>

<p><code>rSPDE.loglike()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># this example illustrates how the function can be used for maximum
# likelihood estimation
# Sample a Gaussian Matern process on R using a rational approximation
sigma.e &lt;- 0.1
n.rep &lt;- 10
n.obs &lt;- 100
n.x &lt;- 51
# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = n.x)
fem &lt;- rSPDE.fem1d(x)
tau &lt;- rep(0.5, n.x)
nu &lt;- 0.8
alpha &lt;- nu + 1/2
kappa &lt;- rep(1, n.x)
# compute rational approximation
op &lt;- spde.matern.operators(
  kappa = kappa, tau = tau, alpha = alpha,
  parameterization = "spde", d = 1,
  loc_mesh = x
)
# Sample the model
u &lt;- simulate(op, n.rep)
# Create some data
obs.loc &lt;- runif(n = n.obs, min = 0, max = 1)
A &lt;- rSPDE.A1d(x, obs.loc)
noise &lt;- rnorm(n.obs * n.rep)
dim(noise) &lt;- c(n.obs, n.rep)
Y &lt;- as.matrix(A %*% u + sigma.e * noise)
# define negative likelihood function for optimization using matern.loglike
mlik &lt;- function(theta) {
  return(-spde.matern.loglike(op, Y, A, sigma.e = exp(theta[4]),
                                 user_nu = exp(theta[3]),
                                 user_kappa = exp(theta[2]),
                                 user_tau = exp(theta[1])))
}
#' #The parameters can now be estimated by minimizing mlik with optim

# Choose some reasonable starting values depending on the size of the domain
theta0 &lt;- log(c(1 / sqrt(var(c(Y))), sqrt(8), 0.9, 0.01))
# run estimation and display the results
theta &lt;- optim(theta0, mlik)
print(data.frame(
  tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),
  nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),
  row.names = c("Truth", "Estimates")
))

</code></pre>


</div>