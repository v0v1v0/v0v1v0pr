<div class="container">

<table style="width: 100%;"><tr>
<td>copulaCorrection</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Linear Models Endogenous Regressors using Gaussian Copula</h2>

<h3>Description</h3>

<p>Fits linear models with continuous or discrete endogenous regressors (or a mixture of both) using Gaussian copulas, as presented in Park and Gupta (2012).
This is a statistical technique to address the endogeneity problem where no external instrumental variables are needed.
The important assumption of the model is that the endogenous variables should NOT be normally distributed, if continuous, preferably with a skewed distribution.
The corrections proposed by Qian, Koschmann, and Xie (2024, p.19-22) are implemented. These mitigate the bias of the original paper for small and moderate sample sizes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">copulaCorrection(formula, data, num.boots = 1000, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A symbolic description of the model to be fitted. See the "Details" section for the exact notation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing the data of all parts specified in the formula parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.boots</code></td>
<td>
<p>Number of bootstrapping iterations. Defaults to 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Show details about the running of the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments for the log-likelihood optimization function in the case of a single continuous endogenous
regressor. Ignored with a warning otherwise.
</p>

<dl>
<dt>start.params</dt>
<dd>
<p>A named vector containing a set of parameters to use in the first optimization iteration.
The names have to correspond exactly to the names of the components specified in the <code>formula</code> parameter.
If not provided, a linear model is fitted to derive them.</p>
</dd>
<dt>optimx.args</dt>
<dd>
<p>A named list of arguments which are passed to <code>optimx</code>. This allows users to tweak optimization settings to their liking.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Method</h4>

<p>The underlying idea of the joint estimation method is that using information contained in the observed data,
one selects marginal distributions for the endogenous regressor and the structural error term, respectively.
Then, the copula model enables the construction of a flexible multivariate joint distribution allowing a wide range
of correlations between the two marginals.
</p>
<p>Consider the model:
</p>
<br><div style="text-align:center">Y<sub>t</sub>=β<sub>0</sub>+β<sub>1</sub>P<sub>t</sub>+β<sub>2</sub>X<sub>t</sub>+ε<sub>t</sub>
</div>
<p>where <code class="reqn">t=1,..,T</code> indexes either time or cross-sectional units, Y<sub>t</sub> is a <code class="reqn">1x1</code> response variable,
X<sub>t</sub> is a <code class="reqn">kxn</code> exogenous regressor,
P<sub>t</sub> is a <code class="reqn">kx1</code> continuous endogenous regressor,
ε<sub>t</sub> is a normally distributed structural error term with mean zero and
E(ε<sup>2</sup>)=σ<sub>ε</sub><sup>2</sup>,
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are model parameters.
</p>
<p>The marginal distribution of the endogenous regressor P<sub>t</sub> is obtained using the Epanechnikov
kernel density estimator (Epanechnikov, 1969), as below:
</p>
<br><div style="text-align:center">ĥ(p)=1/(T·b) ∑(K·((p-P<sub>t</sub>)/b))</div>
<p>where P<sub>t</sub> is the endogenous regressor,
K(x)=0.75·(1-x<sup>2</sup>)·I(|x|&lt;=1)
and the bandwidth <code class="reqn">b</code> is the one proposed by Silverman (1986),
and is equal to b=0.9·T<sup>-1.5</sup>·min(s, IQR/1.34).
<code class="reqn">IQR</code> is the interquartile range while <code class="reqn">s</code> is the data sample standard deviation
and <code class="reqn">T</code> is the number of time periods observed in the data.
After obtaining the joint distribution of the error term and the continuous endogenous regressor, the model parameters are estimated using
maximum likelihood estimation.
</p>
<p>The additional parameters used during model fitting and printed in <code>summary</code> hence are:
</p>

<dl>
<dt><code>rho</code></dt>
<dd>
<p>The correlation between the endogenous regressor and the error.</p>
</dd>
<dt><code>sigma</code></dt>
<dd>
<p>The variance of the model's error.</p>
</dd>
</dl>
<p>With more than one continuous endogenous regressor or an endogenous discrete regressor, an alternative approach to the
estimation using Gaussian copula should be applied. This approach is similar to the control function approach (Petrin and Train, 2010).
The core idea is to apply OLS estimation on the original set of explanatory variables in the model equation above, plus an additional regressor
P<sub>t</sub>*=Φ<sup>-1</sup>(H(P<sub>t</sub>)).
Here, H(P<sub>t</sub>) is the marginal distribution of the endogenous regressor <code class="reqn">P</code>.
Including this regressor solves the correlation between the endogenous regressor and the structural error, <code class="reqn">\epsilon</code>,
OLS providing consistent parameter estimates. Due to identification problems, the discrete endogenous regressor cannot have a binomial
distribution.
</p>
<p>Hence, only in the case of a single continuous endogenous regressor maximum likelihood estimation is used.
In all other cases, augmented OLS based on Gaussian copula is applied. This includes cases of multiple endogenous regressors
of both discrete and continuous distributions.
</p>
<p>In the case of discrete endogenous regressors, a random seed needs to be assigned because the marginal distribution function of
the endogenous regressor is a step function in this case. This means that the value of P*
lies between 2 values, Φ<sup>-1</sup>(H(P<sub>t</sub>-1)) and
Φ<sup>-1</sup>(H(P<sub>t</sub>)).
However, the reported upper and lower bounds of the 95% bootstrapped confidence interval gives indication of the variance of the estimates.
</p>

<p>Since the inference procedure in both cases, augmented OLS and maximum likelihood, occurs in two stages (first the empirical distribution of the endogenous
regressor is computed and then used in constructing the likelihood function), the standard errors are not correct. Therefore, in both cases, the standard errors
and the confidence intervals are obtained based on the sampling distributions resulted from bootstrapping. Since the distribution of the bootstrapped parameters
is highly skewed, we report the percentile confidence intervals. Moreover, the variance-covariance matrix is also computed based on the bootstrapped
parameters, and not based on the Hessian.
</p>


<h4>Formula parameter</h4>

<p>The <code>formula</code> argument follows a two part notation:
</p>
<p>A two-sided formula describing the model (e.g. <code>y ~ X1 + X2 + P</code>) to be estimated and a
second right-hand side part in which the endogenous regressors and their distributional
assumptions are indicated (e.g. <code>continuous(P)</code>). These two parts are separated by a single vertical bar (<code>|</code>).
In the second part, the special functions <code>continuous</code>, <code>discrete</code>, or a combination
of both, are used to indicate the endogenous regressors and their respective distribution.
Both functions use the <code>...</code> parameter in which the respective endogenous regressors is specified.
</p>
<p>Note that no argument to <code>continuous</code> or <code>discrete</code> is to be supplied as character
but as symbols without quotation marks.
</p>
<p>See the example section for illustrations on how to specify the <code>formula</code> parameter.
</p>



<h3>Value</h3>

<p>For all cases, an object of classes <code>rendo.copula.correction</code>, <code>rendo.boots</code>, and <code>rendo.base</code> is returned
which is a list and contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>The formula given to specify the fitted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>terms</code></td>
<td>
<p>The terms object used for model fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>The model.frame used for model fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>A named vector of all coefficients resulting from model fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.main.coefs</code></td>
<td>
<p>a vector specifying which coefficients are from the model. For internal usage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.vars.continuous</code></td>
<td>
<p>The names of the continuous endogenous regressors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.vars.discrete</code></td>
<td>
<p>The names of the discrete endogenous regressors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>Fitted values at the found solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>The residuals at the found solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boots.params</code></td>
<td>
<p>The bootstrapped coefficients.</p>
</td>
</tr>
</table>
<p>For the case of a single continuous endogenous regressor, the returned object further
contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>start.params</code></td>
<td>
<p>A named vector with the initial set of parameters used to optimize the log-likelihood function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res.optimx</code></td>
<td>
<p>The result object returned by the function <code>optimx</code> after optimizing the log-likelihood function.</p>
</td>
</tr>
</table>
<p>For all other cases, the returned object further contains the following component:
</p>
<table><tr style="vertical-align: top;">
<td><code>res.lm.real.data</code></td>
<td>
<p>The linear model fitted on the original data together with generated p.star data.</p>
</td>
</tr></table>
<p>The function <code>summary</code> can be used to obtain and print a summary of the results.
Depending on the returned object, the generic accessor functions <code>coefficients</code>, <code>fitted.values</code>,
<code>residuals</code>, <code>vcov</code>, <code>logLik</code>, <code>AIC</code>, <code>BIC</code>, and <code>nobs</code> are available.
</p>


<h3>References</h3>

<p>Park, S. and Gupta, S., (2012), "Handling Endogenous Regressors by Joint Estimation Using Copulas", Marketing Science, 31(4), 567-86.
</p>
<p>Qian, Y., Koschmann, A., and Xie, H. (2024). "A Practical Guide to Endogeneity Correction Using Copulas". National Bureau of Economic Research, w32231.
</p>
<p>Epanechnikov V (1969). "Nonparametric Estimation of a Multidimensional Probability Density." Teoriya veroyatnostei i ee primeneniya, 14(1), 156–161.
</p>
<p>Silverman B (1986). "Density Estimation for Statistics and Data Analysis". CRC Monographs on Statistics and Applied Probability. London: Chapman &amp; Hall.
</p>
<p>Petrin A, Train K (2010). "A Control Function Approach to Endogeneity in Consumer Choice Models." Journal of Marketing Research, 47(1), 3–13.
</p>


<h3>See Also</h3>

<p><code>summary</code> for how fitted models are summarized
</p>
<p><code>vcov</code> for how the variance-covariance matrix is derived
</p>
<p><code>confint</code> for how confidence intervals are derived
</p>
<p><code>optimx</code> for possible elements of parameter <code>optimx.arg</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("dataCopCont")
data("dataCopCont2")
data("dataCopDis")
data("dataCopDis2")
data("dataCopDisCont")


## Not run: 
# Single continuous: log-likelihood optimization
c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P), num.boots=10, data=dataCopCont)
# same as above, with start.parameters and number of bootstrappings
c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P), num.boots=10, data=dataCopCont,
                       start.params = c("(Intercept)"=1, X1=1, X2=-2, P=-1))

# All following examples fit linear model with Gaussian copulas

# 2 continuous endogenous regressors
c2 &lt;- copulaCorrection(y~X1+X2+P1+P2|continuous(P1, P2),
                        num.boots=10, data=dataCopCont2)
# same as above
c2 &lt;- copulaCorrection(y~X1+X2+P1+P2|continuous(P1)+continuous(P2),
                        num.boots=10, data=dataCopCont2)

# single discrete endogenous regressor
d1 &lt;- copulaCorrection(y~X1+X2+P|discrete(P), num.boots=10, data=dataCopDis)

# two discrete endogenous regressor
d2 &lt;- copulaCorrection(y~X1+X2+P1+P2|discrete(P1)+discrete(P2),
                        num.boots=10, data=dataCopDis2)
# same as above but less bootstrap runs
d2 &lt;- copulaCorrection(y~X1+X2+P1+P2|discrete(P1, P2), num.boots = 10,
                       data=dataCopDis2)

# single discrete, single continuous
cd &lt;- copulaCorrection(y~X1+X2+P1+P2|discrete(P1)+continuous(P2),
                        num.boots=10, data=dataCopDisCont)

# For single continuous only: use own optimization settings (see optimx())
# set maximum number of iterations to 50'000
res.c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P),
                           optimx.args = list(itnmax = 50000),
                            num.boots=10, data=dataCopCont)

# print detailed tracing information on progress
 res.c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P),
                            optimx.args = list(control = list(trace = 6)),
                             num.boots=10, data=dataCopCont)

# use method L-BFGS-B instead of Nelder-Mead and print report every 50 iterations
 res.c1 &lt;- copulaCorrection(y~X1+X2+P|continuous(P),
                            optimx.args = list(method = "L-BFGS-B",
                                               control=list(trace = 2, REPORT=50)),
                             num.boots=10, data=dataCopCont)

# For coef(), the parameter "complete" determines if only the
# main model parameters or also the auxiliary coefficients are returned

c1.all.coefs &lt;- coef(res.c1) # also returns rho and sigma
# same as above
c1.all.coefs &lt;- coef(res.c1, complete = TRUE)

# only main model coefs
c1.main.coefs &lt;- coef(res.c1, complete = FALSE)


## End(Not run)

</code></pre>


</div>