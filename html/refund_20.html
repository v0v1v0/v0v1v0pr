<div class="container">

<table style="width: 100%;"><tr>
<td>ff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct a function-on-function regression term</h2>

<h3>Description</h3>

<p>Defines a term <code class="reqn">\int^{s_{hi, i}}_{s_{lo, i}} X_i(s)\beta(t,s)ds</code> for
inclusion in an <code>mgcv::gam</code>-formula (or <code>bam</code> or <code>gamm</code> or
<code>gamm4:::gamm4</code>) as constructed by <code>pffr</code>. <br> Defaults to a
cubic tensor product B-spline with marginal first order differences penalties
for <code class="reqn">\beta(t,s)</code> and numerical integration over the entire range
<code class="reqn">[s_{lo, i}, s_{hi, i}] = [\min(s_i), \max(s_i)]</code> by using Simpson
weights. Can't deal with any missing <code class="reqn">X(s)</code>, unequal lengths of
<code class="reqn">X_i(s)</code> not (yet?) possible. Unequal integration ranges for different
<code class="reqn">X_i(s)</code> should work. <code class="reqn">X_i(s)</code> is assumed to be numeric (duh...).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ff(
  X,
  yind = NULL,
  xind = seq(0, 1, l = ncol(X)),
  basistype = c("te", "t2", "ti", "s", "tes"),
  integration = c("simpson", "trapezoidal", "riemann"),
  L = NULL,
  limits = NULL,
  splinepars = if (basistype != "s") {
     list(bs = "ps", m = list(c(2, 1), c(2, 1)), k
    = c(5, 5))
 } else {
     list(bs = "tp", m = NA)
 },
  check.ident = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an n by <code>ncol(xind)</code> matrix of function evaluations
<code class="reqn">X_i(s_{i1}),\dots, X_i(s_{iS})</code>; <code class="reqn">i=1,\dots,n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yind</code></td>
<td>
<p><em>DEPRECATED</em> used to supply matrix (or vector) of indices of
evaluations of <code class="reqn">Y_i(t)</code>, no longer used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xind</code></td>
<td>
<p>vector of indices of evaluations of <code class="reqn">X_i(s)</code>,
i.e, <code class="reqn">(s_{1},\dots,s_{S})</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basistype</code></td>
<td>
<p>defaults to "<code>te</code>", i.e. a tensor product
spline to represent <code class="reqn">\beta(t,s)</code>. Alternatively, use <code>"s"</code> for
bivariate basis functions (see <code>mgcv</code>'s <code>s</code>) or
<code>"t2"</code> for an alternative parameterization of tensor product splines
(see <code>mgcv</code>'s <code>t2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integration</code></td>
<td>
<p>method used for numerical integration. Defaults to
<code>"simpson"</code>'s rule for calculating entries in <code>L</code>. Alternatively
and for non-equidistant grids, <code>"trapezoidal"</code> or <code>"riemann"</code>.
<code>"riemann"</code> integration is always used if <code>limits</code> is specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>optional: an n by <code>ncol(xind)</code> matrix giving the weights for
the numerical integration over <code class="reqn">s</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>
<p>defaults to NULL for integration across the entire range of
<code class="reqn">X(s)</code>, otherwise specifies the integration limits <code class="reqn">s_{hi}(t),
s_{lo}(t)</code>: either one of <code>"s&lt;t"</code> or <code>"s&lt;=t"</code> for
<code class="reqn">(s_{hi}(t), s_{lo}(t)) = (t, 0]</code> or <code class="reqn">[t, 0]</code>, respectively, or a
function that takes <code>s</code> as the first and <code>t</code> as the second
argument and returns TRUE for combinations of values <code>(s,t)</code> if
<code>s</code> falls into the integration range for the given <code>t</code>. This is
an experimental feature and not well tested yet; use at your own risk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splinepars</code></td>
<td>
<p>optional arguments supplied to the <code>basistype</code>-term.
Defaults to a cubic tensor product B-spline with marginal first difference
penalties, i.e. <code>list(bs="ps", m=list(c(2, 1), c(2,1)))</code>. See
<code>te</code> or <code>s</code> in <span class="pkg">mgcv</span> for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.ident</code></td>
<td>
<p>check identifiability of the model spec. See Details and
References. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>check.ident==TRUE</code> and <code>basistype!="s"</code>  (the default), the
routine checks conditions for non-identifiability of the effect.  This occurs
if a) the marginal basis for the functional covariate is rank-deficient
(typically because the functional covariate has lower rank than the spline
basis along its index) and simultaneously b) the kernel of Cov<code class="reqn">(X(s))</code> is
not disjunct from the kernel of the marginal penalty over <code>s</code>. In
practice, a) occurs quite frequently, and b) occurs usually because
curve-wise mean centering has removed all constant components from the
functional covariate. <br> If there is kernel overlap, <code class="reqn">\beta(t,s)</code> is
constrained to be orthogonal to functions in that overlap space (e.g., if the
overlap contains constant functions, constraints "<code class="reqn">\int \beta(t,s) ds =
0</code> for all t" are enforced). See reference for details.<br> A warning is
always given if the effective rank of Cov<code class="reqn">(X(s))</code> (defined as the number
of eigenvalues accounting for at least 0.995 of the total variance in
<code class="reqn">X_i(s)</code>) is lower than 4. If <code class="reqn">X_i(s)</code> is of very low rank,
<code>ffpc</code>-term may be preferable.
</p>


<h3>Value</h3>

<p>A list containing </p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>a "call" to
<code>te</code> (or <code>s</code> or <code>t2</code>)
using the appropriately constructed covariate and weight matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a list containing the necessary covariate and weight matrices</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Fabian Scheipl, Sonja Greven
</p>


<h3>References</h3>

<p>For background on <code>check.ident</code>:<br> Scheipl, F., Greven,
S. (2016). Identifiability in penalized function-on-function regression
models. Electronic Journal of Statistics, 10(1), 495â€“526.
<a href="https://projecteuclid.org/journals/electronic-journal-of-statistics/volume-10/issue-1/Identifiability-in-penalized-function-on-function-regression-models/10.1214/16-EJS1123.full">https://projecteuclid.org/journals/electronic-journal-of-statistics/volume-10/issue-1/Identifiability-in-penalized-function-on-function-regression-models/10.1214/16-EJS1123.full</a>
</p>


<h3>See Also</h3>

<p><code>mgcv</code>'s <code>linear.functional.terms</code>
</p>


</div>