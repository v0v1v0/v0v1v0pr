<div class="container">

<table style="width: 100%;"><tr>
<td>Interpolation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Interpolation</h2>

<h3>Description</h3>

<p>Some interpolation methods are available to be used as part of 'RTMB' objective functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">interpol1Dfun(z, xlim = c(1, length(z)), ...)

interpol2Dfun(z, xlim = c(1, nrow(z)), ylim = c(1, ncol(z)), ...)

## S4 method for signature 'ANY,advector,ANY,missing'
splinefun(x, y, method = c("fmm", "periodic", "natural"))

## S4 method for signature 'advector,missing,ANY,missing'
splinefun(x, method = c("fmm", "periodic", "natural"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Matrix to be interpolated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>Domain of x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Configuration parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>Domain of y</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>spline x coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>spline y coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Same as for the stats version, however only the three first are available.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>interpol1Dfun</code> and <code>interpol2Dfun</code> are kernel smoothers useful in the case where you need a 3rd order <em>smooth</em> representation of a <em>data</em> vector or matrix.
A typical use case is when a high-resolution map needs to be accessed along a random effect trajectory.
Both 1D and 2D cases accept an 'interpolation radius' parameter (default R=2) controlling the degree of smoothness. Note, that only the value R=1 will match the data exactly, while higher radius trades accuracy for smoothness. Note also that these smoothers do not attempt to extrapolate: The returned value will be <code>NaN</code> outside the valid range (<code>xlim</code> / <code>ylim</code>).
</p>
<p><code>splinefun</code> imitates the corresponding <code>stats</code> function. The AD implementation (in contrast to <code>interpol1Dfun</code>) works for parameter dependent y-coordinates.
</p>


<h3>Value</h3>

<p>function of x.
</p>
<p>function of x and y.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>interpol1Dfun()</code>: Construct a kernel smoothed representation of a vector.
</p>
</li>
<li> <p><code>interpol2Dfun()</code>: Construct a kernel smoothed representation of a matrix.
</p>
</li>
<li> <p><code>splinefun(x = ANY, y = advector, method = ANY, ties = missing)</code>: Construct a spline function.
</p>
</li>
<li> <p><code>splinefun(x = advector, y = missing, method = ANY, ties = missing)</code>: Construct a spline function.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## ======= interpol1D
## R=1 =&gt; exact match of observations
f &lt;- interpol1Dfun(sin(1:10), R=1)
layout(t(1:2))
plot(sin(1:10))
plot(f, 1, 10, add=TRUE)
title("R=1")
F &lt;- MakeTape(f, 0)
F3 &lt;- F$jacfun()$jacfun()$jacfun()
plot(Vectorize(F3), 1, 10)
title("3rd derivative")
## ======= interpol2D
## R=1 =&gt; exact match of observations
f &lt;- interpol2Dfun(volcano, xlim=c(0,1), ylim=c(0,1), R=1)
f(0,0) == volcano[1,1]   ## Top-left corner
f(1,1) == volcano[87,61] ## Bottom-right corner
## R=2 =&gt; trades accuracy for smoothness
f &lt;- interpol2Dfun(volcano, xlim=c(0,1), ylim=c(0,1), R=2)
f(0,0) - volcano[1,1]    ## Error Top-left corner
F &lt;- MakeTape(function(x) f(x[1],x[2]), c(.5,.5))
## ======= splinefun
T &lt;- MakeTape(function(x){
   S &lt;- splinefun(sin(x))
   S(4:6)
}, 1:10)
</code></pre>


</div>