<div class="container">

<table style="width: 100%;"><tr>
<td>ValueObject</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Value Object Pattern</h2>

<h3>Description</h3>

<p>Model a domain concept using natural lingo of the domain
experts, such as "Passenger", "Address", and "Money".
</p>


<h3>Usage</h3>

<pre><code class="language-R">ValueObject(given = NA_character_, family = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>given</code></td>
<td>
<p>(<code>character</code>) A character vector with the given name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>(<code>character</code>) A character vector with the family name.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>&lt;div class="alert alert-danger"&gt;
**Caution:** ValueObject is designed for demonstration purposes. Instead of directly using the design pattern as it appears in the package, you'd have to adjust the source code to the problem you are trying to solve.
&lt;/div&gt;
&lt;!– One line about what the function does –&gt;
</p>
<p>A <strong>Value Object</strong> models a domain concept using natural lingo of the domain
experts, such as "Passenger", "Address", and "Money".
</p>
<p>Any <strong>Value Object</strong> is created by a function that receives input, applies some
transformations, and outputs the results in some data structure such as a
vector, a list or a data.frame.
</p>


<h4>How It Works</h4>

<p>In R, a good option for creating a <strong>Value Object</strong> is to follow two
instructions:
</p>

<ul>
<li>
<p> A <strong>Value Object</strong> is created by a <code>function</code>, rather than a class method;
and
</p>
</li>
<li>
<p> A <strong>Value Object</strong> returns a <code>tibble</code>, rather than a list or a vector.
</p>
</li>
</ul>
<p>In essence, a <strong>Value Object</strong> is a data type, like <code>integer</code>, <code>logical</code>, <code>Date</code>
or <code>data.frame</code> data types to name a few. While the built-in data types in R fit
any application, <strong>Value Objects</strong> are domain specific and as such, they fit
only to a specific application. This is because, <code>integer</code> is an abstract that
represent whole numbers. This abstract is useful in any application. However, a
<strong>Value Object</strong> represent a high-level abstraction that appears in a particular
domain.
</p>
<p>An example of a <strong>Value Object</strong> is the notion of a "Person". Any person in the
world has a name. Needless to say, a person name is spelt by letters, rather
than numbers. A <strong>Value Object</strong> captures these attribute as <code>tibble</code> columns
and type checks:
</p>
<div class="sourceCode r"><pre>Person &lt;- function(given = NA_character_, family = NA_character_){
  stopifnot(is.character(given), is.character(family))
  stopifnot(length(given) == length(family))
  
  return(
    tibble::tibble(given = given, family = family)
    %&gt;% tidyr::drop_na(given)
  )
}
</pre></div>
<p>Instantiating a person <strong>Value Object</strong> is done by calling the <code>Person</code>
constructor function:
</p>
<div class="sourceCode r"><pre>person &lt;- Person(given = "Bilbo", family = "Baggins")
</pre></div>
<p>Getting to know the advantages of a <strong>Value Object</strong>, we should consider the
typical alternative – constructing a Person by using the <code>tibble</code> function
directly:
</p>
<div class="sourceCode r"><pre>person &lt;- tibble::tibble(given = "Bilbo", family = "Baggins")
</pre></div>
<p>Both implementations return objects with identical content and structure, that
is, their column names, column types and cell values are identical. Then, why
would one prefer using a <strong>Value Object</strong> and its constructor over the direct
alternative?
</p>
<p>There are four predominant qualities offered by the <strong>Value Object</strong> pattern
which are not offered by the alternative:
</p>

<ol>
<li>
<p> Readability. Each <strong>Value Object</strong> captures a concept belonging to the
problem domain. Rather than trying to infer what a <code>tibble</code> is by looking at
its low-level details, the <strong>Value Object</strong> constructor descries a context
on a high-level.
</p>
</li>
<li>
<p> Explicitness. Since the constructor of the <strong>Value Object</strong> is a function,
its expected input arguments and their type can be detailed in a helper
file. Moreover, assigning input arguments with default values of specific
type, such as <code>NA</code> (logical NA), <code>NA_integer_</code>, <code>NA_character_</code>, or
<code>NA_Date</code> (see <code>lubridate::NA_Date</code>), expresses clearly the variable types
of the <strong>Value Object</strong>.
</p>
</li>
<li>
<p> Coherence. The representation of a <strong>Value Object</strong> is concentrated in one
place – its constructor. Any change, mainly modifications and extensions,
applied to the constructor promise the change would propagate to all
instances of the Value Objects. That means, no structure discrepancies
between instances that are supposed to represent the same concept.
</p>
</li>
<li>
<p> Safety. The constructor may start with <a href="https://en.wikipedia.org/wiki/Defensive_programming">defensive programming</a> to ensure
the qualities of its input. One important assertion is type checking. Type
checking eliminated the risk of implicit type coercing. Another important
assertion is checking if the lengths of the input arguments meet some
criteria, say all inputs are of the same length, or more restrictively, all
inputs are scalars. Having a set of checks makes the code base more robust.
This is because <strong>Value Objects</strong> are regularly created with the output of
other functions calls, having a set of checks serves as pseudo-tests of
these functions output throughout the code.
</p>
</li>
</ol>
<p>In addition to these qualities, there are two desirable behaviours which are not
offered by directly calling <code>tibble</code>:
</p>

<ol>
<li>
<p> Null Value Object. Calling the <strong>Value Object</strong> constructor with no input
arguments returns the structure of the <code>tibble</code> (column names and column
types).
</p>
</li>
<li>
<p> Default values for missing input arguments. In this manner, the <strong>Value
Object</strong> has a well-defined behaviour for a person without a family name,
such as Madonna and Bono.
</p>
</li>
</ol>
<p>In addition to native R data types, a <strong>Value Object</strong> constructor can receive
other <strong>Value Objects</strong> as input arguments. Here are two examples that transmute
Person to other Person-based concepts:
</p>
<div class="sourceCode r"><pre># A Passenger is a Person with a flight booking reference
Passenger &lt;- function(person = Person(), booking_reference = NA_character_){
  stopifnot(all(colnames(person) %in% colnames(Person())))
  stopifnot(is.character(booking_reference))
  
  return(
    person 
    %&gt;% tibble::add_column(booking_reference = booking_reference)
    %&gt;% tidyr::drop_na(booking_reference)
  )
}

person &lt;- Person(given = "Bilbo", family = "Baggins")
passenger &lt;- Passenger(person = person, booking_reference = "B662HR")
print(passenger)
#&gt; # A tibble: 1 × 3
#&gt;   given family  booking_reference
#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;            
#&gt; 1 Bilbo Baggins B662HR
</pre></div>
<div class="sourceCode r"><pre># A Diner is a Person that may have dinner reservation
Diner &lt;- function(person = Person(), reservation_time = NA_POSIXct_){
  stopifnot(all(colnames(person) %in% colnames(Person())))
  stopifnot(is.POSIXct(reservation_time))
  
  return(
    person 
    %&gt;% tibble::add_column(reservation_time = reservation_time)
  )
}

person &lt;- Person(given = "Bilbo", family = "Baggins")
timestamp &lt;- as.POSIXct("2021-01-23 18:00:00 NZDT")
diner &lt;- Diner(person = person, reservation_time = timestamp)
print(diner)
#&gt; # A tibble: 1 × 3
#&gt;   given family  reservation_time   
#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;dttm&gt;             
#&gt; 1 Bilbo Baggins 2021-01-23 18:00:00
</pre></div>



<h4>When to Use It</h4>


<ul>
<li>
<p> In situations where domain concepts are more important then the database
schema. For example, when you are modelling Passengers, your first instinct
might be to think about the different data sources you'd need for the
analysis. You may envision "FlightDetails" and "CustomerDetails". Next you
will define the relationship between them. Instead, let the domain drive the
design. Create a Passenger <strong>Value Object</strong> with the attributes you must
have, regardless of any particular database schema.
</p>
</li>
<li>
<p> In a function that runs within a specific context. Rather than having an
input argument called <code>data</code> of type <code>data.frame</code>, use the appropriate
<strong>Value Object</strong> name and pass it its constructor.
</p>
</li>
</ul>
<div class="sourceCode r"><pre>Audience &lt;- Person

## Without a Value Object
clean_audience_data &lt;- function(data) 
  dplyr::mutate(.data = data, given = stringr::str_to_title(given))

## With a Value Object
clean_audience_data &lt;- function(attendees = Audience()) 
  dplyr::mutate(.data = attendees, given = stringr::str_to_title(given))
</pre></div>

<ul><li>
<p> In <a href="https://en.wikipedia.org/wiki/Pipeline_(software)">pipes and filters</a>
architecture.
</p>
</li></ul>
<p>&lt;div class="alert alert-warning"&gt;
**Note:** **Value Objects** do not need to have unit-tests. This is because of two reasons: 
(1) **Value Objects** are often called by other functions that are being tested. That means, **Value Objects** are implicitly tested. 
(2) **Value Objects** are data types similarly to 'data.frame' or 'list'. As such, they need no testing
&lt;/div&gt;
</p>



<h3>See Also</h3>

<p>Other base design patterns: 
<code>NullObject()</code>,
<code>Singleton</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># See more examples at &lt;https://tidylab.github.io/R6P/articles&gt;

# In this example we are appointing elected officials to random ministries, just
# like in real-life.
Person &lt;- ValueObject
Person()

# Create a test for objects of type Person
# * Extract the column names of Person by using its Null Object (returned by Person())
# * Check that the input argument has all the columns that a Person has
is.Person &lt;- function(x) all(colnames(x) %in% colnames(Person()))

# A 'Minister' is a 'Person' with a ministry title. We capture that information
# in a new Value Object named 'Minister'.
# The Minister constructor requires two inputs:
# 1. (`Person`) Members of parliament
# 2. (`character`) Ministry titles
Minister &lt;- function(member = Person(), title = NA_character_){
    stopifnot(is.Person(member), is.character(title))
    stopifnot(nrow(member) == length(title) | all(is.na(title)))

    member %&gt;% dplyr::mutate(title = title)
}

# Given one or more parliament members
# When appoint_random_ministries is called
# Then the parliament members are appointed to an office.
appoint_random_ministries &lt;- function(member = Person()){
    positions &lt;- c(
        "Arts, Culture and Heritage", "Finance", "Corrections",
        "Racing", "Sport and Recreation", "Housing", "Energy and Resources",
        "Education", "Public Service", "Disability Issues", "Environment",
        "Justice", "Immigration", "Defence", "Internal Affairs", "Transport"
    )

   Minister(member = member, title = sample(positions, size = nrow(member)))
}

# Listing New Zealand elected officials in 2020, we instantiate a Person Object,
# appoint them to random offices and return a Member value object.
set.seed(2020)

parliament_members &lt;- Person(
    given = c("Jacinda", "Grant",     "Kelvin", "Megan", "Chris",   "Carmel"),
    family = c("Ardern", "Robertson", "Davis",  "Woods", "Hipkins", "Sepuloni")
)

parliament_members

appoint_random_ministries(member = parliament_members)
</code></pre>


</div>