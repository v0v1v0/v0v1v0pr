<div class="container">

<table style="width: 100%;"><tr>
<td>pred_succ</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predecessor and Successor Functions</h2>

<h3>Description</h3>

<p>Functions for traversing the BTG (Better-Than-Graph or Hasse diagram) of a preference.
</p>


<h3>Usage</h3>

<pre><code class="language-R">init_pred_succ(p, df = NULL)

hasse_pred(p, v, intersect = FALSE)

hasse_succ(p, v, intersect = FALSE)

all_pred(p, v, intersect = FALSE)

all_succ(p, v, intersect = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>A preference. Worse tuples in the induced order are successors and better tuples are predecessors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>(optional) A data frame characterizing the set wherein predecessors/successors are searched. 
If <code>df</code> is <code>NULL</code> then the data frame associated with the preference is used.
Causes an error if <code>df == NULL</code> and no data frame is associated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>A numeric vector of indices in <code>df</code>. This represents the set of tuples for which predecessors/successors are searched.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intersect</code></td>
<td>
<p>(optional) Logical value. 
If it is <code>FALSE</code> (by default) the union of all predecessors/successors of <code>v</code> is returned.
For <code>intersect = TRUE</code> the intersection of those values is returned.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions return the predecessors and successors in the Better-Than-Graph of a preference.
Note that the successors/predecessors can can be plotted via <code>get_btg</code>. 
Before any of the successor/predecessor functions can be used the initialization has to be called as follows:
</p>
<p><code>init_pred_succ(p, df)</code>
</p>
<p>There <code>p</code> is a preference object and <code>df</code> a data frame. 
When this done, the data frame <code>df</code> is associated with <code>p</code>, i.e.,
implicitly <code>assoc.df</code> is called. 
If the preference has already an associated data frame, <code>df</code> can be omitted. For example
</p>
<p><code>p &lt;- low(mpg, df = mtcars)</code> <br><code>init_pred_succ(p)</code>
</p>
<p>does the initialization of the preference <code>low(mpg)</code> on the data set <code>mtcars</code>.
</p>
<p>The <code>init_pred_succ</code> function calculates the Better-Than-Relation on <code>df</code> w.r.t. <code>p</code>. 
Afterwards the predecessor and successor functions, as subsequently described, can be called. 
The value of <code>v</code> is a numeric vector within <code>1:nrow(df)</code> 
and characterizes a subset of tuples in <code>df</code>. 
The return value of these functions is again a numeric vector referring to the row numbers in <code>df</code> 
and it is always ordered ascending, independently of the order of the indices in <code>v</code>.
</p>

<dl>
<dt><code>all_pred(p, v)</code></dt>
<dd>
<p>Returns all predecessors of <code>v</code>, i.e., indices of better tuples than <code>v</code>.</p>
</dd>
<dt><code>all_succ(p, v)</code></dt>
<dd>
<p>Returns all successors of <code>v</code>, i.e., indices of worse tuples than <code>v</code>.</p>
</dd>
<dt><code>hasse_pred(p, v)</code></dt>
<dd>
<p>Returns the direct predecessors of <code>v</code>, 
i.e., indices of better tuples than <code>v</code> where the better-than-relation is contained in the transitive reduction.</p>
</dd>
<dt><code>hasse_succ(p, v)</code></dt>
<dd>
<p>Returns the direct successors of <code>v</code>, 
i.e., indices of worse tuples than <code>v</code> where the better-than-relation is contained in the transitive reduction.</p>
</dd>
</dl>
<p>If <code>v</code> has length 1, then the value of <code>intersect</code> does not matter, as there is nothing to intersect or join. 
For scalar values <code>x</code> and <code>y</code> the following identities hold, where <code>f</code> is one of the predecessor/successor functions:
</p>
<p><code>f(p, c(x, y), intersect = FALSE) == union(f(p, x), f(p, y))</code>
</p>
<p><code>f(p, c(x, y), intersect = TRUE) == intersect(f(p, x), f(p, y))</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Preference on mtcars for high mpg and low weight
p &lt;- high(mpg) * low(wt)
init_pred_succ(p, mtcars)

# Helper to show mpg/hp values
show_vals &lt;- function(x) mtcars[x,c('mpg','wt')]

# Pick some tuple "in the middle":
show_vals(10)

# Show (direct) predecessors/successors of tuple 10:
show_vals(hasse_pred(p, 10)) # Next better car
show_vals(hasse_succ(p, 10)) # Next worse car
show_vals(all_pred(p, 10))   # All better cars
show_vals(all_succ(p, 10))   # All worse cars
</code></pre>


</div>