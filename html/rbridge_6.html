<div class="container">

<table style="width: 100%;"><tr>
<td>cv.bridge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for bridge</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation for bridge, produces a plot, and returns a value for lambda
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.bridge(X, y, q, lambda, nfolds = 10, lambda.min = ifelse(n &gt; p,
  0.001, 0.05), nlambda = 100, eta = 1e-07, converge = 10^10,
  num_threads = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>X</code> matrix as in bridge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response <code>y</code> as in bridge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>is the degree of norm which includes ridge regression with <code>q=2</code> and lasso estimates with <code>q=1</code> as special cases</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>lambda sequence; default is NULL. It is given by user or <code>cv.rbridge</code> chooses its own sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of folds - default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>The smallest value for lambda if <code>n&gt;p</code> is <code>0.001</code> and <code>0.05</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of lambda values - default is <code>100</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>is a preselected small positive threshold value. It is deleted <code>jth</code> variable to make the algorithm stable and also is excluded <code>jth</code> variable from the final model. Default is <code>1e-07</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge</code></td>
<td>
<p>is the value of converge. Defaults is <code>10^10</code>. In each iteration, it is calculated by sum of square the change in linear predictor for each coefficient. The algorithm iterates until <code>converge &gt; eta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_threads</code></td>
<td>
<p>Number of threads used for parallel computation over the folds,</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes bridge
</p>


<h3>Value</h3>

<p>An object of class rbridge, a list with entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cve</code></td>
<td>
<p>the mean cross-validated error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvse</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvup</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlo</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nz</code></td>
<td>
<p>number of non-zero coefficients at each <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betas</code></td>
<td>
<p>estimated coefficient at each <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>value of lambda that gives minimum <code>cve</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p>largest value of <code>lambda</code> such that error is within 1 standard error of the minimum</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Bahadir Yuzbasi, Mohammad Arashi and Fikri Akdeniz <br> Maintainer: Bahadir Yuzbasi <a href="mailto:b.yzb@hotmail.com">b.yzb@hotmail.com</a>
</p>


<h3>See Also</h3>

<p><code>bridge</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(2019) 
beta &lt;- c(3, 1.5, 0, 0, 2, 0, 0, 0)
p &lt;- length(beta)
beta &lt;- matrix(beta, nrow = p, ncol = 1)

n = 100
X = matrix(rnorm(n*p),n,p)
y = X%*%beta + rnorm(n) 

######## Model 1 
model1 &lt;- cv.bridge(X, y, q = 1)
print(model1)
coef(model1,s='lambda.min')
predict(model1,newx=X[1:5,], s="lambda.min", type="response")
predict(model1, s="lambda.min",type="coefficient")

######## Model 2 
model2 &lt;- cv.bridge(X, y, q = 2)
print(model2)
coef(model2,s='lambda.min')
predict(model2,newx=X[1:5,], s="lambda.min", type="response")
predict(model2, s="lambda.min",type="coefficient")

</code></pre>


</div>