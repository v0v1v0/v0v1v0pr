<div class="container">

<table style="width: 100%;"><tr>
<td>tsgen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Artificial light curve generator
</h2>

<h3>Description</h3>

<p>This function generates light curves (special time series) with unequally sampled observation times, different periodicities both in sampling and observed values, with white and power law (red) noise in the observed values and possibly disturbed observations.
See <code>RobPer-package</code> for more information about light curves and also Thieler, Fried and Rathjens (2016) for more details in general.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tsgen(ttype, ytype, pf, redpart, s.outlier.fraction = 0, interval, npoints,
 ncycles, ps, SNR, alpha = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ttype</code></td>
<td>

<p>character string: Specifying the sampling pattern. Possible choices are <code>"equi"</code> for equidistant sampling without gaps (unperiodic), <code>"unif"</code> for uniform non-equidistant unperiodic sampling, <code>"sine"</code> for sampling with periodic sine density, <code>"trian"</code> for sampling with periodic triangular density, both with period <code class="reqn">p_s</code> (see Details and <code>sampler</code>). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ytype</code></td>
<td>

<p>character string: Specifying the shape of the periodic fluctuation with period <code class="reqn">p_f</code>. Possible choices are <code>"const"</code> for constantly being zero (so no periodicity), <code>"sine"</code> for a sine, <code>"trian"</code> for a periodic triangular function, <code>"peak"</code> for a peak function (see Details and <code>signalgen</code> for more details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>

<p>positive number: Period <code class="reqn">p_f</code> of the periodic fluctuation, argument of <code>signalgen</code> (see Details and <code>signalgen</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redpart</code></td>
<td>

<p>numeric value in [0,1]: Proportion of the power law noise in noise components (see Details). The generated measurement accuracies <code class="reqn">s_i</code> do not contain information about this noise component. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.outlier.fraction</code></td>
<td>

<p>numeric value in [0,1]: Fraction of measurement accuracies to be replaced by outliers. A value of 0 means that no measurement accuracy is replaced by an outlier (for more details see <code>disturber</code>). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>

<p>logical: If <code>TRUE</code>, the observed values belonging to a random time interval of length 3<code class="reqn">p_s</code> are replaced by atypical values (for more details see <code>disturber</code>).  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npoints</code></td>
<td>

<p>integer value: Defines the sample size <code class="reqn">n</code> for the generated light curve.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncycles</code></td>
<td>

<p>integer value: number <code class="reqn">n_s</code> of sampling cycles that is observed (see Details). 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps</code></td>
<td>

<p>positive number: Sampling period <code class="reqn">p_s</code>, influencing the sampling and how the light curve is disturbed (see Details and <code>disturber</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SNR</code></td>
<td>

<p>positive number: Defines the relation between signal <code class="reqn">y_f</code> and noise <code class="reqn">y_w+y_r</code> (see Details).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>

<p>numeric value: Power law index <code class="reqn">\alpha</code> for the power law noise component <code class="reqn">y_r</code> (see Details). 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>tsgen</code> generates an artificial light curve consisting of observation times <code class="reqn">t_1,\ldots,t_n</code>, observation values <code class="reqn">y_1,\ldots,y_n</code> and measurement accuracies <code class="reqn">s_1,\ldots,s_n</code>. It calls several subfunctions (see there for details):
</p>
<p><code>sampler</code>  is used to sample observation times <code class="reqn">t_1,\ldots,t_n</code> in the interval <code class="reqn">[0,n_s*p_s]</code> with a possibly periodic sampling of period <code class="reqn">p_s</code>.
</p>
<p><code>signalgen</code> generates periodically varying values <code class="reqn">y_{f;1},\ldots,y_{f;n}</code> at time points <code class="reqn">t_1,\ldots,t_n</code> with fluctuation period <code class="reqn">p_f</code>.
</p>
<p><code>lc_noise</code>  samples measurement accuracies <code class="reqn">s_1,\ldots,s_n</code> 
from a Gamma(3,10)-distribution and a white noise component 
<code class="reqn">y_{w;1},\ldots,y_{w;n}</code> with from <code class="reqn">\mathcal N(0,s_i^2)</code> distributions. A second noise component <code class="reqn">y_{r;1},\ldots,y_{r;n}</code> does not depend on the <code class="reqn">s_i</code>. It is generated as red noise, i.e. following a power law with power law index <code class="reqn">\alpha</code>. For white noise choose <code class="reqn">\alpha=0</code>, for flicker noise (pink noise) <code class="reqn">\alpha=1</code>, for brown noise <code class="reqn">\alpha=2</code>. The power law noise is generated using <code>TK95_uneq</code> and <code>TK95</code>. The noise components are scaled so that the variance of the <code class="reqn">y_{r;i}</code> has approximately the proportion <code>redpart</code> in the overall noise variance and that <code>SNR</code> is the ratio <code class="reqn">var(y_f)/var(y_w+y_r)</code>. The observed values are set to <code class="reqn">y_i= y_{f;i}+y_{w;i}+y_{r;i} \forall i</code>.
</p>
<p><code>disturber</code> disturbes the light curve replacing measurement accuracies 
<code class="reqn">s_i</code> by outliers (if <code>s.outlier.fraction&gt;0</code>) and observed values 
<code class="reqn">y_i</code> by atypical values (if <code>interval=TRUE</code>). 
In case of <code>s.outlier.fraction=0</code> and <code>interval=FALSE</code>, the function returns all values unchanged.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tt</code></td>
<td>
<p>numeric vector: Generated observation times<code class="reqn">\ t_1,\ldots,t_n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric vector: Generated observation values<code class="reqn">\ y_1,\ldots,y_n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>numeric vector: Generated measurement accuracies<code class="reqn">\ s_1,\ldots,s_n</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Note that the white noise components' variances are exactly <code class="reqn">s_i^2</code>, so the <code class="reqn">s_i</code> are no estimates, but true values. In this sense, the measurement accuracies of a generated light curve are more informative than for real light curves, where the measurement accuracies are estimates, see Thieler et al. (2013), where also a former version of this function is applied. 
</p>
<p>To lower the informativity of the measurement accuracies, set <code>redpart</code> to a strictly positive value, possibly with <code>alpha=0</code> if no other noise components than white ones are required.
</p>


<h3>Author(s)</h3>

<p>Anita M. Thieler and Jonathan Rathjens
</p>


<h3>References</h3>

<p>Thieler, A. M., Backes, M., Fried, R. and Rhode, W. (2013): Periodicity Detection in Irregularly Sampled Light Curves by Robust Regression and Outlier Detection. Statistical Analysis and Data Mining, 6 (1), 73-89
</p>
<p>Thieler, A. M., Fried, R. and Rathjens, J. (2016): RobPer: An R Package to Calculate Periodograms for Light Curves Based on Robust Regression. Journal of Statistical Software, 69 (9), 1-36, &lt;doi:10.18637/jss.v069.i09&gt;
</p>


<h3>See Also</h3>

<p>Applies <code>sampler</code>, <code>signalgen</code>, <code>lc_noise</code>, <code>disturber</code>, <code>TK95</code>, <code>TK95_uneq</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate a light curve:
set.seed(22)
lightcurve&lt;- tsgen(ttype="sine", ytype="peak" , pf=7, redpart=0.1, s.outlier.fraction=0, 
    interval=FALSE, npoints=200, ncycles=100, ps=5, SNR=3, alpha=0)

# Or do it step by step:
# First sampling observation times:
set.seed(22)
tt &lt;- sampler(ttype="sine", npoints=200, ncycles=100, ps=5)

# show obviously irregular observation times as grey vertical bars on a red time line:
plot(tt, tt*0, type="n", axes=FALSE, xlab="Observation Times", ylab="")
    abline(v=tt, col="grey")
axis(1, pos=0, col="red", col.axis="red")

# Sampling period is 5, look at observation times modulo 10:
hist(tt%%5, xlab="Observation time modulo 5", 
    main="Sine Distribution for the phase (tt modulo 5)", freq=FALSE)
dsin &lt;- function(tt) 0.2*(sin(2*pi*tt/5)+1)
curve(dsin, add=TRUE)

# Then generate periodic fluctuation
yf &lt;- signalgen(tt, ytype="peak", pf=7)

plot(tt, yf, xlab="Observation Times", ylab="Periodic Fluctuation")
plot(tt%%7, yf, main="Phase Diagram (time modulo 7)", 
    xlab="Observation time modulo 7",  ylab="Periodic Fluctuation")

# Add noise and scale signal to the right SNR
temp &lt;- lc_noise(tt,sig=yf, SNR=3, redpart=0.1, alpha=0)
y &lt;- temp$y
s &lt;- temp$s

# Plotting the light curve (vertical bars show measurement accuracies)
plot(tt, y, pch=16, cex=0.5, xlab="t", ylab="y", main="a Light Curve")
rect(tt, y+s, tt, y-s)

# The lightcurve has period 7:
plot(tt%%7, y, pch=16, cex=0.5, xlab="t", ylab="y", 
    main="Phase Diagram of a Light Curve")
rect(tt%%7, y+s, tt%%7, y-s)

# replace measurement accuracies by tiny outliers or include a peak
temp &lt;- disturber(tt,y,s,ps=5, s.outlier.fraction=0, interval=FALSE)

# Phase diagram (observation times modulo 10)
plot(tt%%7, temp$y, pch=16, cex=0.5, xlab="t", ylab="y", 
    main="Phase Diagram of a Light Curve")
rect(tt%%7, temp$y+temp$s, tt%%7, temp$y-temp$s)

# The result is the same:
all(cbind(tt,temp$y,temp$s)==lightcurve)
</code></pre>


</div>