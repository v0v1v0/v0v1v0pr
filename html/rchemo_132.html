<div class="container">

<table style="width: 100%;"><tr>
<td>lwplsr_agg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregation of KNN-LWPLSR models with different numbers of LVs</h2>

<h3>Description</h3>

<p>Ensemblist method where the predictions are calculated by averaging the predictions of KNN-LWPLSR models (<code>lwplsr</code>) built with different numbers of latent variables (LVs). 
</p>
<p>For instance, if argument <code>nlv</code> is set to <code>nlv = "5:10"</code>, the prediction for a new observation is the simple average of the predictions returned by the models with 5 LVS, 6 LVs, ... 10 LVs, respectively. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">
lwplsr_agg(
    X, Y,
    nlvdis, diss = c("eucl", "mahal"),
    h, k,
    nlv,
    cri = 4,
    verb = FALSE
    )

## S3 method for class 'Lwplsr_agg'
predict(object, X, ...)  

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>For the main function: Training X-data (<code class="reqn">n, p</code>). â€” For the auxiliary function: New X-data (<code class="reqn">m, p</code>) to consider.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Training Y-data (<code class="reqn">n, q</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlvdis</code></td>
<td>
<p>The number of LVs to consider in the global PLS used for the dimension reduction before calculating the dissimilarities. If <code>nlvdis = 0</code>, there is no dimension reduction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diss</code></td>
<td>
<p>The type of dissimilarity used for defining the neighbors. Possible values are "eucl" (default; Euclidean distance), "mahal" (Mahalanobis distance), or "correlation". Correlation dissimilarities are calculated by sqrt(.5 * (1 - rho)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>A scale scalar defining the shape of the weight function. Lower is <code class="reqn">h</code>, sharper is the function. See <code>wdist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of nearest neighbors to select for each observation to predict.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlv</code></td>
<td>
<p>A character string such as "5:20" defining the range of the numbers of LVs to consider (here: the models with nb LVS = 5, 6, ..., 20 are averaged). Syntax such as "10" is also allowed (here: correponds to the single model with 10 LVs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cri</code></td>
<td>
<p>Argument <code>cri</code> in function <code>wdist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p>Logical. If <code>TRUE</code>, fitting information are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>For the auxiliary function: A fitted model, output of a call to the main function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For the auxiliary function: Optional arguments. Not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>lwplsr_agg</code>: object of class <code>Lwplsr_agg</code>
</p>
<p>For <code>predict.Lwplsr_agg</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>prediction calculated for each observation, which is the most occurent level (vote) over the predictions returned by the models with different numbers of LVS respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listnn</code></td>
<td>
<p>list with the neighbors used for each observation to be predicted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listd</code></td>
<td>
<p>list with the distances to the neighbors used for each observation to be predicted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>list with the weights attributed to the neighbors used for each observation to be predicted</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>In the examples, <code>gridscore</code> and <code>gricv</code> have been used as there is no sense to use <code>gridscorelv</code> and <code>gricvlv</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## EXAMPLE 1

n &lt;- 30 ; p &lt;- 10
Xtrain &lt;- matrix(rnorm(n * p), ncol = p)
ytrain &lt;- rnorm(n)
Ytrain &lt;- cbind(ytrain, 100 * ytrain)
m &lt;- 4
Xtest &lt;- matrix(rnorm(m * p), ncol = p)
ytest &lt;- rnorm(m)
Ytest &lt;- cbind(ytest, 10 * ytest)

nlvdis &lt;- 5 ; diss &lt;- "mahal"
h &lt;- 2 ; k &lt;- 10
nlv &lt;- "2:6" 
fm &lt;- lwplsr_agg(
    Xtrain, Ytrain, 
    nlvdis = nlvdis, diss = diss,
    h = h, k = k,
    nlv = nlv)
names(fm)
res &lt;- predict(fm, Xtest)
names(res)
res$pred
msep(res$pred, Ytest)

## EXAMPLE 2

n &lt;- 30 ; p &lt;- 10
Xtrain &lt;- matrix(rnorm(n * p), ncol = p)
ytrain &lt;- rnorm(n)
Ytrain &lt;- cbind(ytrain, 100 * ytrain)
m &lt;- 4
Xtest &lt;- matrix(rnorm(m * p), ncol = p)
ytest &lt;- rnorm(m)
Ytest &lt;- cbind(ytest, 10 * ytest)

nlvdis &lt;- 5 ; diss &lt;- "mahal"
h &lt;- c(2, Inf)
k &lt;- c(10, 20)
nlv &lt;- c("1:3", "2:5")
pars &lt;- mpars(nlvdis = nlvdis, diss = diss,
    h = h, k = k, nlv = nlv)
pars
res &lt;- gridscore(
    Xtrain, Ytrain, Xtest, Ytest, 
    score = msep, 
    fun = lwplsr_agg, 
    pars = pars)
res

## EXAMPLE 3

n &lt;- 30 ; p &lt;- 10
Xtrain &lt;- matrix(rnorm(n * p), ncol = p)
ytrain &lt;- rnorm(n)
Ytrain &lt;- cbind(ytrain, 100 * ytrain)
m &lt;- 4
Xtest &lt;- matrix(rnorm(m * p), ncol = p)
ytest &lt;- rnorm(m)
Ytest &lt;- cbind(ytest, 10 * ytest)

K = 3
segm &lt;- segmkf(n = n, K = K, nrep = 1)
segm
res &lt;- gridcv(
    Xtrain, Ytrain, 
    segm, score = msep, 
    fun = lwplsr_agg, 
    pars = pars,
    verb = TRUE)
res

</code></pre>


</div>