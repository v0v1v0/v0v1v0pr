<div class="container">

<table style="width: 100%;"><tr>
<td>mean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mean rotation</h2>

<h3>Description</h3>

<p>Compute the sample geometric or projected mean.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'SO3'
mean(x, type = "projected", epsilon = 1e-05, maxIter = 2000, ...)

## S3 method for class 'Q4'
mean(x, type = "projected", epsilon = 1e-05, maxIter = 2000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code class="reqn">n\times p</code> matrix where each row corresponds to a
random rotation in matrix form (<code class="reqn">p=9</code>) or quaternion (<code class="reqn">p=4</code>) form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>string indicating "projected" or "geometric" type mean estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>stopping rule for the geometric-mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>maximum number of iterations allowed for geometric-mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function takes a sample of 3D rotations (in matrix or quaternion form)
and returns the projected arithmetic mean denoted <code class="reqn">\widehat{\bm
S}_P</code> or geometric mean <code class="reqn">\widehat{\bm S}_G</code> according to the
<code>type</code> option. For a sample of <code class="reqn">n</code> rotations in matrix form
<code class="reqn">\bm{R}_i\in SO(3), i=1,2,\dots,n</code>, the
mean-type estimator is defined as </p>
<p style="text-align: center;"><code class="reqn">\widehat{\bm{S}}=argmin_{\bm{S}\in
SO(3)}\sum_{i=1}^nd^2(\bm{R}_i,\bm{S})</code>
</p>
<p> where <code class="reqn">d</code>
is the Riemannian or Euclidean distance. For more on the projected mean see
<cite>moakher02</cite> and for the geometric mean see <cite>manton04</cite>. For the
projected mean from a quaternion point of view see <cite>tyler1981</cite>.
</p>
<p>tyler1981, moakher02, manton04
</p>


<h3>Value</h3>

<p>Estimate of the projected or geometric mean of the sample in the same
parametrization.
</p>


<h3>See Also</h3>

<p><code>median.SO3</code>, <code>bayes.mean</code>, <code>weighted.mean.SO3</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">Rs &lt;- ruars(20, rvmises, kappa = 0.01)

# Projected mean
mean(Rs)

# Same as mean(Rs)
project.SO3(colMeans(Rs))

# Geometric mean
mean(Rs, type = "geometric")

# Bias of the projected mean
rot.dist(mean(Rs))

# Bias of the geometric mean
rot.dist(mean(Rs, type = "geometric"))

# Same thing with quaternion form
Qs &lt;- as.Q4(Rs)
mean(Qs)
mean(Qs, type = "geometric")
rot.dist(mean(Qs))
rot.dist(mean(Qs, type = "geometric"))
</code></pre>


</div>