<div class="container">

<table style="width: 100%;"><tr>
<td>E</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Function for the Computation of (Conditional) Expectations</h2>

<h3>Description</h3>

<p>Generic function for the computation of (conditional) expectations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">E(object, fun, cond, ...)

## S4 method for signature 'GEV,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 
## 'DistributionsIntegratingByQuantiles,function,missing'
E(object,
         fun, low = NULL, upp = NULL,
         rel.tol= getdistrExOption("ErelativeTolerance"),
         lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
         upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
         IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
## S4 method for signature 'Gumbel,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'GPareto,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'GPareto,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
## S4 method for signature 'Pareto,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> object of class <code>"Distribution"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p> if missing the (conditional) expectation is computed
else the (conditional) expection of <code>fun</code> is computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>
<p> if not missing the conditional expectation 
given <code>cond</code> is computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low</code></td>
<td>
<p>lower bound of integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upp</code></td>
<td>
<p>upper bound of integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upperTruncQuantile</code></td>
<td>
<p>upper quantile for quantile based integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IQR.fac</code></td>
<td>
<p>factor for scale based integration range (i.e.; 
median of the distribution <code class="reqn">\pm</code><code>IQR.fac</code><code class="reqn">\times</code>IQR).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to <code>fun</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The precision of the computations can be controlled via 
certain global options; cf. <code>distrExOptions</code>. 
Also note that arguments <code>low</code> and <code>upp</code> should be given as
named arguments in order to prevent them to be matched by arguments
<code>fun</code> or <code>cond</code>. Also the result, when arguments 
<code>low</code> or <code>upp</code> is given, is the <em>unconditional value</em> of the
expectation; no conditioning with respect to <code>low &lt;= object &lt;= upp</code>
is done. To be able to use integration after transformation via the
respective probability transformation to [0,1], we introduce a class union
<code>"DistributionsIntegratingByQuantiles"</code>, which currently comprises
classes <code>"GPareto"</code>, <code>"Pareto"</code>, <code>"Weibull"</code>, <code>"GEV"</code>.
In addition, the specific method for <code>"GPareto", "function", "missing"</code>
uses integration on [0,1] via the substitution method (y := log(x)).
</p>
<p>Diagnostics on the involved integrations are available
if argument   <code>diagnostic</code> is <code>TRUE</code>. Then there is attribute
<code>diagnostic</code> attached to the return value, which may be inspected
and accessed through <code>showDiagnostic</code> and
<code>getDiagnostic</code>.
</p>


<h3>Value</h3>

<p>The expectation is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>object = "Gumbel", fun = "missing", cond = "missing":</dt>
<dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "GPareto", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "DistributionsIntegratingByQuantiles",
fun = "function", cond = "missing":</dt>
<dd>
<p>use probability transform, i.e., a substitution <code>y = p(object)(x)</code>
for numerical integration.</p>
</dd>
<dt>object = "GPareto", fun = "function", cond = "missing":</dt>
<dd>
<p>use substitution method (y := log(x)) for numerical integration.</p>
</dd>
<dt>object = "Pareto", fun = "missing", cond = "missing":</dt>
<dd>
<p>exact evaluation using explicit expressions.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code>distrExIntegrate</code>, <code>m1df</code>, <code>m2df</code>,
<code>Distribution-class</code></p>


<h3>Examples</h3>

<pre><code class="language-R">GP &lt;- GPareto(shape=0.3)

E(GP)
E(GP, fun = function(x){2*x^2}) ## uses the log trafo

P &lt;- Pareto()
E(P)
E(P,fun = function(x){1/(x^2+1)})

</code></pre>


</div>