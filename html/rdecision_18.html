<div class="container">

<table style="width: 100%;"><tr>
<td>ExprModVar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A model variable constructed from an expression of other variables</h2>

<h3>Description</h3>

<p>An R6 class representing a model variable constructed from an
expression involving other variables.
</p>


<h3>Details</h3>

<p>A class to support expressions involving objects of base class
<code>ModVar</code>, which itself behaves like a model variable. For example, if
<code>A</code> and <code>B</code> are variables with base class <code>ModVar</code> and
<code>c</code> is a variable of type <code>numeric</code>, then it is not possible to
write, for example, <code>x &lt;- 42*A/B + c</code>, because R cannot manipulate class
variables using the same operators as regular variables. But such forms of
expression may be desirable in constructing a model and this class provides
a mechanism for doing so. Inherits from class <code>ModVar</code>.
</p>


<h3>Super class</h3>

<p><code>rdecision::ModVar</code> -&gt; <code>ExprModVar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ExprModVar-new"><code>ExprModVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-add_method"><code>ExprModVar$add_method()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-is_probabilistic"><code>ExprModVar$is_probabilistic()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-operands"><code>ExprModVar$operands()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-distribution"><code>ExprModVar$distribution()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-mean"><code>ExprModVar$mean()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-mode"><code>ExprModVar$mode()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-SD"><code>ExprModVar$SD()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-quantile"><code>ExprModVar$quantile()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-mu_hat"><code>ExprModVar$mu_hat()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-sigma_hat"><code>ExprModVar$sigma_hat()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-q_hat"><code>ExprModVar$q_hat()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-set"><code>ExprModVar$set()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-get"><code>ExprModVar$get()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprModVar-clone"><code>ExprModVar$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="description"><a href="../../rdecision/html/ModVar.html#method-ModVar-description"><code>rdecision::ModVar$description()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="is_expression"><a href="../../rdecision/html/ModVar.html#method-ModVar-is_expression"><code>rdecision::ModVar$is_expression()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="r"><a href="../../rdecision/html/ModVar.html#method-ModVar-r"><code>rdecision::ModVar$r()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="ModVar" data-id="units"><a href="../../rdecision/html/ModVar.html#method-ModVar-units"><code>rdecision::ModVar$units()</code></a></span></li>
</ul></details><hr>
<a id="method-ExprModVar-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a <code>ModVar</code> formed from an expression involving
other model variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$new(description, units, quo, nemp = 1000L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>description</code></dt>
<dd>
<p>Name for the model variable expression. In
a complex model it may help to tabulate how model variables are
combined into costs, probabilities and rates.</p>
</dd>
<dt><code>units</code></dt>
<dd>
<p>Units in which the variable is expressed.</p>
</dd>
<dt><code>quo</code></dt>
<dd>
<p>A <code style="white-space: pre;">⁠quosure⁠</code> (see package <span class="pkg">rlang</span>), which contains an
expression and its environment. The usage is <code>quo(x+y)</code> or
<code>rlang::quo(x+y)</code>.</p>
</dd>
<dt><code>nemp</code></dt>
<dd>
<p>sample size of the empirical distribution which will be
associated with the expression, and used to estimate values for
<code>mu_hat</code>, <code>sigma_hat</code> and <code>q_hat</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An object of type <code>ExprModVar</code>
</p>


<hr>
<a id="method-ExprModVar-add_method"></a>



<h4>Method <code>add_method()</code>
</h4>

<p>Create a new <code style="white-space: pre;">⁠quosure⁠</code> from that supplied in
<code>new()</code> but with each <code>ModVar</code>
operand appended with <code>$x</code> where <code>x</code> is the argument to this
function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$add_method(method = "mean()")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt>
<dd>
<p>A character string with the method, e.g. <code>"mean()"</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This method is mostly intended for internal use within the
class and will not generally be needed for normal use of
<code>ExprModVar</code> objects. The returned expression is <em>not</em>
syntactically checked or evaluated before it is returned.
</p>



<h5>Returns</h5>

<p>A <dfn>quosure</dfn> whose expression is each <code>ModVar</code> <code>v</code>
in the
expression replaced with <code>v$method</code> and the same environment as
specified in the quosure supplied in new().
</p>


<hr>
<a id="method-ExprModVar-is_probabilistic"></a>



<h4>Method <code>is_probabilistic()</code>
</h4>

<p>Tests whether the model variable is probabilistic, i.e.
a random variable that follows a distribution, or an expression involving
random variables, at least one of which follows a distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$is_probabilistic()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if probabilistic
</p>


<hr>
<a id="method-ExprModVar-operands"></a>



<h4>Method <code>operands()</code>
</h4>

<p>Return a list of operands.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$operands(recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recursive</code></dt>
<dd>
<p>Whether to include nested variables in the list.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Finds operands that are themselves <code>ModVar</code>s in the
expression. if <code>recursive=TRUE</code>, the list includes all
<code>ModVar</code>s that are operands of expression operands, recursively.
</p>



<h5>Returns</h5>

<p>A list of model variables.
</p>


<hr>
<a id="method-ExprModVar-distribution"></a>



<h4>Method <code>distribution()</code>
</h4>

<p>Accessor function for the name of the expression model
variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$distribution()</pre></div>



<h5>Returns</h5>

<p>Expression as a character string with all control characters
having been removed.
</p>


<hr>
<a id="method-ExprModVar-mean"></a>



<h4>Method <code>mean()</code>
</h4>

<p>Return the value of the expression when its operands take
their mean value (i.e. value returned by call to <code>mean</code> or their
value, if numeric). See notes on this class for further explanation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$mean()</pre></div>



<h5>Returns</h5>

<p>Mean value as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-mode"></a>



<h4>Method <code>mode()</code>
</h4>

<p>Return the mode of the variable. By default returns
<code>NA</code>, which will be the case for most <code>ExprModVar</code> variables,
because an arbitrary expression is not guaranteed to be unimodal.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$mode()</pre></div>



<h5>Returns</h5>

<p>Mode as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-SD"></a>



<h4>Method <code>SD()</code>
</h4>

<p>Return the standard deviation of the distribution as
<code>NA</code> because the variance is not available as a closed form for
all functions of distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$SD()</pre></div>



<h5>Returns</h5>

<p>Standard deviation as a numeric value
</p>


<hr>
<a id="method-ExprModVar-quantile"></a>



<h4>Method <code>quantile()</code>
</h4>

<p>Find quantiles of the uncertainty distribution. Not
available as a closed form, and returned as <code>NA</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$quantile(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt>
<dd>
<p>Numeric vector of probabilities, each in range [0,1].</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Vector of numeric values of the same length as <code>probs</code>.
</p>


<hr>
<a id="method-ExprModVar-mu_hat"></a>



<h4>Method <code>mu_hat()</code>
</h4>

<p>Return the estimated expected value of the variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$mu_hat()</pre></div>



<h5>Details</h5>

<p>This is computed by numerical simulation because there is, in
general, no closed form expressions for the mean of a function of
distributions. It is derived from the empirical distribution associated
with the object.
</p>



<h5>Returns</h5>

<p>Expected value as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-sigma_hat"></a>



<h4>Method <code>sigma_hat()</code>
</h4>

<p>Return the estimated standard deviation of the distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$sigma_hat()</pre></div>



<h5>Details</h5>

<p>This is computed by numerical simulation because there is, in
general, no closed form expressions for the SD of a function of
distributions. It is derived from the empirical distribution associated
with the object.
</p>



<h5>Returns</h5>

<p>Standard deviation as a numeric value.
</p>


<hr>
<a id="method-ExprModVar-q_hat"></a>



<h4>Method <code>q_hat()</code>
</h4>

<p>Return the estimated quantiles by sampling the variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$q_hat(probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>probs</code></dt>
<dd>
<p>Vector of probabilities, in range [0,1].</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This is computed by numerical simulation because there is, in
general, no closed form expressions for the quantiles of a function of
distributions. The quantiles are derived from the empirical distribution
associated with the object.
</p>



<h5>Returns</h5>

<p>Vector of quantiles.
</p>


<hr>
<a id="method-ExprModVar-set"></a>



<h4>Method <code>set()</code>
</h4>

<p>Sets the value of the <code>ExprModVar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$set(what = "random", val = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt>
<dd>
<p>Until <code>set</code> is called again, subsequent calls to
<code>get</code> will return a value determined by the <code>what</code> parameter.
as follows:
</p>

<dl>
<dt><code>"random"</code></dt>
<dd>
<p>a random sample is derived by taking a random
sample from each of the operands and evaluating the expression. It
does not draw from the empirical distribution because of the possibility
of nested autocorrelation. For example, if <code class="reqn">z=xy</code>, where <code class="reqn">x</code> is a
model variable and <code class="reqn">y</code> is an expression which involves <code class="reqn">x</code>, then
<code class="reqn">y</code> and <code class="reqn">x</code> are correlated and will produce a different
distribution for <code class="reqn">z</code> than if <code class="reqn">x</code> and <code class="reqn">y</code> were independent.
However, if <code class="reqn">z</code> was sampled from the empirical distribution of
<code class="reqn">y</code> and the uncertainty distribution of <code class="reqn">x</code> independently, the
effect of correlation would be lost;</p>
</dd>
<dt><code>"expected"</code></dt>
<dd>
<p>the value of the expression when each of its
operands takes its expected value. This will not - in general - be the
mean of the uncertainty distribution for the expression which can be
estimated by calling <code>mu_hat</code>;</p>
</dd>
<dt><code>"q2.5"</code></dt>
<dd>
<p>the value of the expression when each of its
operands is equal to the 2.5th centile of their own uncertainty
distribution. In general, this will be a more extreme value than the
2.5th centile of the uncertainty distribution of the expression, which
can be found by using <code>q_hat(p=0.025)</code>;</p>
</dd>
<dt><code>"q50"</code></dt>
<dd>
<p>as per <code>"q2.5"</code> but for the 50th
centile (median);</p>
</dd>
<dt><code>"q97.5"</code></dt>
<dd>
<p>as per <code>"q2.5"</code> but for the 97.5th
centile;</p>
</dd>
<dt><code>"current"</code></dt>
<dd>
<p>leaves the <code>what</code> parameter of method
<code>set</code> unchanged <em>for each operand</em> and causes the expression
to be re-evaluated at subsequent calls to <code>get</code>. Thus, after calling
<code>set(what="current")</code> for the expression, subsequent calls to
<code>get</code> for the expression may not return the same value, if method
<code>set</code> has been called for one or more operands in the meantime;</p>
</dd>
<dt><code>"value"</code></dt>
<dd>
<p>sets the value of the expression to be equal to
parameter <code>val</code>. This is not recommended for normal usage because it
allows the model variable to be set to an implausible value, based on its
defined uncertainty. An example of where this may be needed is in
threshold finding.</p>
</dd>
</dl>
</dd>
<dt><code>val</code></dt>
<dd>
<p>A numeric value, only used with <code>what</code>=<code>"value"</code>,
ignored otherwise.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The available options for parameter <code>what</code> are identical to
those available for the <code>set</code> method of <code>ModVar</code>. However,
because an <code>ExprModVar</code> represents the left hand side of an
expression involving operands, the effect of some options is different
from its effect on a non-expression <code>ModVar</code>.
</p>



<h5>Returns</h5>

<p>Updated <code>ExprModVar</code>.
</p>


<hr>
<a id="method-ExprModVar-get"></a>



<h4>Method <code>get()</code>
</h4>

<p>Gets the value of the <code>ExprModVar</code> that was set by the most recent
call to <code>set()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$get()</pre></div>



<h5>Returns</h5>

<p>Value determined by last <code>set()</code>.
</p>


<hr>
<a id="method-ExprModVar-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprModVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Note</h3>

<p>For many expressions involving model variables there will
be no closed form expressions for the mean, standard deviation and
the quantiles. When an <code>ExprModVar</code> is created, an empirical
distribution is generated by repeatedly drawing a random sample from each
operand and evaluating the expression. The empirical distribution, which
becomes associated with the object, is used to provide estimates of the
mean, standard deviation and the quantiles via functions <code>mu_hat</code>,
<code>sigma_hat</code> and <code>q_hat</code>.
</p>
<p>For consistency with <code>ModVar</code>s which are not expressions, the
function <code>mean</code> returns the value of the expression when all
its operands take their mean values. This will, in general, not
be the mean of the expression distribution (which can be obtained
via <code>mu_hat</code>), but is the value normally used in the base
case of a model as the point estimate. As Briggs <em>et al</em> note
(section 4.1.1) "in all but the most non-linear models, the
difference between the expectation over the output of a
probabilistic model and that model evaluated at the mean values
of the input parameters, is likely to be modest."
</p>
<p>Functions <code>SD</code>, <code>mode</code> and <code>quantile</code> return <code>NA</code>
because they do not necessarily have a closed form. The standard
deviation can be estimated by calling <code>sigma_hat</code> and the
quantiles by <code>q_hat</code>. Because a unimodal distribution is not
guaranteed, there is no estimator provided for the mode.
</p>
<p>Method <code>distribution</code> returns the string representation
of the expression used to create the model variable.
</p>


<h3>Author(s)</h3>

<p>Andrew J. Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Briggs A, Claxton K, Sculpher M. Decision modelling for health
economic evaluation. Oxford, UK: Oxford University Press; 2006.

</p>


</div>