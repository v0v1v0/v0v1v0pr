<div class="container">

<table style="width: 100%;"><tr>
<td>fur</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>FUR</h2>

<h3>Description</h3>

<p><em>FUR</em> is a heuristic algorithm to obtain a consensus ranking.
It contains three branches – Fixed, Update, and Range – that use
<em>Subiterative Convergence</em> and <em>Greedy Algorithm</em> iteratively.
See ‘Details’ for more information on each branch.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fur(
  input_rkgs,
  subit_len_list,
  search_radius,
  seed_rkg = c(),
  objNames = c(),
  wt = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input_rkgs</code></td>
<td>
<p>a <code>n</code> by <code>k</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each column is a complete ranking.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subit_len_list</code></td>
<td>
<p>a vector containing positive integer(s) for the subiteration
lengths to <em>Subiterative Convergence</em>. Recommended values are between 2 and 8.
Smaller subiteration lengths result in shorter run-time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search_radius</code></td>
<td>
<p>a positive integer for the maximum change in the rank of each
object in the <em>Greedy Algorithm</em>. The default value
of <code>0</code> considers all possible rank changes for each object. It is
recommended to use a search radius of less than or equal to <code class="reqn">\min(30, \lfloor \mbox{n}/2 \rfloor)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed_rkg</code></td>
<td>
<p>a vector of length <code>n</code> with an initial ranking to begin FUR. If
the default value of an empty vector is used, then the <code>mean seed ranking</code> is adopted
as the initial ranking to FUR.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objNames</code></td>
<td>
<p>a <code>n</code>-length vector containing object names. An optional
parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Fixed branch applies <em>Subiterative Convergence</em> using one subiteration
length from <code>subit_len_list</code> at a time.
</p>
<p>The Update branch executes <em>Subiterative Convergence</em> using the first
subiteration length in <code>subit_len_list</code>, and then uses its output in the
next call to <em>Subiterative Convergence</em> with the next subiteration length in the list.
This process repeats until <code>subit_len_list</code> is exhausted.
</p>
<p>The Range branch calls <em>Subiterative Convergence</em> on all subiteration lengths in
<code>subit_len_list</code> and only retains the best ranking among these separate calls.
</p>
<p>The output from the <em>Subiterative Convergence</em> calls are fed into the <em>Greedy Algorithm</em>
as its seed ranking, and the FUR algorithm is terminated when the input to the
<em>Greedy Algorithm</em> converges to the output and all branches have been executed at
least once.
</p>


<h3>Value</h3>

<p>A list containing the consensus ranking (expressed as ordering), total Kemeny distance, and average
tau correlation coefficient corresponding to the consensus ranking.
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>See Also</h3>

<p><code>mean_seed</code>, <code>subit_convergence</code>, <code>rap_greedy_alg</code>, <code>sigfur</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## One subiteration length
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
subit_len_list &lt;- 2
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius) # Determined the consensus ranking, total Kemeny
                                              # distance, and average tau correlation coefficient

## Multiple subiteration lengths
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
subit_len_list &lt;- c(2,3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius)

## Five input rankings with five objects 
## 2nd ranking == 3rd ranking, so if a third object is weighted as zero,
## we should get the same answer as the first examples
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
## Multiple subiteration lengths
wt = c(1,1,0,1,1)
subit_len_list &lt;- c(2,3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius,wt=wt)

## Using five input rankings with five objects with prepare_data to 
## automatically prepare the weight vector
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
out = prepare_data(input_rkgs) 
input_rkgs = out$input_rkgs
wt = out$wt
subit_len_list &lt;- c(2,3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius,wt=wt)

## Included dataset of 15 input rankings of 50 objects
data(data50x15)
input_rkgs &lt;- as.matrix(data50x15[, -1])
subit_len_list &lt;- c(2, 3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius)

</code></pre>


</div>