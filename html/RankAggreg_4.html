<div class="container">

<table style="width: 100%;"><tr>
<td>RankAggreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighted Rank Aggregation of partial ordered lists</h2>

<h3>Description</h3>

<p>Performs aggregation of ordered lists based on the ranks (optionally with additional
weights) via the Cross-Entropy Monte Carlo algorithm or the Genetic Algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RankAggreg(x, k, weights=NULL, method=c("CE", "GA"),
distance=c("Spearman", "Kendall"), seed=NULL, maxIter = 1000,
convIn=ifelse(method=="CE", 7, 30), importance=rep(1,nrow(x)),
rho=.1, weight=.25, N=10*k^2, v1=NULL,
popSize=100, CP=.4, MP=.01, verbose=TRUE, standardizeWeights = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of ordered lists to be combined (lists must be in rows)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>size of the top-k list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a matrix of scores (weights) to be used in the aggregation process. Weights in 
each row must be ordered either in decreasing or increasing order and must correspond to the elements
in x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method to be used to perform rank aggregation: Cross Entropy Monte Carlo (CE) or Genetic Algorithm (GA)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>distance to be used which "measures" the similarity of ordered lists</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a random seed specified for reproducability; default: NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>
<p>the maximum number of iterations allowed; default: 1000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convIn</code></td>
<td>
<p>stopping criteria for both CE and GA algorithms. If the best solution
does not change in convIn iterations, the algorithm converged; default: 7 for CE, 30 for GA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>importance</code></td>
<td>
<p>vector of weights indicating the importance of each list in x; default: a vector of 1's (
equal weights are given to all lists</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>(rho*N) is the "quantile" of candidate lists sorted by the function values. Used only by the Cross-Entropy algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>a learning factor used in the probability update procedure of the CE algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>a number of samples to be generated by the MCMC; default: 10nk, where n is the number of 
unique elements in x. Used only by the Cross-Entropy algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v1</code></td>
<td>
<p>optional, can be used to specify the initial probability matrix; if v1=NULL,
the initial probability matrix is set to 1/n, where n is the number of unique elements in x</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>popSize</code></td>
<td>
<p>population size in each generation of Genetic Algorithm; default: 100</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CP</code></td>
<td>
<p>Cross-over probability for the GA; the default value is .4</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MP</code></td>
<td>
<p>Mutation probability for the GA. This value should be small and the number of mutations in the population of size popSize
and the number of features k is computed as popSize*k*MP.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>boolean, if console output is to be displayed at each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardizeWeights</code></td>
<td>
<p>boolean, default is true which standardizes weights to [0,1]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments can be passed to the internal procedures:
</p>
<p>â€“ p - penalty for the Kendall's tau distance; default: 0</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function performs rank aggregation via the Cross-Entropy Monte Carlo algorithm or the Genetic Algorithm. Both approaches can and 
should be used when k is relatively large (k &gt; 10). If k is small, one can enumerate all possible
candidate lists and find the minimum directly using the BruteAggreg function available in this package.
</p>
<p>The Cross-Entropy Monte Carlo algorithm is an iterative procedure for solving difficult combinatorial 
problems in which it is computationally not feasable to find the solution directly. In the context of 
rank aggregation, the algorithm searches for the "super"-list which is as close as possible to the
ordered lists in x. We use either the Spearman footrule distance or the Kendall's tau to measure the "closeness" of any two
ordered lists (or modified by us the weighted versions of these distances). Please refer to the paper 
in the references for further details.
</p>
<p>The Genetic Algorithm requires setting CP and MP parameters which effect the rate of "evolution" in the population. If both
CP and MP are small, the algorithms is very conservative and may take a long time to search the solution space of all ordered candidate
lists. On the other hand, setting CP and MP (especially MP) large will introduce a large number of mutations in the population which
can result in a local optima. 
</p>
<p>The convergence criteria used by both algorithms is the repetition of the same minimum value
of the objective function in <em>convIn</em> consecutive iterations.</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>top.list</code></td>
<td>
<p>Top-k aggregated list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimal.value</code></td>
<td>
<p>the minimum value of the objective function corresponding to the top-k list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.size</code></td>
<td>
<p>the number of samples generated by the MCMC at each iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.iter</code></td>
<td>
<p>the number of iterations until convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>which algorithm was used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>which distance was used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>importance</code></td>
<td>
<p>an importance vector used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lists</code></td>
<td>
<p>the original ordered lists</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>scaled weights if specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>objective function scores from the last iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary</code></td>
<td>
<p>matrix containing minimum and median objective function scores for each iteration</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Vasyl Pihur, Somnath Datta, Susmita Datta</p>


<h3>References</h3>

<p>Pihur, V., Datta, S., and Datta, S. (2007) "Weighted rank aggregation of cluster validation 
measures: a Monte Carlo cross-entropy approach" Bioinformatics, 23(13):1607-1615 </p>


<h3>See Also</h3>

<p><code>BruteAggreg</code>, <code>plot</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># rank aggregation without weights
x &lt;- matrix(c("A", "B", "C", "D", "E",
        "B", "D", "A", "E", "C",
        "B", "A", "E", "C", "D",
        "A", "D", "B", "C", "E"), byrow=TRUE, ncol=5)

(CESnoweights &lt;- RankAggreg(x, 5, method="CE", distance="Spearman", N=100, convIn=5, rho=.1))

# weighted rank aggregation
set.seed(100)
w &lt;- matrix(rnorm(20), ncol=5)
w &lt;- t(apply(w, 1, sort))

# using the Cross-Entropy Monte-Carlo algorithm
(CES &lt;- RankAggreg(x, 5, w, "CE", "Spearman", rho=.1, N=100, convIn=5))
plot(CES)
(CEK &lt;- RankAggreg(x, 5, w, "CE", "Kendall", rho=.1, N=100, convIn=5))

# using the Genetic algorithm
(GAS &lt;- RankAggreg(x, 5, w, "GA", "Spearman"))
plot(GAS)
(GAK &lt;- RankAggreg(x, 5, w, "GA", "Kendall"))

# more complex example (to get a better solution, increase maxIter)
data(geneLists)
topGenes &lt;- RankAggreg(geneLists, 25, method="GA", maxIter=100)
plot(topGenes)
</code></pre>


</div>