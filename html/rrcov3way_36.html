<div class="container">

<table style="width: 100%;"><tr>
<td>Tucker3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Robust Tucker3 estimator for compositional data
</h2>

<h3>Description</h3>

<p>Compute a robust Tucker3 model for compositional data
</p>


<h3>Usage</h3>

<pre><code class="language-R">Tucker3(X, P = 2, Q = 2, R = 2, 
    center = FALSE, center.mode = c("A", "B", "C", "AB", "AC", "BC", "ABC"), 
    scale = FALSE, scale.mode = c("B", "A", "C"), 
    conv = 1e-06, start="svd",
    robust = FALSE, coda.transform=c("none", "ilr", "clr"), 
    ncomp.rpca = 0, alpha = 0.75, robiter=100, crit=0.975, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>3-way array of data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>Number of A-mode components</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>Number of B-mode components</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Number of C-mode components</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>Whether to center the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center.mode</code></td>
<td>
<p>If scaling the data, on which mode to do this</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Whether to scale the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.mode</code></td>
<td>
<p>If centering the data, on which mode to do this</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>Convergence criterion, defaults to <code>1e-6</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be <code>"svd"</code> 
for starting point of the algorithm from SVD's, <code>"random"</code> for random
starting point (orthonormalized component matrices), or a list containing user specified components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>Whether to apply a robust estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coda.transform</code></td>
<td>
<p>If the data are a composition, use an <em>ilr</em> or <em>clr</em> transformation. 
Default is non-compositional data, i.e. <code>coda.transform="none"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp.rpca</code></td>
<td>
<p>Number of components for robust PCA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Measures the fraction of outliers the algorithm should
resist. Allowed values are between 0.5 and 1 and the default is 0.75</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robiter</code></td>
<td>
<p>Maximal number of iterations for robust estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>Cut-off for identifying outliers, default <code>crit=0.975</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Logical, provide trace output</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function can compute four
versions of the Tucker3 model:
</p>

<ol>
<li>
<p> Classical Tucker3,
</p>
</li>
<li>
<p> Tucker3 for compositional data,
</p>
</li>
<li>
<p> Robust Tucker3 and
</p>
</li>
<li>
<p> Robust Tucker3 for compositional data.
</p>
</li>
</ol>
<p>This is controlled through the parameters <code>robust=TRUE</code> and <code>coda.transform="ilr"</code>.
</p>


<h3>Value</h3>

<p>An object of class "tucker3" which is basically a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Fit value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fp</code></td>
<td>
<p>Fit percentage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Orthogonal loading matrix for the A-mode</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Orthogonal loading matrix for the B-mode</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bclr</code></td>
<td>
<p>Orthogonal loading matrix for the B-mode, clr transformed.
Available only if <code>coda.transform="ilr"</code>, otherwise NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>Orthogonal loading matrix for the C-mode</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GA</code></td>
<td>
<p>Core matrix, which describes the relation between <code>A</code>, <code>B</code> and <code>C</code>,
unfolded in A-form. The largest squared elements of the core matrix indicate the
most important factors in the model of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rd</code></td>
<td>
<p>Residual distances</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>Score distances</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flag</code></td>
<td>
<p>The observations whose residual distance <code>RD</code> is larger than cutoff.RD can be
considered as outliers and receive a flag equal to zero.
The regular observations receive a flag 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>The paramater <code>robust</code>, whether robust method is used or not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coda.transform</code></td>
<td>
<p>The input paramater <code>coda.transform</code>, what trnasofrmation for compositional data was used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>La</code></td>
<td>
<p>Diagonal matrix containing the <em>intrinsic eigenvalues</em> for A-mode</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lb</code></td>
<td>
<p>Diagonal matrix containing the <em>intrinsic eigenvalues</em> for B-mode</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lc</code></td>
<td>
<p>Diagonal matrix containing the <em>intrinsic eigenvalues</em> for C-mode</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Maria Anna Di Palma <a href="mailto:madipalma@unior.it">madipalma@unior.it</a> and
Michele Gallo <a href="mailto:mgallo@unior.it">mgallo@unior.it</a>
</p>


<h3>References</h3>

<p>Tucker, L.R. (1966). Some mathematical notes on three-mode 
factor analysis. <em>Psychometrika</em>, 31: 279–311.
</p>
<p>Egozcue J.J., Pawlowsky-Glahn, V.,  Mateu-Figueras G. and 
Barcel'o-Vidal, C. (2003). Isometric logratio transformations 
for compositional data analysis. <em>Mathematical Geology</em>, 35(3): 279–300.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############
##
## Example with the UNIDO Manufacturing value added data

data(va3way)
dim(va3way)

## Treat quickly and dirty the zeros in the data set (if any)
va3way[va3way==0] &lt;- 0.001

##
res &lt;- Tucker3(va3way)
res
print(res$fit)
print(res$A)

## Print the core matrix
print(res$GA)

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")

## Paired component plot, mode A
plot(res, which="comp", main="Paired component plot (mode A)")

## Paired component plot, mode B
plot(res, which="comp", mode="B", main="Paired component plot (mode B)")

## Joint biplot
plot(res, which="jbplot", main="Joint biplot")

## Trajectory
plot(res, which="tjplot", choices=c(1:4), arrows=FALSE, main="Trajectory biplot")

</code></pre>


</div>