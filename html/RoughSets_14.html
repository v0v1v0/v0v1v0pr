<div class="container">

<table style="width: 100%;"><tr>
<td>C.FRNN.FRST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The fuzzy-rough nearest neighbor algorithm</h2>

<h3>Description</h3>

<p>It is used to predict new datasets/patterns based on the fuzzy-rough nearest neighbor algorithm (FRNN)
proposed by (Jensen and Cornelis, 2011).
</p>


<h3>Usage</h3>

<pre><code class="language-R">C.FRNN.FRST(decision.table, newdata, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decision.table</code></td>
<td>
<p>a <code>"DecisionTable"</code> class representing the decision table. See <code>SF.asDecisionTable</code>. 
It should be noted that the data must be numeric values instead of string/char.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a <code>"DecisionTable"</code> class representing data for the test process. 
</p>
<p>See <code>SF.asDecisionTable</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of other parameters as follows.
</p>

<ul>
<li> <p><code>type.LU</code>: a type of lower and upper approximations. See Section <code>Details</code>. The default value is <code>type.LU = "implicator.tnorm"</code>.
</p>
</li>
<li> <p><code>k</code>: the number of neighbors. It should be taken into account that 
this value could affect the accuracy. The default value is 5.
</p>
</li>
<li> <p><code>type.aggregation</code>: the type of the aggregation operator. See <code>BC.IND.relation.FRST</code>.
The default value is <code>type.aggregation = c("t.tnorm", "lukasiewicz")</code>.
</p>
</li>
<li> <p><code>type.relation</code>: the type of relation. See <code>BC.LU.approximation.FRST</code>.
</p>
<p>The default value is <code>c("tolerance", "eq.1")</code>.
</p>
</li>
<li> <p><code>type.implicator</code>: the type of implicator operator. 
</p>
<p>See <code>BC.LU.approximation.FRST</code>. The default value is <code>"lukasiewicz"</code>.
</p>
</li>
<li> <p><code>q.some</code>: a vector of values of alpha and beta parameters of VQRS. 
</p>
<p>See <code>BC.LU.approximation.FRST</code>. The default value is <code>c(0.1, 0.6)</code>.
</p>
</li>
<li> <p><code>q.most</code>: a vector of values of alpha and beta parameter of VQRS. 
</p>
<p>See <code>BC.LU.approximation.FRST</code>. The default value is <code>c(0.2, 1)</code>.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This method uses the fuzzy lower and upper approximations to improve the fuzzy nearest neighbor (FNN) algorithm.
This algorithm assigns a class to a target instance <code class="reqn">t</code> as follows.
</p>

<ul>
<li>
<p> Determine <code class="reqn">k</code> nearest neighbors considering their similarity to new patterns.
</p>
</li>
<li>
<p> Assign new patterns to the class based on maximal value of fuzzy lower and upper approximations. 
If a value of fuzzy lower approximation is high, it shows that neighbors of newdata belong to a particular class, e.g. <code>C</code>. On the other hand, 
a high value of fuzzy upper approximation means that at least one neighbor belongs to that class. 
</p>
</li>
</ul>
<p>In this function, we provide two approaches based on types of fuzzy lower and upper approximations. The following is 
a list of the considered approximations:
</p>

<ul>
<li> <p><code>"implicator.tnorm"</code>: It refers to lower and upper approximations based on implicator/t-norm approach. 
For more detail, it can be seen in <code>BC.LU.approximation.FRST</code>. When using this approach, 
we need to assign the <code>control</code> parameter as follows:
</p>
<p><code>control &lt;- list(type.LU = "implicator.tnorm", k,</code>
</p>
<p><code>type.aggregation, type.relation, t.implicator)</code>
</p>
<p>The detailed description of the components in the <code>control</code> parameter can be seen in 
</p>
<p><code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>"vqrs"</code>: It refers to lower and upper approximations based on vaguely quantified rough sets. 
For more detail, it can be seen in <code>BC.LU.approximation.FRST</code>. When using this approach, 
we need to assign the <code>control</code> parameter as follows:
</p>
<p><code>control &lt;- list(type.LU = "vqrs", k, q.some, q.most,</code>
</p>
<p><code>type.relation, type.aggregation)</code>
</p>
<p>The detailed description of the components in the <code>control</code> parameter can be seen in 
</p>
<p><code>BC.LU.approximation.FRST</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A matrix of predicted classes of newdata.
</p>


<h3>Author(s)</h3>

<p>Lala Septem Riza
</p>


<h3>References</h3>

<p>R. Jensen and C. Cornelis, "Fuzzy-rough Nearest Neighbour Classification and Prediction",
Theoretical Computer Science, vol. 412, p. 5871 - 5884 (2011).
</p>


<h3>See Also</h3>

<p><code>C.FRNN.O.FRST</code>, 
<code>C.POSNN.FRST</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#############################################################
## In this example, we are using Iris dataset.
## It should be noted that since the values of the decision attribute are strings,
## they should be transformed into numeric values using unclass()
#############################################################
data(iris)
## shuffle the data
set.seed(2)
irisShuffled &lt;- iris[sample(nrow(iris)),]

## transform values of the decision attribute into numerics
irisShuffled[,5] &lt;- unclass(irisShuffled[,5])

## split the data into training and testing data
iris.training &lt;- irisShuffled[1:105,]
iris.testing &lt;- irisShuffled[106:nrow(irisShuffled),1:4]

colnames(iris.training) &lt;- c("Sepal.Length", "Sepal.Width", "Petal.Length", 
                       "Petal.Width", "Species")

## convert into a standard decision table
decision.table &lt;- SF.asDecisionTable(dataset = iris.training, decision.attr = 5, 
                                     indx.nominal = c(5))
tst.iris &lt;- SF.asDecisionTable(dataset = iris.testing)

###### FRNN algorithm using lower/upper approximation: 
###### Implicator/tnorm based approach
control &lt;- list(type.LU = "implicator.tnorm", k = 20, 
                type.aggregation = c("t.tnorm", "lukasiewicz"), 
                type.relation = c("tolerance", "eq.1"), t.implicator = "lukasiewicz") 									   
## Not run: res.1 &lt;- C.FRNN.FRST(decision.table = decision.table, newdata = tst.iris,
                             control = control)
## End(Not run)

###### FRNN algorithm using VQRS
control &lt;- list(type.LU = "vqrs", k = 20, q.some = c(0.1, 0.6), q.most = c(0.2, 1), 
                 type.relation = c("tolerance", "eq.1"), 
                 type.aggregation = c("t.tnorm","lukasiewicz"))
## Not run: res.2 &lt;- C.FRNN.FRST(decision.table = decision.table, newdata = tst.iris,
                             control = control)
## End(Not run)

</code></pre>


</div>