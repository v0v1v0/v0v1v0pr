<div class="container">

<table style="width: 100%;"><tr>
<td>rev.rstack</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reverse an rstack</h2>

<h3>Description</h3>

<p>Returns a reversed version of an rstack, where the old last element (generally
inaccessible) is now the top (and thus now accessible).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'rstack'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>rstack to reverse.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>This method runs in  <code class="reqn">O(N)</code> in the size of the rstack, though it works behind-the-scenes
for efficiency by converting the input stack
to a list, reversing the list, and building the result as a new rstack. The original is thus
left alone, preserving <code class="reqn">O(1)</code> amortized time for the original (assuming the "cost" of reversing
is charged to the newly created stack) at the cost of additional memory usage. But,
if the stack is not being used in a preserved manner, e.g. <code>s &lt;- rev(s)</code>, the garbage collector
will be free to clean up the original data if it is no longer usable.
</p>


<h3>Value</h3>

<p>a reversed version of the rstack.
</p>


<h3>See Also</h3>

<p><code>as.list.rstack</code> for converting an rstack to a list.
</p>


<h3>Examples</h3>

<pre><code class="language-R">s &lt;- rstack()
s &lt;- insert_top(s, "a")
s &lt;- insert_top(s, "b")
s &lt;- insert_top(s, "c")

r &lt;- rev(s)
print(r)
print(s)
</code></pre>


</div>