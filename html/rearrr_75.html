<div class="container">

<table style="width: 100%;"><tr>
<td>triplet_extremes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Makes triplets of extreme values and sort by them</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>The values are grouped in three such that the first group is formed by
the lowest and highest values and the value closest to the median,
the second group is formed by the second lowest and second
highest values and the value second closest to the median, and so on.
The values are then sorted by these groups and their actual value.
</p>
<p>When the number of rows/elements in <code>`data`</code> is not evenly divisible by three,
the <code>`unequal_method_1`</code> (single excessive element) and
<code>`unequal_method_2`</code> (two excessive elements)
determines which element(s) should form a smaller group.
This group will be the first group <em>in a given grouping</em> (see <code>`num_groupings`</code>)
with the identifier <code>1</code>.
</p>
<p>The <code>*_vec()</code> version takes and returns a <code>vector</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4, 5, 6)</code>
</p>
<p>Are sorted in triplets as:
</p>
<p><code>c(1, 3, 6, 2, 4, 5)</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">triplet_extremes(
  data,
  col = NULL,
  middle_is = "middle",
  unequal_method_1 = "middle",
  unequal_method_2 = c("middle", "middle"),
  num_groupings = 1,
  balance = "mean",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_triplets = FALSE,
  factor_name = ifelse(num_groupings == 1, ".triplet", ".tripleting"),
  overwrite = FALSE
)

triplet_extremes_vec(
  data,
  middle_is = "middle",
  unequal_method_1 = "middle",
  unequal_method_2 = c("middle", "middle"),
  num_groupings = 1,
  balance = "mean",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_triplets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>middle_is</code></td>
<td>
<p>Whether the middle element in the triplet is the nth closest element
to the median value or the nth+1 lowest/highest value.
</p>
<p>One of: <code>middle</code> (default), <code>min</code>, or <code>max</code>.
</p>
<p>Triplet grouping is performed greedily from the most extreme values to the least extreme
values. E.g. <code>c(1, 6, 12)</code> is created before <code>c(2, 5, 11)</code> which is made
before <code>c(3, 7, 10)</code>.
</p>
<p><strong>Examples</strong>:
</p>
<p>When <code>`middle_is` == 'middle'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 6, 12), c(2, 7, 11), c(3, 5, 10),  c(4, 8, 9) )</code>
</p>
<p>When <code>`middle_is` == 'min'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 2, 12), c(3, 4, 11), c(5, 6, 10),  c(7, 8, 9) )</code>
</p>
<p>When <code>`middle_is` == 'max'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 11, 12), c(2, 9, 10), c(3, 7, 8),  c(4, 5, 6) )</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unequal_method_1, unequal_method_2</code></td>
<td>
<p>Method for dealing with either
a single excessive element (<code>`unequal_method_1`</code>) or two excessive elements (<code>`unequal_method_2`</code>)
when the number of rows/elements in <code>`data`</code> are not evenly divisible by three.
</p>
<p><code>`unequal_method_1`</code>: One of: <code>min</code>, <code>middle</code> or <code>max</code>.
</p>
<p><code>`unequal_method_2`</code>: Vector with two of: <code>min</code>, <code>middle</code> or <code>max</code>. Can be the same value twice.
</p>
<p>Note: The excessive element(s) are extracted before triplet grouping. These elements
are put in their own group and given group identifier <code>1</code>.
</p>
<p>E.g. When <code>`unequal_method_2`</code> is <code>c("middle", "middle")</code> the two elements
closest to the median are extracted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_groupings</code></td>
<td>
<p>Number of times to group into triplets (recursively). At least <code>1</code>.
</p>
<p>Based on <code>`balance`</code>, the secondary groupings perform extreme triplet grouping on either the
<em>sum</em>, <em>absolute difference</em>, <em>min</em>, or <em>max</em> of the triplet elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>balance</code></td>
<td>
<p>What to balance triplets for in a given <em>secondary</em> triplet grouping.
Either <code>"mean"</code>, <code>"spread"</code>, <code>"min"</code>, or <code>"max"</code>.
Can be a single string used for all secondary groupings
or one for each secondary grouping (<code>`num_groupings` - 1</code>).
</p>
<p>The first triplet grouping always groups the actual element values.
</p>


<h4>mean</h4>

<p>Triplets have similar means. The values in the triplets from the previous grouping
are aggregated with <code>`sum()`</code> and extreme triplet grouped.
</p>



<h4>spread</h4>

<p>Triplets have similar spread (e.g. standard deviations). The values in the triplets
from the previous triplet grouping are aggregated with <code>`sum(abs(diff()))`</code> and
extreme triplet grouped.
</p>



<h4>min / max</h4>

<p>Triplets have similar minimum / maximum values. The values in the triplets from the
previous triplet grouping are aggregated with <code>`min()`</code> / <code>`max()`</code> and extreme
triplet grouped.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_by_aggregates</code></td>
<td>
<p>Whether to order the groups from initial groupings (first <code>`num_groupings` - 1</code>)
by their aggregate values instead of their group identifiers.
</p>
<p>N.B. Only used when <code>`num_groupings` &gt; 1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle_members</code></td>
<td>
<p>Whether to shuffle the order of the group members within the groups. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shuffle_triplets</code></td>
<td>
<p>Whether to shuffle the order of the triplets. Triplet members remain together. (Logical)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factor_name</code></td>
<td>
<p>Name of new column with the sorting factor.
If <code>`NULL`</code>, no column is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the sorting factor added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`keep_factors`</code> is <code>`FALSE`</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code>center_max()</code>,
<code>center_min()</code>,
<code>closest_to()</code>,
<code>furthest_from()</code>,
<code>pair_extremes()</code>,
<code>position_max()</code>,
<code>position_min()</code>,
<code>rev_windows()</code>,
<code>roll_elements()</code>,
<code>shuffle_hierarchy()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:12,
  "A" = sample(1:12),
  "B" = runif(12),
  "C" = LETTERS[1:12],
  "G" = c(
    1, 1, 1, 1, 2, 2,
    2, 2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Triplet group extreme indices (row numbers)
triplet_extremes(df)

# Triplet group extremes in each of the columns
triplet_extremes(df, col = "A")$A
triplet_extremes(df, col = "B")$B
triplet_extremes(df, col = "C")$C

# Shuffle the members triplet-wise
# The triplets maintain their order
# but the rows within each triplet are shuffled
triplet_extremes(df, col = "A", shuffle_members = TRUE)

# Shuffle the order of the triplets
# The triplets are shuffled but
# the rows within each triplet maintain their order
triplet_extremes(df, col = "A", shuffle_triplets = TRUE)

# Use recursive grouping
# Mostly meaningful with much larger datasets
# Order initial grouping by group identifiers
triplet_extremes(df, col = "A", num_groupings = 2)
# Order initial grouping by aggregate values
triplet_extremes(df, col = "A", num_groupings = 2, order_by_aggregates = TRUE)

# Grouped by G
# Each G group only has 4 elements
# so it only creates 1 triplet and a group
# with the single excessive element
# per G group
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  triplet_extremes(col = "A")

# Plot the extreme triplets
plot(
  x = 1:12,
  y = triplet_extremes(df, col = "A")$A,
  col = as.character(rep(1:4, each = 3))
)
# With shuffled triplet members (run a few times)
plot(
  x = 1:12,
  y = triplet_extremes(df, col = "A", shuffle_members = TRUE)$A,
  col = as.character(rep(1:4, each = 3))
)
# With shuffled triplets (run a few times)
plot(
  x = rep(1:6, each = 2),
  y = triplet_extremes(df, col = "A", shuffle_triplets = TRUE)$A,
  col = as.character(rep(1:4, each = 3))
)
</code></pre>


</div>