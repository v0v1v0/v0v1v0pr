<div class="container">

<table style="width: 100%;"><tr>
<td>fpcr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional principal component regression</h2>

<h3>Description</h3>

<p>Implements functional principal component regression (Reiss and Ogden,
2007, 2010) for generalized linear models with scalar responses and
functional predictors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fpcr(
  y,
  xfuncs = NULL,
  fdobj = NULL,
  ncomp = NULL,
  pve = 0.99,
  nbasis = NULL,
  basismat = NULL,
  penmat = NULL,
  argvals = NULL,
  covt = NULL,
  mean.signal.term = FALSE,
  spline.order = NULL,
  family = "gaussian",
  method = "REML",
  sp = NULL,
  pen.order = 2,
  cv1 = FALSE,
  nfold = 5,
  store.cv = FALSE,
  store.gam = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>scalar outcome vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xfuncs</code></td>
<td>
<p>for 1D predictors, an <code class="reqn">n \times d</code> matrix of
signals/functional predictors, where <code class="reqn">n</code> is the length of <code>y</code> and
<code class="reqn">d</code> is the number of sites at which each signal is defined.  For 2D
predictors, an <code class="reqn">n \times d1 \times d2</code> array representing <code class="reqn">n</code>
images of dimension <code class="reqn">d1 \times d2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fdobj</code></td>
<td>
<p>functional data object (class "<code>fd</code>") giving
the functional predictors. Allowed only for 1D functional predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>number of principal components. If <code>NULL</code>, this is chosen
by <code>pve</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pve</code></td>
<td>
<p>proportion of variance explained: used to choose the number of
principal components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>
<p>number(s) of B-spline basis functions: either a scalar, or a
vector of values to be compared.  For 2D predictors, tensor product
B-splines are used, with the given basis dimension(s) in each direction;
alternatively, <code>nbasis</code> can be given in the form <code>list(v1,v2)</code>,
in which case cross-validation will be performed for each combination of
the first-dimension basis sizes in <code>v1</code> and the second-dimension basis
sizes in <code>v2</code>. Ignored if <code>fdobj</code> is supplied. If <code>fdobj</code> is
<em>not</em> supplied, this defaults to 40 (i.e., 40 B-spline basis
functions) for 1D predictors, and 15 (i.e., tensor product B-splines with
15 functions per dimension) for 2D predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basismat</code></td>
<td>
<p>a <code class="reqn">d \times K</code> matrix of values of <code class="reqn">K</code> basis
functions at the <code class="reqn">d</code> sites.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penmat</code></td>
<td>
<p>a <code class="reqn">K \times K</code> matrix defining a penalty on the basis
coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>points at which the functional predictors and the
coefficient function are evaluated.  By default, if 1D functional
predictors are given by the <code class="reqn">n \times d</code> matrix <code>xfuncs</code>,
<code>argvals</code> is set to <code class="reqn">d</code> equally spaced points from 0 to 1; if they
are given by <code>fdobj</code>, <code>argvals</code> is set to 401 equally spaced
points spanning the domain of the given functions. For 2D (image)
predictors supplied as an <code class="reqn">n \times d1 \times d2</code> array, <code>argvals</code>
defaults to a list of (1) <code class="reqn">d1</code> equally spaced points from 0 to 1; (2)
<code class="reqn">d2</code> equally spaced points from 0 to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covt</code></td>
<td>
<p>covariates: an <code class="reqn">n</code>-row matrix, or a vector of length
<code class="reqn">n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.signal.term</code></td>
<td>
<p>logical: should the mean of each subject's signal
be included as a covariate?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spline.order</code></td>
<td>
<p>order of B-splines used, if <code>fdobj</code> is not
supplied; defaults to <code>4</code>, i.e., cubic B-splines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>generalized linear model family. Current version supports
<code>"gaussian"</code> (the default) and <code>"binomial"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>smoothing parameter selection method, passed to function
<code>gam</code>; see the <code>gam</code> documentation for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp</code></td>
<td>
<p>a fixed smoothing parameter; if <code>NULL</code>, an optimal value is
chosen (see <code>method</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pen.order</code></td>
<td>
<p>order of derivative penalty applied when estimating the
coefficient function; defaults to <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv1</code></td>
<td>
<p>logical: should cross-validation be performed to select the best
model if only one set of tuning parameters provided? By default,
<code>FALSE</code>. Note that, if there are multiple sets of tuning parameters
provided, cv is always performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfold</code></td>
<td>
<p>the number of validation sets ("folds") into which the data
are divided; by default, 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.cv</code></td>
<td>
<p>logical: should a CV result table be in the output? By
default, <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store.gam</code></td>
<td>
<p>logical: should the <code>gam</code> object be
included in the output? Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments passed to function <code>gam</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>One-dimensional functional predictors can be given either in functional
data object form, using argument <code>fdobj</code> (see the <span class="pkg">fda</span> package of
Ramsay, Hooker and Graves, 2009, and Method 1 in the example below), or
explicitly, using <code>xfuncs</code> (see Method 2 in the example).  In the
latter case, arguments <code>basismat</code> and <code>penmat</code> can also be used
to specify the basis and/or penalty matrices (see Method 3).
</p>
<p>For two-dimensional predictors, functional data object form is not
supported.  Instead of radial B-splines as in Reiss and Ogden (2010), this
implementation employs tensor product cubic B-splines, sometimes known as
bivariate O-splines (Ormerod, 2008).
</p>
<p>For purposes of interpreting the fitted coefficients, please note that the
functional predictors are decorrelated from the scalar predictors before
fitting the model (when there are no scalar predictors other than the
intercept, this just means the columns of the functional predictor matrix
are de-meaned); see section 3.2 of Reiss (2006) for details.
</p>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr style="vertical-align: top;">
<td><code>gamObject</code></td>
<td>
<p>if <code>store.gam = TRUE</code>,
an object of class <code>gam</code> (see <code>gamObject</code> in the
<span class="pkg">mgcv</span> package documentation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fhat</code></td>
<td>
<p>coefficient function
estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>pointwise Bayesian standard error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>undecor.coef</code></td>
<td>
<p>undecorrelated coefficient for covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>the supplied value of <code>argvals</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv.table</code></td>
<td>
<p>a
table giving the CV criterion for each combination of <code>nbasis</code> and
<code>ncomp</code>, if <code>store.cv = TRUE</code>; otherwise, the CV criterion only
for the optimized combination of these parameters.  Set to <code>NULL</code> if
CV is not performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis, ncomp</code></td>
<td>
<p>when CV is performed, the values
of <code>nbasis</code> and <code>comp</code> that minimize the CV criterion.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Philip Reiss <a href="mailto:phil.reiss@nyumc.org">phil.reiss@nyumc.org</a>, Lan Huo
<a href="mailto:lan.huo@nyumc.org">lan.huo@nyumc.org</a>, and Lei Huang <a href="mailto:huangracer@gmail.com">huangracer@gmail.com</a>
</p>


<h3>References</h3>

<p>Ormerod, J. T. (2008).  On semiparametric regression and data
mining.  Ph.D. dissertation, School of Mathematics and Statistics,
University of New South Wales.
</p>
<p>Ramsay, J. O., Hooker, G., and Graves, S. (2009). <em>Functional Data
Analysis with R and MATLAB</em>. New York: Springer.
</p>
<p>Reiss, P. T. (2006).  Regression with signals and images as predictors.
Ph.D. dissertation, Department of Biostatistics, Columbia University.
</p>
<p>Reiss, P. T., and Ogden, R. T. (2007).  Functional principal component
regression and functional partial least squares.  <em>Journal of the
American Statistical Association</em>, 102, 984–996.
</p>
<p>Reiss, P. T., and Ogden, R. T. (2010).  Functional generalized linear
models with images as predictors.  <em>Biometrics</em>, 66, 61–69.
</p>
<p>Wood, S. N. (2006). <em>Generalized Additive Models: An Introduction with
R</em>. Boca Raton, FL: Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
require(fda)
### 1D functional predictor example ###

######### Octane data example #########
data(gasoline)

# Create the requisite functional data objects
bbasis = create.bspline.basis(c(900, 1700), 40)
wavelengths = 2*450:850
nir &lt;- t(gasoline$NIR)
gas.fd = smooth.basisPar(wavelengths, nir, bbasis)$fd

# Method 1: Call fpcr with fdobj argument
gasmod1 = fpcr(gasoline$octane, fdobj = gas.fd, ncomp = 30)
plot(gasmod1, xlab="Wavelength")
## Not run: 
# Method 2: Call fpcr with explicit signal matrix
gasmod2 = fpcr(gasoline$octane, xfuncs = gasoline$NIR, ncomp = 30)
# Method 3: Call fpcr with explicit signal, basis, and penalty matrices
gasmod3 = fpcr(gasoline$octane, xfuncs = gasoline$NIR,
               basismat = eval.basis(wavelengths, bbasis),
               penmat = getbasispenalty(bbasis), ncomp = 30)

# Check that all 3 calls yield essentially identical estimates
all.equal(gasmod1$fhat, gasmod2$fhat, gasmod3$fhat)
# But note that, in general, you'd have to specify argvals in Method 1
# to get the same coefficient function values as with Methods 2 &amp; 3.

## End(Not run)

### 2D functional predictor example ###

n = 200; d = 70

# Create true coefficient function
ftrue = matrix(0,d,d)
ftrue[40:46,34:38] = 1

# Generate random functional predictors, and scalar responses
ii = array(rnorm(n*d^2), dim=c(n,d,d))
iimat = ii; dim(iimat) = c(n,d^2)
yy = iimat %*% as.vector(ftrue) + rnorm(n, sd=.3)

mm = fpcr(yy, ii, ncomp=40)

image(ftrue)
contour(mm$fhat, add=TRUE)

## Not run: 
### Cross-validation ###
cv.gas = fpcr(gasoline$octane, xfuncs = gasoline$NIR,
                 nbasis=seq(20,40,5), ncomp = seq(10,20,5), store.cv = TRUE)
image(seq(20,40,5), seq(10,20,5), cv.gas$cv.table, xlab="Basis size",
      ylab="Number of PCs", xaxp=c(20,40,4), yaxp=c(10,20,2))


## End(Not run)
</code></pre>


</div>