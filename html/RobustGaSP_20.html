<div class="container">

<table style="width: 100%;"><tr>
<td>findInertInputs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

find inert inputs with the posterior mode
</h2>

<h3>Description</h3>


<p>The function tests for inert inputs (inputs that barely affect the outputs) using the posterior mode. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">findInertInputs(object,threshold=0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object </code></td>
<td>


<p>an object of  class <code>rgasp</code> or the <code>ppgasp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>

<p>a threshold between 0 to 1. If the normalized inverse parameter of an input is smaller this value, it is classified as inert inputs. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>This function utilizes the following quantity 
</p>
<p>object@p*object@beta_hat*object@CL/sum(object@beta_hat*object@CL)
</p>
<p>for each input to identify the inert outputs. The average estimated normalized inverse range parameters will be 1. If the estimated normalized inverse range parameters of an input is close to 0, it means this input might be an inert input. 
</p>
<p>In this method, a prior that has shrinkage effects is suggested to use, .e.g the jointly robust prior (i.e. one should set <code>prior_choice='ref_approx'</code> in <code>rgasp()</code> to obtain the use <code>rgasp</code> object before using this function). Moreover, one may not add a lower bound of the range parameters to perform this method, i.e. one should set <code>lower_bound=F</code> in <code>rgasp()</code>.  For more details see Chapter 4 in the reference below.
</p>
<p>Mengyang Gu. (2016). Robust Uncertainty Quantification and Scalable Computation for Computer Models with Massive Output. Ph.D. thesis. Duke University.
</p>


<h3>Value</h3>

<p>A vector that has the same dimension of the number of inputs indicating how likely the inputs are inerts. The average value is 1. When a value is very close to zero, it tends to be an inert inputs. 
</p>


<h3>Author(s)</h3>


<p>Mengyang Gu [aut, cre],
  Jesus Palomo [aut],
  James Berger [aut]
</p>
<p>Maintainer: Mengyang Gu &lt;mengyang@pstat.ucsb.edu&gt;
</p>


<h3>References</h3>

<p>Mengyang Gu. (2016). Robust Uncertainty Quantification and Scalable Computation for Computer Models with Massive Output. Ph.D. thesis. Duke University.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  #-----------------------------------------------
  # test for inert inputs in the Borehole function
  #-----------------------------------------------
# dimensional of the inputs
dim_inputs &lt;- 8    
# number of the inputs
num_obs &lt;- 40       

# uniform samples of design
set.seed(0)
input &lt;-matrix(runif(num_obs*dim_inputs), num_obs,dim_inputs) 
# Following codes use maximin Latin Hypercube Design, which is typically better than uniform
# library(lhs)
# input &lt;- maximinLHS(n=num_obs, k=dim_inputs)  # maximin lhd sample

# rescale the design to the domain
input[,1]&lt;-0.05+(0.15-0.05)*input[,1];
input[,2]&lt;-100+(50000-100)*input[,2];
input[,3]&lt;-63070+(115600-63070)*input[,3];
input[,4]&lt;-990+(1110-990)*input[,4];
input[,5]&lt;-63.1+(116-63.1)*input[,5];
input[,6]&lt;-700+(820-700)*input[,6];
input[,7]&lt;-1120+(1680-1120)*input[,7];
input[,8]&lt;-9855+(12045-9855)*input[,8];

# outputs from the 8 dim Borehole function

output=matrix(0,num_obs,1)
for(i in 1:num_obs){
  output[i]=borehole(input[i,])
}





# use constant mean basis with trend, with no constraint on optimization
m3&lt;- rgasp(design = input, response = output, lower_bound=FALSE)

P=findInertInputs(m3)


</code></pre>


</div>