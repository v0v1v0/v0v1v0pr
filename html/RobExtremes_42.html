<div class="container">

<table style="width: 100%;"><tr>
<td>internal_interpolate_helpers_for_RobExtremes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal helper functions for generating interpolation grids for
speed up in package RobExtremes</h2>

<h3>Description</h3>

<p>These functions are used internally to generate interpolation grids,
for Lagrange multipliers or LDEstimators in package <span class="pkg">RobExtremes</span>,
to be stored in the respective ‘<span class="file">sysdata.rda</span>’ file. </p>


<h3>Usage</h3>

<pre><code class="language-R">.getPsi(param, fct, L2Fam , type)
.getPsi.wL(param, fct, L2Fam , type)
.getPsi.P(xi, L2Fam , type)


.is.na.Psi(param, fct, nam = "shape")

.modify.xi.PFam.call(xi, PFam)

.RMXE.xi(xi, PFam)
.MBRE.xi(xi, PFam)
.OMSE.xi(xi, PFam)

.getLMGrid(xiGrid = getShapeGrid(), PFam = GParetoFamily(scale=1,shape=2),
           optFct = .RMXE.xi, GridFileName="LMGrid.Rdata", withPrint = FALSE,
           len = 13)

.svInt(optF = .RMXE.th, xiGrid = getShapeGrid(700, cutoff.at.0=0.005),
       PFam = GParetoFamily(shape=1,scale=2), radius = 0.5, upper = 1e4,
       lower = 1e-4, OptOrIter = "iterate",  maxiter = 150,
       tol = .Machine$double.eps^0.5, loRad = 0, upRad = Inf, loRad0 = 1e-3,
       loRad.s = 0.2, upRad.s = 1, withStartLM = TRUE, len = 13, namFzus = "")

.generateInterpGridSn(xiGrid = getShapeGrid(500, cutoff.at.0=0.005),
                      PFam = GParetoFamily(), withPrint = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>object of class <code>"ParamFamParameter"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fct</code></td>
<td>
<p>list of functions containing the interpolators. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2Fam</code></td>
<td>
<p>an object of class <code>"L2ParamFamily"</code>, the parametric family
at which to evaluate the Lagrange multipliers or LDEstimators;
in our use case, it is a shape-scale model, hence the respective
(main) parameter must contain <code>"scale"</code> and <code>"shape"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nam</code></td>
<td>
<p>character; name of the shape parameter. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of the optimality: one of ".OMSE" for maxMSE,
".RMXE" for rmx, and  ".MBRE" for MBRE. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>numeric of length 1; shape value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PFam</code></td>
<td>
<p>an object of class <code>"ParamFamily"</code>, the parametric family
at which to evaluate the Lagrange multipliers or LDEstimators;
in our use case, it is a shape-scale model, hence the respective
(main) parameter must contain <code>"scale"</code> and <code>"shape"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xiGrid</code></td>
<td>
<p>numeric; grid of shape values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optFct, optF</code></td>
<td>
<p>function with arguments <code>xi</code> and <code>PFam</code>;
determines the Lagrange multipliers. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GridFileName</code></td>
<td>
<p>character; if <code>GridFileName!=""</code>, the pure
y-grid values are saved under this filename. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withPrint</code></td>
<td>
<p>logical of length 1: shall current shape value be printed out?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p> [for OMSE]: positive numeric of length 1: the radius of the
neighborhood for which the LM's are to be computed;
defaults to 0.5. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRad</code></td>
<td>
<p> the lower end point of the interval to be searched
in the inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upRad</code></td>
<td>
<p> the upper end point of the interval to be searched in the
inner optimization (for the least favorable situation
to the user-guessed radius). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRad.s</code></td>
<td>
<p> the lower end point of the interval
to be searched in the outer optimization
(for the user-guessed radius); if <code>NULL</code>
set to <code>loRad</code> in the algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upRad.s</code></td>
<td>
<p> the upper end point of the interval to be searched in the
outer optimization (for the user-guessed radius); if
<code>NULL</code> set to <code>upRad</code> in the algorithm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loRad0</code></td>
<td>
<p> for numerical reasons: the effective lower bound for the zero search;
internally set to <code>max(loRad,loRad0)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withStartLM</code></td>
<td>
<p> logical of length 1: shall the LM's of the preceding grid
value serve as starting value for the next grid value? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p>integer; number of Lagrange multipliers to be calibrated. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namFzus</code></td>
<td>
<p>character; infix for the name of the ‘<span class="file">.csv</span>’-File
to which the results are written; used to split the
work on xi-grids into chunks.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>.getpsi</code> reads the respective interpolating function
from an object from ‘<span class="file">sysdata.rda</span>’ and generates a respective
<code>HampelIC</code> object by a call to  <code>generateIC</code>.
<code>.getpsi.wL</code> does the same thing for the 3-dim model
<code>GEVFamilyMuUnknown</code>.
Last, due to scale equivariance, or the <code>ParetoFamliy</code>, <code>.getpsi.P</code>
reads the LM's for the reference parameter and then generates
the  respective <code>HampelIC</code> object by a call to  <code>generateIC</code>.
</p>
<p><code>.is.na.Psi</code> checks whether the shape parameter already lies
beyond the range for which inter-/extrapolation is admitted
(and, correspondingly, returns <code>TRUE</code> if one has to compute the
IC completely anew.).
</p>
<p><code>.MBRE.xi</code> computes the Lagrange multipliers for the MBRE estimator,
<code>.OMSE.xi</code> for the OMSE estimator at radius <code>r=0.5</code>,
and <code>.RMXE.xi</code> the RMXE estimator.
</p>
<p><code>.svInt</code> is a short form for <code>ROptEst:::.generateInterpGrid</code>
for LM interpolation.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.getpsi</code></td>
<td>
<p>an IC. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.is.na.Psi</code></td>
<td>
<p>logical of length 1. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.modify.xi.PFam.call</code></td>
<td>
<p>A call to evaluate the parametric
family at the new parameter value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.MBRE.xi</code></td>
<td>
<p>A list with items <code>b</code> (a number; clipping height),
<code>a</code> (a 2-vector; outer centering),
<code>a.w</code> (a 2-vector; inner centering, in
the weight), <code>A</code> (a 2x2 matrix; outer standardization),
<code>A.w</code> (a 2x2 matrix; inner standardization, in the weight).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.OMSE.xi</code></td>
<td>
<p>as <code>.MBRE.xi</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.RMXE.xi</code></td>
<td>
<p>as <code>.MBRE.xi</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.getLMGrid</code></td>
<td>
<p>A list with items <code>grid</code>, a matrix with the interpolation
grid and <code>fct</code> a function in <code>x</code> (the shape)
and <code>i</code> deciding on the Lagrange multiplier. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.generateInterpGridSn</code></td>
<td>
  <p><code>invisible(NULL)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.svInt</code></td>
<td>
  <p><code>invisible(NULL)</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>These functions are only meant for the developers of package <span class="pkg">RobExtremes</span>
(or respective packages).
They can be used to speed up things by interpolation.
Our use case is a speed up for further scale-shape families (or enhance
existing speed-ups) such that the respective grids are stored in
the ‘<span class="file">sysdata.rda</span>’ file of this package and can be used in
(exported) new particular methods for functional <code>Sn</code>.
Special attention has to be paid for R-versions pre and post R-2.16.
So if interpolation functions are desired for both alternatives, one
has to run <code>ROptEst:::.recomputeInterpolators</code> once on each
version.
</p>


<h3>See Also</h3>

<p><code>interpolateSn</code></p>


</div>