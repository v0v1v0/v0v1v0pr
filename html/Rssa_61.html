<div class="container">

<table style="width: 100%;"><tr>
<td>iossa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Iterative O-SSA nested decomposition</h2>

<h3>Description</h3>

<p>Perform Iterative O-SSA (IOSSA) algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'ssa'
iossa(x, nested.groups, ..., tol = 1e-5, kappa = 2,
      maxiter = 100,
      norm = function(x) sqrt(mean(x^2)),
      trace = FALSE,
      kappa.balance = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>SSA object holding SSA decomposition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested.groups</code></td>
<td>
<p>list or named list of numbers of eigentriples
from full decomposition, describes initial grouping for IOSSA iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for IOSSA iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>‘kappa’ parameter for sigma-correction (see ‘Details’ and ‘References’) procedure.
If 'NULL', sigma-correction will not be performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>upper bound for the number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>function, calculates a norm of a vector; this norm is
applied to the difference between the reconstructed series at
sequential iterations and is used for convergence detection</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical, indicates whether the convergence process should be traced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa.balance</code></td>
<td>
<p>sharing proportion of sigma-correction multiplier
between column and row inner products</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>decompose</code>
routines</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See Golyandina N. and Shlemov A. (2015) and Section 2.4 in Golyanina et al (2018) 
for full details in the 1D case and 
p.250-252 from the same book for an example in the 2D case.
</p>
<p>Briefly, Iterative Oblique SSA (IOSSA) is an iterative (EM-like) method for
improving separability in SSA. In particular, it serves for separation
of mixed components, which are not  orthogonal, e.g., of sinusoids
with close frequencies or for trend separation for short series. IOSSA
performs a new decomposition of a part of the ssa-object, which is
given by a set of eigentriples. Note that eigentriples that do not
belong to the chosen set are not changed.
</p>
<p>Oblique SSA can make many series orthogonal by the choice of inner
product. Iterative O-SSA find the separating inner products by
iterations that are hopefully converges to a stationary point. See
References for more details.
</p>
<p>Sigma-correction procedure does the renormalization of new inner
products. This prevents the mixing of the components during the next
iteration. Such approach makes the whole procedure more stable and can
solve the problem of lack of strong separability.
</p>
<p>Details of the used algorithms can be found in Golyandina et al (2018), 
Algorithms 2.7 and 2.8.
</p>


<h3>Value</h3>

<p>Object of ‘ossa’ class. In addition to usual ‘ssa’ class
fields, it also contains the following fields:
</p>

<dl>
<dt>iossa.result</dt>
<dd>
<p>object of ‘iossa.result’ class, a list which
contains algorithm parameters, condition numbers, separability
measures, the number of iterations and convergence status (see
<code>iossa.result</code>)</p>
</dd>
<dt>iossa.groups</dt>
<dd>
<p>list of groups within the nested decomposition;
numbers of components correspond to their numbers in the full
decomposition</p>
</dd>
<dt>iossa.groups.all</dt>
<dd>
<p>list, describes cumulative grouping after
after sequential Iterative O-SSA decompositions in the case of
non-intersecting <code>nested.groups</code>. Otherwise,
<code>iossa.groups.all</code> coincides with <code>iossa.groups</code></p>
</dd>
<dt>ossa.set</dt>
<dd>
<p>vector of the indices of elementary components used
in Iterative O-SSA (that is, used in <code>nested.groups</code>)</p>
</dd>
</dl>
<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Golyandina N. and Shlemov A. (2015): <em>Variations of Singular Spectrum Analysis
for separability improvement: non-orthogonal decompositions of time series</em>, 
Statistics and Its Interface. Vol.8, No 3, P.277-294.
<a href="https://arxiv.org/abs/1308.4022">https://arxiv.org/abs/1308.4022</a>
</p>


<h3>See Also</h3>

<p><code>Rssa</code> for an overview of the package, as well as,
<code>ssa-object</code>,
<code>fossa</code>,
<code>owcor</code>,
<code>iossa.result</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Separate three non-separable sine series with different amplitudes
N &lt;- 150
L &lt;- 70

omega1 &lt;- 0.05
omega2 &lt;- 0.06
omega3 &lt;- 0.07

F &lt;- 4*sin(2*pi*omega1 * (1:N)) + 2*sin(2*pi*omega2 * (1:N)) + sin(2*pi*omega3 * (1:N))
s &lt;- ssa(F, L)
ios &lt;- iossa(s, nested.groups = list(1:2, 3:4, 5:6), kappa = NULL, maxiter = 100, tol = 1e-3)

plot(reconstruct(ios, groups = ios$iossa.groups))
summary(ios)


# Separate two non-separable sines with equal amplitudes
N &lt;- 200
L &lt;- 100
omega1 &lt;- 0.07
omega2 &lt;- 0.06

F &lt;- sin(2*pi*omega1 * (1:N)) + sin(2*pi*omega2 * (1:N))
s &lt;- ssa(F, L)

# Apply FOSSA and then IOSSA
fs &lt;- fossa(s, nested.groups = 1:4)
ios &lt;- iossa(fs, nested.groups = list(1:2, 3:4), maxiter = 100)
summary(ios)

opar &lt;- par(mfrow = c(3, 1))
plot(reconstruct(s, groups = list(1:2, 3:4)))
plot(reconstruct(fs, groups = list(1:2, 3:4)))
plot(reconstruct(ios, groups = ios$iossa.groups))
par(opar)

wo &lt;- plot(wcor(ios, groups = 1:4))
gwo &lt;- plot(owcor(ios, groups = 1:4))
plot(wo, split = c(1, 1, 2, 1), more = TRUE)
plot(gwo, split = c(2, 1, 2, 1), more = FALSE)



data(USUnemployment)
unempl.male &lt;- USUnemployment[, "MALE"]

s &lt;- ssa(unempl.male)
ios &lt;- iossa(s, nested.groups = list(c(1:4, 7:11), c(5:6, 12:13)))
summary(ios)

# Comparison of reconstructions
rec &lt;- reconstruct(s, groups = list(c(1:4, 7:11), c(5:6, 12:13)))
iorec &lt;- reconstruct(ios, groups &lt;- ios$iossa.groups)
# Trends
matplot(data.frame(iorec$F1, rec$F1, unempl.male), type='l',
        col=c("red","blue","black"), lty=c(1,1,2))
# Seasonalities
matplot(data.frame(iorec$F2, rec$F2), type='l', col=c("red","blue"),lty=c(1,1))

# W-cor matrix before IOSSA and w-cor matrix after it
ws &lt;- plot(wcor(s, groups = 1:30), grid = 14)
wios &lt;- plot(wcor(ios, groups = 1:30), grid = 14)
plot(ws, split = c(1, 1, 2, 1), more = TRUE)
plot(wios, split = c(2, 1, 2, 1), more = FALSE)

# Eigenvectors before and after Iterative O-SSA
plot(s, type = "vectors", idx = 1:13)
plot(ios, type = "vectors", idx = 1:13)

# 2D plots of periodic eigenvectors before and after Iterative O-SSA
plot(s, type = "paired", idx = c(5, 12))
plot(ios, type = "paired", idx = c(10, 12), plot.contrib = FALSE)

data(AustralianWine)
Fortified &lt;- AustralianWine[, "Fortified"]
s &lt;- ssa(window(Fortified, start = 1982 + 5/12, end = 1986 + 5/12), L = 18)
ios &lt;- iossa(s, nested.groups = list(trend = 1, 2:7),
             kappa = NULL,
             maxIter = 1)
fs &lt;- fossa(s, nested.groups = 1:7, gamma = 1000)

rec.ssa &lt;- reconstruct(s, groups = list(trend = 1, 2:7))
rec.iossa &lt;- reconstruct(ios, groups = ios$iossa.groups);
rec.fossa &lt;- reconstruct(fs, groups = list(trend = 7, 1:6))

Fort &lt;- cbind(`Basic SSA trend` = rec.ssa$trend,
              `Iterative O-SSA trend` = rec.iossa$trend,
              `DerivSSA trend` = rec.fossa$trend,
              `Full series` = Fortified)

library(lattice)
xyplot(Fort, superpose = TRUE, col = c("red", "blue", "green4", "black"))



# Shaped 2D I. O-SSA separates finite rank fields exactly
mx1 &lt;- outer(1:50, 1:50,
             function(i, j) exp(i/25 - j/20))
mx2 &lt;- outer(1:50, 1:50,
             function(i, j) sin(2*pi * i/17) * cos(2*pi * j/7))

mask &lt;- matrix(TRUE, 50, 50)
mask[23:25, 23:27] &lt;- FALSE
mask[1:2, 1] &lt;- FALSE
mask[50:49, 1] &lt;- FALSE
mask[1:2, 50] &lt;- FALSE

mx1[!mask] &lt;- mx2[!mask] &lt;- NA

s &lt;- ssa(mx1 + mx2, kind = "2d-ssa", L = c(10, 10))
plot(reconstruct(s, groups = list(1, 2:5)))

ios &lt;- iossa(s, nested.groups = list(1, 2:5), kappa = NULL)
plot(reconstruct(ios, groups = ios$iossa.groups))


# I. O-SSA for MSSA
N.A &lt;- 150
N.B &lt;- 120
L &lt;- 40

omega1 &lt;- 0.05
omega2 &lt;- 0.055

tt.A &lt;- 1:N.A
tt.B &lt;- 1:N.B
F1 &lt;- list(A = 2 * sin(2*pi * omega1 * tt.A), B = cos(2*pi * omega1 * tt.B))
F2 &lt;- list(A = 1 * sin(2*pi * omega2 * tt.A), B = cos(2*pi * omega2 * tt.B))

F &lt;- list(A = F1$A + F2$A, B = F1$B + F2$B)

s &lt;- ssa(F, kind = "mssa")
plot(reconstruct(s, groups = list(1:2, 3:4)), plot.method = "xyplot")

ios &lt;- iossa(s, nested.groups = list(1:2, 3:4), kappa = NULL)
plot(reconstruct(ios, groups = ios$iossa.groups), plot.method = "xyplot")

</code></pre>


</div>