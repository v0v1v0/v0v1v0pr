<div class="container">

<table style="width: 100%;"><tr>
<td>KorAPQuery-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class KorAPQuery</h2>

<h3>Description</h3>

<p>This class provides methods to perform different kinds of queries on the KorAP API server.
<code>KorAPQuery</code> objects, which are typically created by the <code>corpusQuery()</code> method,
represent the current state of a query to a KorAP server.
</p>
<p><strong><code>corpusQuery</code></strong> performs a corpus query via a connection to a KorAP-API-server
</p>
<p><strong><code>fetchNext</code></strong> fetches the next bunch of results of a KorAP query.
</p>
<p><strong><code>fetchAll</code></strong> fetches all results of a KorAP query.
</p>
<p><strong><code>frequencyQuery</code></strong> combines <code>corpusQuery()</code>, <code>corpusStats()</code> and
<code>ci()</code> to compute a table with the relative frequencies and
confidence intervals of one ore multiple search terms across one or multiple
virtual corpora.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'KorAPQuery'
initialize(
  .Object,
  korapConnection = NULL,
  request = NULL,
  vc = "",
  totalResults = 0,
  nextStartIndex = 0,
  fields = c("corpusSigle", "textSigle", "pubDate", "pubPlace", "availability",
    "textClass", "snippet", "tokens"),
  requestUrl = "",
  webUIRequestUrl = "",
  apiResponse = NULL,
  hasMoreMatches = FALSE,
  collectedMatches = NULL
)

## S4 method for signature 'KorAPConnection'
corpusQuery(
  kco,
  query = if (missing(KorAPUrl))
    stop("At least one of the parameters query and KorAPUrl must be specified.", call. =
    FALSE) else httr::parse_url(KorAPUrl)$query$q,
  vc = if (missing(KorAPUrl)) "" else httr::parse_url(KorAPUrl)$query$cq,
  KorAPUrl,
  metadataOnly = TRUE,
  ql = if (missing(KorAPUrl)) "poliqarp" else httr::parse_url(KorAPUrl)$query$ql,
  fields = c("corpusSigle", "textSigle", "pubDate", "pubPlace", "availability",
    "textClass", "snippet", "tokens"),
  accessRewriteFatal = TRUE,
  verbose = kco@verbose,
  expand = length(vc) != length(query),
  as.df = FALSE,
  context = NULL
)

## S4 method for signature 'KorAPQuery'
fetchNext(
  kqo,
  offset = kqo@nextStartIndex,
  maxFetch = maxResultsPerPage,
  verbose = kqo@korapConnection@verbose,
  randomizePageOrder = FALSE
)

## S4 method for signature 'KorAPQuery'
fetchAll(kqo, verbose = kqo@korapConnection@verbose, ...)

## S4 method for signature 'KorAPQuery'
fetchRest(kqo, verbose = kqo@korapConnection@verbose, ...)

## S4 method for signature 'KorAPConnection'
frequencyQuery(
  kco,
  query,
  vc = "",
  conf.level = 0.95,
  as.alternatives = FALSE,
  ...
)

buildWebUIRequestUrl(
  kco,
  query = if (missing(KorAPUrl))
    stop("At least one of the parameters query and KorAPUrl must be specified.", call. =
    FALSE) else httr::parse_url(KorAPUrl)$query$q,
  vc = if (missing(KorAPUrl)) "" else httr::parse_url(KorAPUrl)$query$cq,
  KorAPUrl,
  metadataOnly = TRUE,
  ql = if (missing(KorAPUrl)) "poliqarp" else httr::parse_url(KorAPUrl)$query$ql,
  fields = c("corpusSigle", "textSigle", "pubDate", "pubPlace", "availability",
    "textClass", "snippet", "tokens"),
  accessRewriteFatal = TRUE
)

## S3 method for class 'KorAPQuery'
format(x, ...)

## S4 method for signature 'KorAPQuery'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.Object</code></td>
<td>
<p>…</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>korapConnection</code></td>
<td>
<p>KorAPConnection object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>request</code></td>
<td>
<p>query part of the request URL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vc</code></td>
<td>
<p>string describing the virtual corpus in which the query should be performed. An empty string (default) means the whole corpus, as far as it is license-wise accessible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totalResults</code></td>
<td>
<p>number of hits the query has yielded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nextStartIndex</code></td>
<td>
<p>at what index to start the next fetch of query results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fields</code></td>
<td>
<p>(meta)data fields that will be fetched for every match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>requestUrl</code></td>
<td>
<p>complete URL of the API request</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>webUIRequestUrl</code></td>
<td>
<p>URL of a web frontend request corresponding to the API request</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>apiResponse</code></td>
<td>
<p>data-frame representation of the JSON response of the API request</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hasMoreMatches</code></td>
<td>
<p>logical that signals if more query results can be fetched</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collectedMatches</code></td>
<td>
<p>matches already fetched from the KorAP-API-server</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kco</code></td>
<td>
<p><code>KorAPConnection()</code> object (obtained e.g. from <code>new("KorAPConnection")</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>string that contains the corpus query. The query language depends on the <code>ql</code> parameter. Either <code>query</code> must be provided or <code>KorAPUrl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>KorAPUrl</code></td>
<td>
<p>instead of providing the query and vc string parameters, you can also simply copy a KorAP query URL from your browser and use it here (and in <code>KorAPConnection</code>) to provide all necessary information for the query.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metadataOnly</code></td>
<td>
<p>logical that determines whether queries should return only metadata without any snippets. This can also be useful to prevent access rewrites. Note that the default value is TRUE.
If you want your corpus queries to return not only metadata, but also KWICS, you need to authorize
your RKorAPClient application as explained in the
<a href="https://github.com/KorAP/RKorAPClient#authorization">authorization section</a>
of the RKorAPClient Readme on GitHub and set the <code>metadataOnly</code> parameter to
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ql</code></td>
<td>
<p>string to choose the query language (see <a href="https://github.com/KorAP/Kustvakt/wiki/Service:-Search-GET#user-content-parameters">section on Query Parameters</a> in the Kustvakt-Wiki for possible values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accessRewriteFatal</code></td>
<td>
<p>abort if query or given vc had to be rewritten due to insufficient rights (not yet implemented).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print progress information if true</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expand</code></td>
<td>
<p>logical that decides if <code>query</code> and <code>vc</code> parameters are expanded to all of their combinations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.df</code></td>
<td>
<p>return result as data frame instead of as S4 object?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>context</code></td>
<td>
<p>string that specifies the size of the left and the right context returned in <code>snippet</code>
(provided that <code>metadataOnly</code> is set to <code>false</code> and that the necessary access right are  met).
The format of the context size specifcation (e.g. <code style="white-space: pre;">⁠3-token,3-token⁠</code>) is described in the <a href="https://github.com/KorAP/Kustvakt/wiki/Service:-Search-GET">Service: Search GET documentation of the Kustvakt Wiki</a>.
If the parameter is not set, the default context size secification of the KorAP server instance will be used.
Note that you cannot overrule the maximum context size set in the KorAP server instance,
as this is typically legally motivated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kqo</code></td>
<td>
<p>object obtained from <code>corpusQuery()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>start offset for query results to fetch</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxFetch</code></td>
<td>
<p>maximum number of query results to fetch</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomizePageOrder</code></td>
<td>
<p>fetch result pages in pseudo random order if true. Use <code>set.seed()</code> to set seed for reproducible results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>confidence level of the returned confidence interval (passed through <code>ci()</code>  to <code>prop.test()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.alternatives</code></td>
<td>
<p>LOGICAL that specifies if the query terms should be treated as alternatives. If <code>as.alternatives</code> is TRUE, the sum over all query hits, instead of the respective vc token sizes is used as total for the calculation of relative frequencies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>KorAPQuery object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>KorAPQuery object</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Depending on the <code>as.df</code> parameter, a table or a <code>KorAPQuery()</code> object that, among other information, contains the total number of results in <code style="white-space: pre;">⁠@totalResults⁠</code>. The resulting object can be used to fetch all query results (with <code>fetchAll()</code>) or the next page of results (with <code>fetchNext()</code>).
A corresponding URL to be used within a web browser is contained in <code style="white-space: pre;">⁠@webUIRequestUrl⁠</code>
Please make sure to check <code style="white-space: pre;">⁠$collection$rewrites⁠</code> to see if any unforeseen access rewrites of the query's virtual corpus had to be performed.
</p>
<p>The <code>kqo</code> input object with updated slots <code>collectedMatches</code>, <code>apiResponse</code>, <code>nextStartIndex</code>, <code>hasMoreMatches</code>
</p>


<h3>References</h3>

<p><a href="https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026">https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026</a>
</p>
<p><a href="https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026">https://ids-pub.bsz-bw.de/frontdoor/index/index/docId/9026</a>
</p>


<h3>See Also</h3>

<p><code>KorAPConnection()</code>, <code>fetchNext()</code>, <code>fetchRest()</code>, <code>fetchAll()</code>, <code>corpusStats()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# Fetch metadata of every query hit for "Ameisenplage" and show a summary
new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchAll()

## End(Not run)

## Not run: 

# Use the copy of a KorAP-web-frontend URL for an API query of "Ameise" in a virtual corpus
# and show the number of query hits (but don't fetch them).

new("KorAPConnection", verbose = TRUE) %&gt;%
 corpusQuery(KorAPUrl =
   "https://korap.ids-mannheim.de/?q=Ameise&amp;cq=pubDate+since+2017&amp;ql=poliqarp")

## End(Not run)

## Not run: 

# Plot the time/frequency curve of "Ameisenplage"
new("KorAPConnection", verbose=TRUE) %&gt;%
  { . -&gt;&gt; kco } %&gt;%
  corpusQuery("Ameisenplage") %&gt;%
  fetchAll() %&gt;%
  slot("collectedMatches") %&gt;%
  mutate(year = lubridate::year(pubDate)) %&gt;%
  dplyr::select(year) %&gt;%
  group_by(year) %&gt;%
  summarise(Count = dplyr::n()) %&gt;%
  mutate(Freq = mapply(function(f, y)
    f / corpusStats(kco, paste("pubDate in", y))@tokens, Count, year)) %&gt;%
  dplyr::select(-Count) %&gt;%
  complete(year = min(year):max(year), fill = list(Freq = 0)) %&gt;%
  plot(type = "l")

## End(Not run)
## Not run: 

q &lt;- new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchNext()
q@collectedMatches

## End(Not run)

## Not run: 

q &lt;- new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchAll()
q@collectedMatches

## End(Not run)

## Not run: 

q &lt;- new("KorAPConnection") %&gt;% corpusQuery("Ameisenplage") %&gt;% fetchRest()
q@collectedMatches

## End(Not run)

## Not run: 

new("KorAPConnection", verbose = TRUE) %&gt;%
  frequencyQuery(c("Mücke", "Schnake"), paste0("pubDate in ", 2000:2003))

## End(Not run)

</code></pre>


</div>