<div class="container">

<table style="width: 100%;"><tr>
<td>row-col-notation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Row and column notation</h2>

<h3>Description</h3>

<p>It is often convenient to represent matrix row and column names
with notation that includes a prefix and a suffix,
with corresponding separators or start-end string sequences.
There are several functions to generate specialized versions
or otherwise manipulate row and column names on their own or as row or column names.
</p>

<ul>
<li> <p><code>flip_pref_suff()</code> Switches the location of prefix and suffix, such that the prefix becomes the suffix, and
the suffix becomes the prefix.
E.g., "a -&gt; b" becomes "b -&gt; a" or "a [b]" becomes "b [a]".
</p>
</li>
<li> <p><code>get_pref_suff()</code> Selects only prefix or suffix, discarding notational elements
and the rejected part.
Internally, this function calls <code>split_pref_suff()</code> and selects only the desired portion.
</p>
</li>
<li> <p><code>notation_vec()</code> Builds a vector of notation symbols in a standard format.
By default, it builds a list of notation symbols that provides an arrow
separator (" -&gt; ") between prefix and suffix.
</p>
</li>
<li> <p><code>paste_pref_suff()</code> <code>paste0</code>'s prefixes and suffixes, the inverse of <code>split_pref_suff()</code>.
Always returns a character vector.
</p>
</li>
<li> <p><code>preposition_notation()</code> Builds a list of notation symbols that provides (by default) square brackets around the suffix with a preposition ("prefix [preposition suffix]").
</p>
</li>
<li> <p><code>split_pref_suff()</code> Splits prefixes from suffixes, returning each in a list with names <code>pref</code> and <code>suff</code>.
If no prefix or suffix delimiters are found, <code>x</code> is returned in the <code>pref</code> item, unmodified,
and the <code>suff</code> item is returned as <code>""</code> (an empty string).
If there is no prefix, and empty string is returned for the <code>pref</code> item.
If there is no suffix, and empty string is returned for the <code>suff</code> item.
</p>
</li>
<li> <p><code>switch_notation()</code> Switches from one type of notation to another based on the <code>from</code> and <code>to</code> arguments.
Optionally, prefix and suffix can be <code>flip</code>ped.
</p>
</li>
</ul>
<p>Parts of a <code>notation</code> vector are
"pref_start", "pref_end", "suff_start", and "suff_end".
None of the strings in a notation vector are considered part of the prefix or suffix.
E.g., "a -&gt; b" in arrow notation means that "a" is the prefix and "b" is the suffix.
If <code>sep</code> only is specified for <code>notation_vec()</code> (default is " -&gt; "),
<code>pref_start</code>, <code>pref_end</code>, <code>suff_start</code>, and <code>suff_end</code> are
set appropriately.
</p>
<p>For functions where the <code>notation</code> argument is used to identify portions of the row or column label
(such as <code>split_pref_suff()</code>, <code>get_pref_suff()</code>,
and the <code>from</code> argument to <code>switch_notation()</code>),
(Note: <code>flip_pref_suff()</code> cannot infer notation, because it switches prefix and suffix in a known, single notation.)
if <code>notation</code> is a list, it is treated as a store from which
the most appropriate notation is inferred by <code>infer_notation(choose_most_specific = TRUE)</code>.
Because default is <code>RCLabels::notations_list</code>,
notation is inferred by default.
The argument <code>choose_most_specific</code> tells what to do when two <code>notation</code>s match a label:
if <code>TRUE</code> (the default), the notation with most characters is selected.
If <code>FALSE</code>, the first matching notation in <code>notation</code> will be selected.
See details at <code>infer_notation()</code>.
</p>
<p>If specifying more than one <code>notation</code>, be sure the notations are in a list.
<code>notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>
is unlikely to produce the desired result, because the notations
are concatenated together to form a long string vector.
Rather say
<code>notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>.
</p>
<p>For functions that construct labels (such as <code>paste_pref_suff()</code>),
<code>notation</code> can be a list of notations
over which the paste tasks is mapped.
If <code>notation</code> is a list, it must have as many items as
there are prefix/suffix pairs to be pasted.
</p>
<p>If either <code>pref</code> or <code>suff</code> are a zero-length character vector
(essentially an empty character vector
such as obtained from <code>character()</code>)
input to <code>paste_pref_suff()</code>,
an error is thrown.
Instead, use an empty character string
(such as obtained from <code>""</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">notation_vec(
  sep = " -&gt; ",
  pref_start = "",
  pref_end = "",
  suff_start = "",
  suff_end = ""
)

preposition_notation(preposition, suff_start = " [", suff_end = "]")

split_pref_suff(
  x,
  transpose = FALSE,
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = TRUE
)

paste_pref_suff(
  ps = list(pref = pref, suff = suff),
  pref = NULL,
  suff = NULL,
  notation = RCLabels::arrow_notation,
  squish = TRUE
)

flip_pref_suff(
  x,
  notation = RCLabels::notations_list,
  inf_notation = TRUE,
  choose_most_specific = TRUE
)

get_pref_suff(
  x,
  which = c("pref", "suff"),
  inf_notation = TRUE,
  notation = RCLabels::notations_list,
  choose_most_specific = TRUE
)

switch_notation(
  x,
  from = RCLabels::notations_list,
  to,
  flip = FALSE,
  inf_notation = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>A string separator between prefix and suffix. Default is " -&gt; ".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pref_start</code></td>
<td>
<p>A string indicating the start of a prefix. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pref_end</code></td>
<td>
<p>A string indicating the end of a prefix. Default is the value of <code>sep</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suff_start</code></td>
<td>
<p>A string indicating the start of a suffix. Default is the value of <code>sep</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suff_end</code></td>
<td>
<p>A string indicating the end of a suffix. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preposition</code></td>
<td>
<p>A string used to indicate position for energy flows, typically "from" or "to" in different notations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A string or vector of strings to be operated upon.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transpose</code></td>
<td>
<p>A boolean that tells whether to <code>purr::transpose()</code> the result.
Set <code>transpose = TRUE</code> when using <code>split_pref_suff()</code> in a <code>dplyr::mutate()</code>
call in the context of a data frame.
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code>infer_notation()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notation</code></td>
<td>
<p>A notation vector generated by one of the <code style="white-space: pre;">⁠*_notation()⁠</code> functions, such as
<code>notation_vec()</code>, <code>arrow_notation</code>, or <code>bracket_notation</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choose_most_specific</code></td>
<td>
<p>A boolean that tells whether to choose the most specific
notation from the <code>notation</code> argument when the <code>notation</code> argument is a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps</code></td>
<td>
<p>A list of prefixes and suffixes in which each item of the list is itself a list with two items named <code>pref</code> and <code>suff</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pref</code></td>
<td>
<p>A string or list of strings that are prefixes. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suff</code></td>
<td>
<p>A string of list of strings that are suffixes. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>squish</code></td>
<td>
<p>A boolean that tells whether to remove extra spaces in the output of <code style="white-space: pre;">⁠paste_*()⁠</code> functions.
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Tells which to keep, the prefix ("pref") or the suffix ("suff").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>The <code>notation</code> to switch <em>away from</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>The <code>notation</code> to switch <em>to</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip</code></td>
<td>
<p>A boolean that tells whether to also flip the notation. Default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>notation_vec()</code>, <code>arrow_notation</code>, and <code>bracket_notation</code>,
a string vector with named items <code>pref_start</code>, <code>pref_end</code>, <code>suff_start</code>, and <code>suff_end</code>;
For <code>split_pref_suff()</code>, a string list with named items <code>pref</code> and <code>suff</code>.
For <code>paste_pref_suff()</code>, <code>split_pref_suff()</code>, and <code>switch_notation()</code>,
a string list in notation format specified by various <code>notation</code> arguments, including
<code>from</code>, and <code>to</code>.
For <code>keep_pref_suff</code>, one of the prefix or suffix or a list of prefixes or suffixes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">notation_vec()
arrow_notation
bracket_notation
split_pref_suff("a -&gt; b", notation = arrow_notation)
# Or infer the notation (by default from notations_list)
split_pref_suff("a -&gt; b")
split_pref_suff(c("a -&gt; b", "c -&gt; d", "e -&gt; f"))
split_pref_suff(c("a -&gt; b", "c -&gt; d", "e -&gt; f"), transpose = TRUE)
flip_pref_suff("a [b]", notation = bracket_notation)
# Infer notation
flip_pref_suff("a [b]")
get_pref_suff("a -&gt; b", which = "suff")
switch_notation("a -&gt; b", from = arrow_notation, to = bracket_notation)
# Infer notation and flip prefix and suffix
switch_notation("a -&gt; b", to = bracket_notation, flip = TRUE)
# Also works for vectors
switch_notation(c("a -&gt; b", "c -&gt; d"),
                from = arrow_notation,
                to = bracket_notation)
# Functions can infer the correct notation and return multiple matches
infer_notation("a [to b]",
               allow_multiple = TRUE,
               choose_most_specific = FALSE)
# Or choose the most specific notation
infer_notation("a [to b]",
               allow_multiple = TRUE,
               choose_most_specific = TRUE)
# When setting the from notation, only that type of notation will be switched
switch_notation(c("a -&gt; b", "c [to d]"),
                from = arrow_notation,
                to = bracket_notation)
# But if notations are inferred, all notations can be switched
switch_notation(c("a -&gt; b", "c [to d]"), to = bracket_notation)
# A double-switch can be accomplished.
# In this first example, `RCLabels::first_dot_notation` is inferred.
switch_notation("a.b.c", to = arrow_notation)
# In this second example,
# it is easier to specify the `from` and `to` notations.
switch_notation("a.b.c", to = arrow_notation) %&gt;%
  switch_notation(from = first_dot_notation, to = arrow_notation)
# "" can be used as an input
paste_pref_suff(pref = "a", suff = "", notation = RCLabels::from_notation)
</code></pre>


</div>