<div class="container">

<table style="width: 100%;"><tr>
<td>estimate.mle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit the Model</h2>

<h3>Description</h3>

<p>Estimate the parameters of the model by maximizing the likelihood function (or, rather, by minimizing the negative log likelihood).
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimate.mle(
  hessian = FALSE,
  H.E = NULL,
  H.W = NULL,
  cases = NULL,
  cfg = NULL,
  ini_params = NULL,
  params_limits = NULL,
  restrictions = NULL,
  restriction.starts = NULL,
  ranges = NULL,
  rt_func = 1,
  silence.errors = FALSE,
  fit.t.pred = NULL,
  param_scale = NULL,
  num.iter = NULL,
  scenario = NULL,
  adj.period = NULL,
  population = NULL,
  rho = NULL,
  serial_mean = serial_mean,
  serial_var = serial_var,
  lt = NULL,
  window_size = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>Logical. If TRUE, computes the variance-covariance matrix at the MLE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.E</code></td>
<td>
<p>Mobility metrics for category Retail &amp; Entertainment. Currently unsupported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H.W</code></td>
<td>
<p>Mobility metrics for category Workplaces. Currently unsupported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cases</code></td>
<td>
<p>Vector of case counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cfg</code></td>
<td>
<p>The object that contains all variables from the configuration file.
This includes all function arguments except for <code>cases</code>, <code>hessian</code>, <code>H.E</code>, and <code>H.W</code>. All other
arguments are overridden if <code>cfg</code> is passed to the method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ini_params</code></td>
<td>
<p>Initial parameter values to be used in optimization. Includes the following sets of parameters in a vector, in this order:
</p>

<ul>
<li>
<p>   (a1,a2,a3,a4) = parameters for curve c() specified by <code>rt_func</code>;
</p>
</li>
<li>
<p>   nu = loss of immunity rate;
</p>
</li>
<li>
<p>   (v2,v3,v4,v5) = transmissibility of variants in waves 2+, as relative multiplication factors compared to transmissibility in wave 1;
</p>
</li>
<li>
<p>   (psi1,psi2,psi3,psi4) = psi parameters for severity levels 1,2,3 and 4.
</p>
</li>
<li>
<p>   (u,v) = variance parameters. Only u is currently in use.
</p>
</li>
<li>
<p>   (beta0,beta.R,beta.E,beta.W), when restrictions = NULL. Currently unsupported.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>params_limits</code></td>
<td>
<p>Boundaries/limits of the ini_params.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restrictions</code></td>
<td>
<p>A numeric integer vector giving the severity of restrictions.
Zero means no restriction, and higher numbers means greater severity/disruption.
The ordered unique values should be consecutive integers starting from zero.
Each number (other than 0) adds a new parameter to the fit. restrictions = NULL
causes the function to use mobility data instead of the psi values (currently unsupported).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restriction.starts</code></td>
<td>
<p>A vector of same length as restrictions, of times when restrictions
came into effect. Note: the first index time should be 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranges</code></td>
<td>
<p>An vector of time ranges for the different waves.
The waves ranges should be contiguous, with at least one unit of time
between consecutive waves.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rt_func</code></td>
<td>
<p>The parametric form of function c(). Options are listed under function c_helper.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silence.errors</code></td>
<td>
<p>Logical. If TRUE, ignores certain errors to allow optimization to proceed. Not all errors can be ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.t.pred</code></td>
<td>
<p>Time from which prediction is done. If use.actual.not.predicted is TRUE, values of <code class="reqn">S_t</code> before this time will be computed using actual counts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param_scale</code></td>
<td>
<p>Parameter scale. Passed as argument parscale to optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.iter</code></td>
<td>
<p>Maximum number of iterations. Passed as argument maxit to optim.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scenario</code></td>
<td>
<p>A character string describing options to deal with restrictions. Currently unsupported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.period</code></td>
<td>
<p>Delays in society adjusting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>population</code></td>
<td>
<p>total population size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>A vector of under-reporting rates of the same length as cases. If a scalar is supplied, the vector will be constant with this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lt</code></td>
<td>
<p>The length of cases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If TRUE, provides additional details while running the function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of maximum likelihood estimates of the parameters. Includes:
</p>

<ul>
<li>
<p> a1
</p>
</li>
<li>
<p> a2
</p>
</li>
<li>
<p> a3
</p>
</li>
<li>
<p> a4
</p>
</li>
<li>
<p> nu
</p>
</li>
<li>
<p> vt_params_est
</p>
</li>
<li>
<p> Psi
</p>
</li>
<li>
<p> betas
</p>
</li>
<li>
<p> negative_log_lik
</p>
</li>
<li>
<p> mle
</p>
</li>
<li>
<p> hessian
</p>
</li>
<li>
<p> SE
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(REffectivePred)
## Read in the data
path_to_data &lt;- system.file("extdata/NY_OCT_4_2022.csv", package = "REffectivePred")
data &lt;- read.csv(path_to_data)
head(data)
cases &lt;- diff(c(0, data$cases)) # Convert cumulative cases into daily cases
lt &lt;- length(cases)             # Length of cases
Time &lt;- as.Date(data$date, tryFormats = c("%d-%m-%Y", "%d/%m/%Y"))

navigate_to_config() # Open the config file, make any necessary changes here.
path_to_config &lt;- system.file("config.yml", package = "REffectivePred")  # Read config file
cfg &lt;- load_config()    # Build the cfg object

##### Option 1: populate the global environment with args to pass to function.
population &lt;- cfg$population # Population size
window_size &lt;- cfg$window.size
adj.period &lt;- cfg$adj.period
fit.t.pred &lt;- cfg$fit.t.pred # Time of prediction
not.predict &lt;- cfg$not.predict
rt.func.num &lt;- cfg$rt.func.num # choose which Rt function you want to use
num.iter &lt;- cfg$num.iter
silence.errors &lt;- cfg$silence.errors
predict.beyond &lt;- cfg$predict.beyond
curve_params &lt;- as.double(unlist(cfg$curve_params))
vt_params &lt;- as.double(unlist(cfg$vt_params)) # The vt initial values, starting at wave 2
restriction_levels &lt;- as.double(unlist(cfg$restriction_levels)) # Psi, u, and v parameters
betas &lt;- as.double(unlist(cfg$betas)) #   betas
ini_params &lt;- c(curve_params, vt_params, restriction_levels, betas)
restrictions_params &lt;- cfg$restrictions_params
restriction_st_params &lt;- cfg$restriction_st_params
param_scale &lt;- abs(ini_params) / 10
waves_list &lt;- ranges_to_waves(cfg$waves_list)
params_limits &lt;- cfg$params_limits
num_waves &lt;- cfg$num_waves
waves &lt;- waves_1d_list(num_waves, waves_list)
rho &lt;- eval(parse(text = cfg$rho))
serial_mean &lt;- cfg$serial_mean
serial_var &lt;- cfg$serial_var

est &lt;- estimate.mle(
  ini_params = ini_params,
  params_limits = params_limits,
  restrictions = restrictions_params,
  restriction.starts = restriction_st_params,
  ranges = waves,
  rt_func = rt.func.num,
  silence.errors = silence.errors,

  fit.t.pred = fit.t.pred,
  param_scale = param_scale,
  num.iter = num.iter,
  cases = cases,
  scenario = NULL,
  H.E = NULL,
  H.W = NULL,
  adj.period = adj.period,
  population = population,
  rho = rho,
  serial_mean = serial_mean,
  serial_var = serial_var,
  lt = lt,
  window_size = window_size,
  hessian = FALSE
)
print(est)

##### Option 2: pass the cfg object instead.
est &lt;- estimate.mle(
    cases = cases,
    cfg = cfg,
    hessian = FALSE
    )
print(est)
</code></pre>


</div>