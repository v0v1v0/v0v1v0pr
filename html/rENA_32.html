<div class="container">

<table style="width: 100%;"><tr>
<td>ena.plot.network</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot an ENA network</h2>

<h3>Description</h3>

<p>Plot an ENA network: nodes and edges
</p>


<h3>Usage</h3>

<pre><code class="language-R">ena.plot.network(
  enaplot = NULL,
  network = NULL,
  node.positions = enaplot$enaset$rotation$nodes,
  adjacency.key = NULL,
  colors = c(pos = enaplot$palette[1], enaplot$palette[2]),
  edge_type = "line",
  show.all.nodes = T,
  threshold = c(0),
  thin.lines.in.front = T,
  layers = c("nodes", "edges"),
  thickness = c(min(abs(network)), max(abs(network))),
  opacity = thickness,
  saturation = thickness,
  scale.range = c(ifelse(min(network) == 0, 0, 0.1), 1),
  node.size = c(3, 10),
  labels = NULL,
  label.offset = "middle right",
  label.font.size = enaplot$get("font.size"),
  label.font.color = enaplot$get("font.color"),
  label.font.family = enaplot$get("font.family"),
  legend.name = NULL,
  legend.include.edges = F,
  scale.weights = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>enaplot</code></td>
<td>
<p><code>ENAplot</code> object to use for plotting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>network</code></td>
<td>
<p>dataframe or matrix containing the edge weights for the network graph; typically comes from ENAset$line.weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node.positions</code></td>
<td>
<p>matrix containing the positiions of the nodes. Defaults to enaplot$enaset$node.positions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjacency.key</code></td>
<td>
<p>matrix containing the adjacency key for looking up the names and positions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colors</code></td>
<td>
<p>A String or vector of colors for positive and negative line weights. E.g. red or c(pos= red, neg = blue), default: c(pos= red, neg = blue)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge_type</code></td>
<td>
<p>A String representing the type of line to draw, either "line", "dash", or "dot"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.all.nodes</code></td>
<td>
<p>A Logical variable, default: true</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>A vector of numeric min/max values, default: c(0,Inf) plotting . Edge weights below the min value will not be displayed; edge weights above the max value will be shown at the max value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin.lines.in.front</code></td>
<td>
<p>A logical, default: true</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layers</code></td>
<td>
<p>ordering of layers, default: c("nodes", "edges")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thickness</code></td>
<td>
<p>A vector of numeric min/max values for thickness, default:  c(min(abs(network)), max(abs(network)))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opacity</code></td>
<td>
<p>A vector of numeric min/max values for opacity, default: thickness</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saturation</code></td>
<td>
<p>A vector of numeric min/max values for saturation, default: thickness</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.range</code></td>
<td>
<p>A vector of numeric min/max to scale from, default: c(0.1,1) or if min(network) is 0, c(0,1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node.size</code></td>
<td>
<p>A lower and upper bound used for scaling the size of the nodes, default c(0, 20)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>A character vector of node labels, default: code names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.offset</code></td>
<td>
<p>A character vector of representing the positional offset relative to the respective node. Defaults to "middle right" for all nodes. If a single values is provided, it is used for all positions, else the length of the</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.font.size</code></td>
<td>
<p>An integer which determines the font size for graph labels, default: enaplot$font.size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.font.color</code></td>
<td>
<p>A character which determines the color of label font, default: enaplot$font.color</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label.font.family</code></td>
<td>
<p>A character which determines font type, choices: Arial, Courier New, Times New Roman, default: enaplot$font.family</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.name</code></td>
<td>
<p>A character name used in the plot legend. Not included in legend when NULL (Default), if legend.include.edges is TRUE will always be "Nodes"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.include.edges</code></td>
<td>
<p>Logical value indicating if the edge names should be included in the plot legend. Forces legend.name to be "Nodes"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.weights</code></td>
<td>
<p>Logical indicating to scale the supplied network</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>lots a network graph, including nodes (taken from codes in the ENAplot) and the edges (provided in network)
</p>


<h3>Value</h3>

<p>The <code>ENAplot</code> provided to the function, with its plot updated to include the nodes and provided connecting lines.
</p>


<h3>See Also</h3>

<p><code>ena.plot</code>, <code>ena.plot.points</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(RS.data)

codeNames = c('Data','Technical.Constraints','Performance.Parameters',
  'Client.and.Consultant.Requests','Design.Reasoning','Collaboration');

accum = ena.accumulate.data(
  units = RS.data[,c("UserName","Condition")],
  conversation = RS.data[,c("Condition","GroupName")],
  metadata = RS.data[,c("CONFIDENCE.Change","CONFIDENCE.Pre","CONFIDENCE.Post")],
  codes = RS.data[,codeNames],
  window.size.back = 4
)

set = ena.make.set(
  enadata = accum,
  rotation.by = ena.rotate.by.mean,
  rotation.params = list(
    accum$meta.data$Condition=="FirstGame",
    accum$meta.data$Condition=="SecondGame"
  )
)

plot = ena.plot(set)

### Subset rotated points and plot Condition 1 Group Mean
as.matrix(set$points$Condition$FirstGame)

first.game.points = as.matrix(set$points$Condition$FirstGame)
plot = ena.plot.group(plot, first.game.points, labels = "FirstGame",
    colors = "red", confidence.interval = "box")

### Subset rotated points and plot Condition 2 Group Mean
second.game.points = as.matrix(set$points$Condition$SecondGame)
plot = ena.plot.group(plot, second.game.points, labels = "SecondGame",
    colors  = "blue", confidence.interval = "box")

### get mean network plots
first.game.lineweights = as.matrix(set$line.weights$Condition$FirstGame)
first.game.mean = colMeans(first.game.lineweights)

second.game.lineweights = as.matrix(set$line.weights$Condition$SecondGame)
second.game.mean = colMeans(second.game.lineweights)

subtracted.network = first.game.mean - second.game.mean
plot = ena.plot.network(plot, network = subtracted.network)

## Not run: print(plot)

</code></pre>


</div>