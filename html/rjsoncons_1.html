<div class="container">

<table style="width: 100%;"><tr>
<td>as_r</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parse JSON or NDJSON to R</h2>

<h3>Description</h3>

<p><code>as_r()</code> transforms JSON or NDJSON to an <em>R</em> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">as_r(
  data,
  object_names = "asis",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed to <code>jsonlite::toJSON</code> when <code>data</code> is an <em>R</em> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_records</code></td>
<td>
<p>numeric(1) maximum number of NDJSON records parsed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical(1) report progress when parsing large NDJSON
files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_type</code></td>
<td>
<p>character(1) type of <code>data</code>; one of <code>"json"</code>,
<code>"ndjson"</code>, or a value returned by <code>j_data_type()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>as = "R"</code> argument to <code>j_query()</code>, <code>j_pivot()</code>, and the
<code>as_r()</code> function transform JSON or NDJSON to an <em>R</em> object. JSON
and NDJSON can be a character vector, file, or url, or an <em>R</em>
object (which is first translated to a JSON string). Main rules are:
</p>

<ul>
<li>
<p> JSON arrays of a single type (boolean, integer, double, string)
are transformed to <em>R</em> vectors of the same length and
corresponding type. A JSON scalar and a JSON vector of length 1
are represented in the same way in <em>R</em>.
</p>
</li>
<li>
<p> If a JSON 64-bit integer array contains a value larger than <em>R</em>'s
32-bit integer representation, the array is transformed to an <em>R</em>
numeric vector. NOTE that this results in loss of precision for
64-bit integer values greater than <code>2^53</code>.
</p>
</li>
<li>
<p> JSON arrays mixing integer and double values are transformed to
<em>R</em> numeric vectors.
</p>
</li>
<li>
<p> JSON objects are transformed to <em>R</em> named lists.
</p>
</li>
</ul>
<p>The vignette reiterates this information and provides additional
details.
</p>


<h3>Value</h3>

<p><code>as_r()</code> returns an <em>R</em> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## as_r()
as_r('[1, 2, 3]')       # JSON integer array -&gt; R integer vector
as_r('[1, 2.0, 3]')     # JSON intger and double array -&gt; R numeric vector
as_r('[1, 2.0, "3"]')   # JSON mixed array -&gt; R list
as_r('[1, 2147483648]') # JSON integer &gt; R integer max -&gt; R numeric vector

json &lt;- '{"b": 1, "a": ["c", "d"], "e": true, "f": [true], "g": {}}'
as_r(json) |&gt; str()     # parsing complex objects
identical(              # JSON scalar and length 1 array identical in R
    as_r('{"a": 1}'), as_r('{"a": [1]}')
)

</code></pre>


</div>