<div class="container">

<table style="width: 100%;"><tr>
<td>goGARCHforecast-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>class: GO-GARCH Forecast Class</h2>

<h3>Description</h3>

<p>Class for the GO-GARCH forecast.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code>gogarchforecast</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>mforecast</code>:</dt>
<dd>
<p>Multivariate forecast object.</p>
</dd>
<dt>
<code>model</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code> containing details of the
GOGARCH model specification.</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"mGARCHforecast"</code>, directly.
Class <code>"GARCHforecast"</code>, by class "mGARCHforecast", distance 2.
Class <code>"rGARCH"</code>, by class "mGARCHforecast", distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>convolution</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:<br>
function:<br><b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c("user", "adaptive"),
use.ff = TRUE, cluster = NULL, trace = 0,...)</b><br>
The convolution method takes a goGARCHforecast object and a weights vector
or matrix and calculates the weighted density. If a vector is given, it must
be the same length as the number of assets, otherwise a matrix with
row dimension equal to the total forecast horizon.
In the case of the multivariate normal distribution, this simply returns the
linear and quadratic transformation of the mean and covariance matrix,
while in the multivariate affine NIG distribution this is based on the
numerical inversion by FFT of the characteristic function. In that case,
the “fft.step” option determines the stepsize for tuning the
characteristic function inversion, “fft.by” determines the resolution
for the equally spaced support given by “fft.support”, while the use
of the “ff” package is recommended to avoid memory problems on some
systems and is turned on via the “use.ff” option. The “support.method”
option allows either a fixed support range to be given (option ‘user’),
else an adaptive method is used based on the min and max of the assets at
each point in time at the 0.00001 and 1-0.00001 quantiles. The range is
equally spaced subject to the “fft.by” value but the returned object
no longer makes of the “ff” package returning instead a list.
The option for parallel computation is available via the use of a
cluster object as elsewhere in this package. There is no special treatment of
the forecast type here (unconditional or rolling), since either n.ahead with
no roll or rolling with 1-ahead only choices are available for the
<code>gogarchforecast</code> method. This means that the stored object does not
distringuish between an unconditional or rolling forecast, calculating the
density for all points (see note).
</p>
</dd>
<dt>gportmoments</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:<br>
function:<br><b>gportmoments(object, weights)</b><br>
Calculates the first 4 standardized portfolio moments using the geometric
properties of the model, given a matrix of asset weights with row dimension
equal to the forecast n.ahead or n.roll horizon. Returns an array of
dimensions n.ahead x 4 (moments) x n.roll, with the third array dimension
labelled with the T+0 index times. If the number of assets &gt; 100, then the
kurtosis is not returned (see cokurtosis restrictions below).</p>
</dd>
<dt>rcoskew</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:<br>
function:<br><b>rcoskew(object, standardize = TRUE, from = 1, to = 1, roll = 0)</b><br>
Returns the 'time-varying'  NxN^2 (coskewness tensor) x (to:from|roll) in
array format. The “from” and “to” options indicate the time
indices for which to return the array and “roll” the rolling index
(base=0). The third dimension array label denotes the T+i (i=from:to)
forecast horizon given the T+0 roll index which is returned as an attribute
(attr(,“T+0”)) of the array. The “standardize” option
indicates whether the coskewness should be standardized by the
conditional sigma (see equations in vignette). It is also possible to set
roll to the character ‘all’ in which case all the rolling 1-ahead
forecasts are returned in an n by n^2 by (n.roll+1) array with 3rd
dimension label the T+0 dates (instead of being an attribute).</p>
</dd>
<dt>rcokurt</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:<br>
function:<br><b>rcokurt(object, standardize = TRUE, from = 1, to = 1, roll = 0)</b><br>
Returns the 'time-varying'  NxN^3 (cokurtosis tensor) x (to:from|roll) in
array format. The “from” and “to” options indicate the time
indices for which to return the array and “roll” the rolling index
(base=0).  Because of memory issues, this is only returned when the number
of assets are less than 100. The third dimension array label denotes the
T+i (i=from:to) forecast horizon given the T+0 roll index which is returned
as an attribute (attr(,“T+0”)) of the array. The “standardize”
option indicates whether the cokurtosis should be standardized by the
conditional sigma (see equations in vignette). It is also possible to set
roll to the character ‘all’ in which case all the rolling 1-ahead
forecasts are returned in an n by n^3 by (n.roll+1) array with 3rd
dimension label the T+0 dates (instead of being an attribute.</p>
</dd>
<dt>rcov</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
Returns the conditional covariances, in a list of length (n.roll+1), with
names the T+0 index, and each list slot having an array of dimensions
n.asset x n.asset x n.ahead, with the third array dimension labelled
as T+i (i&gt;0). A further argument ‘output’ allows to switch
between “array” and “matrix” returned object.</p>
</dd>
<dt>rcor</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
Returns the conditional correlations, in a list of length (n.roll+1), with
names the T+0 index, and each list slot having an array of dimensions
n.asset x n.asset x n.ahead, with the third array dimension labelled
as T+i (i&gt;0). A further argument ‘output’ allows to switch
between “array” and “matrix” returned object.</p>
</dd>
<dt>coef</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
Extraction of independent factor GARCH model coefficients saved from the
goGARCHfit object.</p>
</dd>
<dt>fitted</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
Extracts the conditional mean forecast values. Returns an n.ahead
x n.assets x (n.roll+1) array where the third dimension array labels are the
T+0 index times.</p>
</dd>
<dt>sigma</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
Extracts the conditional sigma forecast values. Returns an n.ahead
x n.assets x (n.roll+1) array where the third dimension array labels are the
T+0 index times. Takes optional argument “factors” (default TRUE)
denoting whether to return the factor conditional sigma or the transformed
sigma for the assets.</p>
</dd>
<dt>as.matrix</dt>
<dd>
<p><code>signature(x = "goGARCHforecast")</code>:<br>
function:<br><b>as.matrix(x, which = "A")</b><br>
This returns four types of matrices relating to the estimation of the
independent components in the GO-GARCH model. Valid choices are “A”
for the mixing matrix, “W” for the unmixing matrix, “U” for the
rotational matrix and “K” for the whitening matrix, “Kinv” for
the de-whitening matrix.</p>
</dd>
<dt>betacovar</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
function:<br><b>betacovar(object, weights, asset = 1)</b><br>
Returns the covariance beta given a matrix (of length equal to the number of
rows of the forecast horizon, or vector which is then recycled to the number
of rows of the forecast horizon) of benchmark weights and the asset number.</p>
</dd>
<dt>betacoskew</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
function:<br><b>betacoskew(object, weights, asset = 1)</b><br>
Returns the coskewness beta given a matrix (of length equal to the number of
rows of the forecast horizon, or vector which is then recycled to the number
of rows of the forecast horizon) of benchmark weights and the asset number.</p>
</dd>
<dt>betacokurt</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>:
function:<br><b>betacokurt(object, weights, asset = 1)</b><br>
Returns the cokurtosis beta given a matrix (of length equal to the number of
rows of the forecast horizon, or vector which is then recycled to the number
of rows of the forecast horizon) of benchmark weights and the asset number.</p>
</dd>
<dt>show</dt>
<dd>
<p><code>signature(object = "goGARCHforecast")</code>: Summary method. </p>
</dd>
</dl>
<h3>Note</h3>

<p>The reference by Chen et al (2010) and Paolella (2007) contains more details on
the algorithm for the characteristic function inversion via FFT. The de Athayde
and Flores (2002) paper is the basis for some of the geometric properties of
the higher moment tensors. The paper by Ghalanos et al (2013) contains more
specific details.<br>
Forecasts are carried out on the time varying parameters of the factor
distributions, and then scaled and transformed to those of the assets after
adding back the mean forecast (which is either a constant or the AR/VAR mean
forecast).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Chen, Y., Hardle, W., and Spokoiny, V. 2010, GHICA-Risk analysis with GH
distributions and independent components, <em>Journal of Empirical Finance</em>,
<b>17(2)</b>, 255–269.<br>
de Athayde, G.M. and Flores Jr, R.G. 2002, On Certain Geometric Aspects of
Portfolio Optimisation with Higher Moments, <em>mimeo</em>.<br>
Ghalanos, A., Rossi, E., and Urga, G. (2013). <em>Independent Factor
Autoregressive Conditional Density Model</em>, <b>forthcoming</b>.<br>
Paolella, M.S. 2007, Intermediate Probability - A Computational Approach,
<em>Wiley-Interscience</em>.<br></p>


</div>