<div class="container">

<table style="width: 100%;"><tr>
<td>mice.impute.rfnode</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Univariate sampler function for mixed types of variables for node-based
imputation, using predicting nodes of random forests</h2>

<h3>Description</h3>

<p>Please note that functions with names starting with "mice.impute" are
exported to be visible for the mice sampler functions. Please do not call
these functions directly unless you know exactly what you are doing.
</p>
<p><code>RfNode</code> imputation methods, adapter for <code>mice</code> samplers.
These functions can be called by the <code>mice</code> sampler functions.
</p>
<p><code>mice.impute.rfnode.cond</code> is for imputation using the conditional formed
by the predicting nodes of random forests. To use this function, set
<code>method = "rfnode.cond"</code> in <code>mice</code> function.
</p>
<p><code>mice.impute.rfnode.prox</code> is for imputation based on proximity measures
from random forests, and provides functionality similar to
<code>mice.impute.rf</code>. To use this function, set
<code>method = "rfnode.prox"</code> in <code>mice</code> function.
</p>
<p><code>mice.impute.rfnode</code> is the main function for performing imputation, and
both <code>mice.impute.rfnode.cond</code> and <code>mice.impute.rfnode.prox</code> call
this function. By default, <code>mice.impute.rfnode</code> works like
<code>mice.impute.rfnode.cond</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mice.impute.rfnode(
  y,
  ry,
  x,
  wy = NULL,
  num.trees.node = 10,
  pre.boot = TRUE,
  use.node.cond.dist = TRUE,
  obs.eq.prob = FALSE,
  do.sample = TRUE,
  num.threads = NULL,
  ...
)

mice.impute.rfnode.cond(
  y,
  ry,
  x,
  wy = NULL,
  num.trees = 10,
  pre.boot = TRUE,
  obs.eq.prob = FALSE,
  ...
)

mice.impute.rfnode.prox(
  y,
  ry,
  x,
  wy = NULL,
  num.trees = 10,
  pre.boot = TRUE,
  obs.eq.prob = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector to be imputed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ry</code></td>
<td>
<p>Logical vector of length <code>length(y)</code> indicating the
the subset <code>y[ry]</code> of elements in <code>y</code> to which the imputation
model is fitted. The <code>ry</code> generally distinguishes the observed
(<code>TRUE</code>) and missing values (<code>FALSE</code>) in <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric design matrix with <code>length(y)</code> rows with predictors for
<code>y</code>. Matrix <code>x</code> may have no missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wy</code></td>
<td>
<p>Logical vector of length <code>length(y)</code>. A <code>TRUE</code> value
indicates locations in <code>y</code> for which imputations are created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.trees.node</code></td>
<td>
<p>Number of trees to build, default to <code>10</code>. For
function <code>mice.impute.rfnode</code> only.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pre.boot</code></td>
<td>
<p>Perform bootstrap prior to imputation to get 'proper'
imputation, i.e. accommodating sampling variation in estimating population
regression parameters (see Shah et al. 2014).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.node.cond.dist</code></td>
<td>
<p>If <code>TRUE</code>, use conditional distribution formed
by predicting nodes of random forest (out-of-bag observations were excluded);
if <code>FALSE</code>, use proximity-based imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.eq.prob</code></td>
<td>
<p>If <code>TRUE</code>, the candidate observations will be sampled
with equal probability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.sample</code></td>
<td>
<p>If <code>TRUE</code>, draw samples for missing observations.
If <code>FALSE</code>, the corresponding observations numbers will be returned,
for testing purposes only, and WILL CAUSE ERRORS for the <code>mice</code> sampler
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.threads</code></td>
<td>
<p>Number of threads for parallel computing. The default is
<code>num.threads = NULL</code> and all the processors available can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to pass down.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.trees</code></td>
<td>
<p>Number of trees to build, default to <code>10</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Advanced users can get more flexibility from <code>mice.impute.rfnode</code>
function, as it provides more options than <code>mice.impute.rfnode.cond</code> or
<code>mice.impute.rfnode.prox</code>.
</p>


<h3>Value</h3>

<p>Vector with imputed data, same type as <code>y</code>, and of length
<code>sum(wy)</code>.
</p>


<h3>Author(s)</h3>

<p>Shangzhi Hong
</p>


<h3>References</h3>

<p>Hong, Shangzhi, et al. "Multiple imputation using chained random forests."
Preprint, submitted April 30, 2020. https://arxiv.org/abs/2004.14823.
</p>
<p>Doove, Lisa L., Stef Van Buuren, and Elise Dusseldorp.
"Recursive partitioning for missing data imputation in the presence of
interaction effects."
Computational Statistics &amp; Data Analysis 72 (2014): 92-104.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Prepare data: convert categorical variables to factors
nhanes.fix &lt;- conv.factor(nhanes, c("age", "hyp"))

# Using "rfnode.cond" or "rfnode"
impRfNodeCond &lt;- mice(nhanes.fix, method = "rfnode.cond", m = 5,
maxit = 5, maxcor = 1.0, eps = 0, printFlag = FALSE)

# Using "rfnode.prox"
impRfNodeProx &lt;- mice(nhanes.fix, method = "rfnode.prox", m = 5,
maxit = 5, maxcor = 1.0, eps = 0,
remove.collinear = FALSE, remove.constant = FALSE,
printFlag = FALSE)

</code></pre>


</div>