<div class="container">

<table style="width: 100%;"><tr>
<td>fparse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast, Friendly, and Flexible JSON Parsing</h2>

<h3>Description</h3>

<p>Parse JSON strings and files to R objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fparse(
  json,
  query = NULL,
  empty_array = NULL,
  empty_object = NULL,
  single_null = NULL,
  parse_error_ok = FALSE,
  on_parse_error = NULL,
  query_error_ok = FALSE,
  on_query_error = NULL,
  max_simplify_lvl = c("data_frame", "matrix", "vector", "list"),
  type_policy = c("anything_goes", "numbers", "strict"),
  int64_policy = c("double", "string", "integer64", "always"),
  always_list = FALSE
)

fload(
  json,
  query = NULL,
  empty_array = NULL,
  empty_object = NULL,
  single_null = NULL,
  parse_error_ok = FALSE,
  on_parse_error = NULL,
  query_error_ok = FALSE,
  on_query_error = NULL,
  max_simplify_lvl = c("data_frame", "matrix", "vector", "list"),
  type_policy = c("anything_goes", "numbers", "strict"),
  int64_policy = c("double", "string", "integer64", "always"),
  always_list = FALSE,
  verbose = FALSE,
  temp_dir = tempdir(),
  keep_temp_files = FALSE,
  compressed_download = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>json</code></td>
<td>
<p>JSON strings, file paths, or raw vectors.
</p>

<ul>
<li> <p><code>fparse()</code>
</p>

<ul>
<li> <p><code>character</code>: One or more JSON strings.
</p>
</li>
<li> <p><code>raw</code>: <code>json</code> is interpreted as the bytes of a single
JSON string.
</p>
</li>
<li> <p><code>list</code> Every element must be of type <code>"raw"</code> and each
is individually interpreted as the bytes of a single JSON string.
</p>
</li>
</ul>
</li>
<li> <p><code>fload()</code>
</p>

<ul><li> <p><code>character</code>: One or more paths to files (local or remote)
containing JSON.
</p>
</li></ul>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>If not <code>NULL</code>, JSON Pointer(s) used to identify and extract
specific elements within <code>json</code>. See Details and Examples.
<code>NULL</code>, <code>character()</code>, or <code>list()</code> of <code>character()</code>. default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>empty_array</code></td>
<td>
<p>Any R object to return for empty JSON arrays.
default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>empty_object</code></td>
<td>
<p>Any R object to return for empty JSON objects.
default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>single_null</code></td>
<td>
<p>Any R object to return for single JSON nulls.
default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parse_error_ok</code></td>
<td>
<p>Whether to allow parsing errors.
default: <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>on_parse_error</code></td>
<td>
<p>If <code>parse_error_ok</code> is <code>TRUE</code>, <code>on_parse_error</code> is any
R object to return when query errors occur.
default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>query_error_ok</code></td>
<td>
<p>Whether to allow parsing errors.
default: <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>on_query_error</code></td>
<td>
<p>If <code>query_error_ok</code> is <code>TRUE</code>, <code>on_query_error</code> is any
R object to return when query errors occur.
default: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_simplify_lvl</code></td>
<td>
<p>Maximum simplification level.
<code>character(1L)</code> or <code>integer(1L)</code>, default: <code>"data_frame"</code>
</p>

<ul>
<li> <p><code>"data_frame"</code> or <code>0L</code>
</p>
</li>
<li> <p><code>"matrix"</code> or <code>1L</code>
</p>
</li>
<li> <p><code>"vector"</code> or <code>2L</code>
</p>
</li>
<li> <p><code>"list"</code> or <code>3L</code> (no simplification)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type_policy</code></td>
<td>
<p>Level of type strictness.
<code>character(1L)</code> or <code>integer(1L)</code>, default: <code>"anything_goes"</code>.
</p>

<ul>
<li> <p><code>"anything_goes"</code> or <code>0L</code>: non-recursive arrays always become atomic vectors
</p>
</li>
<li> <p><code>"numbers"</code> or <code>1L</code>: non-recursive arrays containing only numbers always become atomic vectors
</p>
</li>
<li> <p><code>"strict"</code> or <code>2L</code>: non-recursive arrays containing mixed types never become atomic vectors
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>int64_policy</code></td>
<td>
<p>How to return big integers to R.
<code>character(1L)</code> or <code>integer(1L)</code>, default: <code>"double"</code>.
</p>

<ul>
<li> <p><code>"double"</code> or <code>0L</code>: big integers become <code>double</code>s
</p>
</li>
<li> <p><code>"string"</code> or <code>1L</code>: big integers become <code>character</code>s
</p>
</li>
<li> <p><code>"integer64"</code> or <code>2L</code>: big integers become <code>bit64::integer64</code>s
</p>
</li>
<li> <p><code>"always"</code> or <code>3L</code>: all integers become <code>bit64::integer64</code>s
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>always_list</code></td>
<td>
<p>Whether a <code>list</code> should always be returned, even when <code>length(json) == 1L</code>.
default: <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to display status messages.
<code>TRUE</code> or <code>FALSE</code>, default: <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temp_dir</code></td>
<td>
<p>Directory path to use for any temporary files.
<code>character(1L)</code>, default: <code>tempdir()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_temp_files</code></td>
<td>
<p>Whether to remove any temporary files created by
<code>fload()</code> from <code>temp_dir</code>.
<code>TRUE</code> or <code>FALSE</code>, default: <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compressed_download</code></td>
<td>
<p>Whether to request server-side compression on
the downloaded document, default: <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments which can be use <em>e.g.</em> to pass additional
header settings</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p> Instead of using <code>lapply()</code> to parse multiple values, just use
<code>fparse()</code> and <code>fload()</code> directly.
</p>

<ul>
<li>
<p> They are vectorized in order to leverage the underlying
<code>simdjson::dom::parser</code>'s ability to reuse its internal buffers
between parses.
</p>
</li>
<li>
<p> Since the overwhelming majority of JSON parsed will not result in
scalars, a <code>list()</code> is always returned if <code>json</code> contains
more than one value.
</p>
</li>
<li>
<p> If <code>json</code> contains multiple values and has <code>names()</code>, the
returned object will have the same names.
</p>
</li>
<li>
<p> If <code>json</code> contains multiple values and is unnamed, <code>fload()</code>
names each returned element using the file's <code>basename()</code>.
</p>
</li>
</ul>
</li>
<li> <p><code>query</code>'s goal is to minimize te amount of data that must be
materialized as R objects (the main performance bottleneck) as well as
facilitate any post-parse processing.
</p>

<ul><li>
<p> To maximize flexibility, there are two approaches to consider when designing <code>query</code> arguments.
</p>

<ul>
<li> <p><code>character</code> vectors are interpreted as containing queries that
meant to be applied to all elements of <code>json=</code>.
</p>

<ul><li>
<p> If <code>json=</code> contains 3 strings and <code>query=</code> contains
3 strings, the returned object will be a list of 3 elements (1 for each element
of <code>json=</code>), which themselves each contain 3 lists (1 for each element
of <code>query=</code>).
</p>
</li></ul>
</li>
<li> <p><code>list</code>s of <code>character</code> vectors are interpreted as containing
queries meant to be applied  to <code>json</code> in a zip-like fashion.
</p>
</li>
</ul>
</li></ul>
</li>
</ul>
<h3>Author(s)</h3>

<p>Brendan Knapp
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simple parsing ============================================================
json_string &lt;- '{"a":[[1,null,3.0],["a","b",true],[10000000000,2,3]]}'
fparse(json_string)

raw_json &lt;- as.raw(
    c(0x22, 0x72, 0x61, 0x77, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x63,
      0x61, 0x6e, 0x20, 0x62, 0x65, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x4a, 0x53,
      0x4f, 0x4e, 0x20, 0x74, 0x6f, 0x6f, 0x21, 0x22)
)
fparse(raw_json)

# ensuring a list is always returned ========================================
fparse(json_string, always_list = TRUE)
fparse(c(named_single_element_character = json_string), always_list = TRUE)

# controlling type-strictness ===============================================
fparse(json_string, type_policy = "numbers")
fparse(json_string, type_policy = "strict")
fparse(json_string, type_policy = "numbers", int64_policy = "string")

if (requireNamespace("bit64", quietly = TRUE)) {
    fparse(json_string, type_policy = "numbers", int64_policy = "integer64")
}

# vectorized parsing ========================================================
json_strings &lt;- c(
    json1 = '[{"b":true,
               "c":null},
              {"b":[[1,2,3],
                    [4,5,6]],
               "c":"Q"}]',
    json2 = '[{"b":[[7, 8, 9],
                   [10,11,12]],
              "c":"Q"},
              {"b":[[13,14,15],
                   [16,17,18]],
              "c":null}]'
)
fparse(json_strings)

fparse(
    list(
        raw_json1 = as.raw(c(0x74, 0x72, 0x75, 0x65)),
        raw_json2 = as.raw(c(0x66, 0x61, 0x6c, 0x73, 0x65))
    )
)

# controlling simplification ================================================
fparse(json_strings, max_simplify_lvl = "matrix")
fparse(json_strings, max_simplify_lvl = "vector")
fparse(json_strings, max_simplify_lvl = "list")

# customizing what `[]`, `{}`, and single `null`s return ====================
empties &lt;- "[[],{},null]"
fparse(empties)
fparse(empties,
       empty_array = logical(),
       empty_object = `names&lt;-`(list(), character()),
       single_null = NA_real_)

# handling invalid JSON and parsing errors ==================================
fparse("junk JSON", parse_error_ok = TRUE)
fparse("junk JSON", parse_error_ok = TRUE,
       on_parse_error = "can't parse invalid JSON")
fparse(
    c(junk_JSON_1 = "junk JSON 1",
      valid_JSON_1 = '"this is valid JSON"',
      junk_JSON_2 = "junk JSON 2",
      valid_JSON_2 = '"this is also valid JSON"'),
    parse_error_ok = TRUE,
    on_parse_error = NA
)

# querying JSON w/ a JSON Pointer ===========================================
json_to_query &lt;- c(
    json1 = '[
    "a",
    {
        "b": {
            "c": [[1,2,3],
                  [4,5,6]]
        }
    }
]',
    json2 = '[
    "a",
    {
        "b": {
            "c": [[7,8,9],
                  [10,11,12]],
           "d": [1,2,3,4]
        }
    }
]')
fparse(json_to_query, query = "/1")
fparse(json_to_query, query = "/1/b")
fparse(json_to_query, query = "/1/b/c")
fparse(json_to_query, query = "/1/b/c/1")
fparse(json_to_query, query = "/1/b/c/1/0")

# handling invalid queries ==================================================
fparse(json_to_query, query = "/1/b/d",
       query_error_ok = TRUE,
       on_query_error = "d isn't a key here!")

# multiple queries applied to EVERY element =================================
fparse(json_to_query, query = c(query1 = "/1/b/c/1/0",
                                query2 = "/1/b/c/1/1",
                                query3 = "/1/b/c/1/2"))

# multiple queries applied to EACH element ==================================
fparse(json_to_query,
       query = list(queries_for_json1 = c(c1 = "/1/b/c/1/0",
                                          c2 = "/1/b/c/1/1"),
                    queries_for_json2 = c(d1 = "/1/b/d/1",
                                          d2 = "/1/b/d/2")))

# load JSON files ===========================================================
single_file &lt;- system.file("jsonexamples/small/demo.json", package = "RcppSimdJson")
fload(single_file)

multiple_files &lt;- c(
  single_file,
  system.file("jsonexamples/small/smalldemo.json", package = "RcppSimdJson")
)
fload(multiple_files)


## Not run: 

# load remote JSON ==========================================================
a_url &lt;- "https://api.github.com/users/lemire"
fload(a_url)

multiple_urls &lt;- c(
  a_url,
  "https://api.github.com/users/eddelbuettel",
  "https://api.github.com/users/knapply",
  "https://api.github.com/users/dcooley"
)
fload(multiple_urls, query = "name", verbose = TRUE)

# download compressed (faster) JSON =========================================
fload(multiple_urls, query = "name", verbose = TRUE,
      compressed_download = TRUE)

## End(Not run)

</code></pre>


</div>