<div class="container">

<table style="width: 100%;"><tr>
<td>vcg_smooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Implicitly smooth a triangular mesh</h2>

<h3>Description</h3>

<p>Applies smoothing algorithms on a triangular mesh.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vcg_smooth_implicit(
  mesh,
  lambda = 0.2,
  use_mass_matrix = TRUE,
  fix_border = FALSE,
  use_cot_weight = FALSE,
  degree = 1L,
  laplacian_weight = 1
)

vcg_smooth_explicit(
  mesh,
  type = c("taubin", "laplace", "HClaplace", "fujiLaplace", "angWeight",
    "surfPreserveLaplace"),
  iteration = 10,
  lambda = 0.5,
  mu = -0.53,
  delta = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>triangular mesh stored as object of class 'mesh3d'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>In <code>vcg_smooth_implicit</code>, the amount of smoothness,
useful only if <code>use_mass_matrix</code> is <code>TRUE</code>; default is <code>0.2</code>.
In <code>vcg_smooth_explicit</code>, parameter for <code>'taubin'</code> smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_mass_matrix</code></td>
<td>
<p>logical: whether to use mass matrix to keep the mesh
close to its original position (weighted per area distributed on vertices);
default is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix_border</code></td>
<td>
<p>logical: whether to fix the border vertices of the mesh;
default is <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_cot_weight</code></td>
<td>
<p>logical: whether to use cotangent weight; default is
<code>FALSE</code> (using uniform 'Laplacian')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>integer: degrees of 'Laplacian'; default is <code>1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>laplacian_weight</code></td>
<td>
<p>numeric: weight when <code>use_cot_weight</code> is <code>FALSE</code>;
default is <code>1.0</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>method name of explicit smooth, choices are <code>'taubin'</code>,
<code>'laplace'</code>, <code>'HClaplace'</code>, <code>'fujiLaplace'</code>,
<code>'angWeight'</code>, <code>'surfPreserveLaplace'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iteration</code></td>
<td>
<p>number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>parameter for <code>'taubin'</code> explicit smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>parameter for scale-dependent 'Laplacian' smoothing or
maximum allowed angle (in 'Radian') for deviation between surface preserving
'Laplacian'.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class "mesh3d" with:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>vb</code></td>
<td>
<p>vertex coordinates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normals</code></td>
<td>
<p>vertex normal vectors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>it</code></td>
<td>
<p>triangular face index</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
if(is_not_cran()) {

# Prepare mesh with no normals
data("left_hippocampus_mask")

# Grow 2mm on each direction to fill holes
volume &lt;- grow_volume(left_hippocampus_mask, 2)

# Initial mesh
mesh &lt;- vcg_isosurface(volume)

# Start: examples
rgl_view({
  rgl_call("mfrow3d", 2, 4)
  rgl_call("title3d", "Naive ISOSurface")
  rgl_call("shade3d", mesh, col = 2)

  rgl_call("next3d")
  rgl_call("title3d", "Implicit Smooth")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_implicit(mesh, degree = 2))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - taubin")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "taubin"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - laplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "laplace"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - angWeight")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "angWeight"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - HClaplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "HClaplace"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - fujiLaplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "fujiLaplace"))

  rgl_call("next3d")
  rgl_call("title3d", "Explicit Smooth - surfPreserveLaplace")
  rgl_call("shade3d", col = 2,
           x = vcg_smooth_explicit(mesh, "surfPreserveLaplace"))
})

}

</code></pre>


</div>