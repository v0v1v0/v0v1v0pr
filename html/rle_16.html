<div class="container">

<table style="width: 100%;"><tr>
<td>Ops.rle</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Unary and Binary Operations for <code>rle</code> Objects</h2>

<h3>Description</h3>

<p>Unary and binary Arithmetic and Logic operators (with
exceptions given below) are implemented between two <code>rle</code> objects
and between an <code>rle</code> object and a scalar.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'rle'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>e1, e2</code></td>
<td>
<p>Arguments to unary (<code>e1</code>) and binary (<code>e1</code> and <code>e2</code>)
operators.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Supported operations include all elements of the <code>Ops</code>
group, as well as <code>xor</code>. Within the Arithmetic and Logic
operators, this includes (taken from the R help): <code>+</code>, <code>-</code>, <code>*</code>,
<code>/</code>, <code>^</code>, <code>&lt;</code> , <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code>, <code>%%</code>, <code>%/%</code>, <code>&amp;</code>,
<code>|</code>, <code>!</code>, and <code>xor</code>; but excludes non-vector logical functions
and operators such as <code>isTRUE</code> and <code>&amp;&amp;</code>.
</p>


<h3>Value</h3>

<p>In every supported case, the operation should result in an
<code>rle</code> that would have resulted had the operation been applied
to the original (uncompressed) vectors, then compressed using
<code>rle</code>, with the proviso that if the resulting function creates
adjacent runs of the same value, they are <em>not</em> merged. This must
be done explicitly with <code>compress.rle</code>. (At no point in the
calculation are the uncompressed vectors actually constructed, of
course.)
</p>
<p>An operation between an <code>rle</code> and a zero-length object produces
an empty <code>rle</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
x &lt;- rle(as.logical(rbinom(10,1,.7)))
y &lt;- rle(as.logical(rbinom(10,1,.3)))

stopifnot(isTRUE(all.equal((!inverse.rle(x)),inverse.rle(!x))))

stopifnot(isTRUE(all.equal((inverse.rle(x)|inverse.rle(y)),inverse.rle(x|y))))

stopifnot(isTRUE(all.equal((inverse.rle(x)&amp;inverse.rle(y)),inverse.rle(x&amp;y))))

x &lt;- rle(sample(c(-1,+1), 10, c(.7,.3), replace=TRUE))
y &lt;- rle(sample(c(-1,+1), 10, c(.3,.7), replace=TRUE))

stopifnot(isTRUE(all.equal((inverse.rle(x)*inverse.rle(y)),inverse.rle(x*y))))
stopifnot(isTRUE(all.equal((2*inverse.rle(y)),inverse.rle(2*y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)*2),inverse.rle(x*2))))

stopifnot(isTRUE(all.equal((inverse.rle(x)/inverse.rle(y)),inverse.rle(x/y))))
stopifnot(isTRUE(all.equal((2/inverse.rle(y)),inverse.rle(2/y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)/2),inverse.rle(x/2))))

stopifnot(isTRUE(all.equal((-inverse.rle(y)),inverse.rle(-y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)-inverse.rle(y)),inverse.rle(x-y))))

stopifnot(isTRUE(all.equal((inverse.rle(x)%/%inverse.rle(y)),inverse.rle(x%/%y))))

stopifnot(isTRUE(all.equal(inverse.rle(x)==inverse.rle(y),inverse.rle(x==y))))

stopifnot(isTRUE(all.equal((inverse.rle(x)&gt;inverse.rle(y)),inverse.rle(x&gt;y))))
</code></pre>


</div>