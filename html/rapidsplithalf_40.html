<div class="container">

<table style="width: 100%;"><tr>
<td>stratifiedItersplits</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>stratifiedItersplits</h2>

<h3>Description</h3>

<p>Generate stratified splits for a single participant
</p>


<h3>Usage</h3>

<pre><code class="language-R">stratifiedItersplits(splits, groupsizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>splits</code></td>
<td>
<p>Number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupsizes</code></td>
<td>
<p>An integer vector of how many RTs per group need to be stratified.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This equally splits what can be equally split within groups.
Then it randomly splits all the leftovers to ensure near-equal split sizes.
This function is moreso used internally, 
but you can use it if you know what you are doing.
</p>


<h3>Value</h3>

<p>A matrix with zeroes and ones. Each column is a random split.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# We will create splits stratified by stimulus for a single participant
data(foodAAT)
currdata&lt;-foodAAT[foodAAT$subjectid==3,]
currdata$stratfactor&lt;-interaction(currdata$is_pull,currdata$is_target,currdata$stimid)
currdata&lt;-currdata[order(currdata$stratfactor),]
groupsizes&lt;-rle(as.character(currdata$stratfactor))$lengths

mysplits&lt;-stratifiedItersplits(splits=1000,groupsizes=groupsizes)

# Now the data can be split with the values from any column.
half1&lt;-currdata[mysplits[,1]==1,]
half2&lt;-currdata[mysplits[,1]==0,]

# Or the split objects can be used as masks for the aggregation functions in this package
meansByMask(x=currdata$RT,mask=mysplits==1)
 
</code></pre>


</div>