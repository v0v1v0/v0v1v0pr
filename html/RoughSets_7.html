<div class="container">

<table style="width: 100%;"><tr>
<td>BC.IND.relation.FRST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The indiscernibility relation based on fuzzy rough set theory</h2>

<h3>Description</h3>

<p>This is a function used to implement a fundamental concept of FRST which is fuzzy indiscernibility relations. 
It is used for any fuzzy relations that determine the degree to which two objects are indiscernibility. 
The detailed description about basic concepts of FRST 
can be found in <code>Introduction-FuzzyRoughSets</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">BC.IND.relation.FRST(decision.table, attributes = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decision.table</code></td>
<td>
<p>a <code>"DecisionTable"</code> class representing a decision table. See <code>SF.asDecisionTable</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attributes</code></td>
<td>
<p>a numerical vector expressing indexes of subset of attributes to be considered. 
The default value is <code>NULL</code> which means that 
all conditional attributes will be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of other parameters consisting of the following parameters:
</p>
 
<ul>
<li> <p><code>type.relation</code>: a list containing string values that express the 
type of the fuzzy relation and its equation. The default value is <code>type.relation = c("tolerance", "eq.1")</code>. See in the Section <code>Details</code>.
</p>
</li>
<li> <p><code>type.aggregation</code>: a list expressing type of aggregation. The default value is <code>type.aggregation = c("t.tnorm", "lukasiewicz")</code>. 
See in the Section <code>Details</code>.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Briefly, the indiscernibility relation is a relation that shows a degree of similarity among the objects.
For example, <code class="reqn">R(x_i, x_j) = 0</code> means the object <code class="reqn">x_i</code> is completely different from <code class="reqn">x_j</code>, 
and otherwise if <code class="reqn">R(x_i, x_j) = 1</code>, while between those values we consider a degree of similarity. 
To calculate this relation, several methods have been implemented
in this function which are approaches based on fuzzy tolerance, equivalence and <code class="reqn">T</code>-equivalence relations. 
The fuzzy tolerance relations proposed by (Jensen and Shen, 2009) include three equations while
(Hu, 2004) proposed five <code class="reqn">T_{cos}</code>-transitive kernel functions as fuzzy <code class="reqn">T</code>-equivalence relations. The simple
algorithm of fuzzy equivalence relation is implemented as well. Furthermore, we facilitate users to define their own equation for similarity relation.
</p>
<p>To calculate a particular relation, we should pay attention to several components in 
the parameter <code>control</code>. The main component in the <code>control</code> parameter is <code>type.relation</code> that defines 
what kind of approach we are going to use. The detailed explanation about the parameters and their equations 
is as follows:
</p>

<ul>
<li> <p><code>"tolerance"</code>: It refers to fuzzy tolerance relations proposed by (Jensen and Shen, 2009). 
In order to represent the <code>"tolerance"</code> relation, we must set <code>type.relation</code> as follows:
</p>
<p><code>type.relation = c("tolerance", &lt;chosen equation&gt;)</code> 
</p>
<p>where the chosen equation called as <code>t.similarity</code> is one of the
<code>"eq.1"</code>, <code>"eq.2"</code>, and <code>"eq.3"</code> equations which have been explained in <code>Introduction-FuzzyRoughSets</code>.
</p>
</li>
<li> <p><code>"transitive.kernel"</code>: It refers to the relations employing kernel functions (Genton, 2001).
In order to represent the relation, we must set the <code>type.relation</code> parameter as follows.
</p>
<p><code>type.relation = c("transitive.kernel", &lt;chosen equation&gt;, &lt;delta&gt;)</code>      
</p>
<p>where the chosen equation is one of five following equations (called <code>t.similarity</code>):
</p>

<ul>
<li> <p><code>"gaussian"</code>: It means Gaussian kernel which is <code class="reqn">R_G(x,y) = \exp (-\frac{|x - y|^2}{\delta})</code>
</p>
</li>
<li> <p><code>"exponential"</code>: It means exponential kernel which is <code class="reqn">R_E(x,y) = \exp(-\frac{|x - y|}{\delta})</code>
</p>
</li>
<li> <p><code>"rational"</code>: It means rational quadratic kernel which is <code class="reqn">R_R(x,y) = 1 - \frac{|x - y|^2}{|x - y|^2 + \delta}</code>
</p>
</li>
<li> <p><code>"circular"</code>: It means circular kernel which is if <code class="reqn">|x - y| &lt; \delta</code>, 
<code class="reqn">R_C(x,y) = \frac{2}{\pi}\arccos(\frac{|x - y|}{\delta}) - \frac{2}{\pi}\frac{|x - y|}{\delta}\sqrt{1 - (\frac{|x - y|}{\delta})^2}</code>
</p>
</li>
<li> <p><code>"spherical"</code>: It means spherical kernel which is if <code class="reqn">|x - y| &lt; \delta</code>,
<code class="reqn">R_S(x,y) = 1 - \frac{3}{2}\frac{|x - y|}{\delta} + \frac{1}{2}(\frac{|x - y|}{\delta})^3</code>
</p>
</li>
</ul>
<p>and <code>delta</code> is a specified value. 
For example: let us assume we are going to use <code>"transitive.kernel"</code> as the fuzzy relation,
<code>"gaussian"</code> as its equation and the delta is 0.2. So, we assign the <code>type.relation</code> parameter as follows:
</p>
<p><code>type.relation = c("transitive.kernel", "gaussian", 0.2)</code>
</p>
<p>If we omit the <code>delta</code> parameter then we are using <code>"gaussian"</code> defined as <code class="reqn">R_E(x,y) = \exp(-\frac{|x - y|}{2\sigma^2})</code>, where <code class="reqn">\sigma</code> is the variance.
Furthermore, when using this relation, usually we set 
</p>
<p><code>type.aggregation = c("t.tnorm", "t.cos")</code>.  
</p>
</li>
<li> <p><code>"kernel.frst"</code>: It refers to <code class="reqn">T</code>-equivalence relation proposed by (Hu, 2004).
In order to represent the relation, we must set <code>type.relation</code> parameter as follows.
</p>
<p><code>type.relation = c("kernel.frst", &lt;chosen equation&gt;, &lt;delta&gt;)</code>      
</p>
<p>where the chosen equation is one of the kernel functions, but they have different names corresponding to previous ones: 
<code>"gaussian.kernel"</code>, <code>"exponential.kernel"</code>, <code>"rational.kernel"</code>, <code>"circular.kernel"</code>, and <code>"spherical.kernel"</code>. And
<code>delta</code> is a specified value. 
For example: let us assume we are going to use <code>"gaussian.kernel"</code> as its equation and the delta is 0.2. 
So, we assign the <code>type.relation</code> parameter as follows:
</p>
<p><code>type.relation = c("kernel.frst", "gaussian.kernel", 0.2)</code>
</p>
<p>In this case, we do not need to define type of aggregation. Furthemore, regarding the distance used in the equations if objects <code class="reqn">x</code> and <code class="reqn">y</code> contains mixed values (nominal and continuous)
then we use the Gower distance and we use the euclidean distance for continuous only. 
</p>
</li>
<li> <p><code>"transitive.closure"</code>: It refers to similarity relation (also called fuzzy equivalence relation). 
We consider a simple algorithm to calculate this relation as follows:
</p>
<p>Input: a fuzzy relation R
</p>
<p>Output: a min-transitive fuzzy relation <code class="reqn">R^m</code>
</p>
<p>Algorithm:
</p>
<p>1. For every x, y: compute
</p>
<p><code class="reqn">R'(x,y) = max(R(x,y), max_{z \in U}min(R(x,z), R(z,y)))</code>
</p>
<p>2. If <code class="reqn">R' \not= R</code>, then <code class="reqn">R \gets R'</code> and go to 1, else <code class="reqn">R^m \gets R'</code>
</p>
<p>For interested readers, other algorithms can be seen in (Naessens et al, 2002). Let <code>"eq.1"</code> be the <code class="reqn">R</code> fuzzy relations, to define it as parameter is
</p>
<p><code>type.relation = c("transitive.closure", "eq.1")</code>. We can also use other equations that have been explained in <code>"tolerance"</code> and <code>"transitive.kernel"</code>.
</p>
</li>
<li> <p><code>"crisp"</code>: It uses crisp equality for all attributes and 
we set the parameter <code>type.relation = "crisp"</code>. In this case, we only have <code class="reqn">R(x_i, x_j) = 0</code> 
which means the object <code class="reqn">x_i</code> is completely different from <code class="reqn">x_j</code>, 
and otherwise if <code class="reqn">R(x_i, x_j) = 1</code>. 
</p>
</li>
<li> <p><code>"custom"</code>: this value means that we define our own equation for the indiscernibility relation.
The equation should be defined in parameter <code>FUN.relation</code>. 
</p>
<p><code>type.relation = c("custom", &lt;FUN.relation&gt;)</code>
</p>
<p>The function <code>FUN.relation</code> should consist of three arguments which are <code>decision.table</code>, 
<code>x</code>, and <code>y</code>, where <code>x</code> and <code>y</code> represent two objects which we want to compare. 
It should be noted that the user must ensure that the values of this equation are always between 0 and 1. 
An example can be seen in Section <code>Examples</code>.
</p>
</li>
</ul>
<p>Beside the above <code>type.relation</code>, we provide several options of values for the <code>type.aggregation</code> parameter. 
The following is a description about it.
</p>

<ul>
<li> <p><code>type.aggregation = c("crisp")</code>: It uses crisp equality for all attributes.
</p>
</li>
<li> <p><code>type.aggregation = c("t.tnorm", &lt;t.tnorm operator&gt;)</code>: It means we are using <code>"t.tnorm"</code> aggregation 
which is a triangular norm operator with 
a specified operator <code>t.tnorm</code> as follows: 
</p>

<ul>
<li> <p><code>"min"</code>: standard t-norm i.e., <code class="reqn">min(x_1, x_2)</code>.
</p>
</li>
<li> <p><code>"hamacher"</code>: hamacher product i.e., <code class="reqn">(x_1 * x_2)/(x_1 + x_2 - x_1 * x_2)</code>.
</p>
</li>
<li> <p><code>"yager"</code>: yager class i.e., <code class="reqn">1 - min(1, ((1 - x_1) + (1 - x_2)))</code>.
</p>
</li>
<li> <p><code>"product"</code>: product t-norm i.e., <code class="reqn">(x_1 * x_2)</code>.
</p>
</li>
<li> <p><code>"lukasiewicz"</code>: lukasiewicz's t-norm (default) i.e., <code class="reqn">max(x_2 + x_1 - 1, 0)</code>. 
</p>
</li>
<li> <p><code>"t.cos"</code>: <code class="reqn">T_{cos}</code>t-norm i.e., <code class="reqn">max(x_1 * x_2 - \sqrt{1 - x_1^2}\sqrt{1 - x_2^2, 0})</code>.
</p>
</li>
<li> <p><code>FUN.tnorm</code>: It is a user-defined function for <code>"t.tnorm"</code>. It has to have two arguments, for example:
</p>
<p><code>FUN.tnorm &lt;- function(left.side, right.side)</code>
</p>
<p><code>if ((left.side + right.side) &gt; 1)</code>
</p>
<p><code>return(min(left.side, right.side))</code>
</p>
<p><code>else return(0)</code>
</p>
</li>
</ul>
<p>The default value is <code>type.aggregation = c("t.tnorm", "lukasiewicz")</code>.
</p>
</li>
<li> <p><code>type.aggregation = c("custom", &lt;FUN.agg&gt;)</code>: It is used to define our own function for a type of aggregations. <code>&lt;FUN.agg&gt;</code> is 
a function having one argument representing data that is produced by fuzzy similarity equation calculation.
The data is a list of one or many matrices which depend on the number of considered attributes and has dimension: 
the number of object <code class="reqn">\times</code> the number of object. For example:
</p>
<p><code>FUN.agg &lt;- function(data) return(Reduce("+", data)/length(data))</code>
</p>
<p>which is a function to calculate average along all attributes. Then,
we can set <code>type.aggregation</code> as follows:
</p>
<p><code>type.aggregation = c("general.custom", &lt;FUN.agg&gt;)</code>. An example can be seen in Section <code>Examples</code>.        
</p>
</li>
</ul>
<p>Furthermore, the use of this function has been illustrated in Section <code>Examples</code>. 
Finally, this function is important since it is a basic function needed by other functions, such as <code>BC.LU.approximation.FRST</code> and 
<code>BC.positive.reg.FRST</code> for calculating lower and upper approximation and determining positive regions.
</p>


<h3>Value</h3>

<p>A class <code>"IndiscernibilityRelation"</code> which contains
</p>

<ul>
<li> <p><code>IND.relation</code>: a matrix representing the indiscernibility relation over all objects. 
</p>
</li>
<li> <p><code>type.relation</code>: a vector representing the type of relation. 
</p>
</li>
<li> <p><code>type.aggregation</code>: a vector representing the type of aggregation operator.
</p>
</li>
<li> <p><code>type.model</code>: a string showing the type of model which is used. In this case it is <code>"FRST"</code> which means fuzzy rough set theory.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Lala Septem Riza
</p>


<h3>References</h3>

<p>M. Genton, "Classes of Kernels for Machine Learning: a Statistics Perspective", 
J. Machine Learning Research, vol. 2, p. 299 - 312 (2001). 
</p>
<p>H. Naessens, H. De Meyer, and B. De Baets, 
"Algorithms for the Computation of T-Transitive Closures",
IEEE Trans. on Fuzzy Systems, vol. 10, No. 4, p. 541 - 551 (2002).
</p>
<p>R. Jensen and Q. Shen,  
"New Approaches to Fuzzy-Rough Feature Selection", 
IEEE Trans. on Fuzzy Systems, vol. 19, no. 4,
p. 824 - 838 (2009).
</p>
<p>Q. Hu, D. Yu, W. Pedrycz, and D. Chen, "Kernelized Fuzzy Rough Sets and Their Applications",
IEEE Trans. Knowledge Data Eng., vol. 23, no. 11, p. 1649 - 1471 (2011).
</p>


<h3>See Also</h3>

<p><code>BC.LU.approximation.FRST</code>, <code>BC.IND.relation.RST</code>, <code>BC.LU.approximation.RST</code>, 
</p>
<p>and <code>BC.positive.reg.FRST</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">###########################################################
## Example 1: Dataset containing nominal values for 
## all attributes.
###########################################################
## Decision table is represented as data frame
dt.ex1 &lt;- data.frame(c(1,0,2,1,1,2,2,0), c(0, 1,0, 1,0,2,1,1), 
                        c(2,1,0,0,2,0,1,1), c(2,1,1,2,0,1,1,0), c(0,2,1,2,1,1,2,1))
colnames(dt.ex1) &lt;- c("aa", "bb", "cc", "dd", "ee")
decision.table &lt;- SF.asDecisionTable(dataset = dt.ex1, decision.attr = 5, 
      indx.nominal = c(1:5))

## In this case, we only consider the second and third attributes.
attributes &lt;- c(2, 3)

## calculate fuzzy indiscernibility relation ##
## in this case, we are using "crisp" as a type of relation and type of aggregation
control.ind &lt;- list(type.relation = c("crisp"), type.aggregation = c("crisp"))
IND &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, control = control.ind)

###########################################################
## Example 2: Dataset containing real-valued attributes
###########################################################
dt.ex2 &lt;- data.frame(c(-0.4, -0.4, -0.3, 0.3, 0.2, 0.2), 
                     c(-0.3, 0.2, -0.4, -0.3, -0.3, 0),
			        c(-0.5, -0.1, -0.3, 0, 0, 0),
			        c("no", "yes", "no", "yes", "yes", "no"))
colnames(dt.ex2) &lt;- c("a", "b", "c", "d")
decision.table &lt;- SF.asDecisionTable(dataset = dt.ex2, decision.attr = 4)

## in this case, we only consider the first and second attributes
attributes &lt;- c(1, 2)

## Calculate fuzzy indiscernibility relation 
## in this case, we choose "tolerance" relation and "eq.1" as similarity equation
## and "lukasiewicz" as t-norm of type of aggregation
control.1 &lt;- list(type.aggregation = c("t.tnorm", "lukasiewicz"), 
                    type.relation = c("tolerance", "eq.1"))
IND.1 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.1) 

## Calculate fuzzy indiscernibility relation: transitive.kernel
control.2 &lt;- list(type.aggregation = c("t.tnorm", "t.cos"), 
                    type.relation = c("transitive.kernel", "gaussian", 0.2))
IND.2 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.2) 

## Calculate fuzzy indiscernibility relation: kernel.frst 
control.3 &lt;- list(type.relation = c("kernel.frst", "gaussian.kernel", 0.2))
IND.3 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.3) 

## calculate fuzzy transitive closure
control.4 &lt;- list(type.aggregation = c("t.tnorm", "lukasiewicz"), 
                    type.relation = c("transitive.closure", "eq.1"))
IND.4 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.4) 

## Calculate fuzzy indiscernibility relation: using user-defined relation
## The customized function should have three arguments which are : decision.table 
## and object x, and y.
## This following example shows that we have an equation for similarity equation: 
## 1 - abs(x - y) where x and y are two objects that will be compared.
## In this case, we do not consider decision.table in calculation.
FUN.relation &lt;- function(decision.table, x, y) {
           return(1 - (abs(x - y)))
       }
control.5 &lt;- list(type.aggregation = c("t.tnorm", "lukasiewicz"), 
                     type.relation = c("custom", FUN.relation))
IND.5 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.5) 

## In this case, we calculate aggregation as average of all objects 
## by executing the Reduce function
FUN.average &lt;- function(data){
  	 return(Reduce("+", data)/length(data))
}
control.6 &lt;- list(type.aggregation = c("custom", FUN.average), 
                     type.relation = c("tolerance", "eq.1"))
IND.6 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.6)

## using user-defined tnorms 
FUN.tnorm &lt;- function(left.side, right.side) {
               if ((left.side + right.side) &gt; 1)
                   return(min(left.side, right.side))
               else return(0)}
control.7 &lt;- list(type.aggregation = c("t.tnorm", FUN.tnorm), 
                    type.relation = c("tolerance", "eq.1"))
IND.7 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.7) 

## Calculate fuzzy indiscernibility relation: kernel fuzzy rough set 
control.8 &lt;- list(type.relation = c("kernel.frst", "gaussian.kernel", 0.2))
IND.8 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, 
                              control = control.8) 						   
##################################################################
## Example 3: Dataset containing continuous and nominal attributes
## Note. we only consider type.relation = c("tolerance", "eq.1")
## but other approaches have the same way.
##################################################################
data(RoughSetData)
decision.table &lt;- RoughSetData$housing7.dt 

## in this case, we only consider the attribute: 1, 2, 3, 4 
attributes &lt;- c(1,2,3,4)

## Calculate fuzzy indiscernibility relation
control.9 &lt;- list(type.aggregation = c("t.tnorm", "lukasiewicz"),
                    type.relation = c("tolerance", "eq.1"))
IND.9 &lt;- BC.IND.relation.FRST(decision.table, attributes = attributes, control = control.9) 

</code></pre>


</div>