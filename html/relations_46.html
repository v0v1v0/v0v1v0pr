<div class="container">

<table style="width: 100%;"><tr>
<td>consensus</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Consensus Relations</h2>

<h3>Description</h3>

<p>Compute consensus relations of a relation ensemble.
</p>


<h3>Usage</h3>

<pre><code class="language-R">relation_consensus(x, method = NULL, weights = 1,
                   control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an ensemble of relations (see
<code>relation_ensemble()</code>),
or something which can be coerced to such.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a character string specifying one of the built-in
methods for computing consensus relations, or a function to be
taken as a user-defined method, or <code>NULL</code> (default value).  If
a character string, its lower-cased version is matched against the
lower-cased names of the available built-in methods using
<code>pmatch()</code>.  See <b>Details</b> for available built-in
methods and defaults.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a numeric vector with non-negative case weights.
Recycled to the number of elements in the ensemble given by <code>x</code>
if necessary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>a list of control parameters (overruling those specified
in <code>control</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consensus relations “synthesize” the information in the
elements of a relation ensemble into a single relation, often by
minimizing a criterion function measuring how dissimilar consensus
candidates are from the (elements of) the ensemble (the so-called
“optimization approach”), typically of the form
<code class="reqn">\Phi(R) = \sum w_b d(R_b, R) ^ e</code>, where <code class="reqn">d</code> is a suitable
dissimilarity measure (see <code>relation_dissimilarity()</code>),
<code class="reqn">w_b</code> is the case weight given to element <code class="reqn">R_b</code> of the
ensemble, and <code class="reqn">e \ge 1</code>.  Such consensus relations are called
“central relations” in Régnier (1965).  For <code class="reqn">e = 1</code>, we
obtain (generalized) medians; <code class="reqn">e = 2</code> gives (generalized) means
(least squares consensus relations).
</p>
<p>Available built-in methods are as follows.  Apart from Condorcet's and
the unrestricted Manhattan and Euclidean consensus methods, these are
applicable to ensembles of endorelations only. 
</p>

<dl>
<dt><code>"Borda"</code></dt>
<dd>
<p>the consensus method proposed by Borda (1781).
For each relation <code class="reqn">R_b</code> and object <code class="reqn">x</code>, one determines the
Borda/Kendall scores, i.e., the number of objects <code class="reqn">y</code> such
that <code class="reqn">y R_b x</code>.  These are then aggregated across relations
by weighted averaging.  Finally, objects are ordered according to
their aggregated scores. Note that this may result in a weak order
(i.e., with objects being tied).
</p>
<p>One can enforce a linear order by setting the control parameter
<code>L</code> to <code>TRUE</code>, and obtain a relation ensemble with up to
<em>n</em> or all such solutions by additionally setting the control
parameter <code>n</code> to some positive integer or <code>"all"</code>,
respectively.
</p>
</dd>
<dt><code>"Copeland"</code></dt>
<dd>
<p>the consensus method proposed by Copeland
(1951).  For each relation <code class="reqn">R_b</code> and object <code class="reqn">x</code>, one
determines the Copeland scores, i.e., the number of objects
<code class="reqn">y</code> such that <code class="reqn">y R_b x</code>, minus the number of objects
<code class="reqn">y</code> such that <code class="reqn">x R_b y</code>.  Like the Borda method, these are
then aggregated across relations by weighted averaging.  Finally,
objects are ordered according to their aggregated scores.
Note that this may result in a weak order
(i.e., with objects being tied).
</p>
<p>One can enforce a linear order by setting the control parameter
<code>L</code> to <code>TRUE</code>, and obtain a relation ensemble with up to
<em>n</em> or all such solutions by additionally setting the control
parameter <code>n</code> to some positive integer or <code>"all"</code>,
respectively.
</p>
</dd>
<dt><code>"Condorcet"</code></dt>
<dd>
<p>the consensus method proposed by Condorcet
(1785).  For a given ensemble of crisp relations, this minimizes
the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as symmetric
difference distance and <code class="reqn">e = 1</code> over all possible crisp 
relations.  In the case of endorelations, consensus is obtained by
weighting voting, such that <code class="reqn">x R y</code> if the weighted number of
times that <code class="reqn">x R_b y</code> is no less than the weighted number of
times that this is not the case.  Even when aggregating linear
orders, this can lead to intransitive consensus solutions
(“effet Condorcet”).
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
solutions consensus relations by setting the control parameter
<code>n</code> to some positive integer or <code>"all"</code>, respectively.
</p>
</dd> 
<dt><code>"CS"</code></dt>
<dd>
<p>the consensus method of Cook and Seiford (1978)
which determines a linear order minimizing the criterion function
<code class="reqn">\Phi</code> with <code class="reqn">d</code> as generalized Cook-Seiford (ranking)
distance and <code class="reqn">e = 1</code> via solving a linear sum assignment
problem.
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
</p>
</dd>
<dt><code>"symdiff/<var>F</var>"</code></dt>
<dd>
<p>an exact solver for determining the
consensus relation of an ensemble of crisp endorelations by
minimizing the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as
symmetric difference (“symdiff”) distance and <code class="reqn">e = 1</code>
over a suitable class (“Family”) of crisp endorelations as
indicated by <var>F</var>, with values:
</p>

<dl>
<dt><code>G</code></dt>
<dd>
<p>general (crisp) endorelations.</p>
</dd>
<dt><code>A</code></dt>
<dd>
<p>antisymmetric relations.</p>
</dd>
<dt><code>C</code></dt>
<dd>
<p>complete relations.</p>
</dd>
<dt><code>E</code></dt>
<dd>
<p>equivalence relations: reflexive, symmetric, and
transitive.</p>
</dd>
<dt><code>L</code></dt>
<dd>
<p>linear orders: complete, reflexive,
antisymmetric, and transitive.</p>
</dd>
<dt><code>M</code></dt>
<dd>
<p>matches: complete and reflexive.</p>
</dd>
<dt><code>O</code></dt>
<dd>
<p>partial orders: reflexive, antisymmetric and
transitive.</p>
</dd>
<dt><code>S</code></dt>
<dd>
<p>symmetric relations.</p>
</dd>	
<dt><code>T</code></dt>
<dd>
<p>tournaments: complete, irreflexive and
antisymmetric (i.e., complete and asymmetric).</p>
</dd>
<dt><code>W</code></dt>
<dd>
<p>weak orders (complete preorders, preferences,
“orderings”): complete, reflexive and transitive.</p>
</dd> 
<dt><code>preorder</code></dt>
<dd>
<p>preorders: reflexive and transitive.</p>
</dd>
<dt><code>transitive</code></dt>
<dd>
<p>transitive relations.</p>
</dd>
</dl>
<p>Can also be referred to as <code>"SD/<var>F</var>"</code>.
</p>
<p>Consensus relations are determined by reformulating the consensus
problem as a binary program (for the relation incidences), see
Hornik and Meyer (2007) for details.  The solver employed can be
specified via the control argument <code>solver</code>, with currently
possible values <code>"glpk"</code>, <code>"lpsolve"</code>, <code>"symphony"</code>
or <code>"cplex"</code> or a unique abbreviation thereof, specifying to
use the solvers from packages <span class="pkg">Rglpk</span> (default),
<span class="pkg">lpSolve</span>, <span class="pkg">Rsymphony</span>, or <span class="pkg">Rcplex</span>, respectively.
Unless control option <code>sparse</code> is false, a sparse formulation
of the binary program is used, which is typically more efficient.
</p>
<p>For fitting equivalences and weak orders (cases <code>E</code> and
<code>W</code>) it is possible to specify the number of classes <code class="reqn">k</code>
using the control parameter <code>k</code>.  For fitting weak orders,
one can also specify the number of elements in the classes via
control parameter <code>l</code>.
</p>
<p>Additional constraints on the incidences of the consensus solution
can be given via the control parameter <code>constraints</code>, in the
form of a 3-column matrix whose rows give row and column indices
<code class="reqn">i</code> and <code class="reqn">j</code> and the corresponding incidence <code class="reqn">I_{ij}</code>.
(I.e., incidences can be constrained to be zero or one on an
object by object basis.)
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
(See the examples.)
</p>
</dd>
<dt><code>"manhattan"</code></dt>
<dd>
<p>the (unrestricted) median of the
ensemble, minimizing <code class="reqn">\Phi</code> with <code class="reqn">d</code> as Manhattan (symmetric
difference) distance and <code class="reqn">e = 1</code> over all (possibly fuzzy)
relations.</p>
</dd>
<dt><code>"euclidean"</code></dt>
<dd>
<p>the (unrestricted) mean of the ensemble,
minimizing <code class="reqn">\Phi</code> with <code class="reqn">d</code> as Euclidean distance and
<code class="reqn">e = 2</code> over all (possibly fuzzy) relations.</p>
</dd>
<dt><code>"euclidean/<var>F</var>"</code></dt>
<dd>
<p>an exact solver for determining
the restricted least squares Euclidean consensus relation of an
ensemble of endorelations by minimizing the criterion function
<code class="reqn">\Phi</code> with <code class="reqn">d</code> as Euclidean difference distance and
<code class="reqn">e = 2</code> over a suitable family of crisp endorelations as
indicated by <var>F</var>, with available families and control
parameters as for methods <code>"symdiff/<var>F</var>"</code>.
</p>
</dd>
<dt><code>"majority"</code></dt>
<dd>
<p>a generalized majority method for which the
consensus relation contains of all tuples occurring with a
relative frequency of more than <code class="reqn">100 p</code> percent (of 100
percent if <code class="reqn">p = 1</code>).  The fraction <code class="reqn">p</code> can be specified
via the control parameter <code>p</code>.  By default, <code class="reqn">p = 1/2</code> is
used.
</p>
</dd>
<dt><code>"CKS/<var>F</var>"</code></dt>
<dd>
<p>an exact solver for determining the
consensus relation of an ensemble of crisp endorelations by
minimizing the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as
Cook-Kress-Seiford (“CKS”) distance and <code class="reqn">e = 1</code> over a
suitable class (“Family”) of crisp endorelations as
indicated by <var>F</var>, with available families and control
parameters as for methods <code>"symdiff/<var>F</var>"</code>.
</p>
<p>For fitting equivalences and weak orders (cases <code>E</code> and
<code>W</code>) it is possible to specify the number of classes <code class="reqn">k</code>
using the control parameter <code>k</code>.
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
</p>
</dd>
<dt><code>"PC/<var>F</var>"</code></dt>
<dd>
<p>an exact solver for determining the
consensus relation of an ensemble of crisp endorelations by
minimizing the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as
(generalized) paired comparison (“PC”) distance and
<code class="reqn">e = 1</code> over a suitable class (“Family”) of crisp
endorelations as indicated by <var>F</var>, with available families and
control parameters as for methods <code>"symdiff/<var>F</var>"</code>, and
control option <code>delta</code> for specifying the paired comparison
discrepancies.
</p>
<p>For fitting equivalences and weak orders (cases <code>E</code> and
<code>W</code>) it is possible to specify the number of classes <code class="reqn">k</code>
using the control parameter <code>k</code>.
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
</p>
</dd>
</dl>
<h3>Value</h3>

<p>The consensus relation(s).
</p>


<h3>References</h3>

<p>J. C. Borda (1781),
Mémoire sur les élections au scrutin.
Histoire de l'Académie Royale des Sciences.
</p>
<p>W. D. Cook and M. Kress (1992),
<em>Ordinal information and preference structures: decision models and
applications</em>.
Prentice-Hall: New York.
ISBN: 0-13-630120-7.
</p>
<p>W. D. Cook and L. M. Seiford (1978),
Priority ranking and consensus formation.
<em>Management Science</em>, <b>24</b>/16, 1721–1732.
<a href="https://doi.org/10.1287/mnsc.24.16.1721">doi:10.1287/mnsc.24.16.1721</a>.
</p>
<p>M. J. A. de Condorcet (1785),
Essai sur l'application de l'analyse à la probabilité des décisions
rendues à la pluralité des voix. 
Paris.
</p>
<p>A. H. Copeland (1951),
A Reasonable Social Welfare Function.
<em>mimeo</em>, University of Michigan.
</p>
<p>E. J. Emond and D. W. Mason (2000),
<em>A new technique for high level decision support</em>.
Technical Report ORD Project Report PR2000/13, Operational
Research Division, Department of National Defence, Canada.

</p>
<p>K. Hornik and D. Meyer (2007),
Deriving consensus rankings from benchmarking experiments.
In R. Decker and H.-J. Lenz,
<em>Advances in Data Analysis</em>.
Studies in Classification, Data Analysis, and Knowledge Organization.
Springer-Verlag: Heidelberg, 163–170.
</p>
<p>F. Marcotorchino and P. Michaud (1982).
Agrégation de similarités en classification automatique.
<em>Revue de Statistique Appliquée</em>, <b>30</b>/2, 21–44.
<a href="https://eudml.org/doc/106132">https://eudml.org/doc/106132</a>.
</p>
<p>S. Régnier (1965),
Sur quelques aspects mathématiques des problèmes de classification
automatique.
<em>ICC Bulletin</em>, <b>4</b>, 175–191.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Consensus equivalence.
## (I.e., in fact, consensus partition.)
## Classification of 30 felines, see Marcotorchino and Michaud (1982).
data("Felines")
## Consider each variable an equivalence relation on the objects.
relations &lt;- as.relation_ensemble(Felines)
## This gives a relation ensemble of length 14 (number of variables in
## the data set).
## Now fit an equivalence relation to this:
E &lt;- relation_consensus(relations, "symdiff/E")
## And look at the equivalence classes:
ids &lt;- relation_class_ids(E)
## Or, more nicely:
split(rownames(Felines), ids)
## Which is the same as in the paper ...

## Consensus linear order.
## Example from Cook and Kress, pages 48ff.
## Relation from paired comparisons.
pm &lt;- matrix(c(0, 1, 0, 1, 1,
               0, 0, 0, 1, 1,
               1, 1, 0, 0, 0,
               0, 0, 1, 0, 0,
               0, 0, 1, 1, 0),
             nrow = 5,
             byrow = TRUE,
             dimnames = list(letters[1:5], letters[1:5]))
## Note that this is a Cook and Kress "preference matrix" where entry
## (i,j) is one iff object i is preferred to object j (i &gt; j).
## Set up the corresponding '&lt;' relation:
R &lt;- as.relation(t(pm))
relation_incidence(R)
relation_is(R, "tournament")
## Closest linear order:
L &lt;- relation_consensus(R, "symdiff/L")
relation_incidence(L)
## Visualize provided that Rgraphviz is available.
if(require("Rgraphviz")) plot(L)
## But note that this linear order is not unique.
L &lt;- relation_consensus(R, "symdiff/L", control = list(n = "all"))
print(L)
if(require("Rgraphviz")) plot(L)
## (Oh no: c is once first and once last.)
## Closest weak order relation with at most 3 indifference classes:
W3 &lt;- relation_consensus(R, "symdiff/W", control = list(k = 3))
relation_incidence(W3)

## Consensus weak orders.
## Example from Emond and Mason, pages 28f.
## The reference provides 21 partial rankings of 15 objects,
## in 3 groups of 7 rankings (corresponding to three different
## ranking criteria) with respective weights 4, 5, and 7.
wei &lt;- rep.int(c(4, 5, 7), rep(7, 3))
## The rankings are written by listing the object labels from the
## best to the worst, with a leading minus indicating a tie with
## the previous object:
EM_inputs &lt;-
    c("6 1 -7 -9 10 3 8 11 5 -12 2 -4 -13",
      "6 10 9 3 4 -8 7 1 -5 -11 2 12 13 14 15",
      "6 10 3 7 8 11 5 14 15 12 1 -4 -13 2 -9",
      "6 9 -11 10 3 14 12 7 4 5 2 1 8 13 15",
      "10 6 7 1 11 -13 4 2 3 9 12 14 -15 8 5",
      "6 9 8 -10 11 4 1 5 7 15 2 12 14 13 3",
      "1 -6 -10 7 -12 9 3 4 -11 -14 -15 2 -13 8",
      "4 -10 1 -7 6 -9 -13 5 -14 3 12 8 11 -15 2",
      "4 -9 5 1 14 11 8 3 6 2 -13 10 12 7 15",
      "4 2 -5 8 15 7 11 -14 1 -12 -13 10 9 6",
      "2 -11 -12 -14 -15 6 -13 3 -4 9 8 -10 1 -5 -7",
      "4 14 10 2 5 3 1 13 12 7 15 8 11 6 9",
      "4 2 5 1 15 7 13 14 3 -12 8 11 6 9 10",
      "12 1 3 -4 2 11 -13 -15 9 14 6 8 7 -10 5",
      "5 4 9 2 -7 14 8 -11 3 1 15 12 6 10 13",
      "11 9 -14 15 12 3 4 13 8 6 7 10 5",
      "12 11 2 1 3 9 8 10 13 -14 6 4 -15 5 7",
      "4 -5 10 -12 3 8 -11 6 -7 -9 13 14 15",
      "12 5 -13 14 3 8 15 4 9 -10 11 6 7",
      "4 -5 -8 11 6 14 7 1 -2 -15 10 3 13 9 -12",
      "10 8 5 -11 6 -14 9 4 -13 -15 3 -12 2 1")
## Using the Emond-Mason paired comparison dissimilarity, there
## are three consensus rankings when using the above weights:
EM_solutions &lt;-
    c("4 10 5-11 1 -2-14 3-12 9 8 6 7 13-15",
      "4 10 5-11 1 -2 9 14 3-12 8 6 7 13-15",
      "4 10 5-11 2-14 1 3-12 9 8 6 7 13-15")
## We can reproduce this as follows.
## We first provide a reader for the rankings, and a maker for
## creating the (possibly partial) ranking with the appropriate
## domain:
reader &lt;- function(s) {
    strsplit(unlist(strsplit(gsub(" *-", "-", s),
                             " +")),
             "-",
             fixed = TRUE)
}
maker &lt;- function(s) {
    ranking(lapply(reader(s), as.numeric),
            domain = as.numeric(1 : 15))
}
EM_inputs &lt;- lapply(EM_inputs, maker)
EM_solutions &lt;- lapply(EM_solutions, maker)
## Package 'relations' uses NA for non-diagonal incidences
## featuring unranked objects.
## Following the reference, we impute these by zeroes:
ens &lt;- relation_impute(relation_ensemble(list = EM_inputs), "omit")
## We can now obtain all consensus weak orders (corresponding to
## complete rankings) as follows:
con &lt;- relation_consensus(ens, "PC/W", wei, delta = "EM", all = TRUE)
## To verify that these agree with the solutions given in the
## reference:
sets::set_outer(con, relation_ensemble(list = EM_solutions), `==`)
</code></pre>


</div>