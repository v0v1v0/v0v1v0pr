<div class="container">

<table style="width: 100%;"><tr>
<td>compute.threshold.pooledROC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pooled ROC based threshold values.
</h2>

<h3>Description</h3>

<p>This function implements methods for estimating pooled ROC-based threshold values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compute.threshold.pooledROC(object, criterion = c("FPF", "TPF", "YI"), FPF, TPF, 
  ci.level = 0.95, parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>pooledROC</code> as produced by <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code>, or <code>pooledROC.dpm</code> functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>A character string indicating if the threshold value should be computed based on the Youden index (“YI”), or for fixed false positive fractions (“FPF”) or true positive fractions (“TPF”). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FPF</code></td>
<td>
<p>For <code>criterion = "FPF"</code>, a numeric vector with the FPF at which to calculate the threshold values. Atomic values are also valid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TPF</code></td>
<td>
<p>For <code>criterion = "TPF"</code>, a numeric vector with the TPF at which to calculate the threshold values. Atomic values are also valid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either "no" (default), "multicore" (not available on Windows) or "snow".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = "snow". If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates pooled ROC-based threshold values based on three different criteria, namely, the Youden index (YI), one that gives rise to a pre-specified FPF, and one that gives rise to a pre-specified TPF.
</p>
<p>The Youden Index is defined as
</p>
<p style="text-align: center;"><code class="reqn">YI = \max_{c}\{TPF(c) - FPF(c)\} = \max_{c}\{F_{\bar{D}}(c) - F_{D}(c)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The value <code class="reqn">c^{*}</code> that achieves the maximum is called the optimal YI threshold. Regarding the criterion for a fixed FPF, the threshold value is obtained as follows
</p>
<p style="text-align: center;"><code class="reqn">c = F_{\bar{D}}^{-1}(1-FPF).</code>
</p>

<p>and for a fixed TPF we have
</p>
<p style="text-align: center;"><code class="reqn">c = F_{D}^{-1}(1-TPF).</code>
</p>



<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>If method = "YI", the estimated (optimal) threshold corresponding to the Youden index (the one that maximises TPF/sensitivity + TNF/specificity). If method = "FPF", the estimated threshold corresponding to the specified FPF, and if method = "TPF", the estimated threshold corresponding to the specified TPF. For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), and in both cases, in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YI</code></td>
<td>
<p>If method = "YI", the estimated Youden index. For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FPF</code></td>
<td>
<p>If method = "YI" or method = "TPF", the FPF corresponding to the estimated (optimal) threshold (For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned). If method = "FPF", the supplied FPF argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TPF</code></td>
<td>
<p>If method = "YI" or method = "FPF", the TPF/sensitivity corresponding to the estimated (optimal) threshold. For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned. If method = "TPF", the supplied TPF argument.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Rutter, C.M. and Miglioretti, D. L. (2003). Estimating the Accuracy of Psychological Scales Using Longitudinal Data. Biostatistics, <b>4</b>, 97–107.
</p>
<p>Youden, W. J. (1<code>ci.level</code>*1000). Index for rating diagnostic tests. Cancer, <b>3</b>, 32–35.
</p>


<h3>See Also</h3>

<p><code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code> or <code>pooledROC.dpm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_dpm &lt;- pooledROC.dpm(marker = "l_marker1", group = "status",
            tag.h = 0, data = newpsa, standardise = TRUE, 
            p = seq(0,1,l=101), compute.WAIC = TRUE, compute.lpml = TRUE, 
            compute.DIC = TRUE, 
            prior.h = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            prior.d = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            mcmc = mcmccontrol(nsave = 400, nburn = 100, nskip = 1))


## Threshold values based on the YI
th_m0_dpm_yi &lt;- compute.threshold.pooledROC(m0_dpm, criterion = "YI")

th_m0_dpm_yi$threshold
th_m0_dpm_yi$YI

### Threshold values for a fixed FPF
th_m0_dpm_fpf &lt;- compute.threshold.pooledROC(m0_dpm, criterion = "FPF", FPF = 0.1)

th_m0_dpm_fpf$threshold

  
</code></pre>


</div>