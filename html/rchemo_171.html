<div class="container">

<table style="width: 100%;"><tr>
<td>soplsrda</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Block dimension reduction by SO-PLS-DA</h2>

<h3>Description</h3>

<p>Function <code>soplsrda</code> implements dimension reductions of pre-selected blocks of variables (= set of columns) of a reference (= training) matrix, by sequential orthogonalization-PLS (said "SO-PLS") in a context of discrimination. 
</p>
<p>Function <code>soplsrdacv</code> perfoms repeteated cross-validation of an SO-PLS-RDA model in order to choose the optimal lv combination from the different blocks.
</p>
<p>The block reduction consists in calculating latent variables (= scores) for each block, each block being sequentially orthogonalized to the information computed from the previous blocks.
</p>
<p>The function allows giving a priori weights to the rows of the reference matrix in the calculations.
</p>
<p>In<code>soplslda</code> and <code>soplsqda</code>, probabilistic LDA and QDA are run over the PLS2 LVs, respectively.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
soplsrda(Xlist, y, Xscaling = c("none", "pareto", "sd")[1], 
Yscaling = c("none", "pareto", "sd")[1], weights = NULL, nlv)

soplslda(Xlist, y, Xscaling = c("none", "pareto", "sd")[1], 
Yscaling = c("none", "pareto", "sd")[1], weights = NULL, nlv, 
prior = c("unif", "prop"))

soplsqda(Xlist, y, Xscaling = c("none", "pareto", "sd")[1], 
Yscaling = c("none", "pareto", "sd")[1], weights = NULL, nlv, 
prior = c("unif", "prop"))

soplsrdacv(Xlist, y, Xscaling = c("none", "pareto", "sd")[1], 
Yscaling = c("none", "pareto", "sd")[1], weights = NULL, nlvlist=list(), 
nbrep=30, cvmethod="kfolds", seed = 123, samplingk = NULL, nfolds = 7, 
optimisation = c("global","sequential")[1], 
criterion = c("err","rmse")[1], selection = c("localmin","globalmin","1std")[1])

soplsldacv(Xlist, y, Xscaling = c("none", "pareto", "sd")[1], 
Yscaling = c("none", "pareto", "sd")[1], weights = NULL, nlvlist=list(), 
prior = c("unif", "prop"), nbrep = 30, cvmethod = "kfolds", seed = 123, samplingk = NULL, 
nfolds = 7, optimisation = c("global","sequential")[1], 
criterion = c("err","rmse")[1], selection = c("localmin","globalmin","1std")[1])

soplsqdacv(Xlist, y, Xscaling = c("none", "pareto", "sd")[1], 
Yscaling = c("none", "pareto", "sd")[1], weights = NULL, nlvlist = list(), 
prior = c("unif", "prop"), nbrep = 30, cvmethod = "kfolds", seed = 123, samplingk = NULL, 
nfolds = 7, optimisation = c("global","sequential")[1], 
criterion = c("err","rmse")[1], selection = c("localmin","globalmin","1std")[1])

## S3 method for class 'Soplsrda'
transform(object, X, ...) 

## S3 method for class 'Soplsprobda'
transform(object, X, ...) 

## S3 method for class 'Soplsrda'
predict(object, X, ...) 

## S3 method for class 'Soplsprobda'
predict(object, X, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xlist</code></td>
<td>
<p>For the main functions: A list of matrices or data frames of reference (= training) observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>For the auxiliary functions: list of new X-data, with the same variables than the training X-data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Training class membership (<code class="reqn">n</code>). <b>Note:</b> If <code>y</code> is a factor, it is replaced by a character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xscaling</code></td>
<td>
<p>vector (of length Xlist) of variable scaling for each datablock, among "none" (mean-centering only), "pareto" (mean-centering and pareto scaling), "sd" (mean-centering and unit variance scaling). If "pareto" or "sd", uncorrected standard deviation is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Yscaling</code></td>
<td>
<p>variable scaling for the Y-block, among "none" (mean-centering only), "pareto" (mean-centering and pareto scaling), "sd" (mean-centering and unit variance scaling). If "pareto" or "sd", uncorrected standard deviation is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a priori weights to the rows of the reference matrix in the calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlv</code></td>
<td>
<p>A vector of same length as the number of blocks defining the number of scores to calculate for each block, or a single number. In this last case, the same number of scores is used for all the blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlvlist</code></td>
<td>
<p>A list of same length as the number of X-blocks. Each component of the list gives the number of PLS components of the corresponding X-block to test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbrep</code></td>
<td>
<p>An integer, setting the number of CV repetitions. Default value is 30.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvmethod</code></td>
<td>
<p>"kfolds" for k-folds cross-validation, or "loo" for leave-one-out.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>a numeric. Seed used for the repeated resampling, and if cvmethod is "kfolds" and samplingk is not NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplingk</code></td>
<td>
<p>Optional. A vector of length n. The elements are the values of a qualitative variable used for stratified partition creation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>An integer, setting the number of partitions to create. Default value is 7.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimisation</code></td>
<td>
<p>"global" or "sequential" optimisation of the number of components. If "sequential", the optimal lv number is found for the first X-block, then for the 2nd one, etc...</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>optimisation criterion among "rmse" and "err" (for classification error rate)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection</code></td>
<td>
<p>a character indicating the selection method to use to choose the optimal combination of components, among "localmin","globalmin","1std". If "localmin": the optimal combination corresponds to the first local minimum of the mean CV rmse or error rate. If "globalmin" : the optimal combination corresponds to the minimum mean CV rmse or error rate. If "1std" (one standard error rule) : it corresponds to the first combination after which the mean cross-validated rmse or error rate does not decrease significantly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>The prior probabilities of the classes. Possible values are "unif" (default; probabilities are set equal for all the classes) or "prop" (probabilities are set equal to the observed proportions of the classes in <code>y</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>For the auxiliary functions: A fitted model, output of a call to the main functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For the auxiliary functions: Optional arguments. Not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>soplsrda</code>, <code>soplslda</code>, <code>soplsqda</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fm</code></td>
<td>
<p>list with the PLS models: (<code>T</code>): X-scores matrix; (<code>P</code>): X-loading matrix;(<code>R</code>): The PLS projection matrix (p,nlv); (<code>W</code>): X-loading weights matrix ;(<code>C</code>): The Y-loading weights matrix; (<code>TT</code>): the X-score normalization factor; (<code>xmeans</code>): the centering vector of X (p,1);  (<code>ymeans</code>): the centering vector of Y (q,1); (<code>weights</code>): vector of observation weights; (<code>Xscales</code>): X scaling values; (<code>Yscales</code>): Y scaling values; (<code>U</code>): intermediate output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lev</code></td>
<td>
<p>classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ni</code></td>
<td>
<p>number of observations in each class</p>
</td>
</tr>
</table>
<p>For <code>transform.Soplsrda</code>, <code>transform.Soplsprobda</code>:  the LVs Calculated for the new matrices list <code class="reqn">Xlist</code> from the model.
</p>
<p>For <code>predict.Soplsrda</code>, <code>predict.Soplsprobda</code>: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>predicted class for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posterior</code></td>
<td>
<p>calculated probability of belonging to a class for each observation</p>
</td>
</tr>
</table>
<p>For <code>soplsrdacv</code>, <code>soplsldacv</code>, <code>soplsqdacv</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lvcombi</code></td>
<td>
<p>matrix or list of matrices, of tested component combinations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimCombiLine</code></td>
<td>
<p>number of the combination line corresponding to the optimal one. In the case of a sequential optimisation, it is the number of the combination line in the model with all the X-blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimcombi</code></td>
<td>
<p>the number of PLS components of each X-block allowing the optimisation of the mean rmseCV.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimExplVarCV</code></td>
<td>
<p>cross-validated explained variance for the optimal soplsda model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmseCV</code></td>
<td>
<p>matrix or list of matrices of mean and sd of cross-validated rmse in the model for each combination and response variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ExplVarCV</code></td>
<td>
<p>matrix or list of matrices of mean and sd of cross-validated explained variances in the model for each combination and response variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errCV</code></td>
<td>
<p>matrix or list of matrices of mean and sd of cross-validated classification error rates in the model for each combination and response variables.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>- Biancolillo et al. , 2015. Combining SO-PLS and linear discriminant analysis for
multi-block classification. Chemometrics and Intelligent Laboratory Systems, 141, 58-67.
</p>
<p>- Biancolillo, A. 2016. Method development in the area of multi-block analysis focused on food analysis. PhD. University of copenhagen.
</p>
<p>- Menichelli et al., 2014. SO-PLS as an exploratory tool for path modelling. Food Quality and Preference, 36, 122-134.
</p>
<p>- Tenenhaus, M., 1998. La régression PLS: théorie et pratique. Editions Technip, Paris, France.
</p>


<h3>See Also</h3>

<p><code>soplsr_soplsda_allsteps</code> function to help determine the optimal number of latent variables, perform a permutation test, calculate model parameters and predict new observations.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
N &lt;- 10 ; p &lt;- 12
set.seed(1)
X &lt;- matrix(rnorm(N * p, mean = 10), ncol = p, byrow = TRUE)
y &lt;- matrix(sample(c("1", "4", "10"), size = N, replace = TRUE), ncol=1)
colnames(X) &lt;- paste("x", 1:ncol(X), sep = "")
set.seed(NULL)

n &lt;- nrow(X)

X_list &lt;- list(X[,1:4], X[,5:7], X[,9:ncol(X)])
X_list_2 &lt;- list(X[1:2,1:4], X[1:2,5:7], X[1:2,9:ncol(X)])

# EXEMPLE WITH SO-PLS-RDA
soplsrdacv(X_list, y, Xscaling = c("none", "pareto", "sd")[1], 
Yscaling = c("none", "pareto", "sd")[1], weights = NULL,
nlvlist=list(0:1, 1:2, 0:1), nbrep=1, cvmethod="loo", seed = 123, 
samplingk = NULL, nfolds = 3, optimisation = "global", 
criterion = c("err","rmse")[1], selection = "localmin")

ncomp &lt;- 2
fm &lt;- soplsrda(X_list, y, nlv = ncomp)
predict(fm,X_list_2)
transform(fm,X_list_2)

ncomp &lt;- c(2, 0, 3)
fm &lt;- soplsrda(X_list, y, nlv = ncomp)
predict(fm,X_list_2)
transform(fm,X_list_2)

ncomp &lt;- 0
fm &lt;- soplsrda(X_list, y, nlv = ncomp)
predict(fm,X_list_2)
transform(fm,X_list_2)

# EXEMPLE WITH SO-PLS-LDA
ncomp &lt;- 2
weights &lt;- rep(1 / n, n)
#w &lt;- 1:n
soplslda(X_list, y, Xscaling = "none", nlv = ncomp, weights = weights)
soplslda(X_list, y, Xscaling = "pareto", nlv = ncomp, weights = weights)
soplslda(X_list, y, Xscaling = "sd", nlv = ncomp, weights = weights)

fm &lt;- soplslda(X_list, y, Xscaling = c("none","pareto","sd"), nlv = ncomp, weights = weights)
predict(fm,X_list_2)
transform(fm,X_list_2)

</code></pre>


</div>