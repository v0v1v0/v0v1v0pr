<div class="container">

<table style="width: 100%;"><tr>
<td>rlars</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Robust least angle regression</h2>

<h3>Description</h3>

<p>Robustly sequence candidate predictors according to their predictive content
and find the optimal model along the sequence.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rlars(x, ...)

## S3 method for class 'formula'
rlars(formula, data, ...)

## Default S3 method:
rlars(
  x,
  y,
  sMax = NA,
  centerFun = median,
  scaleFun = mad,
  winsorize = FALSE,
  const = 2,
  prob = 0.95,
  fit = TRUE,
  s = c(0, sMax),
  regFun = lmrob,
  regArgs = list(),
  crit = c("BIC", "PE"),
  splits = foldControl(),
  cost = rtmspe,
  costArgs = list(),
  selectBest = c("hastie", "min"),
  seFactor = 1,
  ncores = 1,
  cl = NULL,
  seed = NULL,
  model = TRUE,
  tol = .Machine$double.eps^0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix or data frame containing the candidate predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed down.  For the default
method, additional arguments to be passed down to
<code>robStandardize</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula describing the full model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
to a data frame by <code>as.data.frame</code>) containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>rlars</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a numeric vector containing the response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sMax</code></td>
<td>
<p>an integer giving the number of predictors to be sequenced.  If
it is <code>NA</code> (the default), predictors are sequenced as long as there are
twice as many observations as predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centerFun</code></td>
<td>
<p>a function to compute a robust estimate for the center
(defaults to <code>median</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleFun</code></td>
<td>
<p>a function to compute a robust estimate for the scale
(defaults to <code>mad</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>winsorize</code></td>
<td>
<p>a logical indicating whether to clean the full data set by
multivariate winsorization, i.e., to perform data cleaning RLARS instead of
plug-in RLARS (defaults to <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>numeric; tuning constant to be used in the initial corralation
estimates based on adjusted univariate winsorization (defaults to 2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>numeric; probability for the quantile of the
<code class="reqn">\chi^{2}</code> distribution to be used in bivariate or
multivariate winsorization (defaults to 0.95).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>a logical indicating whether to fit submodels along the sequence
(<code>TRUE</code>, the default) or to simply return the sequence (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>an integer vector of length two giving the first and last step
along the sequence for which to compute submodels.  The default is to start
with a model containing only an intercept (step 0) and iteratively add all
variables along the sequence (step <code>sMax</code>).  If the second element is
<code>NA</code>, predictors are added to the model as long as there are twice
as many observations as predictors.  If only one value is supplied, it is
recycled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regFun</code></td>
<td>
<p>a function to compute robust linear regressions along the
sequence (defaults to <code>lmrob</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regArgs</code></td>
<td>
<p>a list of arguments to be passed to <code>regFun</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>a character string specifying the optimality criterion to be
used for selecting the final model.  Possible values are <code>"BIC"</code> for
the Bayes information criterion and <code>"PE"</code> for resampling-based
prediction error estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splits</code></td>
<td>
<p>an object giving data splits to be used for prediction error
estimation (see <code>perry</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>a cost function measuring prediction loss (see
<code>perry</code> for some requirements).  The
default is to use the root trimmed mean squared prediction error
(see <code>cost</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>costArgs</code></td>
<td>
<p>a list of additional arguments to be passed to the
prediction loss function <code>cost</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selectBest, seFactor</code></td>
<td>
<p>arguments specifying a criterion for selecting
the best model (see <code>perrySelect</code>).  The default is to
use a one-standard-error rule.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>a positive integer giving the number of processor cores to be
used for parallel computing (the default is 1 for no parallelization).  If
this is set to <code>NA</code>, all available processor cores are used.  For
fitting models along the sequence and for prediction error estimation,
parallel computing is implemented on the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> level using package
<span class="pkg">parallel</span>.  Otherwise parallel computing for some of of the more
computer-intensive computations in the sequencing step is implemented on the
C++ level via OpenMP (<a href="https://www.openmp.org/">https://www.openmp.org/</a>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a <span class="pkg">parallel</span> cluster for parallel computing as generated by
<code>makeCluster</code>.  This is preferred over <code>ncores</code>
for tasks that are parallelized on the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> level, in which case <code>ncores</code>
is only used for tasks that are parallelized on the C++ level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>optional initial seed for the random number generator (see
<code>.Random.seed</code>).  This is useful because many robust regression
functions (including <code>lmrob</code>) involve randomness,
or for prediction error estimation.  On parallel <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> worker processes, random
number streams are used and the seed is set via
<code>clusterSetRNGStream</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>a logical indicating whether the model data should be included
in the returned object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>a small positive numeric value.  This is used in bivariate
winsorization to determine whether the initial estimate from adjusted
univariate winsorization is close to 1 in absolute value.  In this case,
bivariate winsorization would fail since the points form almost a straight
line, and the initial estimate is returned.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If <code>fit</code> is <code>FALSE</code>, an integer vector containing the indices of
the sequenced predictors.
</p>
<p>Else if <code>crit</code> is <code>"PE"</code>, an object of class
<code>"perrySeqModel"</code> (inheriting from class <code>"perrySelect"</code>,
see <code>perrySelect</code>).  It contains information on the
prediction error criterion, and includes the final model as component
<code>finalModel</code>.
</p>
<p>Otherwise an object of class <code>"rlars"</code> (inheriting from class
<code>"seqModel"</code>) with the following components:
</p>

<dl>
<dt><code>active</code></dt>
<dd>
<p>an integer vector containing the indices of the
sequenced predictors.</p>
</dd>
<dt><code>s</code></dt>
<dd>
<p>an integer vector containing the steps for which submodels
along the sequence have been computed.</p>
</dd>
<dt><code>coefficients</code></dt>
<dd>
<p>a numeric matrix in which each column contains
the regression coefficients of the corresponding submodel along the
sequence.</p>
</dd>
<dt><code>fitted.values</code></dt>
<dd>
<p>a numeric matrix in which each column contains
the fitted values of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>residuals</code></dt>
<dd>
<p>a numeric matrix in which each column contains
the residuals of the corresponding submodel along the sequence.</p>
</dd>
<dt><code>df</code></dt>
<dd>
<p>an integer vector containing the degrees of freedom of
the submodels along the sequence (i.e., the number of estimated
coefficients).</p>
</dd>
<dt><code>robust</code></dt>
<dd>
<p>a logical indicating whether a robust fit was
computed (<code>TRUE</code> for <code>"rlars"</code> models).</p>
</dd>
<dt><code>scale</code></dt>
<dd>
<p>a numeric vector giving the robust residual scale
estimates for the submodels along the sequence.</p>
</dd>
<dt><code>crit</code></dt>
<dd>
<p>an object of class <code>"bicSelect"</code> containing the
BIC values and indicating the final model (only returned if argument
<code>crit</code> is <code>"BIC"</code> and argument <code>s</code> indicates more than one
step along the sequence).</p>
</dd>
<dt><code>muX</code></dt>
<dd>
<p>a numeric vector containing the center estimates of the
predictors.</p>
</dd>
<dt><code>sigmaX</code></dt>
<dd>
<p>a numeric vector containing the scale estimates of
the predictors.</p>
</dd>
<dt><code>muY</code></dt>
<dd>
<p>numeric; the center estimate of the response.</p>
</dd>
<dt><code>sigmaY</code></dt>
<dd>
<p>numeric; the scale estimate of the response.</p>
</dd>
<dt><code>x</code></dt>
<dd>
<p>the matrix of candidate predictors (if <code>model</code> is
<code>TRUE</code>).</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>the response (if <code>model</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>w</code></dt>
<dd>
<p>a numeric vector giving the data cleaning weights (if
<code>winsorize</code> is <code>TRUE</code>).</p>
</dd>
<dt><code>call</code></dt>
<dd>
<p>the matched function call.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Andreas Alfons, based on code by Jafar A. Khan, Stefan Van Aelst and
Ruben H. Zamar
</p>


<h3>References</h3>

<p>Khan, J.A., Van Aelst, S. and Zamar, R.H. (2007) Robust linear model
selection based on least angle regression. <em>Journal of the American
Statistical Association</em>, <b>102</b>(480), 1289–1299.
<a href="https://doi.org/10.1198/016214507000000950">doi:10.1198/016214507000000950</a>
</p>


<h3>See Also</h3>

<p><code>coef</code>,
<code>fitted</code>,
<code>plot</code>,
<code>predict</code>,
<code>residuals</code>,
<code>rstandard</code>,
<code>lmrob</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points

## fit robust LARS model
rlars(x, y, sMax = 10)
</code></pre>


</div>