<div class="container">

<table style="width: 100%;"><tr>
<td>pfr_old</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Penalized Functional Regression (old version)</h2>

<h3>Description</h3>

<p>This code implements the function pfr() available in refund 0.1-11. It is included
to maintain backwards compatibility. 
</p>
<p>Functional predictors are entered as a matrix or, in the case of
multiple functional predictors, as a list of matrices using the
<code>funcs</code> argument. Missing values are allowed in the functional
predictors, but it is assumed that they are observed over the same
grid. Functional coefficients and confidence bounds are returned as
lists in the same order as provided in the <code>funcs</code> argument, as
are principal component and spline bases.  Increasing values of
<code>nbasis</code> will increase computational time and the values of
<code>nbasis</code>, <code>kz</code>, and <code>kb</code> in relation to each other may
need to be adjusted in application-specific ways.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pfr_old(
  Y,
  subj = NULL,
  covariates = NULL,
  funcs,
  kz = 10,
  kb = 30,
  nbasis = 10,
  family = "gaussian",
  method = "REML",
  smooth.option = "fpca.sc",
  pve = 0.99,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>vector of all outcomes over all visits</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subj</code></td>
<td>
<p>vector containing the subject number for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>
<p>matrix of scalar covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funcs</code></td>
<td>
<p>matrix, or list of matrices, containing observed functional 
predictors as rows. NA values are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kz</code></td>
<td>
<p>can be NULL; can be a scalar, in which case this will be the 
dimension of principal components basis for each and every observed 
functional predictors; can be a vector of length equal to the number 
of functional predictors, in which case each element will correspond 
to the dimension of principal components basis for the corresponding 
observed functional predictors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kb</code></td>
<td>
<p>dimension of the B-spline basis for the coefficient function 
(note: this is a change from versions 0.1-7 and previous)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>
<p>passed to refund::fpca.sc (note: using fpca.sc is a change 
from versions 0.1-7 and previous)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>generalized linear model family</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>method for estimating the smoothing parameters; defaults 
to REML</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.option</code></td>
<td>
<p>method to do FPC decomposition on the predictors. 
Two options available â€“ "fpca.sc" or "fpca.face". If using "fpca.sc", 
a number less than 35 for <code>nbasis</code> should be used while if using 
"fpca.face",35 or more is recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pve</code></td>
<td>
<p>proportion of variance explained used to choose the number of 
principal components to be included in the expansion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>gam</code> to 
fit the regression model.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fit </code></td>
<td>
<p>result of the call to <code>gam</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.vals </code></td>
<td>
<p>predicted outcomes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.vals.level.0 </code></td>
<td>
<p>predicted outcomes at population level</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.vals.level.1 </code></td>
<td>
<p>predicted outcomes at subject-specific level (if applicable)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betaHat </code></td>
<td>
<p>list of estimated coefficient functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.covariates </code></td>
<td>
<p>parameter estimates for scalar covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varBetaHat </code></td>
<td>
<p>list containing covariance matrices for the estimated coefficient functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bounds </code></td>
<td>
<p>list of bounds of a pointwise 95% confidence interval for the estimated coefficient functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X </code></td>
<td>
<p>design matrix used in the model fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D </code></td>
<td>
<p>penalty matrix used in the model fit</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi </code></td>
<td>
<p>list of B-spline bases for the coefficient functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psi </code></td>
<td>
<p>list of principal components basis for the functional predictors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C </code></td>
<td>
<p>stacked row-specific principal component scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J </code></td>
<td>
<p>transpose of psi matrix multiplied by phi</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CJ </code></td>
<td>
<p>C matrix multiplied J</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z1 </code></td>
<td>
<p>design matrix of random intercepts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subj </code></td>
<td>
<p>subject identifiers as specified by user</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed.mat </code></td>
<td>
<p>the fixed effects design matrix of the pfr as a mixed model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand.mat </code></td>
<td>
<p>the fixed effects design matrix of the pfr as a mixed model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_subj </code></td>
<td>
<p>the number of unique subjects, if subj is specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p </code></td>
<td>
<p>number of scalar covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N.pred </code></td>
<td>
<p>number of functional covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kz </code></td>
<td>
<p>as specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kz.adj</code></td>
<td>
<p>For smooth.option="fpca.sc", will be same as kz (or a vector of repeated values of the specified scalar kz).  For smooth.option="fpca.face", will be the corresponding number of principal components for each functional predictor as determined by fpca.face; will be less than or equal to kz on an elemental-wise level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kb </code></td>
<td>
<p>as specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis </code></td>
<td>
<p>as specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totD </code></td>
<td>
<p>number of penalty matrices created for mgcv::gam</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funcs </code></td>
<td>
<p>as specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates </code></td>
<td>
<p>as specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth.option</code></td>
<td>
<p>as specified</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>Binomial responses should be specified as a numeric vector rather than as a
matrix or a factor.
</p>


<h3>Author(s)</h3>

<p>Bruce Swihart <a href="mailto:bruce.swihart@gmail.com">bruce.swihart@gmail.com</a> and 
Jeff Goldsmith <a href="mailto:jeff.goldsmith@columbia.edu">jeff.goldsmith@columbia.edu</a>
</p>


<h3>References</h3>

<p>Goldsmith, J., Bobb, J., Crainiceanu, C., Caffo, B., and Reich, D. (2011).
Penalized functional regression. <em>Journal of Computational and Graphical
Statistics</em>, 20(4), 830-851.
</p>
<p>Goldsmith, J., Crainiceanu, C., Caffo, B., and Reich, D. (2012). Longitudinal
penalized functional regression for cognitive outcomes on neuronal tract
measurements. <em>Journal of the Royal Statistical Society: Series C</em>,
61(3), 453-469.
</p>
<p>Swihart, Bruce J., Goldsmith, Jeff; and Crainiceanu, Ciprian M. (July 2012). 
Testing for functional effects. Johns Hopkins University Dept. of Biostatistics 
Working Paper 247, available at <a href="https://biostats.bepress.com/jhubiostat/paper247/">https://biostats.bepress.com/jhubiostat/paper247/</a>
American Statistical Association, 109(508): 1425-1439.
</p>


<h3>See Also</h3>

<p><code>rlrt.pfr</code>, <code>predict.pfr</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
##################################################################
#########               DTI Data Example                 #########
##################################################################

##################################################################
# For more about this example, see Swihart et al. 2013
##################################################################

## load and reassign the data;
data(DTI2)
Y  &lt;- DTI2$pasat ## PASAT outcome
id &lt;- DTI2$id    ## subject id
W1 &lt;- DTI2$cca   ## Corpus Callosum
W2 &lt;- DTI2$rcst  ## Right corticospinal
V  &lt;- DTI2$visit ## visit

## prep scalar covariate
visit.1.rest &lt;- matrix(as.numeric(V &gt; 1), ncol=1)
covar.in &lt;- visit.1.rest 


## note there is missingness in the functional predictors
apply(is.na(W1), 2, mean)
apply(is.na(W2), 2, mean)

## fit two univariate models
pfr.obj.t1 &lt;- pfr(Y = Y, covariates=covar.in, funcs = list(W1),     subj = id, kz = 10, kb = 50)
pfr.obj.t2 &lt;- pfr(Y = Y, covariates=covar.in, funcs = list(W2),     subj = id, kz = 10, kb = 50)

### one model with two functional predictors using "smooth.face"
###  for smoothing predictors
pfr.obj.t3 &lt;- pfr(Y = Y, covariates=covar.in, funcs = list(W1, W2), 
                  subj = id, kz = 10, kb = 50, nbasis=35,smooth.option="fpca.face")

## plot the coefficient function and bounds
dev.new()
par(mfrow=c(2,2))
ran &lt;- c(-2,.5)
matplot(cbind(pfr.obj.t1$BetaHat[[1]], pfr.obj.t1$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "CCA", xlab="Location", ylim=ran)
abline(h=0, col="blue")
matplot(cbind(pfr.obj.t2$BetaHat[[1]], pfr.obj.t2$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "RCST", xlab="Location", ylim=ran)
abline(h=0, col="blue")
matplot(cbind(pfr.obj.t3$BetaHat[[1]], pfr.obj.t3$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "CCA  - mult.", xlab="Location", ylim=ran)
abline(h=0, col="blue")
matplot(cbind(pfr.obj.t3$BetaHat[[2]], pfr.obj.t3$Bounds[[2]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "RCST - mult.", xlab="Location", ylim=ran)
abline(h=0, col="blue")


##################################################################
# use baseline data to regress continuous outcomes on functional 
# predictors (continuous outcomes only recorded for case == 1)
##################################################################

data(DTI)

# subset data as needed for this example
cca = DTI$cca[which(DTI$visit ==1 &amp; DTI$case == 1),]
rcst = DTI$rcst[which(DTI$visit ==1 &amp; DTI$case == 1),]
DTI = DTI[which(DTI$visit ==1 &amp; DTI$case == 1),]
# note there is missingness in the functional predictors
apply(is.na(cca), 2, mean)
apply(is.na(rcst), 2, mean)

# fit two models with single functional predictors and plot the results
fit.cca = pfr(Y=DTI$pasat, funcs = cca, kz=10, kb=50, nbasis=20)
fit.rcst = pfr(Y=DTI$pasat, funcs = rcst, kz=10, kb=50, nbasis=20)

par(mfrow = c(1,2))
matplot(cbind(fit.cca$BetaHat[[1]], fit.cca$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "CCA")
matplot(cbind(fit.rcst$BetaHat[[1]], fit.rcst$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "RCST")

# fit a model with two functional predictors and plot the results
fit.cca.rcst = pfr(Y=DTI$pasat, funcs = list(cca, rcst), kz=10, kb=30, nbasis=20)

par(mfrow = c(1,2))
matplot(cbind(fit.cca.rcst$BetaHat[[1]], fit.cca.rcst$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "CCA")
matplot(cbind(fit.cca.rcst$BetaHat[[2]], fit.cca.rcst$Bounds[[2]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "RCST")

##################################################################
# use baseline data to regress binary case-status outcomes on 
# functional predictors
##################################################################

data(DTI)

# subset data as needed for this example
cca = DTI$cca[which(DTI$visit == 1),]
rcst = DTI$rcst[which(DTI$visit == 1),]
DTI = DTI[which(DTI$visit == 1),]

# fit two models with single functional predictors and plot the results
fit.cca = pfr(Y=DTI$case, funcs = cca, family = "binomial")
fit.rcst = pfr(Y=DTI$case, funcs = rcst, family = "binomial")

par(mfrow = c(1,2))
matplot(cbind(fit.cca$BetaHat[[1]], fit.cca$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "CCA")
matplot(cbind(fit.rcst$BetaHat[[1]], fit.rcst$Bounds[[1]]),
        type = 'l', lty = c(1,2,2), col = c(1,2,2), ylab = "BetaHat", 
        main = "RCST")

##################################################################
#########              Octane Data Example               #########
##################################################################

data(gasoline)
Y = gasoline$octane
funcs = gasoline$NIR
wavelengths = as.matrix(2*450:850)

# fit the model using pfr and the smoothing option "fpca.face"
fit = pfr(Y=Y, funcs=funcs, kz=15, kb=50,nbasis=35,smooth.option="fpca.face")

matplot(wavelengths, cbind(fit$BetaHat[[1]], fit$Bounds[[1]]), 
        type='l', lwd=c(2,1,1), lty=c(1,2,2), xlab = "Wavelengths", 
        ylab = "Coefficient Function", col=1)

## End(Not run)
</code></pre>


</div>