<div class="container">

<table style="width: 100%;"><tr>
<td>ssa-object</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Properties of SSA object</h2>

<h3>Description</h3>

<p>Functions to access various fields of SSA object, query
for number of singular values, eigenvectors, factor vectors and ‘special’ decomposition
triples (now, ProjectionSSA triples) in the SSA object and other miscellaneous info.
See Chapter 1 in Golyandina et al (2018) for explanation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nsigma(x)
nu(x)
nv(x)
## S3 method for class 'ssa'
nspecial(x)
## S3 method for class 'ssa'
summary(object, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'ssa'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>SSA object to query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object for which a summary is desired</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>integer, used for number formatting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments affecting the summary produced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>field of SSA object to extract. See 'Details' for list of
the fields</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The internals of SSA object is inheritely opaque, because depending on
the selected SVD method and other conditions it might contains
different fields.
</p>
<p>However, it is possible to extract some fields out of it using the
operator <code>$</code>, in particular, the following values of argument
<code>name</code> are supported:
</p>

<dl>
<dt>sigma</dt>
<dd>
<p>Vector of singular values</p>
</dd>
<dt>U</dt>
<dd>
<p>The matrix of eigenvectors</p>
</dd>
<dt>V</dt>
<dd>
<p>The matrix of factor vectors. Might not exist depending on the selected SVD method</p>
</dd>
</dl>
<p>If SSA with projections is being performed, then the eigentriples are ordered as follows:
at first, row projection triples, then column projection triples and then
SVD-triples. Non-SVD triples (like projection triples) are called ‘special triples’.
The number of special triples can be obtained by calling <code>nspecial</code> method.
Also, one can use the following fields of the SSA object:
</p>

<dl>
<dt>nPR</dt>
<dd>
<p>the number of row projection triples, may be NULL</p>
</dd>
<dt>nPL</dt>
<dd>
<p>the number of column projection triples, may be NULL</p>
</dd>
</dl>
<h3>Value</h3>

<p>an 'integer' of length 1 for <code>nu</code>, <code>nv</code>, <code>nsigma</code>,
<code>nspecial</code> routines, matrix or vector for <code>$</code> operator.
</p>


<h3>About decompositions</h3>

<p>The result of Decomposition step of SSA and its modifications can be written down in the following form:
</p>
<p style="text-align: center;"><code class="reqn">%
    {(*)} \quad \mathbf{X} = \sum_i \mathbf{X}_i, \qquad \mathbf{X}_i = \sigma_i U_i V_i^\mathrm{T},</code>
</p>

<p>where <code class="reqn">\mathbf{X}</code> is the trajectory matrix,
<code class="reqn">U_i \in R^L</code>, <code class="reqn">V_i \in R^K</code>, <code class="reqn">\sigma_i</code> are non-negative numbers.
Also, we assume that <code class="reqn">\|U_i\| = 1</code>, <code class="reqn">\|V_i\| = 1</code>.
</p>
<p>The Singular Value Decomposition is a particular case of <code class="reqn">(*)</code> and corresponds to orthonormal systems of
<code class="reqn">\{U_i\}</code> and <code class="reqn">\{V_i\}</code>.
We call <code class="reqn">(\sigma_i, U_i, V_i)</code> eigentriple, <code class="reqn">\sigma_i</code>
are singular values, <code class="reqn">U_i</code> are left singular values or eigenvectors,
<code class="reqn">V_i</code> are right singular vectors or factor vectors, by analogy with the SVD.
</p>
<p>For the most of SSA decompositions, <code class="reqn">U_i</code> belongs to the column space of <code class="reqn">\mathbf{X}</code>,
while <code class="reqn">V_i</code> belongs to the row space of <code class="reqn">\mathbf{X}</code>.
Therefore, let us consider such decompositions called <em>consistent.</em>
</p>
<p>Note that <code class="reqn">(*)</code> is a decomposition of <code class="reqn">\mathbf{X}</code> into a sum of rank-one matrices.
If the systems <code class="reqn">\{U_i\}</code> and <code class="reqn">\{V_i\}</code> are linearly-independent,
then the decomposition <code class="reqn">(*)</code> is minimal (has minimal possible number of addends).
</p>
<p>If at least one of the systems is not linear independent,
the decomposition <code class="reqn">(*)</code> is not minimal.
If both <code class="reqn">\{U_i\}</code> and <code class="reqn">\{V_i\}</code> are orthonormal,
then the decomposition <code class="reqn">(*)</code> is called bi-orthogonal.
If <code class="reqn">\{U_i\}</code> is orthonormal, the decomposition is called left-orthogonal;
If <code class="reqn">\{V_i\}</code> is orthonormal, the decomposition is called right-orthogonal.
</p>
<p>Let <code class="reqn">r</code> be rank of <code class="reqn">\mathbf{X}</code>. Minimal decomposition has exactly <code class="reqn">r</code> addends.
Introduce the Frobenius-inner product as
<code class="reqn">\langle \mathbf{Z}, \mathbf{Y} \rangle _\mathrm{F} = \sum_{i, j} z_{i, j} \cdot y_{i, j}</code>.
Thus, we can say about F-orthogonality and F-orthogonal decompositions if <code class="reqn">\mathbf{X}_i</code>
are F-orthogonal. For F-orthogonality, left or right orthogonality is sufficient.
</p>
<p>Generally, <code class="reqn">\|\mathbf{X}\|^2</code> can be not equal to <code class="reqn">\sum_i \|\mathbf{X}_i\|^2</code>.
For F-orthogonal decompositions, <code class="reqn">\|\mathbf{X}\|^2 = \sum_i \|\mathbf{X}_i\|^2</code>.
</p>
<p>The contribution of k-th matrix component is defined as
<code class="reqn">{\|\mathbf{X}_k\|^2} / {\|\mathbf{X}\|^2} = {\sigma_k^2} / (\sum_i \sigma_i^2)</code>.
</p>
<p>For F-orthogonal decompositions, the sum of component contributions is equal to 1.
Otherwise, this sum can considerably differ from 1
(e.g., the sum of component contributions can be 90% or 146%).
</p>
<p><strong>Remark.</strong> If the system <code class="reqn">\{U_i\}</code> (or <code class="reqn">\{V_i\}</code>) has vectors
that do not belong to the column (or row) spaces, then the decomposition can be not minimal even
if <code class="reqn">\{U_i\}</code> (or <code class="reqn">\{V_i\}</code>) are linearly independent,
since these projections on the column (or row) space can be dependent.
</p>


<h3>Decompositions for different SSA modifications</h3>


<dl>
<dt>Basic SSA</dt>
<dd>
<p>the SVD, consistent, minimal, bi-orthogonal and
therefore F-orthogonal decomposition. Implemented in
<code>ssa</code> with <code>kind='1d-ssa'</code></p>
</dd>
<dt>FOSSA</dt>
<dd>
<p>consistent, minimal F-orthogonal
decomposition. Implemented in <code>fossa</code></p>
</dd>
<dt>IOSSA</dt>
<dd>
<p>consistent, minimal oblique decomposition. Implemented
in <code>iossa</code></p>
</dd>
<dt>SSA with projections</dt>
<dd>
<p>non-consistent if at least one basis
vector used for the projection does not belong to the column (row)
trajectory space, F-orthogonal decomposition. The components,
which are obtained by projections, are located at the beginning of
the decomposition and have numbers <code class="reqn">1, \dots,
        n_\mathrm{special}</code>. Implemented in <code>ssa</code> with
<code>kind='1d-ssa'</code> and non-<code>NULL</code> <code>row.projector</code> or
<code>column.projector</code> arguments</p>
</dd>
<dt>Toeplitz SSA</dt>
<dd>
<p>generally, non-consistent, non-minimal
F-orthogonal decomposition. Implemented in
<code>ssa</code> with <code>kind='toeplitz-ssa'</code></p>
</dd>
</dl>
<h3>Note</h3>

<p>For <code>nsigma</code>, <code>nu</code>, <code>nv</code>, <code>$</code>  routines, the
values returned solely depend on used singular value decomposition
method and parameters of this method (e.g. 'neig' argument for
'propack' and 'nutrlan' SVD methods).
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><code>Rssa</code> for an overview of the package, as well as,
<code>ssa</code>,
<code>calc.v</code>,
<code>iossa</code>,
<code>fossa</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Decompose 'co2' series with default parameters
s &lt;- ssa(co2, neig = 20)
# Show the number of eigentriples saved in the 's'
print(nsigma(s))
# Show the summary 
summary(s)
# Show the set of singular values
print(s$sigma)
# Show the first eigenvector
print(s$U[, 1])

# Decompose `co2' series with polynomial projections
s &lt;- ssa(co2, row.projector = 1, column.projector = 2)
print(nspecial(s))
print(c(s$nPL, s$nPR))
# Reconstruct a polynomial trend
plot(reconstruct(s, groups = list(trend = seq_len(nspecial(s)))))
</code></pre>


</div>