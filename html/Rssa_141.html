<div class="container">

<table style="width: 100%;"><tr>
<td>vforecast</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform vector SSA forecasting of the series</h2>

<h3>Description</h3>

<p>Perform vector SSA forecasting of the series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class '1d.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'toeplitz.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'toeplitz.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'mssa'
vforecast(x, groups, len = 1,
          direction = c("row", "column"),
          only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'cssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
## S3 method for class 'pssa.1d.ssa'
vforecast(x, groups, len = 1, only.new = TRUE, ...,
          drop = TRUE, drop.attributes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>SSA object holding the decomposition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p>integer, the desired length of the forecasted series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>direction of forecast in multichannel SSA case, "column"
stands for so-called L-forecast and "row" stands for K-forecast</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.new</code></td>
<td>
<p>logical, if 'TRUE' then only forecasted values are returned,
whole series otherwise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>decompose</code>
routines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The routines applies the vector SSA forecasting algorithm to
produce the new series which is expected to 'continue' the current
series on the basis of a given decomposition. Vector forecast
differs from recurrent forecast in such a way that it continues the set
of vectors in the subspace spanning the chosen eigenvectors (the same
formula as described in <code>lrr</code> is used for constructing of
the last components of the new vectors) and then derives the series out
of this extended set of vectors.
</p>
<p>For multichannel SSA, forecast can be constructed in two versions, 
row and column ones; it uses the formulae from Golyandina et al (2015).
</p>
<p>For details of 1D-SSA recurrent forecasting, see Section 3.2.1.3 and 
Algorithm 3.6 in Golyandina et al (2018).
For details of MSSA recurrent forecasting, see Section 4.3.1.3  and 
Algorithm 4.5 (column forecasting).
</p>


<h3>Value</h3>

<p>List of forecasted objects. Elements of the list have the same names
as elements of <code>groups</code>. If group is unnamed, corresponding
component gets name ‘Fn’, where ‘n’ is its index in <code>groups</code>
list.
</p>
<p>Or, the forecasted object itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Golyandina, N., Nekrutkin, V. and Zhigljavsky, A. (2001): <em>Analysis of
Time Series Structure: SSA and related techniques.</em> Chapman and
Hall/CRC. ISBN 1584881941
</p>
<p>Golyandina, N. and Stepanov, D. (2005): <em>SSA-based approaches to
analysis and forecast of multidimensional time series</em>. In
Proceedings of the 5th St.Petersburg Workshop on Simulation, June
26-July 2, 2005, St. Petersburg State University, St. Petersburg,
293–298. <a href="https://www.gistatgroup.com/gus/mssa2.pdf">https://www.gistatgroup.com/gus/mssa2.pdf</a>
</p>
<p>Golyandina, N., Korobeynikov, A., Shlemov, A. and Usevich, K. (2015):
<em>Multivariate and 2D Extensions of Singular Spectrum Analysis
with the Rssa Package</em>. Journal of Statistical Software, Vol. 67, Issue 2.
<a href="https://doi.org/10.18637/jss.v067.i02">doi:10.18637/jss.v067.i02</a>
</p>


<h3>See Also</h3>

<p><code>Rssa</code> for an overview of the package, as well as,
<code>rforecast</code>,
<code>bforecast</code>,
<code>forecast</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Decompose 'co2' series with default parameters
s &lt;- ssa(co2)
# Produce 24 forecasted values of the series using different sets of eigentriples
# as a base space for the forecast.
vfor &lt;- vforecast(s, groups = list(c(1,4), 1:4), len = 24, only.new=FALSE)
matplot(data.frame(c(co2, rep(NA, 24)), vfor), type="l")

# Forecast `co2' trend by SSA with projections
s &lt;- ssa(co2, column.projector = 2, row.projector = 2)
len &lt;- 100
vfor &lt;- vforecast(s, groups = list(trend = seq_len(nspecial(s))), len = len, only.new = FALSE)
matplot(data.frame(c(co2, rep(NA, len)), vfor), type = "l")

# Forecast finite rank series with polynomial component by SSA with projections
v &lt;- 5000 * sin(2*pi / 13 * (1:100)) +  (1:100)^2 + 10000
s &lt;- ssa(v, row.projector = 2, column.projector = 2)
plot(vforecast(s, groups = list(all = 1:6), len = 100, only.new = FALSE), type = "l")
</code></pre>


</div>