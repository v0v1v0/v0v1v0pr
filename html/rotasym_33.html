<div class="container">

<table style="width: 100%;"><tr>
<td>test_rotasym</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Tests of rotational symmetry for hyperspherical data</h2>

<h3>Description</h3>

<p>Tests for assessing the rotational symmetry of a unit-norm
random vector <code class="reqn">\mathbf{X}</code> in
<code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code>, <code class="reqn">p \ge 2</code>, about a location
<code class="reqn">\boldsymbol{\theta}\in S^{p-1}</code>, from a
hyperspherical sample <code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n\in S^{p-1}</code>.
</p>
<p>The vector <code class="reqn">\mathbf{X}</code> is said to be rotational symmetric about
<code class="reqn">\boldsymbol{\theta}</code> if the distributions of
<code class="reqn">\mathbf{OX}</code> and <code class="reqn">\mathbf{X}</code> coincide, where
<code class="reqn">\mathbf{O}</code> is any <code class="reqn">p\times p</code> rotation matrix
that fixes <code class="reqn">\boldsymbol{\theta}</code>, <em>i.e.</em>,
<code class="reqn">\mathbf{O}\boldsymbol{\theta}=\boldsymbol{\theta}</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">test_rotasym(data, theta = spherical_mean, type = c("sc", "loc", "loc_vMF",
  "hyb", "hyb_vMF")[5], Fisher = FALSE, U = NULL, V = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>hyperspherical data, a matrix of size <code>c(n, p)</code> with unit
norm rows. Normalized internally if any row does not have unit norm
(with a <code>warning</code> message). <code>NA</code>s are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>either a unit norm vector of size <code>p</code> giving the axis of
rotational symmetry (for the specified-<code class="reqn">\boldsymbol{\theta}</code>
case) or a function that implements an estimator
<code class="reqn">\hat{\boldsymbol{\theta}}</code> of
<code class="reqn">\boldsymbol{\theta}</code> (for the
unspecified-<code class="reqn">\boldsymbol{\theta}</code> case). The default calls
the <code>spherical_mean</code> function. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character string (case insensitive) indicating the type of
test to conduct:
</p>

<ul>
<li> <p><code>"sc"</code>: "scatter" test based on the statistic
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code>. Evaluates if the
covariance matrix of the multivariate signs is isotropic.
</p>
</li>
<li> <p><code>"loc"</code>: "location" test based on the statistic
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code>. Evaluates if
the expectation of the multivariate signs is zero.
</p>
</li>
<li> <p><code>"loc_vMF"</code>: adapted "location" test, based on the statistic
<code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{loc}}</code>.
</p>
</li>
<li> <p><code>"hyb"</code>: "hybrid" test based on the statistics
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code> and
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code>.
</p>
</li>
<li> <p><code>"hyb_vMF"</code> (default): adapted "hybrid" test based on the
statistics <code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code> and
<code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{loc}}</code>.
</p>
</li>
</ul>
<p>See the details below for further explanations of the tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Fisher</code></td>
<td>
<p>if <code>TRUE</code>, then Fisher's method is employed to aggregate
the scatter and location tests in the hybrid test, see details below.
Otherwise, the hybrid statistic is the sum of the scatter and location
statistics. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p><em>multivariate signs</em> of <code>data</code>, a matrix of size
<code>c(n, p - 1)</code>. Computed if <code>NULL</code> (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p><em>cosines</em> of <code>data</code>, a vector of size <code>n</code>. Computed
if <code>NULL</code> (the default).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Descriptions of the tests:
</p>

<ul>
<li>
<p> The "scatter" test is locally and asymptotically optimal against
tangent elliptical alternatives to rotational
symmetry. However, it is not consistent against
tangent von Mises–Fisher (vMF) alternatives.
The asymptotic null distribution of
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code>
is unaffected if <code class="reqn">\boldsymbol{\theta}</code> is estimated, that is,
the asymptotic null distributions of
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{sc}}</code> and
<code class="reqn">Q_{\hat{\boldsymbol{\theta}}}^{\mathrm{sc}}</code> are
the same.
</p>
</li>
<li>
<p> The "location" test is locally and asymptotically most powerful
against vMF alternatives to rotational symmetry. However, it is not
consistent against tangent elliptical alternatives. The asymptotic
null distribution of
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code>
for known <code class="reqn">\boldsymbol{\theta}</code> (the one implemented in
<code>test_rotasym</code>) <em>does change</em> if <code class="reqn">\boldsymbol{\theta}</code>
is estimated by <code class="reqn">\hat{\boldsymbol{\theta}}</code>. Therefore, if
the test is performed with an estimated <code class="reqn">\boldsymbol{\theta}</code>
(if <code>theta</code> is a function)
<code class="reqn">Q_{\hat{\boldsymbol{\theta}}}^{\mathrm{loc}}</code>
will not be properly calibrated. <code>test_rotasym</code> will give a warning in
such case.
</p>
</li>
<li>
<p> The "vMF location" test is a modification of the "location" test
designed to make its null asymptotic distribution invariant from the
estimation of <code class="reqn">\boldsymbol{\theta}</code> (as the "scatter" test is).
The test is optimal against tangent vMF alternatives with a <em>specific</em>,
vMF-based, angular function <code>g_vMF</code>. Despite not
being optimal against all tangent vMF alternatives, it is
consistent for all of them. As the location test,
it is not consistent against tangent elliptical alternatives.
</p>
</li>
<li>
<p> The "hybrid" test combines (see below how) the "scatter" and
"location" tests. The test is neither optimal against tangent elliptical nor
tangent vMF alternatives, but it is consistent against both. Since it is
based on the "location" test, if computed with an estimator
<code class="reqn">\hat{\boldsymbol{\theta}}</code>, the test statistic will not
be properly calibrated. <code>test_rotasym</code> will give a warning in such case.
</p>
</li>
<li>
<p> The "vMF hybrid" test is the analogous of the "hybrid" test but
replaces the "location" test by the "vMF location" test.
</p>
</li>
</ul>
<p>The combination of the scatter and location tests in the hybrid tests is
done in two different ways:
</p>

<ul>
<li>
<p> If <code>Fisher = FALSE</code>, then the scatter and location tests
statistics give the hybrid test statistic
</p>
<p style="text-align: center;"><code class="reqn">Q^{\mathrm{hyb}}:=Q_{\boldsymbol{\theta}}^{\mathrm{sc}}+
Q_{\boldsymbol{\theta}}^{\mathrm{loc}}.</code>
</p>

</li>
<li>
<p> If <code>Fisher = TRUE</code>, then Fisher's method for aggregating
independent tests (the two test statistics are independent under rotational
symmetry) is considered, resulting the hybrid test statistic:
</p>
<p style="text-align: center;"><code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{hyb}}
:=-2(\log(p_{\mathrm{sc}})+\log(p_{\mathrm{loc}}))</code>
</p>

<p>where <code class="reqn">p_{\mathrm{sc}}</code> and <code class="reqn">p_{\mathrm{loc}}</code> are
the <code class="reqn">p</code>-values of the scatter and location tests, respectively.
</p>
</li>
</ul>
<p>The hybrid test statistic <code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{hyb}}</code> follows analogously to
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{hyb}}</code> by replacing
<code class="reqn">Q_{\boldsymbol{\theta}}^{\mathrm{loc}}</code> with
<code class="reqn">Q_{\mathrm{vMF}}^{\mathrm{loc}}</code>.
</p>
<p>Finally, recall that the tests are designed to test <em>implications</em> of
rotational symmetry. Therefore, the tests are not consistent against
<em>all</em> types of alternatives to rotational symmetry.
</p>


<h3>Value</h3>

<p>An object of the <code>htest</code> class with the following elements:
</p>

<ul>
<li> <p><code>statistic</code>: test statistic.
</p>
</li>
<li> <p><code>parameter</code>: degrees of freedom of the chi-square distribution
appearing in all the null asymptotic distributions.
</p>
</li>
<li> <p><code>p.value</code>: <code class="reqn">p</code>-value of the test.
</p>
</li>
<li> <p><code>method</code>: information on the type of test performed.
</p>
</li>
<li> <p><code>data.name</code>: name of the value of <code>data</code>.
</p>
</li>
<li> <p><code>U</code>: multivariate signs of <code>data</code>.
</p>
</li>
<li> <p><code>V</code>: cosines of <code>data</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873–1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>See Also</h3>

<p><code>tangent-elliptical</code>, <code>tangent-vMF</code>,
<code>spherical_mean</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Rotational symmetry holds

# Sample data from a vMF (rotational symmetric distribution about mu)
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
set.seed(123456789)
data_0 &lt;- r_vMF(n = n, mu = theta, kappa = 1)

# theta known
test_rotasym(data = data_0, theta = theta, type = "sc")
test_rotasym(data = data_0, theta = theta, type = "loc")
test_rotasym(data = data_0, theta = theta, type = "loc_vMF")
test_rotasym(data = data_0, theta = theta, type = "hyb")
test_rotasym(data = data_0, theta = theta, type = "hyb", Fisher = TRUE)
test_rotasym(data = data_0, theta = theta, type = "hyb_vMF")
test_rotasym(data = data_0, theta = theta, type = "hyb_vMF", Fisher = TRUE)

# theta unknown (employs the spherical mean as estimator)
test_rotasym(data = data_0, type = "sc")
test_rotasym(data = data_0, type = "loc") # Warning
test_rotasym(data = data_0, type = "loc_vMF")
test_rotasym(data = data_0, type = "hyb") # Warning
test_rotasym(data = data_0, type = "hyb", Fisher = TRUE) # Warning
test_rotasym(data = data_0, type = "hyb_vMF")
test_rotasym(data = data_0, type = "hyb_vMF", Fisher = TRUE)

## Rotational symmetry does not hold

# Sample non-rotational symmetric data from a tangent-vMF distribution
# The scatter test is blind to these deviations, while the location tests
# are optimal
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
mu &lt;- c(rep(0, p - 2), 1)
kappa &lt;- 2
set.seed(123456789)
r_V &lt;- function(n) {
  r_g_vMF(n = n, p = p, kappa = 1)
}
data_1 &lt;- r_TM(n = n, r_V = r_V, theta = theta, mu = mu, kappa = kappa)

# theta known
test_rotasym(data = data_1, theta = theta, type = "sc")
test_rotasym(data = data_1, theta = theta, type = "loc")
test_rotasym(data = data_1, theta = theta, type = "loc_vMF")
test_rotasym(data = data_1, theta = theta, type = "hyb")
test_rotasym(data = data_1, theta = theta, type = "hyb", Fisher = TRUE)
test_rotasym(data = data_1, theta = theta, type = "hyb_vMF")
test_rotasym(data = data_1, theta = theta, type = "hyb_vMF", Fisher = TRUE)

# theta unknown (employs the spherical mean as estimator)
test_rotasym(data = data_1, type = "sc")
test_rotasym(data = data_1, type = "loc") # Warning
test_rotasym(data = data_1, type = "loc_vMF")
test_rotasym(data = data_1, type = "hyb") # Warning
test_rotasym(data = data_1, type = "hyb", Fisher = TRUE) # Warning
test_rotasym(data = data_1, type = "hyb_vMF")
test_rotasym(data = data_1, type = "hyb_vMF", Fisher = TRUE)

# Sample non-rotational symmetric data from a tangent-elliptical distribution
# The location tests are blind to these deviations, while the
# scatter test is optimal
n &lt;- 200
p &lt;- 10
theta &lt;- c(1, rep(0, p - 1))
Lambda &lt;- matrix(0.5, nrow = p - 1, ncol = p - 1)
diag(Lambda) &lt;- 1
set.seed(123456789)
r_V &lt;- function(n) {
  r_g_vMF(n = n, p = p, kappa = 1)
}
data_2 &lt;- r_TE(n = n, r_V = r_V, theta = theta, Lambda = Lambda)

# theta known
test_rotasym(data = data_2, theta = theta, type = "sc")
test_rotasym(data = data_2, theta = theta, type = "loc")
test_rotasym(data = data_2, theta = theta, type = "loc_vMF")
test_rotasym(data = data_2, theta = theta, type = "hyb")
test_rotasym(data = data_2, theta = theta, type = "hyb", Fisher = TRUE)
test_rotasym(data = data_2, theta = theta, type = "hyb_vMF")
test_rotasym(data = data_2, theta = theta, type = "hyb_vMF", Fisher = TRUE)

# theta unknown (employs the spherical mean as estimator)
test_rotasym(data = data_2, type = "sc")
test_rotasym(data = data_2, type = "loc") # Warning
test_rotasym(data = data_2, type = "loc_vMF")
test_rotasym(data = data_2, type = "hyb") # Warning
test_rotasym(data = data_2, type = "hyb", Fisher = TRUE) # Warning
test_rotasym(data = data_2, type = "hyb_vMF")
test_rotasym(data = data_2, type = "hyb_vMF", Fisher = TRUE)

## Sunspots births data

# Load data
data("sunspots_births")
sunspots_births$X &lt;-
  cbind(cos(sunspots_births$phi) * cos(sunspots_births$theta),
        cos(sunspots_births$phi) * sin(sunspots_births$theta),
        sin(sunspots_births$phi))

# Test rotational symmetry for the 23rd cycle, specified theta
sunspots_23 &lt;- subset(sunspots_births, cycle == 23)
test_rotasym(data = sunspots_23$X, type = "sc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_23$X, type = "loc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_23$X, type = "hyb", theta = c(0, 0, 1))

# Test rotational symmetry for the 23rd cycle, unspecified theta
spherical_loc_PCA(sunspots_23$X)
test_rotasym(data = sunspots_23$X, type = "sc", theta = spherical_loc_PCA)
test_rotasym(data = sunspots_23$X, type = "loc_vMF",
             theta = spherical_loc_PCA)
test_rotasym(data = sunspots_23$X, type = "hyb_vMF",
             theta = spherical_loc_PCA)

# Test rotational symmetry for the 22nd cycle, specified theta
sunspots_22 &lt;- subset(sunspots_births, cycle == 22)
test_rotasym(data = sunspots_22$X, type = "sc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_22$X, type = "loc", theta = c(0, 0, 1))
test_rotasym(data = sunspots_22$X, type = "hyb", theta = c(0, 0, 1))

# Test rotational symmetry for the 22nd cycle, unspecified theta
spherical_loc_PCA(sunspots_22$X)
test_rotasym(data = sunspots_22$X, type = "sc", theta = spherical_loc_PCA)
test_rotasym(data = sunspots_22$X, type = "loc_vMF",
             theta = spherical_loc_PCA)
test_rotasym(data = sunspots_22$X, type = "hyb_vMF",
             theta = spherical_loc_PCA)
</code></pre>


</div>