<div class="container">

<table style="width: 100%;"><tr>
<td>FS.quickreduct.FRST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The fuzzy QuickReduct algorithm based on FRST</h2>

<h3>Description</h3>

<p>It is a function implementing the fuzzy QuickReduct algorithm
for feature selection based on FRST.
The fuzzy QuickReduct is a modification of QuickReduct based on RST (see <code>FS.quickreduct.RST</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">FS.quickreduct.FRST(
  decision.table,
  type.method = "fuzzy.dependency",
  type.QR = "fuzzy.QR",
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decision.table</code></td>
<td>
<p>an object of a <code>"DecisionTable"</code> class representing a decision table. See <code>SF.asDecisionTable</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.method</code></td>
<td>
<p>a string representing the type of methods.
The complete description can be found in Section <code>Details</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.QR</code></td>
<td>
<p>a string expressing the type of QuickReduct algorithm which is one of the two following algorithms:
</p>

<ul>
<li> <p><code>"fuzzy.QR"</code>: it is the original fuzzy rough QuickReduct algorithm based on (Jensen and Shen, 2002).
</p>
</li>
<li> <p><code>"modified.QR"</code>: it is the modified QuickReduct algorithm based on (Bhatt and Gopal, 2005).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of other parameters as follows.
</p>

<ul>
<li> <p><code>type.aggregation</code>: a type of aggregation operator. See <code>BC.IND.relation.FRST</code>.
</p>
</li>
<li> <p><code>t.implicator</code>: a type of implicator function. See <code>BC.LU.approximation.FRST</code>.
The default value is <code>"lukasiewicz"</code>.
</p>
</li>
<li> <p><code>type.relation</code>: a type of indiscernibility relation. See <code>BC.IND.relation.FRST</code>.
The default value is <code>type.relation = c("tolerance", "eq.3")</code>.
</p>
</li>
<li> <p><code>alpha</code>: a real number between 0 and 1 expressing a threshold value or stopping criterion.
The following methods use the parameter: <code>"vqrs"</code>,
</p>
<p><code>"min.positive.reg"</code>, and <code>"fuzzy.discernibility"</code>.
The default value is 0.95.
</p>
</li>
<li> <p><code>alpha.precision</code>: a real number between 0 and 1 expressing variable precision (<code class="reqn">\alpha</code>) for <code>"fvprs"</code>.
See <code>BC.LU.approximation.FRST</code>. The default value is 0.05.
</p>
</li>
<li> <p><code>q.some</code>: a pair of numeric values for the alpha and beta parameter of VQRS for the quantifier <code>some</code>.
The default value is <code>q.some = c(0.1, 0.6)</code>.
</p>
<p>See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>q.most</code>: a pair of numeric values for the alpha and beta parameter of VQRS for the quantifier <code>most</code>.
The default value is <code>q.most = c(0.2, 1)</code>.
</p>
<p>See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>m.owa</code>: a numeric value to define the parameter in OWA. The default value is the mean number of objects.
</p>
</li>
<li> <p><code>type.rfrs</code>: a type of robust fuzzy rough sets.
</p>
<p>The default is <code>type.rfrs = "k.trimmed.min")</code>.
</p>
<p>See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>k.rfrs</code>: a value between 0 and length of data representing index of considered data.
The default is <code>k.rfrs = round(0.5*nrow(decision.table))</code>.
See <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>beta.quasi</code>: a number between 0 and 1 representing <code class="reqn">\beta</code>-precision t-norms and t-conorms.
The default value is 0.05.
</p>
</li>
<li> <p><code>randomize</code>: a boolean value to define whether selecting attributes randomly or not. For more detail,
see in Section <code>Details</code>. The default value is <code>FALSE</code>.
</p>
</li>
</ul>
<p>It should be noted that instead of supplying all the above parameters, we only set
those parameters needed by the considered method. See in Section <code>Details</code>.
Also, we provide some examples to illustrate how the parameters are used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In this function, we provide an algorithm proposed by
(Jensen and Shen, 2002) which is fuzzy QuickReduct. Then, the algorithm has been modified by (Bhatt and Gopal, 2005) to improve stopping criteria.
This function is aimed to implement both algorithms. These algorithms can be executed by assigning the parameter <code>type.QR</code>
with <code>"fuzzy.QR"</code> and <code>"modified.QR"</code> for fuzzy quickreduct and modified fuzzy quickreduct
algorithms, respectively. Additionally, in the <code>control</code> parameter, we provide one component which is
<code>randomize</code> having boolean values: <code>TRUE</code> or <code>FALSE</code>. <code>randomize = TRUE</code> means that
we evaluate some (or not all) attributes randomly along iteration. It will be useful if we have a large number of attributes
in a decision table.
</p>
<p>In this function, we have considered many approaches of the lower and upper approximations.
The following list shows considered methods and their descriptions. Additionally, those approaches can be executed by
assigning the following value to the parameter <code>type.method</code>.
</p>

<ul>
<li> <p><code>"fuzzy.dependency"</code>: It is based on the degree of dependency using the implication/t-norm model approximation (Jensen and Shen, 2009).
The detailed concepts about this approximation have been explained in <code>Introduction-FuzzyRoughSets</code>
and
</p>
<p><code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>"fuzzy.boundary.reg"</code>: It is based on the fuzzy boundary region proposed by (Jensen and Shen, 2009).
This algorithm introduced the usage of the total uncertainty degree <code class="reqn">\lambda_B(Q)</code>
for all concepts of feature subset <code class="reqn">B</code> and decision attribute <code class="reqn">Q</code>.
The total uncertainty degree is used as a parameter to select appropriate features.
</p>
</li>
<li> <p><code>"vqrs"</code>: It is based on vaquely quantified rough set (VQRS)
proposed by (Cornelis and Jensen, 2008). See also <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>"owa"</code>: Based on ordered weighted average (OWA) based fuzzy rough set, (Cornelis et al, 2010) proposed
the degree of dependency as a parameter employed in the algorithm to select appropriate features. The explanation
about lower and upper approximations based on OWA can be found in <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>"rfrs"</code>: It is based on degree of dependency that is obtained by performing
the robust fuzzy rough sets proposed by (Hu et al, 2012).
The detailed concepts about this approximation have been explained in <code>BC.LU.approximation.FRST</code>.
</p>
</li>
<li> <p><code>"min.positive.reg"</code>: Based on measure introduced in (Cornelis et al, 2010) which considers the most problematic element in
the positive region, defined using the implicator/t-norm model.
</p>
</li>
<li> <p><code>"fvprs"</code>: It is based on degree of dependency proposed by (Zhao et al, 2009).
The degree is obtained by using fuzzy lower approximation based on
fuzzy variable precision rough set model.
</p>
</li>
<li> <p><code>"fuzzy.discernibility"</code>: This approach attempts to combine the the decision-relative discernibility matrix
and the fuzzy QuickReduct algorithm. (Jensen and Shen, 2009) introduced a measurement which is the degree of satisfaction to select the attributes.
</p>
</li>
<li> <p><code>"beta.pfrs"</code>: Based on <code class="reqn">\beta</code>-precision fuzzy rough sets (<code class="reqn">\beta</code>-PFRS) proposed by (Salido and Murakami, 2003),
the degree of dependency as a parameter employed in the algorithm to select appropriate features. The explanation
about lower and upper approximations based on <code class="reqn">\beta</code>-PFRS can be found in <code>BC.LU.approximation.FRST</code>.
</p>
</li>
</ul>
<p>It should be noted that the parameter <code>type.method</code> is related to parameter <code>control</code>.
In other words, we only set the components in the <code>control</code> parameter that related to the chosen type of method.
The following is a list showing the components of <code>control</code> needed by each type of methods.
</p>

<ul>
<li> <p><code>type.method = "fuzzy.dependency"</code>:
</p>
<p><code>control &lt;- list(t.implicator, type.relation, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "fuzzy.boundary.reg"</code>:
</p>
<p><code>control &lt;- list(t.implicator, type.relation, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "vqrs"</code>:
</p>
<p><code>control &lt;- list(alpha, q.some, q.most, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "owa"</code>:
</p>
<p><code>control &lt;- list(t.implicator, type.relation, m.owa, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "rfrs"</code>:
</p>
<p><code>control &lt;- list(t.implicator, type.relation, type.rfrs,</code>
</p>
<p><code>k.rfrs, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "min.positive.reg"</code>:
</p>
<p><code>control &lt;- list(alpha, t.implicator, type.relation, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "fuzzy.discernibility"</code>:
</p>
<p><code>control &lt;- list(alpha, t.implicator, type.relation, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "fvprs"</code>:
</p>
<p><code>control &lt;- list(alpha.precision, t.implicator, type.relation, type.aggregation)</code>
</p>
</li>
<li> <p><code>type.method = "beta.pfrs"</code>:
</p>
<p><code>control &lt;- list(t.implicator, type.relation, beta.quasi, type.aggregation)</code>
</p>
</li>
</ul>
<p>The descriptions of each component can be seen in the documentation of the <code>control</code> parameter.
</p>
<p>It should be noted that this function does not give the new decision table directly.
An additional function called <code>SF.applyDecTable</code> is used to produce new decision table based on
information about the reduct from this function. See Section <code>Examples</code>.
</p>


<h3>Value</h3>

<p>A class <code>"FeatureSubset"</code> that contains the following components:
</p>

<ul>
<li> <p><code>reduct</code>: a list representing a single reduct. In this case, it could be a superreduct or just a subset of feature.
</p>
</li>
<li> <p><code>type.method</code>: a string representing the type of method.
</p>
</li>
<li> <p><code>type.task</code>: a string showing the type of task which is <code>"feature selection"</code>.
</p>
</li>
<li> <p><code>model</code>: a string representing the type of model. In this case, it is <code>"FRST"</code> which means fuzzy rough set theory.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Lala Septem Riza
</p>


<h3>References</h3>

<p>C. Cornelis, G. Hurtado Martin, R. Jensen, and D. Slezak,
"Feature Selection with Fuzzy Decision Reducts", Information Sciences, vol. 180, no. 2, p. 209 - 224 (2010).
</p>
<p>C. Cornelis and R. Jensen, "A Noise-tolerant Approach to Fuzzy-rough Feature Selection",
Proceedings of the 2008 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2008),
p. 1598 - 1605 (2008).
</p>
<p>Q. Hu, L. Zhang, S. An, D. Zhang, and D. Yu, "On Robust Fuzzy Rough Set Models",
IEEE Trans. on Fuzzy Systems, vol. 20, no. 4, p. 636 - 651 (2012).
</p>


<h3>See Also</h3>

<p><code>FS.quickreduct.RST</code> and <code>FS.feature.subset.computation</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##########################################################
## Example 1: Dataset containing nominal values on all attributes
##########################################################

data(RoughSetData)
decision.table &lt;- RoughSetData$housing7.dt

########## using fuzzy lower approximation ##############
control &lt;- list(t.implicator = "lukasiewicz", type.relation = c("tolerance", "eq.1"),
               type.aggregation = c("t.tnorm", "lukasiewicz"))
reduct.1 &lt;- FS.quickreduct.FRST(decision.table, type.method = "fuzzy.dependency",
                            type.QR = "fuzzy.QR", control = control)

########## using fuzzy boundary region ##############
## Not run: control &lt;- list(t.implicator = "lukasiewicz", type.relation = c("tolerance", "eq.1"),
                type.aggregation = c("t.tnorm", "lukasiewicz"))
reduct.2 &lt;- FS.quickreduct.FRST(decision.table, type.method = "fuzzy.boundary.reg",
                            type.QR = "fuzzy.QR", control = control)

########## using vaguely quantified rough sets (VQRS) #########
control &lt;- list(alpha = 0.9, q.some = c(0.1, 0.6), q.most = c(0.2, 1),
                type.aggregation = c("t.tnorm", "lukasiewicz"))
reduct.3 &lt;- FS.quickreduct.FRST(decision.table, type.method = "vqrs",
                            type.QR = "fuzzy.QR", control = control)

########## ordered weighted average (OWA) #########
control &lt;- list(t.implicator = "lukasiewicz", type.relation = c("tolerance", "eq.1"),
                m.owa = 3, type.aggregation = c("t.tnorm","lukasiewicz"))
reduct.4 &lt;- FS.quickreduct.FRST(decision.table, type.method = "owa",
                            type.QR = "fuzzy.QR", control = control)

########## robust fuzzy rough sets (RFRS) #########
control &lt;- list(t.implicator = "lukasiewicz", type.relation = c("tolerance", "eq.1"),
               type.rfrs = "k.trimmed.min", type.aggregation = c("t.tnorm", "lukasiewicz"),
               k.rfrs = 0)
reduct.5 &lt;- FS.quickreduct.FRST(decision.table, type.method = "rfrs",
                            type.QR = "fuzzy.QR", control = control)

########## using min positive region (delta) ###########
control &lt;- list(alpha = 1, t.implicator = "lukasiewicz",
                type.relation = c("tolerance", "eq.1"), type.aggregation =
                                c("t.tnorm", "lukasiewicz"))
reduct.6 &lt;- FS.quickreduct.FRST(decision.table, type.method = "min.positive.reg",
                            type.QR = "fuzzy.QR", control = control)

########## using FVPRS approximation ##############
control &lt;- list(alpha.precision = 0.05, t.implicator = "lukasiewicz",
               type.aggregation = c("t.tnorm", "lukasiewicz"),
               type.relation = c("tolerance", "eq.1"))
reduct.7 &lt;- FS.quickreduct.FRST(decision.table, type.method = "fvprs",
                            type.QR = "fuzzy.QR", control = control)

########## using beta.PFRS approximation ##############
control &lt;- list(t.implicator = "lukasiewicz", type.relation = c("tolerance", "eq.1"),
                beta.quasi = 0.05, type.aggregation = c("t.tnorm", "lukasiewicz"))
reduct.8 &lt;- FS.quickreduct.FRST(decision.table, type.method = "beta.pfrs",
                            type.QR = "fuzzy.QR", control = control)

########## using fuzzy discernibility matrix ##############
control &lt;- list(alpha = 1, type.relation = c("tolerance", "eq.1"),
               type.aggregation = c("t.tnorm", "lukasiewicz"),
                t.implicator = "lukasiewicz")
reduct.9 &lt;- FS.quickreduct.FRST(decision.table, type.method = "fuzzy.discernibility",
                            type.QR = "fuzzy.QR", control = control)
## End(Not run)

##########################################################
## Example 2: Dataset containing nominal and continuous values
## In this case, we only provide one method but others work in
## the same way.
## In this example, we will show how to get the
## new decision table as well
##########################################################
data(RoughSetData)
decision.table &lt;- RoughSetData$hiring.dt

########## using fuzzy lower approximation ##############
control &lt;- list(type.aggregation = c("t.tnorm", "lukasiewicz"),
               t.implicator = "lukasiewicz", type.relation = c("tolerance", "eq.1"))
reduct.1 &lt;- FS.quickreduct.FRST(decision.table, type.method = "fuzzy.dependency",
                            type.QR = "fuzzy.QR", control = control)

## get new decision table based on reduct
new.decTable &lt;- SF.applyDecTable(decision.table, reduct.1)

</code></pre>


</div>