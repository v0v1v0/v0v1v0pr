<div class="container">

<table style="width: 100%;"><tr>
<td>fit_ertmpt_SBC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation-based calibration for RT-MPT models</h2>

<h3>Description</h3>

<p>Simulate data from RT-MPT models using <code>ertmpt_model</code> objects. The difference to <code>sim_ertmpt_data</code> is that here only scalars are allowed. This makes it usable for
simulation-based calibration (SBC; Talts et al., 2018). You can specify the random seed, number of subjects, number of trials, and some
parameters (same as <code>prior_params</code> from <code>fit_ertmpt</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_ertmpt_SBC(
  model,
  seed,
  n.eff_samples = 99,
  n.chains = 4,
  n.iter = 5000,
  n.burnin = 200,
  n.thin = 1,
  Rhat_max = 1.05,
  Irep = 1000,
  n.subj = 40,
  n.trials = 30,
  prior_params = NULL,
  sim_list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.eff_samples</code></td>
<td>
<p>Number of effective samples. Default is 99, leading to 100 possible ranks (from 0 to 99).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.chains</code></td>
<td>
<p>Number of chains to use. Default is 4. Must be larger than 1 and smaller or equal to 16.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>Number of samples per chain. Default is 5000. Must be larger or equal to <code>n.eff_samples</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.burnin</code></td>
<td>
<p>Number of warm-up samples. Default is 200.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.thin</code></td>
<td>
<p>Thinning factor. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rhat_max</code></td>
<td>
<p>Maximal Potential scale reduction factor: A lower threshold that needs to be reached before the actual sampling starts. Default is 1.05</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Irep</code></td>
<td>
<p>Every <code>Irep</code> samples an interim state with the current maximal potential scale reduction
factor is shown. Default is 1000. The following statements must hold true for <code>Irep</code>:
</p>

<ul>
<li> <p><code>n.burnin</code> is smaller than or equal to <code>Irep</code>,
</p>
</li>
<li> <p><code>Irep</code> is a multiple of <code>n.thin</code> and
</p>
</li>
<li> <p><code>n.iter</code> is a multiple of <code>Irep / n.thin</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.subj</code></td>
<td>
<p>Number of subjects. Default is 40.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.trials</code></td>
<td>
<p>Number of trials per tree. Default is 30.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_params</code></td>
<td>
<p>Named list of parameters from which the data will be generated. This must be the same named list as <code>prior_params</code> from
<code>fit_ertmpt</code> and has the same defaults. It is not recommended to use the defaults since they lead to many probabilities close or
equal to <code>0</code> and/or <code>1</code> and to RTs close or equal to <code>0</code>. Allowed parameters are:
</p>

<ul>
<li> <p><code>mean_of_exp_mu_beta</code>: This is the expected exponential rate (<code>E(exp(beta)) = E(lambda)</code>) and
<code>1/mean_of_exp_mu_beta</code> is the expected process time (<code>1/E(exp(beta)) = E(tau)</code>). The default
mean is set to <code>10</code>, such that the expected process time is <code>0.1</code> seconds.
</p>
</li>
<li> <p><code>var_of_exp_mu_beta</code>: The group-specific variance of the exponential rates. Since
<code>exp(mu_beta)</code> is Gamma distributed, the rate of the distribution is just mean divided by variance and
the shape is the mean times the rate. The default is set to <code>100</code>.
</p>
</li>
<li> <p><code>mean_of_mu_gamma</code>: This is the expected <em>mean parameter</em> of the encoding and response execution times,
which follow a normal distribution truncated from below at zero, so <code>E(mu_gamma) &lt; E(gamma)</code>. The default is <code>0</code>.
</p>
</li>
<li> <p><code>var_of_mu_gamma</code>: The group-specific variance of the <em>mean parameter</em>. Its default is <code>10</code>.
</p>
</li>
<li> <p><code>mean_of_omega_sqr</code>: This is the expected residual variance (<code>E(omega^2)</code>). The default is <code>0.005</code>.
</p>
</li>
<li> <p><code>var_of_omega_sqr</code>: The variance of the residual variance (<code>Var(omega^2)</code>). The default is
<code>0.01</code>. The default of the mean and variance is equivalent to a shape and rate of <code>0.0025</code> and
<code>0.5</code>, respectivly.
</p>
</li>
<li> <p><code>df_of_sigma_sqr</code>: degrees of freedom for the individual variance of the response executions. The
individual variance follows a scaled inverse chi-squared distribution with <code>df_of_sigma_sqr</code> degrees of freedom and
<code>omega^2</code> as scale. <code>2</code> is the default and it should be an integer.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_SIGMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the process
related parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_SIGMA</code> is a scaling factor, that scales this
matrix (<code>S=sf_of_scale_matrix_SIGMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_GAMMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the encoding and
motor execution parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_GAMMA</code> is a scaling factor that scales
this matrix (<code>S=sf_of_scale_matrix_GAMMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>prec_epsilon</code>: This is epsilon in the paper. It is the precision of mu_alpha and all xi (scaling parameter
in the scaled inverse Wishart distribution). Its default is also <code>1</code>.
</p>
</li>
<li> <p><code>add_df_to_invWish</code>: If <code>P</code> is the number of parameters or rather the size of the scale matrix used in the (scaled)
inverse Wishart distribution then <code>add_df_to_invWish</code> is the number of degrees of freedom that can be added to it. So
<code>DF = P + add_df_to_invWish</code>. The default for <code>add_df_to_invWish</code> is <code>1</code>, such that the correlations are uniformly
distributed within <code>[-1, 1]</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim_list</code></td>
<td>
<p>Object of class <code>ertmpt_sim</code>. This is also an output object. Can be used to re-fit the model if <code>n.eff_samples</code> was not achieved in a previous fitting attempt.
It will then use the data stored in this object. Default is NULL and this object will be created anew.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of the class <code>ertmpt_sbc</code> containing
</p>

<ul>
<li> <p><code>ranks</code>: the rank statistic for all parameters,
</p>
</li>
<li> <p><code>sim_list</code>: an object of the class <code>ertmpt_sim</code>,
</p>
</li>
<li> <p><code>fit_list</code>: an object of the class <code>ertmpt_fit</code>,
</p>
</li>
<li> <p><code>specs</code>: some specifications like the model, seed number, etc.,
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>References</h3>

<p>Talts, S., Betancourt, M., Simpson, D., Vehtari, A., &amp; Gelman, A. (2018). Validating Bayesian inference algorithms with simulation-based calibration. <em>arXiv preprint arXiv:1804.06788</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">########################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be different for each response.
########################################################################################

mdl_2HTM &lt;- "
# targets
d+(1-d)*g     ; 0
(1-d)*(1-g)   ; 1

# lures
(1-d)*g       ; 0
d+(1-d)*(1-g) ; 1

# d: detect; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

params &lt;- list(mean_of_exp_mu_beta = 10,
               var_of_exp_mu_beta = 10,
               mean_of_mu_gamma = 0.5,
               var_of_mu_gamma = 0.0025,
               mean_of_omega_sqr = 0.005,
               var_of_omega_sqr = 0.000025,
               df_of_sigma_sqr = 10,
               sf_of_scale_matrix_SIGMA = 0.1,
               sf_of_scale_matrix_GAMMA = 0.01,
               prec_epsilon = 10,
               add_df_to_invWish = 5)

R = 2 # typically 2000 with n.eff_samples = 99, but this will run many days
rank_mat &lt;- matrix(NA, ncol = 393, nrow = 2)
for (r in 1:R) {
  SBC_out &lt;- fit_ertmpt_SBC(model, seed = r*123, prior_params = params,
                           n.eff_samples = 99, n.thin = 5,
                           n.iter = 5000, n.burnin = 2000, Irep = 5000)
  rank_mat[r, ] &lt;- SBC_out$ranks
}


</code></pre>


</div>