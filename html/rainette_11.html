<div class="container">

<table style="width: 100%;"><tr>
<td>rainette2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Corpus clustering based on the Reinert method - Double clustering</h2>

<h3>Description</h3>

<p>Corpus clustering based on the Reinert method - Double clustering
</p>


<h3>Usage</h3>

<pre><code class="language-R">rainette2(
  x,
  y = NULL,
  max_k = 5,
  min_segment_size1 = 10,
  min_segment_size2 = 15,
  doc_id = NULL,
  min_members = 10,
  min_chi2 = 3.84,
  parallel = FALSE,
  full = TRUE,
  uc_size1,
  uc_size2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>either a quanteda dfm object or the result of <code>rainette()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>if <code>x</code> is a <code>rainette()</code> result, this must be another <code>rainette()</code>
result from same dfm but with different uc size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_k</code></td>
<td>
<p>maximum number of clusters to compute</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_segment_size1</code></td>
<td>
<p>if <code>x</code> is a dfm, minimum uc size for first clustering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_segment_size2</code></td>
<td>
<p>if <code>x</code> is a dfm, minimum uc size for second clustering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doc_id</code></td>
<td>
<p>character name of a dtm docvar which identifies source documents.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_members</code></td>
<td>
<p>minimum members of each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_chi2</code></td>
<td>
<p>minimum chi2 for each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>if TRUE, use <code>parallel::mclapply</code> to compute partitions
(won't work on Windows, uses more RAM)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>if TRUE, all crossed groups are kept to compute optimal partitions, otherwise
only the most mutually associated groups are kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uc_size1</code></td>
<td>
<p>deprecated, use min_segment_size1 instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uc_size2</code></td>
<td>
<p>deprecated, use min_segment_size2 instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>if <code>x</code> is a dfm object, parameters passed to <code>rainette()</code> for both
simple clusterings</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>You can pass a quanteda dfm as <code>x</code> object, the function then performs two simple
clustering with varying minimum uc size, and then proceed to find optimal partitions
based on the results of both clusterings.
</p>
<p>If both clusterings have already been computed, you can pass them as <code>x</code> and <code>y</code> arguments
and the function will only look for optimal partitions.
</p>
<p><code>doc_id</code> must be provided unless the corpus comes from <code>split_segments</code>,
in this case <code>segment_source</code> is used by default.
</p>
<p>If <code>full = FALSE</code>, computation may be much faster, but the chi2 criterion will be the only
one available for best partition detection, and the result may not be optimal.
</p>
<p>For more details on optimal partitions search algorithm, please see package vignettes.
</p>


<h3>Value</h3>

<p>A tibble with optimal partitions found for each available value of <code>k</code> as rows, and the following
columns :
</p>

<ul>
<li> <p><code>clusters</code> list of the crossed original clusters used in the partition
</p>
</li>
<li> <p><code>k</code> the number of clusters
</p>
</li>
<li> <p><code>chi2</code> sum of the chi2 value of each cluster
</p>
</li>
<li> <p><code>n</code> sum of the size of each cluster
</p>
</li>
<li> <p><code>groups</code> group membership of each document for this partition (<code>NA</code> if not assigned)
</p>
</li>
</ul>
<h3>References</h3>


<ul>
<li>
<p> Reinert M, Une méthode de classification descendante hiérarchique : application à l'analyse lexicale par contexte, Cahiers de l'analyse des données, Volume 8, Numéro 2, 1983. <a href="http://www.numdam.org/item/?id=CAD_1983__8_2_187_0">http://www.numdam.org/item/?id=CAD_1983__8_2_187_0</a>
</p>
</li>
<li>
<p> Reinert M., Alceste une méthodologie d'analyse des données textuelles et une application: Aurelia De Gerard De Nerval, Bulletin de Méthodologie Sociologique, Volume 26, Numéro 1, 1990.  <a href="https://doi.org/10.1177/075910639002600103">doi:10.1177/075910639002600103</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>rainette()</code>, <code>cutree_rainette2()</code>, <code>rainette2_plot()</code>, <code>rainette2_explor()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
require(quanteda)
corpus &lt;- data_corpus_inaugural
corpus &lt;- head(corpus, n = 10)
corpus &lt;- split_segments(corpus)
tok &lt;- tokens(corpus, remove_punct = TRUE)
tok &lt;- tokens_remove(tok, stopwords("en"))
dtm &lt;- dfm(tok, tolower = TRUE)
dtm &lt;- dfm_trim(dtm, min_docfreq = 3)

res1 &lt;- rainette(dtm, k = 5, min_segment_size = 10)
res2 &lt;- rainette(dtm, k = 5, min_segment_size = 15)

res &lt;- rainette2(res1, res2, max_k = 4)


</code></pre>


</div>