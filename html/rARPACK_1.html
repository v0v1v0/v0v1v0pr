<div class="container">

<table style="width: 100%;"><tr>
<td>eigs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find a Specified Number of Eigenvalues/vectors for Square Matrix</h2>

<h3>Description</h3>

<p>This function is a simple wrapper of the <code>eigs()</code>
function in the <span class="pkg">RSpectra</span> package. Also see the documentation there.
</p>
<p>Given an <code class="reqn">n</code> by <code class="reqn">n</code> matrix <code class="reqn">A</code>,
function <code>eigs()</code> can calculate a limited
number of eigenvalues and eigenvectors of <code class="reqn">A</code>.
Users can specify the selection criteria by argument
<code>which</code>, e.g., choosing the <code class="reqn">k</code> largest or smallest
eigenvalues and the corresponding eigenvectors.
</p>
<p>Currently <code>eigs()</code> supports matrices of the following classes:
</p>

<table>
<tr>
<td style="text-align: left;">
  <code>matrix</code>     </td>
<td style="text-align: left;"> The most commonly used matrix type,
                         defined in <strong>base</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dgeMatrix</code>  </td>
<td style="text-align: left;"> General matrix, equivalent to <code>matrix</code>,
                         defined in <strong>Matrix</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dgCMatrix</code>  </td>
<td style="text-align: left;"> Column oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dgRMatrix</code>  </td>
<td style="text-align: left;"> Row oriented sparse matrix, defined in
                         <strong>Matrix</strong> package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>dsyMatrix</code>  </td>
<td style="text-align: left;"> Symmetrix matrix, defined in <strong>Matrix</strong>
                         package.</td>
</tr>
<tr>
<td style="text-align: left;">
  <code>function</code>   </td>
<td style="text-align: left;"> Implicitly specify the matrix through a
                         function that has the effect of calculating
                         <code class="reqn">f(x)=Ax</code>. See section
                         <strong>Function Interface</strong> for details.
</td>
</tr>
</table>
<p><code>eigs_sym()</code> assumes the matrix is symmetric,
and only the lower triangle (or upper triangle, which is
controlled by the argument <code>lower</code>) is used for
computation, which guarantees that the eigenvalues and eigenvectors are
real, and in some cases reduces the workload. One exception is when
<code>A</code> is a function, in which case the user is responsible for the
symmetry of the operator.
</p>
<p><code>eigs_sym()</code> supports "matrix", "dgeMatrix", "dgCMatrix", "dgRMatrix"
and "function" typed matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eigs(A, k, which = "LM", sigma = NULL, opts = list(), ...)

eigs_sym(A, k, which = "LM", sigma = NULL, opts = list(),
   lower = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>The matrix whose eigenvalues/vectors are to be computed.
It can also be a function which receives a vector <code class="reqn">x</code>
and calculates <code class="reqn">Ax</code>.
See section <strong>Function Interface</strong> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Number of eigenvalues requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>Selection criteria. See <strong>Details</strong> below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Shift parameter. See section <strong>Shift-And-Invert Mode</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>For symmetric matrices, should the lower triangle
or upper triangle be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments such as <code>n</code> and <code>args</code> that are
related to the Function Interface. See
<code>eigs()</code> in the <span class="pkg">RSpectra</span> package.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>which</code> argument is a character string
that specifies the type of eigenvalues to be computed.
Possible values are:
</p>

<table>
<tr>
<td style="text-align: left;">
  "LM"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest magnitude. Here the
              magnitude means the Euclidean norm of complex numbers.</td>
</tr>
<tr>
<td style="text-align: left;">
  "SM"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest magnitude.</td>
</tr>
<tr>
<td style="text-align: left;">
  "LR"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest real part.</td>
</tr>
<tr>
<td style="text-align: left;">
  "SR"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest real part.</td>
</tr>
<tr>
<td style="text-align: left;">
  "LI"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with largest imaginary part.</td>
</tr>
<tr>
<td style="text-align: left;">
  "SI"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> eigenvalues with smallest imaginary part.</td>
</tr>
<tr>
<td style="text-align: left;">
  "LA"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> largest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
<td style="text-align: left;">
  "SA"  </td>
<td style="text-align: left;">  The <code class="reqn">k</code> smallest (algebraic) eigenvalues, considering any
              negative sign.</td>
</tr>
<tr>
<td style="text-align: left;">
  "BE"  </td>
<td style="text-align: left;">  Compute <code class="reqn">k</code> eigenvalues, half from each end of the
              spectrum. When <code class="reqn">k</code> is odd, compute more from the high
              and then from the low end.
</td>
</tr>
</table>
<p><code>eigs()</code> with matrix type "matrix", "dgeMatrix", "dgCMatrix"
and "dgRMatrix" can use "LM",
"SM", "LR", "SR", "LI" and "SI".
</p>
<p><code>eigs_sym()</code>, and <code>eigs()</code> with matrix type "dsyMatrix"
can use "LM", "SM", "LA", "SA" and "BE".
</p>
<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt>
<dd>
<p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. For general matrix, <code>ncv</code> must satisfy
<code class="reqn">k+2\le ncv \le n</code>, and
for symmetric matrix, the constraint is
<code class="reqn">k &lt; ncv \le n</code>.
Default is <code>min(n, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt>
<dd>
<p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>retvec</code></dt>
<dd>
<p>Whether to compute eigenvectors. If FALSE,
only calculate and return eigenvalues.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A list of converged eigenvalues and eigenvectors.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>Computed eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vectors</code></td>
<td>
<p>Computed eigenvectors. <code>vectors[, j]</code> corresponds to <code>values[j]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nconv</code></td>
<td>
<p>Number of converged eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>niter</code></td>
<td>
<p>Number of iterations used in the computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nops</code></td>
<td>
<p>Number of matrix operations used in the computation.</p>
</td>
</tr>
</table>
<h3>Shift-And-Invert Mode</h3>

<p>The <code>sigma</code> argument is used in the shift-and-invert mode.
</p>
<p>When <code>sigma</code> is not <code>NULL</code>, the selection criteria specified
by argument <code>which</code> will apply to
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\lambda-\sigma}</code>
</p>

<p>where <code class="reqn">\lambda</code>'s are the eigenvalues of <code class="reqn">A</code>. This mode is useful
when user wants to find eigenvalues closest to a given number.
For example, if <code class="reqn">\sigma=0</code>, then <code>which = "LM"</code> will select the
largest values of <code class="reqn">1/|\lambda|</code>, which turns out to select
eigenvalues of <code class="reqn">A</code> that have the smallest magnitude. The result of
using <code>which = "LM", sigma = 0</code> will be the same as
<code>which = "SM"</code>, but the former one is preferable
in that ARPACK is good at finding large
eigenvalues rather than small ones. More explanation of the
shift-and-invert mode can be found in the SciPy document,
<a href="http://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html">http://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html</a>.
</p>


<h3>Function Interface</h3>

<p>The matrix <code class="reqn">A</code> can be specified through a function with
the definition
</p>
<pre>function(x, args)
{
    ## should return A %*% x
}</pre>
<p>which receives a vector <code>x</code> as an argument and returns a vector
of the same length. The function should have the effect of calculating
<code class="reqn">Ax</code>, and extra arguments can be passed in through the
<code>args</code> parameter. In <code>eigs()</code>, user should also provide
the dimension of the implicit matrix through the argument <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Yixuan Qiu <a href="http://statr.me">http://statr.me</a>
</p>
<p>Jiali Mei <a href="mailto:vermouthmjl@gmail.com">vermouthmjl@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>eigen()</code>, <code>svd()</code>,
<code>svds()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(Matrix)
n = 20
k = 5

## general matrices have complex eigenvalues
set.seed(111)
A1 = matrix(rnorm(n^2), n)  ## class "matrix"
A2 = Matrix(A1)             ## class "dgeMatrix"

eigs(A1, k)
eigs(A2, k, opts = list(retvec = FALSE))  ## eigenvalues only

## sparse matrices
A1[sample(n^2, n^2 / 2)] = 0
A3 = as(A1, "dgCMatrix")
A4 = as(A1, "dgRMatrix")

eigs(A3, k)
eigs(A4, k)

## function interface
f = function(x, args)
{
    as.numeric(args %*% x)
}
eigs(f, k, n = n, args = A3)

## symmetric matrices have real eigenvalues
A5 = crossprod(A1)
eigs_sym(A5, k)

## find the smallest (in absolute value) k eigenvalues of A5
eigs_sym(A5, k, which = "SM")

## another way to do this: use the sigma argument
eigs_sym(A5, k, sigma = 0)

## The results should be the same,
## but the latter method is far more stable on large matrices
</code></pre>


</div>