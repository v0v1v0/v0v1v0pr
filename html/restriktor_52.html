<div class="container">

<table style="width: 100%;"><tr>
<td>goric</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Order-Restricted Information Criterion (Approximation) Weights</h2>

<h3>Description</h3>

<p>The <code>goric</code> function computes GORIC(A) weights, which are 
comparable to the Akaike weights. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">goric(object, ...)

## Default S3 method:
goric(object, ..., hypotheses = NULL,
      comparison = NULL, 
      VCOV = NULL, sample_nobs = NULL, type = "goric", 
      control = list(), debug = FALSE)

## S3 method for class 'lm'
goric(object, ..., hypotheses = NULL,
      comparison = NULL, type = "goric",
      missing = "none", auxiliary = c(), emControl = list(),
      debug = FALSE)

## S3 method for class 'numeric'
goric(object, ..., hypotheses = NULL,
      VCOV = NULL, comparison = NULL,
      type = "gorica", sample_nobs = NULL,
      debug = FALSE)

## S3 method for class 'lavaan'
goric(object, ..., hypotheses = NULL,
      comparison = NULL, type = "gorica",
      standardized = FALSE, debug = FALSE)

## S3 method for class 'CTmeta'
goric(object, ..., hypotheses = NULL,
      comparison = NULL, type = "gorica", 
      sample_nobs = NULL, debug = FALSE)

## S3 method for class 'rma'
goric(object, ..., hypotheses = NULL,
      VCOV = NULL, comparison = NULL, type = "gorica", 
      sample_nobs = NULL, debug = FALSE)


## S3 method for class 'con_goric'
print(x, digits = max(3, getOption("digits") - 4), ...)

## S3 method for class 'con_goric'
summary(object, brief = TRUE, digits = max(3, getOption("digits") - 4), ...)
      

## S3 method for class 'con_goric'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object containing the outcome of an unconstrained statistical analysis.
Currently, the following objects can be processed:
</p>

<ul>
<li>
<p> a fitted unconstrained object of class <code>lm</code>, <code>rlm</code> or <code>glm</code>. 
</p>
</li>
<li>
<p> a numeric vector containing the unconstrained estimates resulting from any 
statistical analysis.
</p>
</li>
<li>
<p> a fitted object of class <code>lavaan</code>. See examples on how to specify the hypotheses.
</p>
</li>
<li>
<p> a fitted object of class <code>CTmeta</code>.
</p>
</li>
<li>
<p> a fitted object of class <code>rma</code>.
</p>
</li>
<li>
<p> a fitted object of class <code>nlmerMod</code>.
</p>
</li>
<li>
<p> a fitted object of class <code>glmerMod</code>.
</p>
</li>
<li>
<p> a fitted object of class <code>lmerMod</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object of class <code>con_goric</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>this depends on the class of the object. Note that, the 
objects have to be of the same class. If object is of class <code>lavaan</code>, the 
standardized or unstandardized vcov can be used, using setting <code>standardized = TRUE</code>. 
See details for more information.
</p>
<p><em>Options for calculating the chi-bar-square weights:</em>
</p>
<p>Parameters passed to the truncated multivariate normal distribution. By default, 
restriktor (i.e. <code>con_weights_boot</code> function) uses no truncation points 
for calculating the chi-bar-square weights, which renders to the multivariate 
normal distribution. See the manual page of the <code>rtmvnorm</code> function from 
the <span class="pkg">rtmvnorm</span> to see how to specify a truncated mvnorm distribution and 
the possible arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hypotheses</code></td>
<td>
<p>a named list; Please note that the hypotheses argument in the given 
context serves the same purpose as the constraints argument utilized in the 
restriktor function. The distinction between them is solely semantic.
</p>
<p>There are two ways to constrain parameters. 
First, the hypothesis syntax consists of one or more text-based
descriptions, where the syntax can be specified as a literal 
string enclosed by single quotes. Only the names of <code>coef(model)</code> or
<code>names(vector)</code> can be used as names. See details for more information. 
Note that objects of class "mlm" do not (yet) support this method. 
</p>
<p>Second, the hypothesis syntax consists of a matrix <code class="reqn">R</code> (or a vector in 
case of one constraint) and defines the left-hand side of the constraint 
<code class="reqn">R\theta \ge rhs</code>, where each row represents one constraint. The number of 
columns needs to correspond to the number of parameters estimated (<code class="reqn">\theta</code>) 
by model. The rows should be linear independent, otherwise the function gives an 
error. For more information about constructing the matrix <code class="reqn">R</code> and <code class="reqn">rhs</code> 
see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparison</code></td>
<td>
<p>if "<code>unconstrained</code>" the unconstrained model is 
included in the set of models. If "<code>complement</code>" then the restricted object 
is compared against its complement. Note that the complement can only be computed 
for one model/hypothesis at a time (for now). If "<code>none</code>" the model is only 
compared against the models provided by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VCOV</code></td>
<td>
<p>variance-coviance matrix. Only needed if object is of class numeric and
<code>type = "gorica"</code> or <code>type = "goricac"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_nobs</code></td>
<td>
<p>the number of observations if <code>type = "goricac"</code>. Note that, 
if <code>type = "goricc"</code>, the number of observations are inherited from the fitted
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>if <code>"goric"</code>, the generalized order-restricted 
information criterion value is computed. If <code>"gorica"</code> the 
log-likihood is computed using the multivariate normal distribution 
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>the default setting for objects of class "lm" is listwise:
all cases with missing values are removed from the data before the analysis. This
is only valid if the data are missing completely at random (MCAR). Another 
option is to use "two.stage". In this approach, missing data are imputed using 
an EM algorithm. However, we cannot use the complete data as input for futher 
analyses, because the resulting complete data variance-covariance matrix will 
not be correct. Therefore, we compute the correct aymptotic covariance (Savalei and Bentler, 2009)
and use it as input for the <code>goric.numeric</code> function to compute a GORICA(C)
value. Note that, the parameter estimates are also recomputed using the complete data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auxiliary</code></td>
<td>
<p>Vector. The inclusion of auxiliary variables can improve the
imputation model. These auxiliary variables are not part of the target model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>emControl</code></td>
<td>
<p>a list of control arguments for the <code>emnorm</code> function
from the <span class="pkg">norm</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardized</code></td>
<td>
<p>if TRUE, standardized parameter estimates are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>if TRUE, debugging information is printed out.</p>
</td>
</tr>
</table>
<p>Control options for calculating the chi-bar-square weights:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>


<ul>
<li> <p><code>chunk_size</code> integer; the chi-bar-square weights are computed for samples
of size <code>chunk_size = 5000L</code>. This process is repeated iteratively until the 
weights converges (see <code>convergenge_crit</code>) or the maximum is reached, i.e., 
<code>mix_weights_bootstrap_limit</code>.
</p>
</li>
<li> <p><code>mix_weights_bootstrap_limit</code> integer; maximum number of bootstrap draws.
The default value is set to 1e5.
</p>
</li>
<li> <p><code>convergence_crit</code> the convergence criterion for the iterative bootstrap
process. Default is 1e-03.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>brief</code></td>
<td>
<p>if TRUE, a short overview is printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The GORIC(A) values themselves are not interpretable and 
the interest lie in their differences. The GORIC(A) weights reflect 
the support of each hypothesis in the set. To compare two hypotheses 
(and not one to the whole set), one can examine the ratio of the 
two corresponding GORIC(A) weights. To avoid selecting a weakly supported 
hypothesis as the best one, the unconstrained hypothesis is usually 
included as safeguard.
</p>
<p>In case of one order-constrained hypothesis, say H1, the complement 
Hc can be computed as competing hypothesis. The complement is defined 
as Hc = not H1.
</p>
<p>The hypothesis syntax can be parsed via the hypotheses argument. 
If the object is an unconstrained model of class <code>lm</code>, <code>rlm</code> or <code>glm</code>, 
then the hypotheses can be specified in two ways, see <code>restriktor</code>. Note 
that if the hypotheses are written in matrix notation, then the hypotheses
for each model/hypothesis is put in a named list with specific names constraints, rhs, 
and neq. For example with three parameters x1, x2, x3, and x1 &gt; 0: 
list(model1 = list(constraints = rbind(c(1, 0, 0)), rhs = 0, neq = 0))). The <code>rhs</code> 
and <code>neq</code> are not required if they are equal to 0. If <code>type = "gorica"</code>,
then the object might be a (named) numeric vector. The hypotheses can again be 
specified in two ways, see <code>restriktor</code>. For examples, see below.
</p>
<p>To determine the penalty term values, the chi-bar-square weights (a.k.a. level
probabilities) must be computed. If <code>"mix_weights = "pmvnorm" "</code> (default), 
the chi-bar-square weights are computed based on the multivariate normal distribution 
function with additional Monte Carlo steps. If <code>"mix_weights = "boot" "</code>, the 
chi-bar-square weights are computed using parametric bootstrapping (see <code>restriktor</code>).
</p>
<p>The "two.stage" approach for missing data uses the EM algorithm from the 
<code>norm</code> package. The response variables are assumed to be jointly 
normal. In practice, missing-data procedures designed for variables that are 
normal are sometimes applied to variables that are not. Binary and ordinal 
variables are sometimes imputed under a normal model, and the imputed values 
may be classified or rounded. This is also how restriktor handles (ordered)
factors for now. 
</p>
<p>A better strategy (not implemented yet) would be to convert (ordered) factors 
into a pair of dummy variables. If the (ordered) factors have missing values, 
the dummy variables could be included as columns of Y and imputed, but then you 
have to decide how to convert the continuously distributed imputed values for 
these dummy codes back into categories. 
</p>
<p>### Note on not full row-rank ###
</p>
<p>If the restriction matrix is not of full row-rank, this means one of the following:
</p>

<ul>
<li>
<p> There is at least one redundant restriction specified in the hypothesis. Then, either 
</p>

<ul>
<li>
<p>[a] Leave the redundant one out 
</p>
</li>
<li>
<p>[b] Use another (more time-consuming) way of obtaining the level probabilities 
for the penalty term (goric function does this by default): Bootstrapping, as discussed above.
</p>
</li>
</ul>
</li>
<li>
<p> There is at least one range restriction (e.g., -2 &lt; group1 &lt; 2). 
Such a restriction can be evaluated but there is a sensitivity (of a scaling 
factor in the covariance matrix, like with a prior in a Bayes factor) which 
currently cannot be checked for.
</p>
</li>
<li>
<p> There is at least one conflicting restriction (e.g., 2 &lt; group1 &lt; -2).
</p>
</li>
</ul>
<p>Such a restriction can evidently never hold and is thus impossible to evaluate. 
To prevent this type of error delete the one that is incorrect.
</p>


<h3>Value</h3>

<p>The function returns a dataframe with the log-likelihood,
penalty term, GORIC(A) values and the GORIC(A) weights. Furthermore, a dataframe
is returned with the relative GORIC(A) weights. 
</p>


<h3>Author(s)</h3>

<p>Leonard Vanbrabant and Rebecca Kuiper</p>


<h3>References</h3>

<p>Kuiper, R.M., Hoijtink, H., and Silvapulle, M.J. (2011). An Akaike-type
information criterion for model selection under inequality constraints.
<em>Biometrika</em>, <b>98</b>, 2, 495â€“501.
</p>
<p>Vanbrabant, L. and Kuiper, R. (2020). Evaluating a theory-based hypothesis against 
its complement using an AIC-type information criterion with an application to 
facial burn injury. Psychological Methods. 
</p>
<p>Victoria Savalei and Peter M. Bentler (2009) A Two-Stage Approach to
Missing Data: Theory and Application to Auxiliary Variables, Structural Equation 
Modeling: A Multidisciplinary Journal, 16:3, 477-497, DOI: 10.1080/10705510903008238
</p>


<h3>Examples</h3>

<pre><code class="language-R">## By following these examples, you can appropriately specify hypotheses based on 
## your research questions and analytical framework.

# The hypotheses (i.e., constraints) have to be in a list. It is recommended to name
# each hypothesis in the list. Otherwise the hypotheses are named accordingly 'H1', 'H2', \ldots.
# Another option is to use the \code{llist()} function from the \pkg{Hmisc} package, where.

# text-based syntax (the labels x1, x2, and x2 are the names of coef(model) or names(vector))
h1 &lt;- '(x1, x2, x3) &gt; 0'
h2 &lt;- '(x1, x3) &gt; 0; x2 = 0'
h3 &lt;- 'x1 &gt; 0; x2 &lt; 0; x3 = 0'
hypotheses = list(hypo1 = h1, hypo2 = h2, hypo3 = h3)

# define constraints matrix directly (note that the constraints have to be specified pairwise).
# the element names (i.e., constraints, rhs, neq) must be used. 
h1 &lt;- list(constraints = c(0,1,0)) 
h2 &lt;- list(constraints = rbind(c(0,1,0), c(0,0,1)), rhs = c(0.5, 1), neq = 0) 
hypotheses = list(H1 = h1, H2 = h2)

# mixed syntax:  
hypotheses = list(Ha = h1, Hb = 'x1 = x2 &gt; x3')

# lavaan object syntax:
# we need labels (here a, b and c) to define our hypothesis.
model.lav &lt;- "y ~  1 + a*x1 + b*x2 + c*x3 + x4"
# fit lavaan model, for example
# library(lavaan)
# fit.lav &lt;- sem(model, data = DATA)
# define hypothesis syntax
hypotheses = list(h1 = 'a &gt; b &gt; c')


library(MASS)
## lm
## unrestricted linear model for ages (in months) at which an 
## infant starts to walk alone.

# prepare data
DATA &lt;- subset(ZelazoKolb1972, Group != "Control")
  
# fit unrestrikted linear model
fit1.lm &lt;- lm(Age ~ Group, data = DATA)

# some artificial restrictions
H1 &lt;- "GroupPassive &gt; 0; GroupPassive &lt; GroupNo"
H2 &lt;- "GroupPassive &gt; 0; GroupPassive &gt; GroupNo"
H3 &lt;- "GroupPassive = 0; GroupPassive &lt; GroupNo"


# object is of class lm
goric(fit1.lm, hypotheses = list(H1 = H1, H2 = H2, H3 = H3))

# same result, but using the parameter estimates and covariance matrix as input
# Note, that in case of a numeric input only the gorica(c) can be computed. 
goric(coef(fit1.lm), VCOV = vcov(fit1.lm), hypotheses = list(H1 = H1, H2 = H2, H3 = H3))


# hypothesis H1 versus the complement (i.e., not H1)
goric(fit1.lm, hypotheses = list(H1 = H1), comparison = "complement")


## GORICA
# generate data
n &lt;- 10
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
y &lt;- 1 + x1 + x2 + rnorm(n)
# fit unconstrained linear model
fit.lm &lt;- lm(y ~ x1 + x2)

# extract unconstrained estimates
est &lt;- coef(fit.lm)
# unconstrained variance-covariance matrix
VCOV &lt;- vcov(fit.lm)

## constraint syntax (character)
h1 &lt;- "x1 &gt; 0"
h2 &lt;- "x1 &gt; 0; x2 &gt; 0"
# use fitted unconstrained linear model
goric(fit.lm, hypotheses = list(h1 = h1, h2 = h2), type = "gorica")
# use unconstrained estimates
goric(est, VCOV = VCOV, hypotheses = list(h1 = h1, h2 = h2), type = "gorica")

## constraint syntax (matrix notation)
h1 &lt;- list(constraints = c(0,1,0))
h2 &lt;- list(constraints = rbind(c(0,1,0), c(0,0,1)), rhs = c(0.5, 1), neq = 0)
goric(fit.lm, hypotheses = list(h1 = h1, h2 = h2), type = "gorica")
goric(est, VCOV = VCOV, hypotheses = list(h1 = h1, h2 = h2), type = "gorica")

</code></pre>


</div>