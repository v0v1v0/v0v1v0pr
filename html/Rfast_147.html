<div class="container">

<table style="width: 100%;"><tr>
<td>Distance between vectors and a matrix - Sum of all pairwise distances in a distance matrix.</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distance between vectors and a matrix - Sum of all pairwise distances in a distance matrix.
</h2>

<h3>Description</h3>

<p>Distance between vectors and a matrix - Sum of all pairwise distances in a distance matrix..
</p>


<h3>Usage</h3>

<pre><code class="language-R">dista(xnew, x, type = "euclidean", k = 0, index = FALSE, 
 trans = TRUE, square = FALSE, p = 0, parallel = FALSE)
total.dista(xnew, x, type = "euclidean", k = 0,
 square = FALSE, p = 0, parallel = FALSE)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xnew</code></td>
<td>

<p>A matrix with some data or a vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>A matrix with the data, where rows denotes observations (vectors) and the columns contain the variables.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>

<p>This can be either "euclidean" or "manhattan".
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>Should the k smaller distances or their indices be returned? If k &gt; 0 this will happen.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>

<p>In case k is greater than 0, you have the option to get the indices of the k smallest distances.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>

<p>Do you want the returned matrix to be transposed? TRUE or FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>square</code></td>
<td>

<p>If you choose "euclidean" or "hellinger" as the method, then you can have the option to return the 
squared Euclidean distances by setting this argument to TRUE. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>This is for the the Minkowski, the power of the metric. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>

<p>For methods <b>kullback_leibler</b>, <b>jensen_shannon</b> and <b>itakura_saito</b>, you can run the 
algorithm in parallel. 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The target of this function is to calculate the distances between xnew and x without having to calculate the whole 
distance matrix of xnew and x. The latter does extra calculations, which can be avoided.
</p>

<ul>
<li>
<p> euclidean : <code class="reqn"> \sum \sqrt( \sum | P_i - Q_i |^2)</code>
</p>
</li>
<li>
<p> manhattan : <code class="reqn"> \sum \sum | P_i - Q_i |</code>
</p>
</li>
<li>
<p> minimum : <code class="reqn"> \sum \min | P_i - Q_i |</code>
</p>
</li>
<li>
<p> maximum : <code class="reqn"> \sum \max | P_i - Q_i |</code>
</p>
</li>
<li>
<p> minkowski : <code class="reqn"> \sum ( \sum | P_i - Q_i |^p)^(1/p)</code>
</p>
</li>
<li>
<p> bhattacharyya : <code class="reqn"> \sum - ln \sum \sqrt(P_i * Q_i)</code>
</p>
</li>
<li>
<p> hellinger : <code class="reqn"> \sum 2 * \sqrt( 1 - \sum \sqrt(P_i * Q_i))</code>
</p>
</li>
<li>
<p> kullback_leibler : <code class="reqn"> \sum \sum P_i * log(P_i / Q_i)</code>
</p>
</li>
<li>
<p> jensen_shannon : <code class="reqn"> \sum 0.5 * ( \sum P_i * log(2 * P_i / P_i + Q_i) + \sum Q_i * log(2 * Q_i / P_i + Q_i))</code>
</p>
</li>
<li>
<p> canberra : <code class="reqn"> \sum \sum | P_i - Q_i | / (P_i + Q_i)</code>
</p>
</li>
<li>
<p> chi_square <code class="reqn">X</code>^2 : <code class="reqn"> \sum \sum ( (P_i - Q_i )^2 / (P_i + Q_i) )</code>
</p>
</li>
<li>
<p> soergel : <code class="reqn"> \sum \sum | P_i - Q_i | / \sum \max(P_i , Q_i)</code>
</p>
</li>
<li>
<p> sorensen : <code class="reqn"> \sum \sum | P_i - Q_i | / \sum (P_i + Q_i)</code>
</p>
</li>
<li>
<p> cosine : <code class="reqn"> \sum (P_i * Q_i) / \sqrt(\sum P_i^2) * \sqrt(\sum Q_i^2)</code>
</p>
</li>
<li>
<p> wave_hedges : <code class="reqn"> \sum \sum | P_i - Q_i | / \max(P_i , Q_i)</code>
</p>
</li>
<li>
<p> motyka : <code class="reqn"> \sum \sum \min(P_i , Q_i) / (P_i + Q_i)</code>
</p>
</li>
<li>
<p> harmonic_mean : <code class="reqn"> 2 * \sum (P_i * Q_i) / (P_i + Q_i)</code>
</p>
</li>
<li>
<p> jeffries_matusita : <code class="reqn"> \sum \sqrt( 2 - 2 * \sum \sqrt(P_i * Q_i))</code>
</p>
</li>
<li>
<p> gower : <code class="reqn"> \sum 1/d * \sum | P_i - Q_i |</code>
</p>
</li>
<li>
<p> kulczynski : <code class="reqn"> \sum 1 / \sum | P_i - Q_i | / \sum \min(P_i , Q_i)</code>
</p>
</li>
</ul>
<h3>Value</h3>

<p>A matrix with the distances of each xnew from each vector of x. The number of rows of the xnew and and the number 
of columns of xnew are the dimensions of this matrix.
</p>


<h3>Author(s)</h3>

<p>Michail Tsagris.
</p>
<p>R implementation and documentation: Michail Tsagris &lt;mtsagris@uoc.gr&gt; and Manos Papadakis &lt;papadakm95@gmail.com&gt;.
</p>


<h3>See Also</h3>

<p><code>mahala, Dist, total.dist, total.dista
</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">xnew &lt;- as.matrix( iris[1:10, 1:4] )
x &lt;- as.matrix( iris[-c(1:10), 1:4] )
a &lt;- dista(xnew, x)
b &lt;- as.matrix( dist( rbind(xnew, x) ) )
b &lt;- b[ 1:10, -c(1:10) ]
sum( abs(a - b) )

## see the time
x &lt;- matrix( rnorm(1000 * 4), ncol = 4 )
dista(xnew, x)
as.matrix( dist( rbind(xnew, x) ) )

x&lt;-b&lt;-a&lt;-xnew&lt;-NULL
</code></pre>


</div>