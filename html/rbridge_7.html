<div class="container">

<table style="width: 100%;"><tr>
<td>cv.rbridge</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation for rbridge</h2>

<h3>Description</h3>

<p>Does k-fold cross-validation for rbridge, produces a plot, and returns a value for lambda
</p>


<h3>Usage</h3>

<pre><code class="language-R">cv.rbridge(X, y, q, R, r, lambda, nfolds = 10, lambda.min = ifelse(n &gt;
  p, 0.001, 0.05), nlambda = 100, eta = 1e-07, converge = 10^10,
  num_threads = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p><code>X</code> matrix as in rbridge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>response <code>y</code> as in rbridge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>is the degree of norm which includes ridge regression with <code>q=2</code> and lasso estimates with <code>q=1</code> as special cases</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>is <code>m</code> by <code>p</code> <code>(m&lt;p)</code> matrix of constants.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>is a <code>m</code>-vector of known prespecified constants. If it is given true restriction, then </p>
<p style="text-align: center;"><code class="reqn">r - R\beta = 0.</code>
</p>
<p> Values for <code>r</code> should be given as a matrix. See "Examples".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>lambda sequence; default is NULL. It is given by user or <code>cv.rbridge</code> chooses its own sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of folds - default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>The smallest value for lambda if <code>n&gt;p</code> is <code>0.001</code> and <code>0.05</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of lambda values - default is <code>100</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>is a preselected small positive threshold value. It is deleted <code>jth</code> variable to make the algorithm stable and also is excluded <code>jth</code> variable from the final model. Default is <code>1e-07</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge</code></td>
<td>
<p>is the value of converge. Defaults is <code>10^10</code>. In each iteration, it is calculated by sum of square the change in linear predictor for each coefficient. The algorithm iterates until <code>converge &gt; eta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_threads</code></td>
<td>
<p>Number of threads used for parallel computation over the folds,</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes cv.rbridge
</p>


<h3>Value</h3>

<p>An object of class rbridge, a list with entries
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cve</code></td>
<td>
<p>the mean cross-validated error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvse</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvup</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvlo</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nz</code></td>
<td>
<p>number of non-zero coefficients at each <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>betas</code></td>
<td>
<p>estimated coefficient at each <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min</code></td>
<td>
<p>value of lambda that gives minimum <code>cve</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.1se</code></td>
<td>
<p>largest value of <code>lambda</code> such that error is within 1 standard error of the minimum</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Bahadir Yuzbasi, Mohammad Arashi and Fikri Akdeniz <br> Maintainer: Bahadir Yuzbasi <a href="mailto:b.yzb@hotmail.com">b.yzb@hotmail.com</a>
</p>


<h3>See Also</h3>

<p><code>rbridge</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(2019) 
beta &lt;- c(3, 1.5, 0, 0, 2, 0, 0, 0)
p &lt;- length(beta)
beta &lt;- matrix(beta, nrow = p, ncol = 1)
p.active &lt;- which(beta != 0)

### Restricted Matrix and vector
### Res 1
c1 &lt;- c(1,1,0,0,1,0,0,0)
R1.mat &lt;- matrix(c1,nrow = 1, ncol = p)
r1.vec &lt;- as.matrix(c(6.5),1,1)
### Res 2
c2 &lt;- c(-1,1,0,0,1,0,0,0)
R2.mat &lt;- matrix(c2,nrow = 1, ncol = p)
r2.vec &lt;- matrix(c(0.5),nrow = 1, ncol = 1)
### Res 3
R3.mat &lt;- t(matrix(c(c1,c2),nrow = p, ncol = 2))
r3.vec &lt;- matrix(c(6.5,0.5),nrow = 2, ncol = 1)
### Res 4
R4.mat = diag(1,p,p)[-p.active,]
r4.vec &lt;- matrix(rep(0,p-length(p.active)),nrow = p-length(p.active), ncol = 1)

n = 100
X = matrix(rnorm(n*p),n,p)
y = X%*%beta + rnorm(n) 

######## Model 1 based on first restrictions
model1 &lt;- cv.rbridge(X, y, q = 1, R1.mat, r1.vec)
print(model1)
coef(model1,s='lambda.min')
coef(model1,s='lambda.1se')
predict(model1,newx=X[1:5,], s="lambda.min", type="response")
predict(model1, s="lambda.min",type="coefficient")
predict(model1, s="lambda.1se",type="coefficient")

######## Model 2 based on second restrictions
model2 &lt;- cv.rbridge(X, y, q = 1, R2.mat, r2.vec)
print(model2)
coef(model2,s='lambda.min')
coef(model2,s='lambda.1se')
predict(model2,newx=X[1:5,], s="lambda.min", type="response")
predict(model2, s="lambda.min",type="coefficient")
predict(model2, s="lambda.1se",type="coefficient")

######## Model 3 based on third restrictions
model3 &lt;- cv.rbridge(X, y, q = 1, R3.mat, r3.vec)
print(model3)
coef(model3,s='lambda.min')
coef(model3,s='lambda.1se')
predict(model3,newx=X[1:5,], s="lambda.min", type="response")
predict(model3, s="lambda.min",type="coefficient")
predict(model3, s="lambda.1se",type="coefficient")

######## Model 4 based on fourth restrictions
model4 &lt;- cv.rbridge(X, y, q = 1, R4.mat, r4.vec)
print(model4)
coef(model4,s='lambda.min')
coef(model4,s='lambda.1se')
predict(model4,newx=X[1:5,], s="lambda.min", type="response")
predict(model4, s="lambda.min",type="coefficient")
predict(model4, s="lambda.1se",type="coefficient")


</code></pre>


</div>