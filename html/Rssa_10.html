<div class="container">

<table style="width: 100%;"><tr>
<td>cadzow</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cadzow Iterations
</h2>

<h3>Description</h3>

<p>Perform the finite rank approximation of the series via Cadzow iterations
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'ssa'
cadzow(x, rank, correct = TRUE, tol = 1e-6, maxiter = 0,
         norm = function(x) max(abs(x)),
         trace = FALSE, ..., cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input SSA object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>desired rank of approximation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correct</code></td>
<td>
<p>logical, if 'TRUE' then additional correction as in
Gillard et al (2013) is performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance value used for convergence criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>number of iterations to perform, if zero then
iterations are performed until the convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>distance function used for covergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical, indicates whether the convergence process should be traced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to <code>reconstruct</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Cadzow iterations aim to solve the problem of the approximation of the
input series by a series of finite rank. The idea of the algorithm is
quite simple: alternating projections of the trajectory matrix to
Hankel and low-rank matrices are performed which hopefully converge to
a Hankel low-rank matrix. See Algorithm 3.10 in Golyandina et al (2018).
</p>
<p>Note that the results of one Cadzow iteration with no correction
coincides with the result of reconstruction by the leading <code>rank</code>
components.
</p>
<p>Unfortunately, being simple, the method often yields the solution which is
far away from the optimum.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Cadzow J. A. (1988) Signal enhancement a composite property mapping algorithm,
IEEE Transactions on Acoustics, Speech, and Signal Processing, 36,
49-62.
</p>
<p>Gillard, J. and Zhigljavsky, A. (2013) Stochastic optimization
algorithms for Hankel structured low-rank approximation. Unpublished
Manuscript. Cardiff School of Mathematics. Cardiff.
</p>


<h3>See Also</h3>

<p><code>Rssa</code> for an overview of the package, as well as,
<code>reconstruct</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Decompose co2 series with default parameters
s &lt;- ssa(co2)
# Now make rank 3 approximation using the Cadzow iterations
F &lt;- cadzow(s, rank = 3, tol = 1e-10)
library(lattice)
xyplot(cbind(Original = co2, Cadzow = F), superpose = TRUE)
# All but the first 3 eigenvalues are close to 0
plot(ssa(F))

# Compare with SSA reconstruction
F &lt;- cadzow(s, rank = 3, maxiter = 1, correct = FALSE)
Fr &lt;- reconstruct(s, groups = list(1:3))$F1
print(max(abs(F - Fr)))

# Cadzow with and without weights
set.seed(3)
N &lt;- 60
L &lt;- 30
K &lt;- N - L + 1
alpha &lt;- 0.1

sigma &lt;- 0.1
signal &lt;- cos(2*pi * seq_len(N) / 10)
x &lt;- signal + rnorm(N, sd = sigma)

weights &lt;- rep(alpha, K)
weights[seq(1, K, L)] &lt;- 1
salpha &lt;- ssa(x, L = L,
              column.oblique = "identity",
              row.oblique = weights)
calpha &lt;- cadzow(salpha, rank = 2)

cz &lt;- cadzow(ssa(x, L = L), rank = 2)

print(mean((cz - signal)^2))
print(mean((calpha - signal)^2))
</code></pre>


</div>