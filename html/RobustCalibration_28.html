<div class="container">

<table style="width: 100%;"><tr>
<td>rcalibration</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Setting up the robust Calibration model

</h2>

<h3>Description</h3>


<p>Setting up the Calibration model for estimating the parameters via MCMC with or without a discrepancy function. 

</p>


<h3>Usage</h3>

<pre><code class="language-R">  rcalibration(design, observations, p_theta=NULL, 
  X=matrix(0,dim(as.matrix(design))[1],1), 
  have_trend=FALSE, simul_type=1, input_simul=NULL,output_simul=NULL,simul_nug=FALSE,
  loc_index_emulator=NULL,math_model=NULL, theta_range=NULL,
  sd_proposal=NULL, 
  S=10000,S_0=2000,thinning=1, discrepancy_type='S-GaSP',
  kernel_type='matern_5_2', lambda_z=NA, a=1/2-dim(as.matrix(design))[2], b=1,
  alpha=rep(1.9,dim(as.matrix(design))[2]), 
  output_weights=rep(1,dim(as.matrix(design))[1]),method='post_sample',
  initial_values=NULL,num_initial_values=3,...)
 
      
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>a matrix of observed inputs where each row is a row vector of observable inputs corresponding to one observation, and the number of field or experimental data is the total number of rows. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observations</code></td>
<td>
<p>a vector of field or experimental data. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_theta</code></td>
<td>
<p>an integer about the number of parameters, which should be specified by the user. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a matrix of the mean/trend discrepancy between the reality and math model. The number of rows of X is equal to the number of observations. The default values are a vector of zeros. 

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>have_trend</code></td>
<td>
<p>a bool value meaning whether we assume a mean/trend discrepancy  function.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simul_type</code></td>
<td>
<p>an integer about the math model/simulator. If the simul_type is 0, it means we use RobustGaSP R package to build an emulator for emulation. If the simul_type is 1, it means the function of the math model is given by the user. When simul_type is 2 or 3, the mathematical model is the geophyiscal model for Kilauea Volcano.  If the simul_type is 2, it means it is for the ascending mode InSAR data; if the simul_type is 3, it means it is for the descending mode InSAR data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input_simul</code></td>
<td>
<p>an D x (p_x+p_theta) matrix of design for emulating the math model. It is only useful if simul_type is 0, meaning that we emulate the output of the math model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_simul</code></td>
<td>
<p>a D dimensional vector of the math model runs on the design (input_simul). It is only useful if simul_type is 0, meaning that we emulate the output of the math model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simul_nug</code></td>
<td>
<p>a bool value meaning whether we have a nugget for emulating the math model/simulator. If the math model is stochastic, we often need a nugget. If simul_Nug is TRUE, it means we have a nugget for the emulator. If simul_Nug is FALSE, it means we do not have a nugget for the emulator.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc_index_emulator</code></td>
<td>

<p>a vector of the location index from the ppgasp emulator to output. Only useful for vectorized output computer model emulated by the ppgasp emulator.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>math_model</code></td>
<td>
<p>a function of the math model provided by the user. It is only useful if simul_type is 1, meaning that we know the math model and it can be computed fast. If the math model is computationally slow, one should set simul_type to be 0 to emulate the math model. One can input a function to define  a math_model where the first input of the function is a vector of observable inputs and the second input is a vector of  calibration parameters. The output of each function is a scalar. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_range</code></td>
<td>
<p>a p_theta x 2 matrix of the range of the calibration parameters. The first column is the lower bound and the second column  is the upper bound. It should be specified by the user if the simul_type is 0. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_proposal</code></td>
<td>
<p>a vector of the standard deviation of the proposal distribution in MCMC. The default value of sd of the calibration parameter is 0.05 times <code>theta_range</code>. The rest is set to be 0.05. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>number of posterior samples to run. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S_0</code></td>
<td>
<p>number of burn-in samples. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>
<p>number of posterior samples to record. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrepancy_type</code></td>
<td>
<p>characters about the type of the discrepancy.  If it is 'no-discrepancy', it means no discrepancy function. If it is 'GaSP', it means the GaSP model for the discrepancy function. If it is 'S-GaSP', it means the S-GaSP model for the discrepancy function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_type</code></td>
<td>
<p>characters about the type of the discrepancy type of kernel. <code>matern_3_2</code> and <code>matern_5_2</code> are <code>Matern kernel</code> with roughness parameter 3/2 and 5/2 respectively. <code>pow_exp</code> is power exponential kernel with roughness parameter alpha. If <code>pow_exp</code> is to be used, one needs to specify its roughness parameter alpha.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_z</code></td>
<td>
<p>a <code>vector</code> value about how close the math model to the reality in squared distance when the S-GaSP model is used for modeling the discrepancy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>a scalar of the prior parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a scalar of the prior parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a numeric parameter for the roughness in the kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_weights</code></td>
<td>
<p>a vector of the weights of the outputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>characters for method of parameter estimation. If it is 'post_sample', the posterior sampling will be used. If it is 'mle', the maximum likelihood estimator will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_values</code></td>
<td>

<p>either a vector or a matrix of initial values of parameters. If posterior sampling method is used, it needs to be vector of the initial values of the calibration parameters. If an optimization method is used, it can be a matrix of the calbiration parameters and kernel parameters (log inverse range parameters and the log nugget parameter) to be optimized numerically, where each row of the matrix contains a set of initial values. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_initial_values</code></td>
<td>

<p>the number of initial values of the kernel parameters in optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Extra arguments to be passed to the function (not implemented yet)</p>
</td>
</tr>
</table>
<h3>Value</h3>






<p><code>rcalibration</code> returns an S4 object of class <code>rcalibration</code> (see <code>rcalibration-class</code>).
</p>





<h3>Author(s)</h3>

<p>Mengyang Gu [aut, cre]
</p>
<p>Maintainer: Mengyang Gu &lt;mengyang@pstat.ucsb.edu&gt;
</p>


<h3>References</h3>


<p>A. O'Hagan and M. C. Kennedy (2001), <em>Bayesian calibration of computer models</em>, <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology</em>, <b>63</b>, 425-464.
</p>
<p>K. R. Anderson and M. P. Poland (2016), <em>Bayesian estimation of magma supply, storage, and eroption rates using a multiphysical volcano model: Kilauea volcano, 2000-2012.</em>. <em>Eath and Planetary Science Letters</em>, <b>447</b>, 161-171.
</p>
<p>K. R. Anderson and M. P. Poland (2017), <em>Abundant carbon in the mantle beneath Hawaii</em>. <em>Nature Geoscience</em>, <b>10</b>, 704-708.
</p>
<p>M. Gu (2016), <em>Robust Uncertainty Quantification and Scalable Computation for Computer Models with Massive Output</em>, Ph.D. thesis., Duke University.
</p>
<p>M. Gu and L. Wang (2017) <em>Scaled Gaussian Stochastic Process for Computer Model Calibration and Prediction</em>. arXiv preprint arXiv:1707.08215.
</p>
<p>M. Gu (2018) <em>Jointly Robust Prior for Gaussian Stochastic Process in Emulation, Calibration and Variable Selection
</em>. arXiv preprint arXiv:1804.09329.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(RobustCalibration)

#-------------------------------------------------------------
# an example with multiple local maximum of minimum in L2 loss
#-------------------------------------------------------------

## the reality 
test_funct_eg1&lt;-function(x){
  x*cos(3/2*x)+x
}



## obtain 25 data from the reality plus a noise
set.seed(1)
## 10 data points are very small, one may want to add more data
n=15
input=seq(0,5,5/(n-1))
input=as.matrix(input)

output=test_funct_eg1(input)+rnorm(length(input),mean=0,sd=0.1)

num_obs=n=length(output)



## the math model 
math_model_eg1&lt;-function(x,theta){
  sin(theta*x)+x  
}

##fit the S-GaSP model for the discrepancy
##one can choose the discrepancy_type to GaSP, S-GaSP or no discrepancy
##p_theta is the number of parameters to calibrate and user needs to specifiy 
##one may also want to change the number of posterior samples by change S and S_0
p_theta=1
model_sgasp=rcalibration(design=input, observations=output, p_theta=p_theta,simul_type=1,
                         math_model=math_model_eg1,theta_range=matrix(c(0,3),1,2)
                         ,S=10000,S_0=2000,discrepancy_type='S-GaSP')

##if the acceptance rate is too low or two high, one can adjust sd_proposal, e.g.
#model_sgasp=rcalibration(design=input, observations=output, p_theta=1,simul_type=1,
#                         sd_proposal=c(rep(0.02,p_theta),rep(0.2,dim(input)[2]),0.2)
#                         math_model=math_model_eg1,theta_range=matrix(c(0,3),1,2)
#                         ,S=10000,S_0=2000,discrepancy_type='S-GaSP')

##posterior samples of calibration parameter and value
plot(model_sgasp@post_sample[,1],type='l',xlab='num',ylab=expression(theta))   
plot(model_sgasp@post_value,type='l',xlab='num',ylab='posterior value')   


show(model_sgasp)




##one may want to fit a a model with an estimated baseline mean discrepancy by setting 
##X=matrix(1,dim(input_stack)[1],1),have_trend=TRUE

model_sgasp_with_mean=rcalibration(design=input, observations=output, p_theta=1,simul_type=1,
                                   X=matrix(1,dim(input)[1],1),have_trend=TRUE,
                                   math_model=math_model_eg1,theta_range=matrix(c(0,3),1,2),
                                   S=10000,S_0=2000,discrepancy_type='S-GaSP')

show(model_sgasp_with_mean)

##posterior samples of calibration parameter and value
plot(model_sgasp_with_mean@post_sample[,1],type='l',xlab='num',ylab=expression(theta))   
plot(model_sgasp_with_mean@post_value,type='l',xlab='num',ylab='posterior value')   


## Not run: 
  #-------------------------------------------------------------
  # an example with multiple local maximum of minimum in L2 loss
  # for combing the emulator
  #-------------------------------------------------------------
  
  ## the reality 
  test_funct_eg1&lt;-function(x){
    x*cos(3/2*x)+x
  }
  
  ## obtain 20 data from the reality plus a noise
  set.seed(1)
  n=20
  input=seq(0,5,5/(n-1))
  input=as.matrix(input)
  
  output=test_funct_eg1(input)+rnorm(length(input),mean=0,sd=0.05)
  
  num_obs=n=length(output)
  
  ## the math model 
  math_model_eg1&lt;-function(x,theta){
    sin(theta*x)+x  
  }
  
  ##let's build an emulator for the case if the math model is too slow
  
  # let's say we can only run the math model n_design times
  n_design=80
  
  design_simul=matrix(runif(n_design*2),n_design,2)
  design_simul[,1]=5*design_simul[,1]   ##the first one is the observed input x
  design_simul[,2]=3*design_simul[,2]   ##the second one is the calibration parameter 
  
  output_simul=math_model_eg1(design_simul[,1],design_simul[,2])
  
  
  
  ##this is a little slow compared with the previous model
  model_sgasp_emulator=rcalibration(design=input, observations=output, p_theta=1,simul_type=0, 
                                    input_simul=design_simul, output_simul=output_simul,
                                    theta_range=matrix(c(0,3),1,2),
                                    S=10000,S_0=2000,discrepancy_type='S-GaSP')
  
  ##now the output is a list
  show(model_sgasp_emulator)

  ##here is the plot
  plot(model_sgasp_emulator@post_sample[,1],type='l',xlab='num',ylab=expression(theta))   
  plot(model_sgasp_emulator@post_value,type='l',xlab='num',ylab='posterior value')   

## End(Not run)



</code></pre>


</div>