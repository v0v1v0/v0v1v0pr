<div class="container">

<table style="width: 100%;"><tr>
<td>ru</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized ratio-of-uniforms sampling</h2>

<h3>Description</h3>

<p>Uses the generalized ratio-of-uniforms method to simulate from a
distribution with log-density <code class="reqn">\log f</code> (up to an additive
constant). The density <code class="reqn">f</code> must be bounded, perhaps after a
transformation of variable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ru(
  logf,
  ...,
  n = 1,
  d = 1,
  init = NULL,
  mode = NULL,
  trans = c("none", "BC", "user"),
  phi_to_theta = NULL,
  log_j = NULL,
  user_args = list(),
  lambda = rep(1L, d),
  lambda_tol = 1e-06,
  gm = NULL,
  rotate = ifelse(d == 1, FALSE, TRUE),
  lower = rep(-Inf, d),
  upper = rep(Inf, d),
  r = 1/2,
  ep = 0L,
  a_algor = if (d == 1) "nlminb" else "optim",
  b_algor = c("nlminb", "optim"),
  a_method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"),
  b_method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"),
  a_control = list(),
  b_control = list(),
  var_names = NULL,
  shoof = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>logf</code></td>
<td>
<p>A function returning the log of the target density <code class="reqn">f</code>
evaluated at its first argument.
This function should return <code>-Inf</code> when the density is zero.
It is better to use <code>logf = </code> explicitly, for example,
<code>ru(logf = dnorm, log = TRUE, init = 0.1)</code>,
to avoid argument matching problems.  In contrast,
<code>ru(dnorm, log = TRUE, init = 0.1)</code>
will throw an error because partial matching results in
<code>logf</code> being matched to <code>log = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to <code>logf</code> and related
functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>A non-negative integer scalar.  The number of simulated values
required. If <code>n = 0</code> then no simulation is performed but the
component <code>box</code> in the returned object gives the ratio-of-uniforms
bounding box that would have been used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>A positive integer scalar. The dimension of <code class="reqn">f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>A numeric vector of length <code>d</code>. Initial estimate of the
mode of <code>logf</code>.
If <code>trans = "BC"</code> or <code>trans = "user"</code> this is <em>after</em>
Box-Cox transformation or user-defined transformation, but <em>before</em>
any rotation of axes.
If <code>init</code> is not supplied then <code>rep(1, d)</code> is used.
If <code>length(init) = 1</code> and <code>d &gt; 1</code> then
<code>init &lt;- rep(init, length.out = d)</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>A numeric vector of length <code>d</code>.  The mode of <code>logf</code>.
If <code>trans = "BC"</code> or <code>trans = "user"</code> this is <em>after</em>
Box-Cox transformation or user-defined transformation, but <em>before</em>
any rotation of axes.  Only supply <code>mode</code> if the mode is known: it
will not be checked.  If <code>mode</code> is supplied then <code>init</code> is
ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans</code></td>
<td>
<p>A character scalar. <code>trans = "none"</code> for no
transformation, <code>trans = "BC"</code> for Box-Cox transformation,
<code>trans = "user"</code> for a user-defined transformation.
If <code>trans = "user"</code> then the transformation should be specified
using <code>phi_to_theta</code> and <code>log_j</code> and <code>user_args</code> may be
used to pass arguments to <code>phi_to_theta</code> and <code>log_j</code>.
See <strong>Details</strong> and the <strong>Examples</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_to_theta</code></td>
<td>
<p>A function returning (the inverse) of the transformation
from <code>theta</code> (<code class="reqn">\theta</code>) to <code>phi</code> (<code class="reqn">\phi</code>) that may be
used to ensure positivity of <code class="reqn">\phi</code> prior to Box-Cox transformation.
The argument is <code>phi</code> and the returned value is <code>theta</code>.
If <code>phi_to_theta</code> is undefined at the input value then the
function should return <code>NA</code>. See <strong>Details</strong>.
If <code>lambda$phi_to_theta</code> (see argument <code>lambda</code> below) is
supplied then this is used instead of any function supplied via
<code>phi_to_theta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_j</code></td>
<td>
<p>A function returning the log of the Jacobian of the
transformation from <code>theta</code> (<code class="reqn">\theta</code>) to <code>phi</code> (<code class="reqn">\phi</code>),
i.e., based on derivatives of <code class="reqn">\phi</code> with respect to <code class="reqn">\theta</code>.
Takes <code>theta</code> as its argument.
If <code>lambda$log_j</code> (see argument <code>lambda</code> below) is
supplied then this is used instead of any function supplied via
<code>log_j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_args</code></td>
<td>
<p>A list of numeric components. If <code>trans = "user"</code>
then <code>user_args</code> is a list providing arguments to the user-supplied
functions <code>phi_to_theta</code> and <code>log_j</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Either
</p>

<ul>
<li>
<p> A numeric vector.  Box-Cox transformation parameters, or
</p>
</li>
<li>
<p> A list with components
</p>

<dl>
<dt>lambda</dt>
<dd>
<p>A numeric vector.  Box-Cox parameters (required).</p>
</dd>
<dt>gm</dt>
<dd>
<p>A numeric vector.  Box-Cox scaling parameters (optional).
If supplied this overrides any <code>gm</code> supplied by the individual
<code>gm</code> argument described below.</p>
</dd>
<dt>init_psi</dt>
<dd>
<p>A numeric vector.  Initial estimate of mode <em>after</em>
Box-Cox transformation (optional).</p>
</dd>
<dt>sd_psi</dt>
<dd>
<p>A numeric vector.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables (optional).</p>
</dd>
<dt>phi_to_theta</dt>
<dd>
<p>As above (optional).</p>
</dd>
<dt>log_j</dt>
<dd>
<p>As above (optional).</p>
</dd>
</dl>
<p>This list may be created using find_lambda_one_d (for <code>d</code> = 1)
or find_lambda (for any <code>d</code>).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_tol</code></td>
<td>
<p>A numeric scalar.  Any values in lambda that are less
than <code>lambda_tol</code> in magnitude are set to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gm</code></td>
<td>
<p>A numeric vector. Box-Cox scaling parameters (optional). If
<code>lambda$gm</code> is supplied in input list <code>lambda</code> then
<code>lambda$gm</code> is used, not <code>gm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotate</code></td>
<td>
<p>A logical scalar. If TRUE (<code>d</code> &gt; 1 only) use Choleski
rotation.  If d = 1 and <code>rotate = TRUE</code> then rotate will be set to
FALSE with a warning. See <strong>Details</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>Numeric vectors.  Lower/upper bounds on the arguments of
the function <em>after</em> any transformation from theta to phi implied by
the inverse of <code>phi_to_theta</code>. If <code>rotate = FALSE</code> these
are used in all of the optimisations used to construct the bounding box.
If <code>rotate = TRUE</code> then they are use only in the first optimisation
to maximise the target density.'
If <code>trans = "BC"</code> components of <code>lower</code> that are negative are
set to zero without warning and the bounds implied after the Box-Cox
transformation are calculated inside <code>ru</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>A numeric scalar.  Parameter of generalized ratio-of-uniforms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ep</code></td>
<td>
<p>A numeric scalar.  Controls initial estimates for optimisations
to find the <code class="reqn">b</code>-bounding box parameters.  The default (<code>ep</code> = 0)
corresponds to starting at the mode of <code>logf</code> small positive values
of <code>ep</code> move the constrained variable slightly away from the mode in
the correct direction.  If <code>ep</code> is negative its absolute value is
used, with no warning given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a_algor, b_algor</code></td>
<td>
<p>Character scalars.  Either <code>"nlminb"</code> or
<code>"optim"</code>.
Respective optimisation algorithms used to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a_method, b_method</code></td>
<td>
<p>Character scalars.  Respective methods used by
<code>optim</code> to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r)).
Only used if <code>optim</code> is the chosen algorithm.  If <code>d</code> = 1 then
<code>a_method</code> and <code>b_method</code> are set to <code>"Brent"</code> without
warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a_control, b_control</code></td>
<td>
<p>Lists of control arguments to <code>optim</code> or
<code>nlminb</code> to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r))
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_names</code></td>
<td>
<p>A character (or numeric) vector of length <code>d</code>.  Names
to give to the column(s) of the simulated values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shoof</code></td>
<td>
<p>A numeric scalar in [0, 1].  Sometimes a spurious
non-zero convergence indicator is returned from
<code>optim</code> or <code>nlminb</code>).
In this event we try to check that a minimum has indeed been found using
different algorithm.  <code>shoof</code> controls the starting value provided
to this algorithm.
If <code>shoof = 0</code> then we start from the current solution.
If <code>shoof = 1</code> then we start from the initial estimate provided
to the previous minimisation.  Otherwise, <code>shoof</code> interpolates
between these two extremes, with a value close to zero giving a starting
value that is close to the current solution.
The exception to this is when the initial and current solutions are equal.
Then we start from the current solution multiplied by <code>1 - shoof</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For information about the generalised ratio-of-uniforms method and
transformations see the
<a href="https://paulnorthrop.github.io/rust/articles/rust-a-vignette.html">
Introducing rust</a> vignette.  This can also be accessed using
<code>vignette("rust-a-vignette", package = "rust")</code>.
</p>
<p>If <code>trans = "none"</code> and <code>rotate = FALSE</code> then <code>ru</code>
implements the (multivariate) generalized ratio of uniforms method
described in Wakefield, Gelfand and Smith (1991) using a target
density whose mode is relocated to the origin (‘mode relocation’) in the
hope of increasing efficiency.
</p>
<p>If <code>trans = "BC"</code> then marginal Box-Cox transformations of each of
the <code>d</code> variables is performed, with parameters supplied in
<code>lambda</code>.  The function <code>phi_to_theta</code> may be used, if
necessary, to ensure positivity of the variables prior to Box-Cox
transformation.
</p>
<p>If <code>trans = "user"</code> then the function <code>phi_to_theta</code> enables
the user to specify their own transformation.
</p>
<p>In all cases the mode of the target function is relocated to the origin
<em>after</em> any user-supplied transformation and/or Box-Cox
transformation.
</p>
<p>If <code>d</code> is greater than one and <code>rotate = TRUE</code> then a rotation
of the variable axes is performed <em>after</em> mode relocation.  The
rotation is based on the Choleski decomposition (see chol) of the
estimated Hessian (computed using <code>optimHess</code>
of the negated
log-density after any user-supplied transformation or Box-Cox
transformation.  If any of the eigenvalues of the estimated Hessian are
non-positive (which may indicate that the estimated mode of <code>logf</code>
is close to a variable boundary) then <code>rotate</code> is set to <code>FALSE</code>
with a warning.  A warning is also given if this happens when
<code>d</code> = 1.
</p>
<p>The default value of the tuning parameter <code>r</code> is 1/2, which is
likely to be close to optimal in many cases, particularly if
<code>trans = "BC"</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"ru"</code> is a list containing the following
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sim_vals</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of simulated values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>box</code></td>
<td>
<p>A (2 * <code>d</code> + 1) by <code>d</code> + 2 matrix of
ratio-of-uniforms bounding box information, with row names indicating
the box parameter.  The columns contain
</p>

<dl>
<dt>column 1</dt>
<dd>
<p>values of box parameters.</p>
</dd>
<dt>columns 2 to (2+<code>d</code>-1)</dt>
<dd>
<p>values of variables at which
these box parameters are obtained.</p>
</dd>
<dt>column 2+<code>d</code>
</dt>
<dd>
<p>convergence indicators.</p>
</dd>
</dl>
<p>Scaling of f within <code>ru</code> and relocation of the
mode to the origin means that the first row of <code>box</code> will always
be <code>c(1, rep(0, d))</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pa</code></td>
<td>
<p>A numeric scalar.  An estimate of the probability of
acceptance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The value of <code>r</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>The value of <code>d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logf</code></td>
<td>
<p>A function. <code>logf</code> supplied by the user, but
with f scaled by the maximum of the target density used in the
ratio-of-uniforms method (i.e. <code>logf_rho</code>), to avoid numerical
problems in contouring f in <code>plot.ru</code> when
<code>d = 2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logf_rho</code></td>
<td>
<p>A function. The target function actually used in the
ratio-of-uniforms algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim_vals_rho</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of values simulated
from the function used in the ratio-of-uniforms algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logf_args</code></td>
<td>
<p>A list of further arguments to <code>logf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f_mode</code></td>
<td>
<p>The estimated mode of the target density f, after any
Box-Cox transformation and/or user supplied transformation, but before
mode relocation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans_fn</code></td>
<td>
<p>An R function that performs the inverse transformation
from the transformed variable <code class="reqn">\rho</code>, on which the generalised
ratio-of-uniforms method is performed, back to the original variable
<code class="reqn">\theta</code>. <strong>Note</strong>: <code>trans_fn</code> is <strong>not</strong>
vectorised with respect to <code class="reqn">\rho</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Wakefield, J. C., Gelfand, A. E. and Smith, A. F. M. (1991)
Efficient generation of random variates via the ratio-of-uniforms method.
<em>Statistics and Computing</em> (1991), <strong>1</strong>, 129-133.
<a href="https://doi.org/10.1007/BF01889987">doi:10.1007/BF01889987</a>.
</p>


<h3>See Also</h3>

<p><code>ru_rcpp</code> for a version of <code>ru</code> that uses
the Rcpp package to improve efficiency.
</p>
<p><code>summary.ru</code> for summaries of the simulated values
and properties of the ratio-of-uniforms algorithm.
</p>
<p><code>plot.ru</code> for a diagnostic plot.
</p>
<p><code>find_lambda_one_d</code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for the
<code>d</code> = 1 case.
</p>
<p><code>find_lambda</code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for any value of
<code>d</code>.
</p>
<p><code>optim</code> for choices of the arguments
<code>a_method</code>, <code>b_method</code>, <code>a_control</code> and <code>b_control</code>.
</p>
<p><code>nlminb</code> for choices of the arguments
<code>a_control</code> and <code>b_control</code>.
</p>
<p><code>optimHess</code> for Hessian estimation.
</p>
<p><code>chol</code> for the Choleski decomposition.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Normal density ===================

# One-dimensional standard normal ----------------
x &lt;- ru(logf = function(x) -x ^ 2 / 2, d = 1, n = 1000, init = 0.1)

# Two-dimensional standard normal ----------------
x &lt;- ru(logf = function(x) -(x[1]^2 + x[2]^2) / 2, d = 2, n = 1000,
        init = c(0, 0))

# Two-dimensional normal with positive association ----------------
rho &lt;- 0.9
covmat &lt;- matrix(c(1, rho, rho, 1), 2, 2)
log_dmvnorm &lt;- function(x, mean = rep(0, d), sigma = diag(d)) {
  x &lt;- matrix(x, ncol = length(x))
  d &lt;- ncol(x)
  - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean)
}

# No rotation.
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0),
        rotate = FALSE)

# With rotation.
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0))

# three-dimensional normal with positive association ----------------
covmat &lt;- matrix(rho, 3, 3) + diag(1 - rho, 3)

# No rotation.  Slow !
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = 1000,
        init = c(0, 0, 0), rotate = FALSE)

# With rotation.
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = 1000,
        init = c(0, 0, 0))

# Log-normal density ===================

# Sampling on original scale ----------------
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 1)

# Box-Cox transform with lambda = 0 ----------------
lambda &lt;- 0
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 0.1,
        trans = "BC", lambda = lambda)

# Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox
# transformation and the log-Jacobian by hand
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, init = 0.1,
        trans = "user", phi_to_theta = function(x) exp(x),
        log_j = function(x) -log(x))

# Gamma(alpha, 1) density ===================

# Note: the gamma density in unbounded when its shape parameter is &lt; 1.
# Therefore, we can only use trans="none" if the shape parameter is &gt;= 1.

# Sampling on original scale ----------------

alpha &lt;- 10
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        lower = 0, init = alpha)

alpha &lt;- 1
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        lower = 0, init = alpha)

# Box-Cox transform with lambda = 1/3 works well for shape &gt;= 1. -----------

alpha &lt;- 1
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = 1/3, init = alpha)
summary(x)

# Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox
# transformation and the log-Jacobian by hand

# Note: when phi_to_theta is undefined at x this function returns NA
phi_to_theta  &lt;- function(x, lambda) {
  ifelse(x * lambda + 1 &gt; 0, (x * lambda + 1) ^ (1 / lambda), NA)
}
log_j &lt;- function(x, lambda) (lambda - 1) * log(x)
lambda &lt;- 1/3
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "user", phi_to_theta = phi_to_theta, log_j = log_j,
        user_args = list(lambda = lambda), init = alpha)
summary(x)


# Generalized Pareto posterior distribution ===================

# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = -0.5, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate an initial estimate
init &lt;- c(mean(gpd_data), 0)

# Mode relocation only ----------------
n &lt;- 1000
x1 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
         lower = c(0, -Inf), rotate = FALSE)
plot(x1, xlab = "sigma", ylab = "xi")
# Parameter constraint line xi &gt; -sigma/max(data)
# [This may not appear if the sample is far from the constraint.]
abline(a = 0, b = -1 / ss$xm)
summary(x1)

# Rotation of axes plus mode relocation ----------------
x2 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
         lower = c(0, -Inf))
plot(x2, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x2)

# Cauchy ========================

# The bounding box cannot be constructed if r &lt; 1.  For r = 1 the
# bounding box parameters b1-(r) and b1+(r) are attained in the limits
# as x decreases/increases to infinity respectively.  This is fine in
# theory but using r &gt; 1 avoids this problem and the largest probability
# of acceptance is obtained for r approximately equal to 1.26.

res &lt;- ru(logf = dcauchy, log = TRUE, init = 0, r = 1.26, n = 1000)

# Half-Cauchy ===================

log_halfcauchy &lt;- function(x) {
  return(ifelse(x &lt; 0, -Inf, dcauchy(x, log = TRUE)))
}

# Like the Cauchy case the bounding box cannot be constructed if r &lt; 1.
# We could use r &gt; 1 but the mode is on the edge of the support of the
# density so as an alternative we use a log transformation.

x &lt;- ru(logf = log_halfcauchy, init = 0, trans = "BC", lambda = 0, n = 1000)
x$pa
plot(x, ru_scale = TRUE)

# Example 4 from Wakefield et al. (1991) ===================

# Bivariate normal x bivariate student-t
log_norm_t &lt;- function(x, mean = rep(0, d), sigma1 = diag(d), sigma2 = diag(d)) {
  x &lt;- matrix(x, ncol = length(x))
  log_h1 &lt;- -0.5 * (x - mean) %*% solve(sigma1) %*% t(x - mean)
  log_h2 &lt;- -2 * log(1 + 0.5 * x %*% solve(sigma2) %*% t(x))
  return(log_h1 + log_h2)
}

rho &lt;- 0.9
covmat &lt;- matrix(c(1, rho, rho, 1), 2, 2)
y &lt;- c(0, 0)

# Case in the top right corner of Table 3
x &lt;- ru(logf = log_norm_t, mean = y, sigma1 = covmat, sigma2 = covmat,
  d = 2, n = 10000, init = y, rotate = FALSE)
x$pa

# Rotation increases the probability of acceptance
x &lt;- ru(logf = log_norm_t, mean = y, sigma1 = covmat, sigma2 = covmat,
  d = 2, n = 10000, init = y, rotate = TRUE)
x$pa

# Normal x log-normal: different Box-Cox parameters ==================
norm_lognorm &lt;- function(x, ...) {
  dnorm(x[1], ...) + dlnorm(x[2], ...)
}
x &lt;- ru(logf = norm_lognorm, log = TRUE, n = 1000, d = 2, init = c(-1, 0),
        trans = "BC", lambda = c(1, 0))
plot(x)
plot(x, ru_scale = TRUE)

</code></pre>


</div>