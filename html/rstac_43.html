<div class="container">

<table style="width: 100%;"><tr>
<td>ext_filter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter extension</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
<code>ext_filter()</code> implements Common Query Language (CQL2) filter extension
on <code>rstac</code>. This extension expands the filter capabilities providing a
query language to construct more complex expressions. CQL2 is an OGC
standard and defines how filters can be constructed. It supports predicates
for standard data types like strings, numbers, and boolean as well as
for spatial geometries (point, lines, polygons) and temporal
data (instants and intervals).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
<code>cql2_json()</code> and <code>cql2_text()</code> are helper functions that can be used
to show how expressions are converted into CQL2 standard, either
JSON or TEXT formats.
</p>
<p><code>rstac</code> translates R expressions to CQL2, allowing users to express their
filter criteria using R language. For more details on how to create
CQL2 expressions in <code>rstac</code>. See the details section.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ext_filter(q, expr, lang = NULL, crs = NULL)

cql2_json(expr)

cql2_text(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>a <code>rstac_query</code> object expressing a STAC query
criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>a valid R expression to be translated to CQL2 (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lang</code></td>
<td>
<p>a character value indicating which CQL2 representation
to be used. It can be either <code>"cql2-text"</code> (for plain text) or
<code>"cql2-json"</code> (for JSON format). If <code>NULL</code> (default), <code>"cql2-text"</code> is
used for HTTP <code>GET</code> requests and <code>"cql2-json"</code> for <code>POST</code> requests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>an optional character value informing the coordinate reference
system used by geometry objects. If <code>NULL</code> (default), STAC services assume
<code>"WGS 84"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To allow users to express filter criteria in R language, <code>rstac</code> takes
advantage of the abstract syntax tree (AST) to translate R expressions
to CQL2 expressions. The following topics describe the correspondences
between <code>rstac</code> expressions and CQL2 operators.
</p>


<h4>Non-standard evaluation</h4>


<ul><li> <p><code>ext_filter()</code> uses non-standard evaluation to evaluate its expressions.
That means users must escape any variable or call to be able to use them
in the expressions. The escape is done by using <code>double-curly-braces</code>,
i.e., <code>{{variable}}</code>.
</p>
</li></ul>
<h4>Standard comparison operators</h4>


<ul>
<li> <p><code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, and <code>!=</code> operators correspond to
<code>=</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, and <code style="white-space: pre;">⁠&lt;&gt;⁠</code> in CQL2, respectively.
</p>
</li>
<li>
<p> function <code>is_null(a)</code> and <code>!is_null(a)</code> corresponds to <code style="white-space: pre;">⁠a IS NULL⁠</code> and
<code style="white-space: pre;">⁠a IS NOT NULL⁠</code> CQL2 operators, respectively.
</p>
</li>
</ul>
<h4>Advanced comparison operators</h4>


<ul>
<li> <p><code>a %like% b</code> corresponds to CQL2 <code style="white-space: pre;">⁠a LIKE b⁠</code>, <code>a</code> and <code>b</code> <code>strings</code> values.
</p>
</li>
<li> <p><code>between(a, b, c)</code> corresponds to CQL2 <code style="white-space: pre;">⁠a BETWEEN b AND c⁠</code>, where
<code>b</code> and <code>c</code> <code>integer</code> values.
</p>
</li>
<li> <p><code>a %in% b</code> corresponds to CQL2 <code style="white-space: pre;">⁠a IN (b)⁠</code>, where <code>b</code> should be
a list of values of the same type as <code>a</code>.
</p>
</li>
</ul>
<h4>Spatial operators</h4>


<ul>
<li>
<p> functions <code>s_intersects(a, b)</code>, <code>s_touches(a, b)</code>, <code>s_within(a, b)</code>,
<code>s_overlaps(a, b)</code>, <code>s_crosses(a, b)</code>, and <code>s_contains(a, b)</code> corresponds
to CQL2 <code>S_INTERSECTS(a, b)</code>, <code>S_TOUCHES(a, b)</code>, <code>S_WITHIN(a, b)</code>,
<code>S_OVERLAPS(a, b)</code>, <code>S_CROSSES(a, b)</code>, and <code>S_CONTAINS(a, b)</code> operators,
respectively. Here, <code>a</code> and <code>b</code> should be <code>geometry</code> objects. <code>rstac</code>
accepts <code>sf</code>, <code>sfc</code>, <code>sfg</code>, <code>list</code> (representing GeoJSON objects), or
<code>character</code> (representing either GeoJSON or WKT).
</p>
</li>
<li> <p><strong>NOTE</strong>: All of the above spatial object types, except for the
<code>character</code>, representing a WKT, may lose precision due to numeric
truncation when R converts numbers to JSON text. WKT strings are
sent "as is" to the service. Therefore, the only way for users to
retain precision on spatial objects is to represent them as a WKT
string. However, user can control numeric precision using the
<code>options(stac_digits = ...)</code>. The default value is 15 digits.
</p>
</li>
</ul>
<h4>Temporal operators</h4>


<ul>
<li>
<p> functions <code>date(a)</code>, <code>timestamp(a)</code>, and <code>interval(a, b)</code> corresponds to
CQL2 <code>DATE(a)</code>, <code>TIMESTAMP(a)</code>, and <code>INTERVAL(a, b)</code> operators,
respectively. These functions create literal <code>temporal</code> values.
The first two define an <code>instant</code> type, and the third an <code>interval</code> type.
</p>
</li>
<li>
<p> functions <code>t_after(a, b)</code>, <code>t_before(a, b)</code>, <code>t_contains(a, b)</code>,
<code>t_disjoint(a, b)</code>, <code>t_during(a, b)</code>, <code>t_equals(a, b)</code>,
<code>t_finishedby(a, b)</code>, <code>t_finishes(a, b)</code>, <code>t_intersects(a, b)</code>,
<code>t_meets(a, b)</code>, <code>t_meet(a, b)</code>, <code>t_metby(a, b)</code>, <code>t_overlappedby(a, b)</code>,
<code>t_overlaps(a, b)</code>, <code>t_startedby(a, b)</code>, and <code>t_starts(a, b)</code> corresponds
to CQL2 <code>T_AFTER(a, b)</code>, <code>T_BEFORE(a, b)</code>, <code>T_CONTAINS(a, b)</code>,
<code>T_DISJOINT(a, b)</code>, <code>T_DURING(a, b)</code>, <code>T_EQUALS(a, b)</code>,
<code>T_FINISHEDBY(a, b)</code>, <code>T_FINISHES(a, b)</code>, <code>T_INTERSECTS(a, b)</code>,
<code>T_MEETS(a, b)</code>, <code>T_MEET(a, b)</code>, <code>T_METBY(a, b)</code>, <code>T_OVERLAPPEDBY(a, b)</code>,
<code>T_OVERLAPS(a, b)</code>, <code>T_STARTEDBY(a, b)</code>, and <code>T_STARTS(a, b)</code> operators,
respectively. Here, <code>a</code> and <code>b</code> are <code>temporal</code> values (<code>instant</code> or
<code>interval</code>, depending on function).
</p>
</li>
</ul>
<h4>Array Operators</h4>


<ul>
<li>
<p> R unnamed lists (or vectors of size &gt; 1) are translated to arrays by
<code>rstac</code>. <code>list()</code> and <code>c()</code> functions always create <code>array</code> values
in CQL2 context, no matter the number of its arguments.
</p>
</li>
<li>
<p> functions <code>a_equals(a, b)</code>, <code>a_contains(a, b)</code>, <code>a_containedby(a, b)</code>,
and <code>a_overlaps(a, b)</code> corresponds to CQL2 <code>A_EQUALS(a, b)</code>,
<code>A_CONTAINS(a, b)</code>, <code>A_CONTAINEDBY(a, b)</code>, and <code>A_OVERLAPS(a, b)</code>
operators, respectively. Here, <code>a</code> and <code>b</code> should be <code>arrays</code>.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>rstac_query</code> object  with the subclass <code>ext_filter</code> containing
all request parameters to be passed to <code>get_request()</code> or
<code>post_request()</code> function.
</p>


<h3>Note</h3>

<p>The specification states that double-quoted identifiers should be
interpreted as properties. However, the R language does not distinguish
double quote from single quote strings. The right way to represent
double quoted properties in R is to use the escape character (<code style="white-space: pre;">⁠), for example ⁠</code>"date"'.
</p>


<h3>See Also</h3>

<p><code>ext_query()</code>, <code>stac_search()</code>, <code>post_request()</code>,
<code>before_request()</code>, <code>after_response()</code>, <code>content_response()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Standard comparison operators in rstac:
# Creating a stac search query
req &lt;- stac("https://planetarycomputer.microsoft.com/api/stac/v1") %&gt;%
  stac_search(limit = 5)

# Equal operator '=' with collection property
req %&gt;% ext_filter(collection == "sentinel-2-l2a") %&gt;% post_request()

# Not equal operator '!=' with collection property
req %&gt;% ext_filter(collection != "sentinel-2-l2a") %&gt;% post_request()

# Less than or equal operator '&lt;=' with datetime property
req %&gt;% ext_filter(datetime &lt;= "1986-01-01") %&gt;% post_request()

# Greater than or equal '&gt;=' with AND operator
req %&gt;% ext_filter(collection == "sentinel-2-l2a"   &amp;&amp;
                   `s2:vegetation_percentage` &gt;= 50 &amp;&amp;
                   `eo:cloud_cover` &lt;= 10) %&gt;% post_request()
# Advanced comparison operators
# 'LIKE' operator
req %&gt;% ext_filter(collection %like% "modis%") %&gt;% post_request()

# 'IN' operator
req %&gt;% ext_filter(
  collection %in% c("landsat-c2-l2", "sentinel-2-l2a") &amp;&amp;
    datetime &gt; "2019-01-01" &amp;&amp;
    datetime &lt; "2019-06-01") %&gt;%
  post_request()

# Spatial operator
# Lets create a polygon with list
polygon &lt;- list(
  type = "Polygon",
  coordinates = list(
    matrix(c(-62.34499836, -8.57414572,
             -62.18858174, -8.57414572,
             -62.18858174, -8.15351185,
             -62.34499836, -8.15351185,
             -62.34499836, -8.57414572),
           ncol = 2, byrow = TRUE)
  )
)
# 'S_INTERSECTS' spatial operator with polygon and geometry property
req %&gt;% ext_filter(collection == "sentinel-2-l2a" &amp;&amp;
                   s_intersects(geometry, {{polygon}})) %&gt;% post_request()

# 'S_CONTAINS' spatial operator with point and geometry property
point &lt;- list(type = "Point", coordinates = c(-62.45792211, -8.61158488))
req %&gt;% ext_filter(collection == "landsat-c2-l2" &amp;&amp;
                   s_contains(geometry, {{point}})) %&gt;% post_request()

# 'S_CROSSES' spatial operator with linestring and geometry property
linestring &lt;- list(
  type = "LineString",
  coordinates = matrix(
         c(-62.55735320, -8.43329465, -62.21791603, -8.36815014),
         ncol = 2, byrow = TRUE
  )
)
req %&gt;% ext_filter(collection == "landsat-c2-l2" &amp;&amp;
                   s_crosses(geometry, {{linestring}})) %&gt;% post_request()

# Temporal operator
# 'T_INTERSECTS' temporal operator with datetime property
req %&gt;% ext_filter(
  collection == "landsat-c2-l2" &amp;&amp;
    t_intersects(datetime, interval("1985-07-16T05:32:00Z",
                                    "1985-07-24T16:50:35Z"))) %&gt;%
 post_request()

# 'T_DURING' temporal operator with datetime property
req %&gt;%
 ext_filter(collection == "landsat-c2-l2" &amp;&amp;
            t_during(datetime,
            interval("2022-07-16T05:32:00Z", ".."))) %&gt;%
 post_request()

# 'T_BEFORE' temporal operator with datetime property
req %&gt;%
 ext_filter(collection == "landsat-c2-l2" &amp;&amp;
            t_before(datetime, timestamp("2022-07-16T05:32:00Z"))) %&gt;%
 post_request()

# 'T_AFTER' temporal operator with datetime property
req %&gt;%
 ext_filter(collection == "landsat-c2-l2" &amp;&amp;
            t_after(datetime, timestamp("2022-07-16T05:32:00Z"))) %&gt;%
  post_request()

# Shows how CQL2 expression (TEXT format)
cql2_text(collection == "landsat-c2-l2" &amp;&amp;
  s_crosses(geometry, {{linestring}}))

# Shows how CQL2 expression (JSON format)
cql2_json(collection == "landsat-c2-l2" &amp;&amp;
            t_after(datetime, timestamp("2022-07-16T05:32:00Z")))

## End(Not run)

</code></pre>


</div>