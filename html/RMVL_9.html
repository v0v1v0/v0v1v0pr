<div class="container">

<table style="width: 100%;"><tr>
<td>mvl_extent_index_lapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply function to indices of rows with matching hashes</h2>

<h3>Description</h3>

<p>Please use generic function <code>mvl_index_lapply()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mvl_extent_index_lapply(extent_index, data_list, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>extent_index</code></td>
<td>
<p>MVL_OBJECT computed by <code>mvl_write_extent_index()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_list</code></td>
<td>
<p>a list of vectors of equal length. They can be MVL_OBJECTs or R vectors. If missing, scan the entire table one hash at a time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>a function of two arguments - and index into <code>data_list</code> and a corresponding list of indices</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is passed the index computed by <code>mvl_write_extent_index()</code> and a list of vectors, which rows are used to compute 64-bit hashes.
For each row, we call the function <code>fn(i, idx)</code>, where <code>i</code> gives the index of query row, and <code>idx</code> gives the indices of with matching hashes.
</p>
<p>64-bit hashes have very few collisions, nevertheless the user is advised to double check that the values actually match.
</p>
<p>The hash computation is type dependent, so <code>1</code> stored as an integer will produce a different hash than when stored as floating point. This function accounts for this by internally converting to types the index was generated with.
</p>


<h3>Value</h3>

<p>a list of results of function <code>fn</code>
</p>


<h3>See Also</h3>

<p><code>mvl_index_lapply</code>, <code>mvl_group</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=(1:100) %% 10), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_extent_index(Mtmp, list(Mtmp$df1[,"y",ref=TRUE]), "df1_extent_index_y")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_extent_index_lapply(Mtmp["df1_extent_index_y", ref=TRUE], list(c(2, 3)),
                                           function(i, idx) { return(list(i, idx))})
# Example of full scan
mvl_extent_index_lapply(Mtmp["df1_extent_index_y", ref=TRUE], ,
                                           function(i, idx) { return(list(i, idx))})

## End(Not run)
</code></pre>


</div>