<div class="container">

<table style="width: 100%;"><tr>
<td>lwplsrda_agg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Aggregation of KNN-LWPLSDA models with different numbers of LVs</h2>

<h3>Description</h3>

<p>Ensemblist method where the predictions are calculated by "averaging" the predictions of KNN-LWPLSDA models built with different numbers of latent variables (LVs). 
</p>
<p>For instance, if argument <code>nlv</code> is set to <code>nlv = "5:10"</code>, the prediction for a new observation is the most occurent level (vote) over the predictions returned by the models with 5 LVS, 6 LVs, ... 10 LVs, respectively.
</p>
<p>- <code>lwplsrda_agg</code>: use <code>plsrda</code>.
</p>
<p>- <code>lwplslda_agg</code>: use <code>plslda</code>.
</p>
<p>- <code>lwplsqda_agg</code>: use <code>plsqda</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
lwplsrda_agg(
    X, y,
    nlvdis, diss = c("eucl", "mahal"),
    h, k,
    nlv,
    cri = 4,
    verb = FALSE
    ) 

lwplslda_agg(
    X, y,
    nlvdis, diss = c("eucl", "mahal"),
    h, k,
    nlv, 
    prior = c("unif", "prop"),
    cri = 4,
    verb = FALSE
    ) 

lwplsqda_agg(
    X, y,
    nlvdis, diss = c("eucl", "mahal"),
    h, k,
    nlv, 
    prior = c("unif", "prop"),
    cri = 4,
    verb = FALSE
    ) 

## S3 method for class 'Lwplsrda_agg'
predict(object, X, ...)

## S3 method for class 'Lwplsprobda_agg'
predict(object, X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>For the main functions: Training X-data (<code class="reqn">n, p</code>). â€” For the auxiliary functions: New X-data (<code class="reqn">m, p</code>) to consider.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Training class membership (<code class="reqn">n</code>). <b>Note:</b> If <code>y</code> is a factor, it is replaced by a character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlvdis</code></td>
<td>
<p>The number of LVs to consider in the global PLS used for the dimension reduction before calculating the dissimilarities. If <code>nlvdis = 0</code>, there is no dimension reduction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diss</code></td>
<td>
<p>The type of dissimilarity used for defining the neighbors. Possible values are "eucl" (default; Euclidean distance), "mahal" (Mahalanobis distance), or "correlation". Correlation dissimilarities are calculated by sqrt(.5 * (1 - rho)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>A scale scalar defining the shape of the weight function. Lower is <code class="reqn">h</code>, sharper is the function. See <code>wdist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of nearest neighbors to select for each observation to predict.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlv</code></td>
<td>
<p>A character string such as "5:20" defining the range of the numbers of LVs to consider (here: the models with nb LVS = 5, 6, ..., 20 are averaged). Syntax such as "10" is also allowed (here: correponds to the single model with 10 LVs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>For <code>lwplslda_agg</code> and <code>lwplsqda_agg</code>: The prior probabilities of the classes. Possible values are "unif" (default; probabilities are set equal for all the classes) or "prop" (probabilities are set equal to the observed proportions of the classes in <code>y</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cri</code></td>
<td>
<p>Argument <code>cri</code> in function <code>wdist</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p>Logical. If <code>TRUE</code>, fitting information are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>For the auxiliary functions: A fitted model, output of a call to the main function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For the auxiliary functions: Optional arguments. Not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>lwplsrda_agg</code>, <code>lwplslda_agg</code> and <code>lwplsqda_agg</code>: object of class <code>lwplsrda_agg</code>, <code>lwplslda_agg</code> or <code>lwplsqda_agg</code>
</p>
<p>For <code>predict.Lwplsrda_agg</code> and <code>predict.Lwplsprobda_agg</code>: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>prediction calculated for each observation, which is the most occurent level (vote) over the predictions returned by the models with different numbers of LVS respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listnn</code></td>
<td>
<p>list with the neighbors used for each observation to be predicted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listd</code></td>
<td>
<p>list with the distances to the neighbors used for each observation to be predicted</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>list with the weights attributed to the neighbors used for each observation to be predicted</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The first example concerns KNN-LWPLSRDA-AGG.
The second example concerns KNN-LWPLSLDA-AGG. 
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## KNN-LWPLSRDA-AGG

n &lt;- 40 ; p &lt;- 7
X &lt;- matrix(rnorm(n * p), ncol = p, byrow = TRUE)
y &lt;- sample(c(1, 4, 10), size = n, replace = TRUE)

Xtrain &lt;- X ; ytrain &lt;- y
m &lt;- 5
Xtest &lt;- X[1:m, ] ; ytest &lt;- y[1:m]

nlvdis &lt;- 5 ; diss &lt;- "mahal"
h &lt;- 2 ; k &lt;- 10
nlv &lt;- "2:4" 
fm &lt;- lwplsrda_agg(
    Xtrain, ytrain, 
    nlvdis = nlvdis, diss = diss,
    h = h, k = k,
    nlv = nlv)
res &lt;- predict(fm, Xtest)
res$pred
res$listnn


nlvdis &lt;- 5 ; diss &lt;- "mahal"
h &lt;- c(2, Inf)
k &lt;- c(10, 15)
nlv &lt;- c("1:3", "2:4")
pars &lt;- mpars(nlvdis = nlvdis, diss = diss,
              h = h, k = k, nlv = nlv)
pars

res &lt;- gridscore(
    Xtrain, ytrain, Xtest, ytest, 
    score = err, 
    fun = lwplsrda_agg, 
    pars = pars)
res

segm &lt;- segmkf(n = n, K = 3, nrep = 1)
res &lt;- gridcv(
    Xtrain, ytrain, 
    segm, score = err, 
    fun = lwplsrda_agg, 
    pars = pars,
    verb = TRUE)
names(res)
res$val


## KNN-LWPLSLDA-AGG

n &lt;- 40 ; p &lt;- 7
X &lt;- matrix(rnorm(n * p), ncol = p, byrow = TRUE)
y &lt;- sample(c(1, 4, 10), size = n, replace = TRUE)

Xtrain &lt;- X ; ytrain &lt;- y
m &lt;- 5
Xtest &lt;- X[1:m, ] ; ytest &lt;- y[1:m]

nlvdis &lt;- 5 ; diss &lt;- "mahal"
h &lt;- 2 ; k &lt;- 10
nlv &lt;- "2:4" 
fm &lt;- lwplslda_agg(
    Xtrain, ytrain, 
    nlvdis = nlvdis, diss = diss,
    h = h, k = k,
    nlv = nlv, prior = "prop")
res &lt;- predict(fm, Xtest)
res$pred
res$listnn

nlvdis &lt;- 5 ; diss &lt;- "mahal"
h &lt;- c(2, Inf)
k &lt;- c(10, 15)
nlv &lt;- c("1:3", "2:4")
pars &lt;- mpars(nlvdis = nlvdis, diss = diss,
              h = h, k = k, nlv = nlv, 
              prior = c("unif", "prop"))
pars

res &lt;- gridscore(
    Xtrain, ytrain, Xtest, ytest, 
    score = err, 
    fun = lwplslda_agg, 
    pars = pars)
res

segm &lt;- segmkf(n = n, K = 3, nrep = 1)
res &lt;- gridcv(
    Xtrain, ytrain, 
    segm, score = err, 
    fun = lwplslda_agg, 
    pars = pars,
    verb = TRUE)
names(res)
res$val

</code></pre>


</div>