<div class="container">

<table style="width: 100%;"><tr>
<td>Ugraph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Visualize undirected graph</h2>

<h3>Description</h3>

<p>Function that visualizes the sparsified precision matrix as an undirected
graph.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Ugraph(
  M,
  type = c("plain", "fancy", "weighted"),
  lay = "layout_in_circle",
  coords = NULL,
  Vsize = 15,
  Vcex = 1,
  Vcolor = "orangered",
  VBcolor = "darkred",
  VLcolor = "black",
  prune = FALSE,
  legend = FALSE,
  label = "",
  Lcex = 1.3,
  PTcex = 4,
  cut = 0.5,
  scale = 10,
  pEcolor = "black",
  nEcolor = "grey",
  main = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>(Possibly sparsified) precision <code>matrix</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A <code>character</code> indicating the type of graph to be produced.
Must be one of: "plain", "fancy", "weighted".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lay</code></td>
<td>
<p>A <code>character</code> mimicking a call to <code>igraph</code>
layout functions. Determines the placement of vertices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>A <code>matrix</code> containing coordinates. Alternative to the
lay-argument for determining the placement of vertices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vsize</code></td>
<td>
<p>A <code>numeric</code> determining the vertex size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vcex</code></td>
<td>
<p>A <code>numeric</code> determining the size of the vertex labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vcolor</code></td>
<td>
<p>A <code>character</code> (scalar or vector) determining the vertex
color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VBcolor</code></td>
<td>
<p>A <code>character</code> determining the color of the vertex
border.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VLcolor</code></td>
<td>
<p>A <code>character</code> determining the color of the vertex
labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prune</code></td>
<td>
<p>A <code>logical</code> determining if vertices of degree 0 should be
removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>A <code>logical</code> indicating if the graph should come with a
legend.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>A <code>character</code> giving a name to the legend label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lcex</code></td>
<td>
<p>A <code>numeric</code> determining the size of the legend box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PTcex</code></td>
<td>
<p>A <code>numeric</code> determining the size of the exemplary vertex
in the legend box.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut</code></td>
<td>
<p>A <code>numeric</code> indicating the cut-off for indicating strong
edges when <code>type = "fancy"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>A <code>numeric</code> representing a scale factor for visualizing
strength of edges when <code>type = "weighted"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pEcolor</code></td>
<td>
<p>A <code>character</code> determining the color of the edges tied to
positive precision elements. Only when <code>type = "weighted"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nEcolor</code></td>
<td>
<p>A <code>character</code> determining the color of the edges tied to
negative precision elements. Only when <code>type = "weighted"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>A <code>character</code> giving the main figure title.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The intended use of this function is to visualize a sparsified
precision/partial correlation matrix as an undirected graph. When <code>type
= "plain"</code> a plain undirected graph is given representing the conditional
(in)dependencies exemplified by the sparsified precision.
</p>
<p>When <code>type = "fancy"</code> a more elaborate graph is given in which dashed
lines indicate negative partial correlations while solid lines indicate
positive partial correlations, and in which grey lines indicate strong
edges. Strong edges are deemed such by setting <code>cut</code>. If a the absolute
value of a precision element <code class="reqn">\geq</code> <code>cut</code> the corresponding edge is
deemed strong and colored grey in the graph. The argument <code>cut</code> is thus
only used when <code>type = "fancy"</code>.
</p>
<p>When <code>type = "weighted"</code> an undirected graph is given in which edge
thickness represents the strength of the partial correlations. The
<code>nEcolor</code> colored edges then represent negative partial correlations
while <code>pEcolor</code> colored edges represent positive partial correlations.
(Relative) edge thickness in this type of graph can be set by the argument
<code>scale</code>. The arguments <code>scale</code>, <code>nEcolor</code>, and <code>pEcolor</code>
are thus only used when <code>type = "weighted"</code>.
</p>
<p>The default layout gives a circular placement of the vertices. Most layout
functions supported by <code>igraph</code> are supported (the function is
partly a wrapper around certain <code>igraph</code> functions). The igraph
layouts can be invoked by a <code>character</code> that mimicks a call to a
<code>igraph</code> layout functions in the <code>lay</code> argument. When using
<code>lay = NULL</code> one can specify the placement of vertices with the
<code>coords</code> argument. The row dimension of this matrix should equal the
number of (pruned) vertices. The column dimension then should equal 2 (for
2D layouts) or 3 (for 3D layouts). The <code>coords</code> argument can also be
viewed as a convenience argument as it enables one, e.g., to layout a graph
according to the coordinates of a previous call to <code>Ugraph</code>. If both
the the lay and the coords arguments are not <code>NULL</code>, the lay argument
takes precedence
</p>
<p>The legend allows one to specify the kind of variable the vertices
represent, such as, e.g., mRNA transcripts. The arguments <code>label</code>,
<code>Lcex</code>, and <code>PTcex</code> are only used when <code>legend = TRUE</code>.
</p>
<p>If <code>prune = TRUE</code> the vertices of degree 0 (vertices not implicated by
any edge) are removed. For the colors supported by the arguments
<code>Vcolor</code>, <code>VBcolor</code>, <code>VLcolor</code>, <code>pEcolor</code>, and
<code>nEcolor</code> see <a href="https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf">https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf</a>.
</p>


<h3>Value</h3>

<p>The function returns a graph. The function also returns a
<code>matrix</code> object containing the coordinates of the vertices in the given
graph.
</p>


<h3>Author(s)</h3>

<p>Carel F.W. Peeters &lt;carel.peeters@wur.nl&gt;
</p>


<h3>References</h3>

<p>Csardi, G. and Nepusz, T. (2006). The igraph software package
for complex network research. InterJournal, Complex Systems 1695.
http://igraph.sf.net
</p>
<p>van Wieringen, W.N. &amp; Peeters, C.F.W. (2016). Ridge Estimation of Inverse
Covariance Matrices from High-Dimensional Data, Computational Statistics &amp;
Data Analysis, vol. 103: 284-303. Also available as arXiv:1403.0904v3
[stat.ME].
</p>
<p>van Wieringen, W.N. &amp; Peeters, C.F.W. (2015). Application of a New Ridge
Estimator of the Inverse Covariance Matrix to the Reconstruction of
Gene-Gene Interaction Networks. In: di Serio, C., Lio, P., Nonis, A., and
Tagliaferri, R. (Eds.) 'Computational Intelligence Methods for
Bioinformatics and Biostatistics'. Lecture Notes in Computer Science, vol.
8623. Springer, pp. 170-179.
</p>


<h3>See Also</h3>

<p><code>ridgeP</code>, <code>optPenalty.LOOCV</code>,
<code>optPenalty.aLOOCV</code>, <code>sparsify</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Obtain some (high-dimensional) data
p = 25
n = 10
set.seed(333)
X = matrix(rnorm(n*p), nrow = n, ncol = p)
colnames(X)[1:25] = letters[1:25]

## Obtain regularized precision under optimal penalty
OPT &lt;- optPenalty.LOOCV(X, lambdaMin = .5, lambdaMax = 30, step = 100)

## Determine support regularized standardized precision under optimal penalty
PC0 &lt;- sparsify(symm(OPT$optPrec), threshold = "localFDR")$sparseParCor

## Obtain graphical representation
Ugraph(PC0, type = "fancy", cut = 0.07)

## Obtain graphical representation with Fruchterman-Reingold layout
Ugraph(PC0, type = "fancy", lay = "layout_with_fr", cut = 0.07)

## Add pruning
Ugraph(PC0, type = "fancy", lay = "layout_with_fr",
       cut = 0.07, prune = TRUE)

## Obtain graph and its coordinates
Coordinates &lt;- Ugraph(PC0, type = "fancy", lay = "layout_with_fr",
                      cut = 0.07, prune = TRUE)
Coordinates

</code></pre>


</div>