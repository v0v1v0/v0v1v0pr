<div class="container">

<table style="width: 100%;"><tr>
<td>cp_int2</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ATLD-ALS algorithm for Candecomp/Parafac (CP)</h2>

<h3>Description</h3>

<p>Integrated algorithm combining ATLD and ALS for the
minimization of the Candecomp/Parafac (CP) loss function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cp_int2(
  X,
  n,
  m,
  p,
  ncomp,
  initconv = 0.01,
  conv = 1e-06,
  const = "none",
  start = "random",
  maxit = 5000,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A three-way array or a matrix. If <code>X</code> is a matrix
(matricised threeway array), <code>n</code>, <code>m</code> and <code>p</code> must be
given and are the number of A-, B- and C-mode entities respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of A-mode entities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of B-mode entities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Number of C-mode entities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>Number of components to extract</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initconv</code></td>
<td>
<p>Convergence criterion for the initialization phase (ATLD),
default is <code>conv=1e-2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>Convergence criterion, default is <code>conv=1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>Optional constraints for each mode. Can be a three element
character vector or a single character, one of <code>"none"</code> for no
constraints (default), <code>"orth"</code> for orthogonality constraints or
<code>"zerocor"</code> for zero correlation between the extracted factors.
For example, <code>const="orth"</code> means orthogonality constraints for
all modes, while <code>const=c("orth", "none", "none")</code> sets the
orthogonality constraint only for mode A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be
<code>"svd"</code> for starting point of the algorithm from SVD's,
<code>"random"</code> for random starting point (orthonormalized
component matrices or nonnegative matrices in case of nonnegativity
constraint), or a list containing user specified components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations, default is <code>maxit=10000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Logical, provide trace output.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The result of the decomposition as a list with the following
elements:
</p>

<ul>
<li> <p><code>fit</code> Value of the loss function
</p>
</li>
<li> <p><code>fp</code> Fit value expressed as a percentage
</p>
</li>
<li> <p><code>ss</code> Sum of squares
</p>
</li>
<li> <p><code>A</code> Component matrix for the A-mode
</p>
</li>
<li> <p><code>B</code> Component matrix for the B-mode
</p>
</li>
<li> <p><code>C</code> Component matrix for the C-mode
</p>
</li>
<li> <p><code>iter</code> Number of iterations
</p>
</li>
<li> <p><code>tripcos</code> Minimal triple cosine between two components
across the three component matrices, used to inspect degeneracy
</p>
</li>
<li> <p><code>mintripcos</code> Minimal triple cosine during the iterative
algorithm observed at every 10 iterations, used to inspect degeneracy
</p>
</li>
<li> <p><code>ftiter</code> Matrix containing in each row the function value
and the minimal triple cosine at every 10 iterations
</p>
</li>
<li> <p><code>const</code> Optional constraints (same as the input parameter
<code>const</code>)
</p>
</li>
</ul>
<h3>Note</h3>

<p>The argument <code>const</code> should be a three element character vector.
Set <code>const[j]="none"</code> for unconstrained update in j-th mode weight
matrix (the default),
<code>const[j]="orth"</code> for orthogonal update in j-th mode weight matrix or
<code>const[j]="zerocor"</code> for zero correlation between the extracted
factors.
The default is unconstrained update for all modes.
</p>
<p>The loss function to be minimized is <code class="reqn">sum(k)|| X(k) - A D(k) B' ||^2</code>,
where <code class="reqn">D(k)</code> is a diagonal matrix holding the <code>k</code>-th row of
<code>C</code>.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>; Violetta Simonacci, <a href="mailto:violetta.simonacci@unina.it">violetta.simonacci@unina.it</a>
</p>


<h3>References</h3>

<p>H.-L. Wu, M. Shibukawa, K. Oguma, An alternating trilinear decomposition
algorithm with application to calibration of HPLC-DAD for
simultaneous determination of overlapped chlorinated aromatic hydrocarbons,
<em>Journal of Chemometrics</em> <b>12</b> (1998) 1–26.
</p>
<p>Simonacci, V. and Gallo, M. (2020). An ATLD–ALS method for the trilinear decomposition
of large third-order tensors, <em>Soft Computing</em> 24 13535–13546.
</p>
<p>Todorov, V. and Simonacci, V. and Gallo, M. and Trendafilov, N. (2023). A novel 
estimation procedure for robust CANDECOMP/PARAFAC model fitting. 
<em>Econometrics and Statistics</em>. In press.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
## Example with the OECD data
 data(elind)
 dim(elind)

 res &lt;- cp_int2(elind, ncomp=3)
 res$fp
 res$fp
 res$iter

 res &lt;- cp_int2(elind, ncomp=3, const="orth")
 res$A

## End(Not run)
</code></pre>


</div>