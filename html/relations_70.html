<div class="container">

<table style="width: 100%;"><tr>
<td>predicates</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Relation Predicates</h2>

<h3>Description</h3>

<p>Predicate functions for testing for binary relations and
endorelations, and special kinds thereof.
</p>


<h3>Usage</h3>

<pre><code class="language-R">relation_is(x, predicate, ...)
relation_is_Euclidean(x, na.rm = FALSE)
relation_is_Ferrers(x, na.rm = FALSE)
relation_is_acyclic(x)
relation_is_antisymmetric(x, na.rm = FALSE)
relation_is_asymmetric(x, na.rm = FALSE)
relation_is_bijective(x)
relation_is_binary(x)
relation_is_complete(x, na.rm = FALSE)
relation_is_coreflexive(x, na.rm = FALSE)
relation_is_crisp(x, na.rm = FALSE)
relation_is_cyclic(x)
relation_is_endorelation(x)
relation_is_equivalence(x, na.rm = FALSE)
relation_is_functional(x)
relation_is_homogeneous(x)
relation_is_injective(x)
relation_is_interval_order(x, na.rm = FALSE)
relation_is_irreflexive(x, na.rm = FALSE)
relation_is_left_total(x)
relation_is_linear_order(x, na.rm = FALSE)
relation_is_match(x, na.rm = FALSE)
relation_is_negatively_transitive(x, na.rm = FALSE)
relation_is_partial_order(x, na.rm = FALSE)
relation_is_preference(x, na.rm = FALSE)
relation_is_preorder(x, na.rm = FALSE)
relation_is_quasiorder(x, na.rm = FALSE)
relation_is_quasitransitive(x, na.rm = FALSE)
relation_is_quaternary(x)
relation_is_reflexive(x, na.rm = FALSE)
relation_is_right_total(x)
relation_is_semiorder(x, na.rm = FALSE)
relation_is_semitransitive(x, na.rm = FALSE)
relation_is_strict_linear_order(x, na.rm = FALSE)
relation_is_strict_partial_order(x, na.rm = FALSE)
relation_is_strongly_complete(x, na.rm = FALSE)
relation_is_surjective(x)
relation_is_symmetric(x, na.rm = FALSE)
relation_is_ternary(x)
relation_is_tournament(x, na.rm = FALSE)
relation_is_transitive(x, na.rm = FALSE)
relation_is_trichotomous(x, na.rm = FALSE)
relation_is_weak_order(x, na.rm = FALSE)
relation_has_missings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object inheriting from class <code>relation</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>a logical indicating whether tuples with missing
memberships are excluded in the predicate computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicate</code></td>
<td>
<p>character vector matching one of the following (see <b>details</b>):
<code>"binary"</code>,
<code>"ternary"</code>,
<code>"quaternary"</code>,
<code>"left_total"</code>,
<code>"right_total"</code>,
<code>"surjective"</code>,
<code>"functional"</code>,
<code>"injective"</code>,
<code>"bijective"</code>,
<code>"endorelation"</code>,
<code>"homogeneous"</code>,
<code>"crisp"</code>,
<code>"complete"</code>,
<code>"match"</code>,
<code>"strongly_complete"</code>,
<code>"reflexive"</code>,
<code>"irreflexive"</code>,
<code>"coreflexive"</code>,
<code>"symmetric"</code>,
<code>"asymmetric"</code>,
<code>"antisymmetric"</code>,
<code>"transitive"</code>,
<code>"negatively_transitive"</code>,
<code>"quasitransitive"</code>,
<code>"Ferrers"</code>,
<code>"semitransitive"</code>,
<code>"trichotomous"</code>,
<code>"Euclidean"</code>,
<code>"equivalence"</code>,
<code>"weak_order"</code>,
<code>"preference"</code>,
<code>"preorder"</code>,
<code>"quasiorder"</code>,
<code>"partial_order"</code>,
<code>"linear_order"</code>,
<code>"strict_partial_order"</code>,
<code>"strict_linear_order"</code>,
<code>"tournament"</code>,
<code>"interval_order"</code>,
<code>"semiorder"</code>,
<code>"acyclic"</code>
<code>"cyclic"</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the predicate functions
(currently, only <code>na.rm</code> for most predicates).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This help page documents the predicates currently available. Note that
the preferred way is to use the meta-predicate function
<code>relation_is(x, "FOO")</code> instead of the individual predicates
<code>relation_is_FOO(x)</code> since the latter will become deprecated in
future releases.
</p>
<p>A binary relation is a relation with arity 2.
</p>
<p>A relation <code class="reqn">R</code> on a set <code class="reqn">X</code> is called
<em>homogeneous</em> iff <code class="reqn">D(R) = (X, \dots, X)</code>.
</p>
<p>An <em>endorelation</em> is a binary homogeneous relation.
</p>
<p>For a crisp binary relation, let us write <code class="reqn">x R y</code> iff <code class="reqn">(x, y)</code>
is contained in <code class="reqn">R</code>.
</p>
<p>A crisp binary relation <code class="reqn">R</code> is called
</p>

<dl>
<dt>left-total:</dt>
<dd>
<p>for all <code class="reqn">x</code> there is at least one <code class="reqn">y</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>right-total:</dt>
<dd>
<p>for all <code class="reqn">y</code> there is at least one <code class="reqn">x</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>functional:</dt>
<dd>
<p>for all <code class="reqn">x</code> there is at most one <code class="reqn">y</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>surjective:</dt>
<dd>
<p>the same as right-total.</p>
</dd>
<dt>injective:</dt>
<dd>
<p>for all <code class="reqn">y</code> there is at most one <code class="reqn">x</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>bijective:</dt>
<dd>
<p>left-total, right-total, functional and
injective.</p>
</dd>
</dl>
<p>A crisp endorelation <code class="reqn">R</code> is called
</p>

<dl>
<dt>reflexive:</dt>
<dd>
<p><code class="reqn">x R x</code> for all <code class="reqn">x</code>.</p>
</dd>
<dt>irreflexive:</dt>
<dd>
<p>there is no <code class="reqn">x</code> such that <code class="reqn">x R x</code>.</p>
</dd>
<dt>coreflexive:</dt>
<dd>
<p><code class="reqn">x R y</code> implies <code class="reqn">x = y</code>.</p>
</dd>
<dt>symmetric:</dt>
<dd>
<p><code class="reqn">x R y</code> implies <code class="reqn">y R x</code>.</p>
</dd>
<dt>asymmetric:</dt>
<dd>
<p><code class="reqn">x R y</code> implies that not <code class="reqn">y R x</code>.</p>
</dd>
<dt>antisymmetric:</dt>
<dd>
<p><code class="reqn">x R y</code> and <code class="reqn">y R x</code> imply that
<code class="reqn">x = y</code>.</p>
</dd>
<dt>transitive:</dt>
<dd>
<p><code class="reqn">x R y</code> and <code class="reqn">y R z</code> imply that
<code class="reqn">x R z</code>.</p>
</dd>
<dt>complete:</dt>
<dd>
<p>for all distinct <code class="reqn">x</code> and <code class="reqn">y</code>, <code class="reqn">x R y</code>
or <code class="reqn">y R x</code>.</p>
</dd>
<dt>strongly complete:</dt>
<dd>
<p>for all <code class="reqn">x</code> and <code class="reqn">y</code>, <code class="reqn">x R y</code>
or <code class="reqn">y R x</code> (i.e., complete and reflexive).</p>
</dd>
<dt>negatively transitive:</dt>
<dd>
<p>not <code class="reqn">x R y</code> and not <code class="reqn">y R z</code>
imply that not <code class="reqn">x R z</code>.</p>
</dd>
<dt>Ferrers:</dt>
<dd>
<p><code class="reqn">x R y</code> and <code class="reqn">z R w</code> imply <code class="reqn">x R w</code> or
<code class="reqn">y R z</code>.</p>
</dd>
<dt>semitransitive:</dt>
<dd>
<p><code class="reqn">x R y</code> and <code class="reqn">y R z</code> imply <code class="reqn">x R w</code>
or <code class="reqn">w R z</code>.</p>
</dd>
<dt>quasitransitive:</dt>
<dd>
<p><code class="reqn">x R y</code> and not <code class="reqn">y R x</code> and
<code class="reqn">y R z</code> and not <code class="reqn">z R y</code> imply
<code class="reqn">x R z</code> and not <code class="reqn">z R x</code>
(i.e., the asymmetric part of <code class="reqn">R</code> is transitive).</p>
</dd>
<dt>trichotomous:</dt>
<dd>
<p>exactly one of <code class="reqn">x R y</code>, <code class="reqn">y R x</code>, or
<code class="reqn">x = y</code> holds.</p>
</dd>
<dt>Euclidean:</dt>
<dd>
<p><code class="reqn">x R y</code> and <code class="reqn">x R z</code> imply <code class="reqn">y R z</code>.</p>
</dd>
<dt>acyclic:</dt>
<dd>
<p>the transitive closure of R is antisymmetric.</p>
</dd>
<dt>cyclic:</dt>
<dd>
<p>R is not acyclic.</p>
</dd>
</dl>
<p>Some combinations of these basic properties have special names
because of their widespread use:
</p>

<dl>
<dt>preorder:</dt>
<dd>
<p>reflexive and transitive.</p>
</dd>
<dt>quasiorder:</dt>
<dd>
<p>the same as preorder.</p>
</dd>
<dt>equivalence:</dt>
<dd>
<p>a symmetric preorder (reflexive, symmetric, and
transitive).</p>
</dd>
<dt>weak order:</dt>
<dd>
<p>a complete preorder (complete, reflexive, and
transitive).</p>
</dd>
<dt>preference:</dt>
<dd>
<p>the same as weak order.</p>
</dd>
<dt>partial order:</dt>
<dd>
<p>an antisymmetric preorder (reflexive,
antisymmetric, and transitive).</p>
</dd>
<dt>strict partial order:</dt>
<dd>
<p>irreflexive, antisymmetric, and
transitive, or equivalently: asymmetric and transitive).</p>
</dd>
<dt>linear order:</dt>
<dd>
<p>a complete partial order.</p>
</dd>
<dt>strict linear order:</dt>
<dd>
<p>a complete strict partial order.</p>
</dd>
<dt>match:</dt>
<dd>
<p>strongly complete.</p>
</dd>
<dt>tournament:</dt>
<dd>
<p>complete and asymmetric.</p>
</dd>
<dt>interval order:</dt>
<dd>
<p>complete and Ferrers.</p>
</dd>
<dt>semiorder:</dt>
<dd>
<p>a semitransitive interval order.</p>
</dd>
</dl>
<p>If <code class="reqn">R</code> is a weak order (“(weak) preference relation”),
<code class="reqn">I = I(R)</code> defined by <code class="reqn">x I y</code> iff <code class="reqn">x R y</code> and <code class="reqn">y R x</code>
is an equivalence, the <em>indifference relation</em> corresponding to
<code class="reqn">R</code>.
</p>
<p>There seem to be no commonly agreed definitions for order relations:
e.g., Fishburn (1972) requires these to be irreflexive.
</p>
<p>For a fuzzy binary relation <code class="reqn">R</code>, let <code class="reqn">R(x, y)</code> denote the
membership of <code class="reqn">(x, y)</code> in the relation.  Write <code class="reqn">T</code> and <code class="reqn">S</code>
for the fuzzy t-norm (intersection) and t-conorm (disjunction),
respectively (min and max for the “standard” Zadeh family).
Then generalizations of the above basic endorelation predicates are as
follows.
</p>

<dl>
<dt>reflexive:</dt>
<dd>
<p><code class="reqn">R(x, x) = 1</code> for all <code class="reqn">x</code>.</p>
</dd>
<dt>irreflexive:</dt>
<dd>
<p><code class="reqn">R(x, x) = 0</code> for all <code class="reqn">x</code>.</p>
</dd>
<dt>coreflexive:</dt>
<dd>
<p><code class="reqn">R(x, y) &gt; 0</code> implies <code class="reqn">x = y</code>.</p>
</dd>
<dt>symmetric:</dt>
<dd>
<p><code class="reqn">R(x, y) = R(y, x)</code> for all <code class="reqn">x \ne y</code>.</p>
</dd>
<dt>asymmetric:</dt>
<dd>
<p><code class="reqn">T(R(x, y), R(y, x)) = 0</code> for all <code class="reqn">x, y</code>.</p>
</dd> 
<dt>antisymmetric:</dt>
<dd>
<p><code class="reqn">T(R(x, y), R(y, x)) = 0</code> for all <code class="reqn">x \ne y</code>.</p>
</dd>
<dt>transitive:</dt>
<dd>
<p><code class="reqn">T(R(x, y), R(y, z)) \le R(x, z)</code> for all
<code class="reqn">x, y, z</code>.</p>
</dd>
<dt>complete:</dt>
<dd>
<p><code class="reqn">S(R(x, y), R(y, x)) = 1</code> for all <code class="reqn">x \ne y</code>.</p>
</dd>
<dt>strongly complete:</dt>
<dd>
<p><code class="reqn">S(R(x, y), R(y, x)) = 1</code> for all <code class="reqn">x, y</code>.</p>
</dd>
<dt>negatively transitive:</dt>
<dd>
<p><code class="reqn">R(x, z) \le S(R(x, y), R(y, z))</code> for all <code class="reqn">x, y, z</code>.</p>
</dd>
<dt>Ferrers:</dt>
<dd>
<p><code class="reqn">T(R(x, y), R(z, w)) \le S(R(x, w), R(z, y))</code> for all
<code class="reqn">x, y, z, w</code>.</p>
</dd>
<dt>semitransitive:</dt>
<dd>
<p><code class="reqn">T(R(x, w), R(w, y)) \le S(R(x, z), R(z, y))</code> for all
<code class="reqn">x, y, z, w</code>.</p>
</dd>
</dl>
<p>The combined predicates are obtained by combining the basic predicates
as for crisp endorelations (see above).
</p>
<p>A relation has missings iff at least one cell in the incidence matrix
is <code>NA</code>. In addition to <code>relation_has_missings()</code>, an
<code>is.na</code> method for relations is available, returning a matrix of
logicals corresponding to the incidences tested for missingness.
</p>


<h3>References</h3>

<p>P. C. Fishburn (1972),
<em>Mathematics of decision theory</em>.
Methods and Models in the Social Sciences 3.
Mouton: The Hague.
</p>
<p>H. R. Varian (2002),
<em>Intermediate Microeconomics: A Modern Approach</em>.
6th Edition. W. W. Norton &amp; Company.
</p>


<h3>Examples</h3>

<pre><code class="language-R">require("sets")
R &lt;- relation(domain = c(1, 2, 3), graph = set(c(1, 2), c(2, 3)))
summary(R)

## Note the possible effects of NA-handling:
relation_incidence(R)
relation_is(R, "transitive") ## clearly FALSE

relation_incidence(R)[1, 2] &lt;- NA
relation_incidence(R)
relation_is(R, "transitive") ## clearly NA

## The following gives TRUE, since NA gets replaced with 0:
relation_is(R, "transitive", na.rm = TRUE)
</code></pre>


</div>