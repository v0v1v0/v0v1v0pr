<div class="container">

<table style="width: 100%;"><tr>
<td>apply_transformation_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply transformation matrix to a set of columns</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>Perform matrix multiplication with a transformation matrix and a set of <code>data.frame</code> columns.
</p>
<p>The data points in <code>`data`</code> are moved prior to the transformation, to bring
the origin to <code>0</code> in all dimensions. After the transformation, the
inverse move is applied to bring the origin back to its original position. See <code>`Details`</code> section.
</p>
<p>The columns in <code>`data`</code> are transposed, making the operation (without the origin movement):
</p>
<p style="text-align: center;"><code class="reqn">mat Â· data[, cols]^T</code>
</p>

<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and transforming around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class="language-R">apply_transformation_matrix(
  data,
  mat,
  cols,
  origin = NULL,
  origin_fn = NULL,
  suffix = "_transformed",
  keep_original = TRUE,
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>Transformation <code>matrix</code>. Must have the same number of columns as <code>`cols`</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>Columns to mutate values of. Must be specified when <code>`data`</code> is a <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p>Coordinates of the origin. <code>Vector</code> with the same number
of elements as <code>`cols`</code> (i.e. origin_x, origin_y, ...).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code>create_origin_fn()</code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code>centroid()</code>,
<code>most_centered()</code>,
and <code>midrange()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Example with 2 columns (<code>x</code>, <code>y</code>) and a 2x2 transformation matrix:
</p>

<ul>
<li>
<p>Move origin to <code>(0, 0)</code>:
</p>
<p><code>x = x - origin_x</code>
</p>
<p><code>y = y - origin_y</code>
</p>
</li>
<li>
<p>Convert to transposed matrix:
</p>
<p><code>data_mat = rbind(x, y)</code>
</p>
</li>
<li>
<p>Matrix multiplication:
</p>
<p><code>transformed = mat %*% data_mat</code>
</p>
</li>
<li>
<p>Move origin to original position (after extraction from <code>transformed</code>):
</p>
<p><code>x = x + origin_x</code>
</p>
<p><code>y = y + origin_y</code>
</p>
</li>
</ul>
<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the new, transformed columns and the origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code>cluster_groups()</code>,
<code>dim_values()</code>,
<code>expand_distances()</code>,
<code>expand_distances_each()</code>,
<code>flip_values()</code>,
<code>roll_values()</code>,
<code>rotate_2d()</code>,
<code>rotate_3d()</code>,
<code>shear_2d()</code>,
<code>shear_3d()</code>,
<code>swirl_2d()</code>,
<code>swirl_3d()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(3)

# Create a data frame
df &lt;- data.frame(
  "x" = 1:12,
  "y" = 13:24,
  "z" = runif(12),
  "g" = c(
    1, 1, 1, 1, 2, 2,
    2, 2, 3, 3, 3, 3
  )
)

# Apply identity matrix
mat &lt;- matrix(c(1, 0, 0, 0, 1, 0, 0, 0, 1), nrow = 3)
apply_transformation_matrix(
  data = df,
  mat = mat,
  cols = c("x", "y", "z"),
  origin = c(0, 0, 0)
)

# Apply rotation matrix
# 90 degrees around z-axis
# Origin is the most centered point
mat &lt;- matrix(c(0, 1, 0, -1, 0, 0, 0, 0, 1), nrow = 3)
res &lt;- apply_transformation_matrix(
  data = df,
  mat = mat,
  cols = c("x", "y", "z"),
  origin_fn = most_centered
)

# Plot the rotation
# z wasn't changed so we plot x and y
if (has_ggplot){
  res %&gt;%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    geom_point(aes(x = x_transformed, y = y_transformed)) +
    theme_minimal()
}

# Apply rotation matrix to grouped data frame
# Around centroids
# Same matrix as before
res &lt;- apply_transformation_matrix(
  data = dplyr::group_by(df, g),
  mat = mat,
  cols = c("x", "y", "z"),
  origin_fn = centroid
)

# Plot the rotation
if (has_ggplot){
  res %&gt;%
    ggplot(aes(x = x, y = y, color = g)) +
    geom_point() +
    geom_point(aes(x = x_transformed, y = y_transformed)) +
    theme_minimal()
}
</code></pre>


</div>