<div class="container">

<table style="width: 100%;"><tr>
<td>LGP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The (univariate) Lagrangian Poisson (LGP) Distribution</h2>

<h3>Description</h3>

<p>Density, distribution function, quantile function, summary, random number generation, and utility functions for the (univariate) Lagrangian Poisson distribution.</p>


<h3>Usage</h3>

<pre><code class="language-R">dLGP(x,theta,lambda,nc=NULL,log=FALSE)
pLGP(q,theta,lambda,nc=NULL,lower.tail=TRUE,log.p=FALSE,add.carefully=FALSE)
qLGP(p,theta,lambda,nc=NULL,lower.tail=TRUE,log.p=FALSE,add.carefully=FALSE)
rLGP(n,theta,lambda)
sLGP(theta,lambda,nc=NULL,do.numerically=FALSE,add.carefully=FALSE)
LGP.findmax(theta,lambda)
LGP.get.nc(theta,lambda,nctol=1e-14,add.carefully=FALSE)
LGPMVP(mu,sigma2,theta,lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, q</code></td>
<td>
<p>Numeric vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Numeric vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer; number of observations to be randomly generated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Numeric; the index (or "additive") parameter of the LGP distribution.  Must be non-negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Numeric; the dispersion (or "Lagrangian" or "multiplicative") parameter of the LGP distribution.  Must not exceed 1 in absolute value.  When equal to zero, the LGP reduces to the ordinary Poisson distribution, with mean equal to <code>theta</code>.  When negative, then the distribution has an upper limit to its support, which may be found with <code>LGP.findmax()</code></p>
</td>
</tr>
</table>
<p>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>Numeric; the reciprocal of the normalizing constant of the distribution, by which the raw PMF must be multiplied so that it is a proper PMF, with values that sum to 1 across the support, when <code>lambda</code> is negative.  Defaults to <code>NULL</code>, in which case it is computed numerically by a call to <code>LGP.get.nc()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log, log.p</code></td>
<td>
<p>Logical; if <code>TRUE</code>, then probabilities p are given as log(p).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nctol</code></td>
<td>
<p>Numeric; while numerically computing the normalizing constant, how close to 1 should it be before stopping?  Ignored unless <code>lambda</code> is negative, and the upper support limit exceeds 200,000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.carefully</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the program takes extra steps to try to prevent round-off error during the addition of probabilities.  Defaults to <code>FALSE</code>, which is recommended, since using <code>TRUE</code> is slower and rarely makes a noticeable difference in practice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.numerically</code></td>
<td>
<p>Logical; should moments be computed numerically when <code>lambda</code>&lt;0?  Defaults to <code>FALSE</code>, which is recommended unless the upper support limit is fairly small (say, less than 10).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Numeric vector of mean parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>"Sigma squared"â€“numeric vector of variance parameters.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Lagrangian Poisson (LGP) distribution has density
</p>
<p style="text-align: center;"><code class="reqn">p(x)=\frac{\theta (\theta + \lambda x)^{x-1} \exp(- \theta - \lambda x)}{x!}</code>
</p>
<p> for <code class="reqn">0,1,2,\ldots</code>,
</p>
<p style="text-align: center;"><code class="reqn">p(x)=0</code>
</p>
<p> for <code class="reqn">x&gt;m</code> if <code class="reqn">\lambda&lt;0</code>,
and zero otherwise, where <code class="reqn">\theta&gt;0</code>, <code class="reqn">m=\lfloor-\theta / \lambda\rfloor</code> if <code class="reqn">\lambda&lt;0</code>, and <code class="reqn">\max(-1,-\theta / m)\leq\lambda\leq 1</code>.  So, when <code class="reqn">\lambda</code> is negative, there is an upper limit to the distribution's support, <code class="reqn">m</code>, equal to <code class="reqn">-\theta / \lambda</code>, rounded down to the next-smallest integer.  When <code class="reqn">\lambda</code> is negative, the PMF must also be normalized numerically if it is to describe a proper probability distribution.  When <code class="reqn">\lambda=0</code>, the Lagrangian Poisson reduces to the ordinary Poisson, with mean equal to <code class="reqn">\theta</code>.  When <code class="reqn">\theta=0</code>, we define the distribution as having unit mass on the event <code class="reqn">X=0</code>.
</p>
<p>Function <code>LGP.findmax()</code> calculates the value of upper support limit <code class="reqn">m</code>; <code>LGP.get.nc()</code> calculates the (reciprocal of) the normalizing constant.
</p>
<p>Function <code>LGPMVP()</code> accepts exactly two of its four arguments, and returns the corresponding values of the other two arguments.  For example, if given values for <code>theta</code> and <code>lambda</code>, it will return the corresponding means (<code>mu</code>) and variances (<code>sigma2</code>) of an LGP distribution with the given values of <code class="reqn">\theta</code> and <code class="reqn">\lambda</code>.  <code>LGPMVP()</code> does not enforce the parameter space as strictly as other functions, but will throw a warning for bad parameter values.
</p>
<p>When the upper support limit is 5 or smaller, <code>rLGP()</code> uses simple inversion (i.e., random unit-uniform draws passed to <code>qLGP()</code>).  Otherwise, it uses random-number generation algorithms from Consul &amp; Famoye (2006); exactly which algorithm is used depends upon the values of <code>theta</code> and <code>lambda</code>.  All four of <code>rLGP()</code>, <code>dLGP()</code>, <code>pLGP()</code>, and <code>qLGP()</code> make calls to the corresponding functions for the ordinary Poisson distribution (<code>dpois()</code>,etc.) when <code>lambda</code>=0.
</p>
<p>Vectors of numeric arguments are cycled, whereas only the first element of logical and integer arguments is used.
</p>


<h3>Value</h3>

<p><code>dLGP()</code> and <code>pLGP()</code> return numeric vectors of probabilities.  <code>qLGP()</code>, <code>rLGP()</code>, and <code>LGP.findmax()</code> return  vectors of quantiles, which are of class 'numeric' rather than 'integer' for the sake of compatibility with very large values.  <code>LGP.get.nc()</code> returns a numeric vector of reciprocal normalizing constants.  <code>LGPMVP()</code> returns a numeric matrix with two columns, named for the missing arguments in the function call.
</p>
<p><code>sLGP()</code> returns a numeric matrix with 10 columns, with the mostly self-explanatory names <code>"Mean"</code>, <code>"Median"</code>, <code>"Mode"</code>, <code>"Variance"</code>, <code>"SD"</code>, <code>"ThirdCentralMoment"</code>, <code>"FourthCentralMoment"</code>, <br><code>"PearsonsSkewness"</code>, <code>"Skewness"</code>, and <code>"Kurtosis"</code>.  Here, <code>"Kurtosis"</code> refers to excess kurtosis (greater than 3), and <code>"PearsonsSkewness"</code> equals <code class="reqn">\frac{(mean - mode)}{SD}</code>.  A <code>"Mode"</code> of 0.5 indicates that the point probabilities at <code class="reqn">x=0</code> and <code class="reqn">x=1</code> are tied for highest density; other than this possibility, the LGP is strictly unimodal. 
</p>


<h3>Warning</h3>

<p>There is a known issue with <code>sLGP()</code>: when <code>lambda</code> is negative and <code>theta</code> is large, the third and fourth moments returned by <code>sLGP()</code>, with <code>do.numerically=TRUE</code>, can be quite incorrect due to numerical imprecision.
</p>


<h3>Author(s)</h3>

<p>Robert M. Kirkpatrick <a href="mailto:rkirkpatrick2@vcu.edu">rkirkpatrick2@vcu.edu</a>
</p>


<h3>References</h3>

<p>Consul, P. C.  (1989).  <em>Generalized Poisson Distributions: Properties and Applications</em>.  New York:  Marcel Dekker, Inc.
</p>
<p>Consul, P. C., &amp; Famoye, F.  (2006).  <em>Lagrangian Probability Distributions</em>.  Boston: Birkhauser.
</p>
<p>Johnson, N. L., Kemp, A. W., &amp; Kotz, S.  (2005).  <em>Univariate Discrete Distributions</em> (3rd. ed.).  Hoboken, NJ: John Wiley &amp; Sons, Inc.
</p>


<h3>Examples</h3>

<pre><code class="language-R">LGP.findmax(theta=2, lambda=0.2) #&lt;--No upper support limit
LGP.findmax(theta=2, lambda=-0.2) #&lt;--Upper support limit of 9
LGP.get.nc(theta=2, lambda=0.2)-1==0 #&lt;--TRUE
LGP.get.nc(theta=2, lambda=-0.2)-1 #&lt;--nc differs appreciably from 1
LGP.get.nc(theta=2, lambda=-0.1)-1 #&lt;--nc doesn't differ appreciably from 1
LGPMVP(theta=2, lambda=0.9)
LGPMVP(mu=20, sigma2=2000)
sLGP(theta=2, lambda=0.9)
dLGP(x=0:10,theta=1,lambda=0.1)
dLGP(x=0:10,theta=1,lambda=0)
dLGP(x=0:10,theta=1,lambda=-0.1) #&lt;--Upper support limit of 9
pLGP(q=0:10,theta=1,lambda=0.1)
pLGP(q=0:10,theta=1,lambda=0)
pLGP(q=0:10,theta=1,lambda=-0.1) 
qLGP(p=(0:9)/10,theta=1,lambda=0.1)
qLGP(p=(0:9)/10,theta=1,lambda=0)
qLGP(p=(0:9)/10,theta=1,lambda=-0.1) 
rLGP(n=5,theta=1e12,lambda=-0.0001)
</code></pre>


</div>