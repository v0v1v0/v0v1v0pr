<div class="container">

<table style="width: 100%;"><tr>
<td>infoPlot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot absolute and relative information</h2>

<h3>Description</h3>

<p>Plot absolute and relative information of influence curves.
</p>


<h3>Usage</h3>

<pre><code class="language-R">infoPlot(object,  ...)
## S4 method for signature 'IC'
infoPlot(object, data = NULL,
             ..., withSweave = getdistrOption("withSweave"),
             col = par("col"), lwd = par("lwd"), lty,
             colI = grey(0.5), lwdI = 0.7*par("lwd"), ltyI = "dotted",
             main = FALSE, inner = TRUE, sub = FALSE,
             col.inner = par("col.main"), cex.inner = 0.8,
             bmar = par("mar")[1], tmar = par("mar")[3],
             with.automatic.grid = TRUE,
             with.legend = TRUE, legend = NULL, legend.bg = "white",
             legend.location = "bottomright", legend.cex = 0.8,
             x.vec = NULL, scaleX = FALSE, scaleX.fct, scaleX.inv,
             scaleY = FALSE, scaleY.fct = pnorm, scaleY.inv=qnorm,
             scaleN = 9, x.ticks = NULL, y.ticks = NULL,
             mfColRow = TRUE, to.draw.arg = NULL,
             cex.pts = 1, cex.pts.fun = NULL, col.pts = par("col"),
             pch.pts = 19,
             cex.npts = 1, cex.npts.fun = NULL, col.npts = grey(.5),
             pch.npts = 20,
             jitter.fac = 1, with.lab = FALSE, cex.lbs = 1, adj.lbs = c(0, 0),
             col.lbs = col.pts, lab.pts = NULL, lab.font = NULL, alpha.trsp = NA,
             which.lbs = NULL, which.Order  = NULL, which.nonlbs = NULL,
             attr.pre = FALSE, return.Order = FALSE,
             ylab.abs = "absolute information",
             ylab.rel= "relative information",
             withSubst = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>object of class <code>"InfluenceCurve"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>optional data argument — for plotting observations into the plot;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withSweave</code></td>
<td>
<p>logical: if <code>TRUE</code> (for working with <code>Sweave</code>) 
no extra device is opened</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>logical: is a main title to be used? or <br>
just as argument <code>main</code> in <code>plot.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inner</code></td>
<td>
<p>logical: do panels have their own titles? or <br>
character vector of / cast to length 'number of compared 
dimensions';
if argument <code>to.draw.arg</code> is used, this refers to 
a vector of length <code>1</code> (absolute information) 
<code>+ length(to.draw.arg)</code>, the actually plotted
relative informations. For further information, see  also
<code>main</code> in <code>plot.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub</code></td>
<td>
<p>logical: is a sub-title to be used? or <br>
just as argument <code>sub</code> in <code>plot.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmar</code></td>
<td>
<p>top margin – useful for non-standard main title sizes;
may be a vector with individual values for
each of the panels to be plotted. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bmar</code></td>
<td>
<p>bottom margin – useful for non-standard sub title sizes;
may be a vector with individual values for
each of the panels to be plotted. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>color of IC in argument <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>linewidth of IC in argument <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>line-type of IC in argument <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colI</code></td>
<td>
<p>color of the classically optimal IC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwdI</code></td>
<td>
<p>linewidth of the classically optimal IC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ltyI</code></td>
<td>
<p>line-type of the classically optimal IC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.inner</code></td>
<td>
<p>magnification to be used for inner titles relative
to the current setting of <code>cex</code>; as in 
<code>par</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.inner</code></td>
<td>
<p>character or integer code; color for the inner title</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.automatic.grid</code></td>
<td>
<p>logical; should a grid be plotted alongside
with the ticks of the axes, automatically? If <code>TRUE</code> a respective
call to <code>grid</code> in argument <code>panel.first</code> is ignored. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.legend</code></td>
<td>
<p>logical; shall a legend be plotted?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>either <code>NULL</code> or a list of length (number of plotted panels)
of items which can be used as argument <code>legend</code> in
command <code>legend</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.location</code></td>
<td>
<p>a valid argument <code>x</code> for <code>legend</code> —
the place where to put the legend on the last issued
plot — or a list of length (number of plotted panels) 
of such arguments, one for each plotted panel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.bg</code></td>
<td>
<p>background color for the legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.cex</code></td>
<td>
<p>magnification factor for the legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.vec</code></td>
<td>
<p>a numeric vector of grid points to evaluate the influence curve;
by default, <code>x.vec</code> is <code>NULL</code>; then the grid is
produced automatically according to the distribution of the IC.
<code>x.vec</code> can be useful for usage with a rescaling of the
x-axis to avoid that the evaluation points be selected too
unevenly (i.e. on an equally spaced grid in the original scale,
but then, after rescaling non-equally).
The grid has to be specified in original scale; i.e.; when used
with rescaling, it should be chosen non-equally spaced. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX</code></td>
<td>
<p>logical; shall X-axis be rescaled (by default according to the cdf of
the underlying distribution)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleY</code></td>
<td>
<p>logical; shall Y-axis be rescaled for abs.info-plot
(by default according to a probit scale)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the domain of the IC
to [0,1]; if <code>scaleX</code> is <code>TRUE</code> and <code>scaleX.fct</code> is
missing, the cdf of the underlying observation distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleX.inv</code></td>
<td>
<p>the inverse function to <code>scale.fct</code>, i.e., an isotone,
vectorized function mapping [0,1] to the domain of the IC
such that for any <code>x</code> in the domain,
<code>scaleX.inv(scaleX.fct(x))==x</code>; if <code>scaleX</code> is <code>TRUE</code>
and <code>scaleX.inv</code> is
missing, the quantile function of the underlying observation distribution. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleY.fct</code></td>
<td>
<p>an isotone, vectorized function mapping the
range of the norm of the IC to [0,1]; defaulting
to the cdf of <code class="reqn">{\cal N}(0,1)</code>;
can also be a list of functions with one list element for each
of the panels to be plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleY.inv</code></td>
<td>
<p>an isotone, vectorized function mapping [0,1] into the range
of the norm of the IC; defaulting to the quantile function
of  <code class="reqn">{\cal N}(0,1)</code>;
can also be a list of functions with one list element for each
of the panels to be plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleN</code></td>
<td>
<p>integer; defaults to 9; on rescaled axes, number of x
and y ticks if drawn automatically;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given x-ticks (on original scale);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.ticks</code></td>
<td>
<p>numeric; defaults to NULL; (then ticks are chosen automatically);
if non-NULL, user-given y-ticks (on original scale);
can be a list with one (numeric or NULL) item per panel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mfColRow</code></td>
<td>
<p>shall default partition in panels be used — defaults to <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to.draw.arg</code></td>
<td>
<p>Either <code>NULL</code> (default; 
everything is plotted) or a vector making a selection
among the relative information plots; the absolute
information being plotted in any case. This
vector is either a vector of integers 
(the indices of the subplots to be drawn) or characters 
— the names of the subplots to be drawn: these
names are to be chosen either among the row names of 
the trafo matrix 
<code>rownames(trafo(eval(object@CallL2Fam)@param))</code> 
or if the last expression is <code>NULL</code> a 
vector <code>"dim&lt;dimnr&gt;"</code>, <code>dimnr</code> running through 
the number of rows of the trafo matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withSubst</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) pattern substitution for
titles and lables is used; otherwise no substitution is used. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.pts</code></td>
<td>
<p>color of the points of the <code>data</code> argument plotted;
can be a vector or a matrix. More specifically, if argument <code>attr.pre</code>
is <code>TRUE</code>, it is recycled to fill a matrix of dimension <code>n</code> by 2
(<code>n</code> the number of observations prior to any selection) where filling
is done in order column first. The two columns are used for possibly
different colors for the actual IC from the argument and the classical
IC which is also shown. The selection done via <code>which.lbs</code> and
<code>which.Order</code> is then done afterwards and on this matrix;
argument <code>col.npts</code> is ignored in this case. If <code>attr.pre</code> is <code>FALSE</code>,
<code>col.pts</code> is recycled to fill a matrix of dimension <code>n.s</code> by 2
where <code>n.s</code> is the number of observations selected for labelling
and refers to the index ordering after the selection. Then argument
<code>col.npts</code> deteremines the colors of the shown but non-labelled
observations as given in argument <code>which.nonlbs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch.pts</code></td>
<td>
<p>symbol of the points of the <code>data</code> argument plotted
(may be a vector of length 2 or a matrix, see <code>col.pts</code>,
with argument <code>pch.npts</code> as counterpart).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.pts</code></td>
<td>
<p>size of the points of the <code>data</code> argument plotted
(may be a vector of length 2 or a matrix, see <code>col.pts</code>,
with argument <code>cex.npts</code> as counterpart).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.pts.fun</code></td>
<td>
<p>rescaling function for the size of the points to be plotted;
either <code>NULL</code> (default), then <code>log(1+abs(x))</code> is used for each of
the rescalings, or a function which is then used for each of the
rescalings, or a list of functions; if it is a function or a list of
functions, if necessary it is recylced to length <code>2 * dim</code>
where <code>2</code> is for the classical IC and the IC in argument <code>object</code>
and <code>dim</code> is the number of dimensions of the pICs to be plotted;
in the index of this list, <code>2</code> is incremented first;
then <code>dim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.npts</code></td>
<td>
<p>color of the non-labelled points of the <code>data</code> argument
plotted; (may be a vector of length 2, or it can be a matrix
<code>nnlb &lt;- sum(which.nonlbs)</code> by <code>2</code>,
<code>nnlb</code> the number of non-labelled shown observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch.npts</code></td>
<td>
<p>symbol of the non-labelled points of the <code>data</code> argument
plotted (may be a vector of length <code>2</code> or a matrix,
see <code>col.npts</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.npts</code></td>
<td>
<p>size of the non-labelled points of the <code>data</code> argument
plotted (may be a vector of length <code>2</code> or a matrix, see
<code>col.npts</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.npts.fun</code></td>
<td>
<p>rescaling function for the size of the non-labelled points
to be plotted; either <code>NULL</code> (default), then <code>log(1+abs(x))</code>
is used for each of the rescalings, or a function which is then used
for each of the rescalings, or a list of functions; if it is a
function or a list of functions, if necessary it is recylced
to length <code>2 * dim</code> where <code>dim</code> is the number of dimensions of
the pICs to be plotted;  in the index of this list,
<code>2</code> is incremented first; then <code>dim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr.pre</code></td>
<td>
<p>logical; do graphical attributes for plotted data refer
to indices prior (<code>TRUE</code>) or posterior to selection
via arguments <code>which.lbs</code>, <code>which.Order</code>, <code>which.nonlbs</code>
(<code>FALSE</code>)? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.lab</code></td>
<td>
<p>logical; shall labels be plotted to the observations?
(may be a vector of length 2, see <code>col.pts</code> – 
but not a matrix)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex.lbs</code></td>
<td>
<p>size of the labels; can be vectorized to an array
of dim nlbs x 2 x npnl where npnl is the number of plotted
panels and nlbs the number of plotted labels; if it is
a vector, it is recylced in order labels then ICs
[arg <code>IC</code>/classic] then panels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.lbs</code></td>
<td>
<p>color of the labels; can be vectorized to a matrix
of dim nlbs x 2 as <code>col.pts</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.lbs</code></td>
<td>
<p>adjustment of the labels; can be vectorized to an array
of dim 2 x 2 x npnl matrix, npnl the number of plotted panels;
if it is a vector, it is recycled in order (x,y)-coords then ICs
[arg <code>IC</code>/classic] then panels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab.pts</code></td>
<td>
<p>character or NULL; labels to be plotted to the observations;
can be a vector of length <code>n</code>, <code>n</code> the number of 
all observations prior to any selection with <code>which.lbs</code>,
<code>which.Order</code>; if <code>lab.pts</code> is <code>NULL</code>, 
observation indices are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lab.font</code></td>
<td>
<p>font to be used for labels; (may be a vector of length 2, 
see <code>with.lab</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.trsp</code></td>
<td>
<p>alpha transparency to be added ex post to colors
<code>col.pch</code> and <code>col.nonlbl</code>; if one-dim and NA all colors are
left unchanged. Otherwise, with usual recycling rules <code>alpha.trsp</code>
gets shorted/prolongated to length the number of panel data-symbols to 
be plotted. Coordinates of this vector <code>alpha.trsp</code> with NA are left unchanged,
while for the remaining ones, the alpha channel in rgb space is set
to the respective coordinate value of <code>alpha.trsp</code>. The non-NA
entries must be integers in [0,255] (0 invisible, 255 opaque).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter.fac</code></td>
<td>
<p>jittering factor used in case of a <code>DiscreteDistribution</code>
for plotting points of the <code>data</code> argument in a jittered fashion
(may be a vector of length 2, see <code>with.lab</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.lbs</code></td>
<td>
<p>either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> — then no observation is excluded</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.Order</code></td>
<td>
<p>we order the observations (descending) according to the norm given by
<code>normtype(object)</code>; then <code>which.Order</code>
either is an integer vector with the indices of the <em>ordered</em>
observations (remaining after a possible reduction by argument <code>which.lbs</code>)
to be plotted into graph or <code>NULL</code> — then no (further) observation
is excluded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which.nonlbs</code></td>
<td>
<p>indices of the observations which should be plotted but
not labelled; either an integer vector with the indices of the observations
to be plotted into graph or <code>NULL</code> — then all non-labelled
observations are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.Order</code></td>
<td>
<p>logical; if <code>TRUE</code>, a list of length two with order vectors
is returned — one for ordering w.r.t. the given IC, one for ordering w.r.t.
the classically optimal IC; more specifically, the order of the (remaining) observations
given by their original index is returned (remaining means: after a possible
reduction by argument <code>which.lbs</code>, and ordering is according to the norm given by
<code>normtype(object)</code>);
otherwise we return <code>invisible()</code> as usual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab.abs</code></td>
<td>
<p>character; label to be used for y-axis in absolute information panel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylab.rel</code></td>
<td>
<p>character; label to be used for y-axis in relative information panel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further parameters for <code>plot</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Absolute information is defined as the square of the length
of an IC. The relative information is defined as the 
absolute information of one component with respect to the 
absolute information of the whole IC; confer Section 8.1 
of Kohl (2005). <br></p>
<p>Any parameters of <code>plot.default</code> may be passed on to this particular
<code>plot</code> method. 
</p>
<p>For main-, inner, and subtitles given as arguments <code>main</code>, 
<code>inner</code>, and <code>sub</code>, top and bottom margins are enlarged to 5 resp. 
6 by default but may also be specified by <code>tmar</code> / <code>bmar</code> arguments. 
If <code>main</code> / <code>inner</code> / <code>sub</code> are 
logical then if the respective argument is <code>FALSE</code> nothing is done/plotted, 
but if it is <code>TRUE</code>, we use a default main title taking up the calling 
arguments in case of <code>main</code>, default inner titles taking up the
class and (named) parameter slots of arguments in case of <code>inner</code>,
and a "generated on &lt;data&gt;"-tag in case of <code>sub</code>.
Of course, if <code>main</code> / <code>inner</code> / <code>sub</code> are <code>character</code>, this
is used for the title; in case of <code>inner</code> it is then checked whether it
has correct length. If argument <code>withSubst</code> is <code>TRUE</code>, in all title 
and axis lable arguments, the following patterns are substituted:
</p>

<dl>
<dt><code>"%C"</code></dt>
<dd>
<p>class of argument <code>object</code></p>
</dd>
<dt><code>"%A"</code></dt>
<dd>
<p>deparsed argument  <code>object</code></p>
</dd>
<dt><code>"%D"</code></dt>
<dd>
<p>time/date-string when the plot was generated</p>
</dd>
</dl>
<p>If argument <code>...</code> contains argument <code>ylim</code>, this may either be
as in <code>plot.default</code> (i.e. a vector of length 2) or a vector of 
length 2*(number of plotted dimensions + e), where e is 1 or 0 depending
on whether absolute information is plotted or not; 
in the case of longer length, 
if e is 1, the first two elements are the values for <code>ylim</code> 
in panel "Abs", while the last 2*(number of plotted dimensions)
are the values for <code>ylim</code> for the plotted dimensions of the IC, 
one pair for each dimension.
</p>
<p>Similarly, if argument <code>...</code> contains arguments <code>xaxt</code> or
<code>yaxt</code>, these may be vectorized, with one value for each of the panels
to be plotted. This is useful for stacking panels over each other, using
a common x-axis (see example below).
</p>
<p>The <code>...</code> argument may also contain an argument <code>withbox</code> which
if <code>TRUE</code> warrants that even if <code>xaxt</code> and <code>yaxt</code> both are
<code>FALSE</code>, a box is drawn around the respective panel.
</p>
<p>In addition, argument <code>...</code> may contain arguments <code>panel.first</code>,
<code>panel.last</code>, i.e., hook expressions to be evaluated at the very beginning
and at the very end of each panel (within the then valid coordinates).
To be able to use these hooks for each panel individually, they may also be
lists of expressions (of the same length as the number of panels and
run through in the same order as the panels).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>c("plotInfo","DiagnInfo")</code>, i.e., a list
containing the information needed to produce the
respective plot, which at a later stage could be used by different
graphic engines (like, e.g. <code>ggplot</code>) to produce the plot
in a different framework. A more detailed description will follow in
a subsequent version.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code>L2ParamFamily-class</code>, <code>IC-class</code></p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- NormLocationScaleFamily(mean=0, sd=1) 
IC1 &lt;- optIC(model = N, risk = asCov())
infoPlot(IC1)

## don't run to reduce check time on CRAN

## selection of subpanels for plotting
par(mfrow=c(1,2))
infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"))
infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","sd"), log="y")

infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
              panel.first= grid(), ylim = c(0,4), xlim = c(-6,6))
infoPlot(IC1, mfColRow = FALSE, to.draw.arg=c("Abs","mean"), 
              panel.first= grid(), ylim = c(0,4,-3,3), xlim = c(-6,6))

par(mfrow=c(1,3))
infoPlot(IC1, mfColRow = FALSE, panel.first= grid(),
         ylim = c(0,4,0,.3,0,.8), xlim=c(-6,6))
par(mfrow=c(1,1))

data &lt;- r(N)(20)
par(mfrow=c(1,3))
infoPlot(IC1, data=data, mfColRow = FALSE, panel.first= grid(),
         with.lab = TRUE, cex.pts=2,
         which.lbs = c(1:4,15:20), which.Order = 1:6,
         return.Order = TRUE)
infoPlot(IC1, data=data[1:10], mfColRow = FALSE, panel.first= grid(),
         with.lab = TRUE, cex.pts=0.7)
par(mfrow=c(1,1))

ICr &lt;- makeIC(list(function(x)sign(x),function(x)sign(abs(x)-qnorm(.75))),N)
data &lt;- r(N)(600)
data.c &lt;- c(data, 1000*data[1:30])
par(mfrow=c(3,1))
infoPlot(ICr, data=data.c, tmar=c(4.1,0,0), bmar=c(0,0,4.1),
         xaxt=c("n","n","s"), mfColRow = FALSE, panel.first= grid(),
         cex.pts=c(.9,.9), alpha.trsp=20, lwd=2, lwdI=1.5, col=3,
         col.pts=c(3,2), colI=2, pch.pts=c(20,20), inner=FALSE,
         scaleX = TRUE, scaleX.fct=pnorm, scaleX.inv=qnorm,
         scaleY=TRUE, scaleY.fct=function(x) pchisq(x,df=1),
         scaleY.inv=function(x)qchisq(x,df=1),legend.cex = 1.0)



</code></pre>


</div>