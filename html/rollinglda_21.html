<div class="container">

<table style="width: 100%;"><tr>
<td>updateRollingLDA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Updating an existing RollingLDA object</h2>

<h3>Description</h3>

<p>Performs an update of an existing object consisting of a rolling version
of Latent Dirichlet Allocation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">updateRollingLDA(
  x,
  texts,
  dates,
  chunks,
  memory,
  param = getParam(x),
  compute.topics = TRUE,
  memory.fallback = 0L,
  ...
)

## S3 method for class 'RollingLDA'
RollingLDA(
  x,
  texts,
  dates,
  chunks,
  memory,
  param = getParam(x),
  compute.topics = TRUE,
  memory.fallback = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>[<code>named list</code>]<br><code>RollingLDA</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>texts</code></td>
<td>
<p>[<code>named list</code>]<br>
Tokenized texts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dates</code></td>
<td>
<p>[<code>(un)named Date</code>]<br>
Sorted dates of the tokenized texts. If unnamed, it must match the order of texts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunks</code></td>
<td>
<p>[<code>Date</code> or <code>character(1)</code>]<br>
Sorted dates of the beginnings of each chunk to be modeled as updates.
If passed as <code>character</code>, dates are determined by passing the minimum of
<code>dates</code> as <code>from</code> argument, <code>max(dates)</code> as <code>to</code> argument
and <code>chunks</code> as <code>by</code> argument in <code>seq.Date</code>.
If not passed, all texts are interpreted as one chunk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memory</code></td>
<td>
<p>[<code>Date</code>, <code>character(1)</code> or <code>integer(1)</code>]<br>
Dates of the beginnings of each chunk's memory. If passed as <code>character</code>,
dates are determined by using the dates of the beginnings of each chunk and
substracting the given time interval in <code>memory</code> passing it as
<code>by</code> argument in <code>seq.Date</code>. If passed as
<code>integer/numeric</code>, the dates are determined by going backwards the
modeled texts chronologically and taking the date of the text at position
<code>memory</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>[<code>named list</code>] with entries (Default is <code>getParam(x)</code>)
</p>

<dl>
<dt><code>vocab.abs</code></dt>
<dd>
<p>[<code>integer(1)</code>]
An absolute lower bound limit for which words are taken into account. All
words are considered in the vocabularies that have a count higher than
<code>vocab.abs</code> over all texts and at the same time a higher relative
frequency than <code>vocab.rel</code>.</p>
</dd>
<dt><code>vocab.rel</code></dt>
<dd>
<p>[0,1]
A relative lower bound limit for which words are taken into account.
See also <code>vocab.abs</code>.</p>
</dd>
<dt><code>vocab.fallback</code></dt>
<dd>
<p>[<code>integer(1)</code>]
An absolute lower bound limit for which words are taken into account. All
words are considered in the vocabularies that have a count higher than
<code>vocab.fallback</code> over all texts even if they might not have a higher
relative frequency than <code>vocab.rel</code>.</p>
</dd>
<dt><code>doc.abs</code></dt>
<dd>
<p>[<code>integer(1)</code>]
An absolute lower bound limit for which texts are taken into account. All
texts are considered for modeling that have more words (subsetted to words
occurring in the vocabularies) than <code>doc.abs</code>.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.topics</code></td>
<td>
<p>[<code>logical(1)</code>]<br>
Should the topic matrix of the LDA model be computed? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>memory.fallback</code></td>
<td>
<p>[<code>integer(1)</code>]<br>
If there are no texts as memory in a certain chunk, <code>memory</code> is
determined by going backwards the modeled texts chronologically and taking
the date of the text at position <code>memory.fallback</code>.
Default is 0, which means "end the fitting".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not implemented</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function uses an existing <code>RollingLDA</code> object and
models new texts with a specified memory as initialization of the new LDA chunk.
</p>
<p>The function returns a <code>RollingLDA</code> object. You can receive results and
all other elements of this object with getter functions (see <code>getChunks</code>).
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>id</code></dt>
<dd>
<p>[<code>character(1)</code>] See above.</p>
</dd>
<dt><code>lda</code></dt>
<dd>
<p><code>LDA</code> object of the fitted RollingLDA.</p>
</dd>
<dt><code>docs</code></dt>
<dd>
<p>[<code>named list</code>] with modeled texts in a preprocessed format.
See <code>LDAprep</code></p>
</dd>
<dt><code>dates</code></dt>
<dd>
<p>[<code>named Date</code>] with dates of the modeled texts.</p>
</dd>
<dt><code>vocab</code></dt>
<dd>
<p>[<code>character</code>] with the vocabularies considered
for modeling.</p>
</dd>
<dt><code>chunks</code></dt>
<dd>
<p>[<code>data.table</code>] with specifications for each
model chunk.</p>
</dd>
<dt><code>param</code></dt>
<dd>
<p>[<code>named list</code>] with parameter specifications for
<code>vocab.abs</code> [<code>integer(1)</code>], <code>vocab.rel</code> [0,1],
<code>vocab.fallback</code> [<code>integer(1)</code>] and
<code>doc.abs</code> [<code>integer(1)</code>]. See above for explanation.</p>
</dd>
</dl>
<h3>See Also</h3>

<p>Other RollingLDA functions: 
<code>RollingLDA()</code>,
<code>as.RollingLDA()</code>,
<code>getChunks()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
roll_lda = RollingLDA(texts = economy_texts[economy_dates &lt; "2008-05-01"],
                      dates = economy_dates[economy_dates &lt; "2008-05-01"],
                      chunks = "month",
                      memory = "month",
                      init = 100,
                      K = 10,
                      type = "lda")

# updateRollingLDA = RollingLDA, if first argument is a RollingLDA object
roll_update = RollingLDA(roll_lda,
                         texts = economy_texts[economy_dates &gt;= "2008-05-01"],
                         dates = economy_dates[economy_dates &gt;= "2008-05-01"],
                         chunks = "month",
                         memory = "month")

roll_update
getChunks(roll_update)


</code></pre>


</div>