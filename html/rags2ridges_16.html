<div class="container">

<table style="width: 100%;"><tr>
<td>createS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate sample covariances or datasets</h2>

<h3>Description</h3>

<p>Simulate data from a p-dimensional (zero-mean) gaussian graphical model (GGM)
with a specified (or random) topology and return the sample covariance matrix
or matrices. Can also return the original simulated data or underlying
precision matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">createS(
  n,
  p,
  topology = "identity",
  dataset = FALSE,
  precision = FALSE,
  nonzero = 0.25,
  m = 1L,
  banded.n = 2L,
  invwishart = FALSE,
  nu = p + 1,
  Plist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>A <code>numeric</code> vector giving number of samples. If the length is
larger than 1, the covariance matrices are returned as a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>A <code>numeric</code> of length 1 giving the dimension of the
samples/covariance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topology</code></td>
<td>
<p>character. The topology to use for the simulations. See the
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataset</code></td>
<td>
<p>A <code>logical</code> value specifying whether the sample
covariance or the simulated data itself should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision</code></td>
<td>
<p>A <code>logical</code> value. If <code>TRUE</code> the constructed
precision matrix is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonzero</code></td>
<td>
<p>A <code>numeric</code> of length 1 giving the value of the nonzero
entries used in some topologies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A <code>integer</code> giving the number of blocks (i.e. conditionally
independent components) to create. If <code>m</code> is greater than 1, then the
given <code>topology</code> is used on <code>m</code> blocks of approximately equal
size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>banded.n</code></td>
<td>
<p>A <code>integer</code> of length one giving the number of bands.
Only used if <code>topology</code> is one of <code>"banded"</code>,
<code>"small-world"</code>, or <code>"Watts-Strogatz"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invwishart</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> the constructed precision
matrix is used as the scale matrix of an inverse Wishart distribution and
class covariance matrices are drawn from this distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p><code>numeric</code> greater than <code>p + 1</code> giving the degrees of
freedom in the inverse Wishart distribution.  A large <code>nu</code> implies
high class homogeneity.  A small <code>nu</code> near <code>p + 1</code> implies high
class heterogeneity.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Plist</code></td>
<td>
<p>An optional <code>list</code> of <code>numeric</code> matrices giving the
precision matrices to simulate from. Useful when random matrices have
already been generated by setting <code>precision = TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The data is simulated from a zero-mean <code>p</code>-dimensional multivariate
gaussian distribution with some precision matrix determined by the argument
<code>topology</code> which defines the GGM. If <code>precision</code> is <code>TRUE</code> the
population precision matrix is returned. This is useful to see what the
actual would-be-used precision matrices are. The available values of
<code>topology</code> are described below. Unless otherwise stated the diagonal
entries are always one. If <code>m</code> is 2 or greater block diagonal precision
matrices are constructed and used. </p>
 <ul>
<li> <p><code>"identity"</code>: uses
the identity matrix (<code>diag(p)</code>) as precision matrix.  Corresponds to no
conditional dependencies.  </p>
</li>
<li> <p><code>"star"</code>: simulate from a star
topology. Within each block the first node is selected as the "hub". The
off-diagonal entries <code class="reqn">(1,j)</code> and <code class="reqn">(j,1)</code> values taper off with the
value <code class="reqn">1/(j + 1)</code>.  </p>
</li>
<li> <p><code>"clique"</code>: simulate from clique topology
where each block is a complete graph with off-diagonal elements equal to
<code>nonzero</code>.  </p>
</li>
<li> <p><code>"complete"</code>: alias for (and identical to)
<code>"clique"</code>.  </p>
</li>
<li> <p><code>"chain"</code>: simulate from a chain topology where
the precision matrix is a tridiagonal matrix with off-diagonal elements (in
each block) given by argument <code>nonzero</code>.  </p>
</li>
<li> <p><code>"banded"</code>:
precision elements <code>(i,j)</code> are given by <code class="reqn">1/(|i-j|+1)</code> if <code class="reqn">|i-j|</code>
is less than or equal to <code>banded.n</code> and zero otherwise. </p>
</li>
<li>
<p><code>"scale-free"</code>: The non-zero pattern of each block is generated by a
Barabassi random graph. Non-zero off-diagonal values are given by
<code>nonzero</code>.  Gives are very "hubby" network.  </p>
</li>
<li> <p><code>"Barabassi"</code>:
alias for <code>"scale-free"</code>.  </p>
</li>
<li> <p><code>"small-world"</code>: The non-zero
pattern of each block is generated by a 1-dimensional Watts-Strogatz random
graph with <code>banded.n</code> starting neighbors and <code class="reqn">5\%</code> probability of
rewiring.  Non-zero off-diagonal values are given by <code>nonzero</code>. Gives
are very "bandy" network.  </p>
</li>
<li> <p><code>"Watts-Strogatz"</code>: alias for
<code>"small-world"</code> </p>
</li>
<li> <p><code>"random-graph"</code>: The non-zero pattern of
each block is generated by a Erdos-Renyi random graph where each edge is
present with probability <code class="reqn">1/p</code>.  Non-zero off-diagonal values are given
by <code>nonzero</code>.  </p>
</li>
<li> <p><code>"Erdos-Renyi"</code>: alias for
<code>"random-graph"</code> </p>
</li>
</ul>
<p> When <code>n</code> has length greater than 1, the datasets
are generated i.i.d. given the topology and number of blocks.
</p>
<p>Arguments <code>invwishart</code> and <code>nu</code> allows for introducing class
homogeneity. Large values of <code>nu</code> imply high class homogeneity.
<code>nu</code> must be greater than <code>p + 1</code>. More precisely, if
<code>invwishart == TRUE</code> then the constructed precision matrix is used as
the scale parameter in an inverse Wishart distribution with <code>nu</code> degrees
of freedom. Each class covariance is distributed according to this inverse
Wishart and independent.
</p>


<h3>Value</h3>

<p>The returned type is dependent on <code>n</code> and <code>covariance</code>. The
function generally returns a <code>list</code> of <code>numeric</code> matrices with
the same length as <code>n</code>. If <code>covariance</code> is <code>FALSE</code> the
simulated datasets with size <code>n[i]</code> by <code>p</code> are given in the
<code>i</code> entry of the output. If <code>covariance</code> is <code>TRUE</code> the
<code>p</code> by <code>p</code> sample covariances of the datasets are given. When
<code>n</code> has length 1 the <code>list</code> structure is dropped and the matrix
is returned.
</p>


<h3>Author(s)</h3>

<p>Anders E. Bilgrau, Carel F.W. Peeters &lt;carel.peeters@wur.nl&gt;, Wessel
N. van Wieringen
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate some simple sample covariance matrices
createS(n = 10, p = 3)
createS(n = c(3, 4, 5), p = 3)
createS(n = c(32, 55), p = 7)

## Generate some datasets and not sample covariance matrices
createS(c(3, 4), p = 6, dataset = TRUE)

## Generate sample covariance matrices from other topologies:
A &lt;- createS(2000, p = 4, topology = "star")
round(solve(A), 3)
B &lt;- createS(2000, p = 4, topology = "banded", banded.n = 2)
round(solve(B), 3)
C &lt;- createS(2000, p = 4, topology = "clique")  # The complete graph (as m = 1)
round(solve(C), 3)
D &lt;- createS(2000, p = 4, topology = "chain")
round(solve(D), 3)

## Generate smaple covariance matrices from block topologies:
C3 &lt;- createS(2000, p = 10, topology = "clique", m = 3)
round(solve(C3), 1)
C5 &lt;- createS(2000, p = 10, topology = "clique", m = 5)
round(solve(C5), 1)

## Can also return the precision matrix to see what happens
## m = 2 blocks, each "banded" with 4 off-diagonal bands
round(createS(1, 12, "banded", m = 2, banded.n = 4, precision = TRUE), 2)

## Simulation using graph-games
round(createS(1, 10, "small-world", precision = TRUE), 2)
round(createS(1, 5, "scale-free", precision = TRUE), 2)
round(createS(1, 5, "random-graph", precision = TRUE), 2)

## Simulation using inverse Wishart distributed class covariance
## Low class homogeneity
createS(n = c(10,10), p = 5, "banded", invwishart = TRUE, nu = 10)
## Extremely high class homogeneity
createS(n = c(10,10), p = 5, "banded", invwishart = TRUE, nu = 1e10)

# The precision argument can again be used to see the actual realised class
# precision matrices used when invwishart = TRUE.

# The Plist argument is used to reuse old precision matrices or
# user-generated ones
P &lt;- createS(n = 1, p = 5, "banded", precision = TRUE)
lapply(createS(n = c(1e5, 1e5), p = 5, Plist = list(P, P+1)), solve)

</code></pre>


</div>