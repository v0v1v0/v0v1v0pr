<div class="container">

<table style="width: 100%;"><tr>
<td>primeSieve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate Prime Numbers
</h2>

<h3>Description</h3>

<p>Implementation of the segmented sieve of Eratosthenes with wheel factorization. Generates all prime numbers between <code>bound1</code> and <code>bound2</code> (if supplied) or all primes up to <code>bound1</code>. See this stackoverflow post for an analysis on prime number generation efficiency in R: <a href="https://stackoverflow.com/a/48313378/4408538">Generate a list of primes up to a certain number
</a>
</p>
<p>The fundamental concepts of this algorithm are based off of the implementation by Kim Walisch found here: <a href="https://github.com/kimwalisch/primesieve">kimwalisch/primesieve</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">primeSieve(bound1, bound2 = NULL, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>At the heart of this algorithm is the traditional sieve of Eratosthenes (i.e. given a <a href="https://en.wikipedia.org/wiki/Prime_number">prime</a> <code class="reqn">p</code>, mark all multiples of <code class="reqn">p</code> as <a href="https://en.wikipedia.org/wiki/Composite_number">composite</a>), however instead of sieving the entire interval, we only consider small sub-intervals. The benefits of this method are two fold:
</p>

<ol>
<li>
<p> Reduction of the <a href="https://en.wikipedia.org/wiki/DSPACE">space complexity</a> from <code class="reqn">O(n)</code>, for the traditional sieve, to <code class="reqn">O(\sqrt n)</code>
</p>
</li>
<li>
<p> Reduction of <a href="https://en.wikipedia.org/wiki/CPU_cache#Cache_miss">cache misses</a>
</p>
</li>
</ol>
<p>The latter is of particular importance as cache memory is much more efficient and closer in proximity to the CPU than <a href="https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage">main memory</a>. Reducing the size of the sieving interval allows for more effective utilization of the cache, which greatly impacts the overall efficiency.
</p>
<p>Another optimization over the traditional sieve is the utilization of wheel factorization. With the traditional sieve of Eratosthenes, you typically check every odd index of your logical vector and if the value is true, you have found a prime. With wheel factorization using the first four primes (i.e. 2, 3, 5, and 7) to construct your wheel (i.e. 210 wheel), you only have to check indices of your logical vector that are coprime to 210 (i.e. the product of the first four primes). As an example, with <code class="reqn">n = 10000</code> and a 210 wheel, you only have to check 2285 indices vs. 5000 with the classical implementation.
</p>


<h3>Value</h3>

<p>Returns an integer vector if <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, or a numeric vector otherwise.
</p>


<h3>Note</h3>


<ul>
<li>
<p>It does not matter which bound is larger as the resulting primes will be between <code>min(bound1, bound2)</code> and <code>max(bound1, bound2)</code> if <code>bound2</code> is provided.
</p>
</li>
<li>
<p>The maximum value for either of the bounds is <code class="reqn">2^{53} - 1</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://github.com/kimwalisch/primesieve">primesieve (Fast C/C++ prime number generator)</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Wheel_factorization">Wheel factorization</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Primes up to a thousand
primeSieve(100)

## Primes between 42 and 17
primeSieve(42, 17)

## Equivalent to
primeSieve(17, 42)

## Primes up to one hundred million in no time
system.time(primeSieve(10^8))

## options(scipen = 50)
## Generate large primes over interval
system.time(myPs &lt;- primeSieve(10^13+10^6, 10^13))
## Object created is small
object.size(myPs)

## Using nThreads
system.time(primeSieve(1e7, nThreads = 2))
</code></pre>


</div>