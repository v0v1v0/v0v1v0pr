<div class="container">

<table style="width: 100%;"><tr>
<td>GrossoLocatelliPullanMcRunner</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>LEMON runners</h2>

<h3>Description</h3>

<p>These "runner" functions provide a slightly lower-level access to LEMON. See
"Details".
</p>


<h3>Usage</h3>

<pre><code class="language-R">GrossoLocatelliPullanMcRunner(arcSources, arcTargets, numNodes)

getBipartitePartitionsRunner(arcSources, arcTargets, numNodes)

getAndCheckTopologicalSortRunner(arcSources, arcTargets, numNodes)

getTopologicalSortRunner(arcSources, arcTargets, numNodes)

IsConnectedRunner(arcSources, arcTargets, numNodes)

IsAcyclicRunner(arcSources, arcTargets, numNodes)

IsTreeRunner(arcSources, arcTargets, numNodes)

IsBipartiteRunner(arcSources, arcTargets, numNodes)

IsStronglyConnectedRunner(arcSources, arcTargets, numNodes)

IsDAGRunner(arcSources, arcTargets, numNodes)

IsBiNodeConnectedRunner(arcSources, arcTargets, numNodes)

IsBiEdgeConnectedRunner(arcSources, arcTargets, numNodes)

IsLoopFreeRunner(arcSources, arcTargets, numNodes)

IsParallelFreeRunner(arcSources, arcTargets, numNodes)

IsSimpleGraphRunner(arcSources, arcTargets, numNodes)

IsEulerianRunner(arcSources, arcTargets, numNodes)

CountBiEdgeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

CountConnectedComponentsRunner(arcSources, arcTargets, numNodes)

CountBiNodeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

CountStronglyConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindStronglyConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindStronglyConnectedCutArcsRunner(arcSources, arcTargets, numNodes)

FindBiEdgeConnectedCutEdgesRunner(arcSources, arcTargets, numNodes)

FindBiNodeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindBiNodeConnectedCutNodesRunner(arcSources, arcTargets, numNodes)

FindConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindBiEdgeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

GraphCompatabilityConverter(nodesList, arcSources, arcTargets)

BfsRunner(arcSources, arcTargets, numNodes, startNode = -1L, endNode = -1L)

DfsRunner(arcSources, arcTargets, numNodes, startNode = -1L, endNode = -1L)

MaxCardinalitySearchRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  numNodes,
  startNode = -1L
)

CirculationRunner(
  arcSources,
  arcTargets,
  arcLowerBound,
  arcUpperBound,
  nodeSupplies,
  numNodes
)

PreflowRunner(
  arcSources,
  arcTargets,
  arcDistances,
  sourceNode,
  destinationNode,
  numNodes
)

EdmondsKarpRunner(
  arcSources,
  arcTargets,
  arcDistances,
  sourceNode,
  destinationNode,
  numNodes
)

MaximumWeightPerfectMatchingRunner(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes
)

MaximumWeightFractionalPerfectMatchingRunner(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes
)

MaximumWeightFractionalMatchingRunner(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes
)

MaximumWeightMatchingRunner(arcSources, arcTargets, arcWeights, numNodes)

MaximumCardinalityMatchingRunner(arcSources, arcTargets, numNodes)

MaximumCardinalityFractionalMatchingRunner(arcSources, arcTargets, numNodes)

CycleCancellingRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

CapacityScalingRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

CostScalingRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

NetworkSimplexRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

NagamochiIbarakiRunner(arcSources, arcTargets, arcWeights, numNodes)

HaoOrlinRunner(arcSources, arcTargets, arcWeights, numNodes)

GomoryHuTreeRunner(arcSources, arcTargets, arcWeights, numNodes)

HowardMmcRunner(arcSources, arcTargets, arcDistances, numNodes)

KarpMmcRunner(arcSources, arcTargets, arcDistances, numNodes)

HartmannOrlinMmcRunner(arcSources, arcTargets, arcDistances, numNodes)

KruskalRunner(arcSources, arcTargets, arcDistances, numNodes)

MinCostArborescenceRunner(
  arcSources,
  arcTargets,
  arcDistances,
  sourceNode,
  numNodes
)

PlanarCheckingRunner(arcSources, arcTargets, numNodes)

PlanarEmbeddingRunner(arcSources, arcTargets, numNodes)

PlanarColoringRunner(arcSources, arcTargets, numNodes, useFiveAlg = TRUE)

PlanarDrawingRunner(arcSources, arcTargets, numNodes)

SuurballeRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  startNode,
  endNode
)

DijkstraRunner(arcSources, arcTargets, arcDistances, numNodes, startNode)

BellmanFordRunner(arcSources, arcTargets, arcDistances, numNodes, startNode)

ChristofidesRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

GreedyTSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

InsertionTSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

NearestNeighborTSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

Opt2TSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

lemon_runners()
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>arcSources</code></td>
<td>
<p>a vector corresponding to the source nodes of a graph’s
edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcTargets</code></td>
<td>
<p>a vector corresponding to the destination nodes of a
graph’s edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numNodes</code></td>
<td>
<p>the number of nodes in the graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodesList</code></td>
<td>
<p>a vector of all the nodes in the graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startNode</code></td>
<td>
<p>in path-based algorithms, the start node of the path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endNode</code></td>
<td>
<p>in path-based algorithms, the end node of the path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcCapacities</code></td>
<td>
<p>vector corresponding to the capacities of nodes of a
graph’s edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcLowerBound</code></td>
<td>
<p>vector corresponding to the lower-bound capacities of
nodes of a graph’s edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcUpperBound</code></td>
<td>
<p>vector corresponding to the upper-bound capacities of
nodes of a graph’s edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodeSupplies</code></td>
<td>
<p>vector corresponding to the supplies of each node of the
graph</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcDistances</code></td>
<td>
<p>vector corresponding to the distances of a graph’s edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sourceNode</code></td>
<td>
<p>in flow-based algorithms, the source node of the flow</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>destinationNode</code></td>
<td>
<p>in flow-based algorithms, the destination node of the
flow</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcWeights</code></td>
<td>
<p>vector corresponding to the weights of a graph’s arcs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arcCosts</code></td>
<td>
<p>vector corresponding to the costs of nodes of a graph’s
edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useFiveAlg</code></td>
<td>
<p>if <code>TRUE</code> (default), run a 5-color algorithm. If
<code>FALSE</code>, runs a faster 6-coloring algorithm instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>defaultEdgeWeight</code></td>
<td>
<p>The default edge weight if an edge is not-specified
(default value 999999)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Internally, all exported rlemon functions call a "runner" function to
interface with the C++, for example, <code>MaxFlow(..., algorithm =
"PreFlow")</code> will call <code>PreFlowRunner(...)</code>.
</p>
<p>In almost all cases, users will want to stick with the exported functions.
</p>
<p>Runners differ from exported functions in a few ways:
</p>

<ol>
<li>
<p> Exported functions provide input checking.
</p>
</li>
<li>
<p> Exported functions provide slightly cleaner output, such as
converting 0/1 boolean into <code>logical</code>.
</p>
</li>
<li>
<p> Any <code>list</code> which is returned from an exported function will be
named.
</p>
</li>
<li>
<p> The <code>arcWeights</code> argument is optional to <code>MaxMatching()</code>,
automatically generating a constant weight if it is excluded.
<code>arcWeights</code> is not optional in <code>MaxMatchingRunner()</code>.
</p>
</li>
</ol>
<h3>Value</h3>

<p>Algorithm results
</p>


</div>