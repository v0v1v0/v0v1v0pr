<div class="container">

<table style="width: 100%;"><tr>
<td>RRF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Feature Selection with Regularized Random Forest</h2>

<h3>Description</h3>

<p><code>RRF</code> implements the regularized random forest algorithm. It is based on
the randomForest R package by Andy Liaw, Matthew Wiener, Leo Breiman and Adele Cutler.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
RRF(formula, data=NULL, ..., subset, na.action=na.fail)
## Default S3 method:
RRF(x, y=NULL,  xtest=NULL, ytest=NULL, ntree=500,
             mtry=if (!is.null(y) &amp;&amp; !is.factor(y))
             max(floor(ncol(x)/3), 1) else floor(sqrt(ncol(x))),
             replace=TRUE, classwt=NULL, cutoff, strata,
             sampsize = if (replace) nrow(x) else ceiling(.632*nrow(x)),
             nodesize = if (!is.null(y) &amp;&amp; !is.factor(y)) 5 else 1,
             maxnodes = NULL,
             importance=FALSE, localImp=FALSE, nPerm=1,
             proximity, oob.prox=proximity,
             norm.votes=TRUE, do.trace=FALSE,
             keep.forest=!is.null(y) &amp;&amp; is.null(xtest), corr.bias=FALSE,
             keep.inbag=FALSE,  coefReg=NULL, flagReg=1, feaIni=NULL,...)
## S3 method for class 'RRF'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame containing the variables in the model.
By default the variables are taken from the environment which
<code>RRF</code> is called from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an index vector indicating which rows should be used.
(NOTE: If given, this argument must be named.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function to specify the action to be taken if NAs
are found.  (NOTE: If given, this argument must be named.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, formula</code></td>
<td>
<p>a data frame or a matrix of predictors, or a formula
describing the model to be fitted (for the
<code>print</code> method, an <code>RRF</code> object).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A response vector.  If a factor, classification is assumed,
otherwise regression is assumed.  If omitted, <code>RRF</code>
will run in unsupervised mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xtest</code></td>
<td>
<p>a data frame or matrix (like <code>x</code>) containing
predictors for the test set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ytest</code></td>
<td>
<p>response for the test set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>
<p>Number of trees to grow.  This should not be set to too
small a number, to ensure that every input row gets predicted at
least a few times. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtry</code></td>
<td>
<p>Number of variables randomly sampled as candidates at each
split.  Note that the default values are different for
classification (sqrt(p) where p is number of variables in <code>x</code>)
and regression (p/3)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>Should sampling of cases be done with or without
replacement?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classwt</code></td>
<td>
<p>Priors of the classes.  Need not add up to one.
Ignored for regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>(Classification only)  A vector of length equal to
number of classes.  The ‘winning’ class for an observation is the
one with the maximum ratio of proportion of votes to cutoff.
Default is 1/k where k is the number of classes (i.e., majority vote
wins).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p>A (factor) variable that is used for stratified sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampsize</code></td>
<td>
<p>Size(s) of sample to draw.  For classification, if
sampsize is a vector of the length the number of strata, then
sampling is stratified by strata, and the elements of sampsize
indicate the numbers to be drawn from the strata.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodesize</code></td>
<td>
<p>Minimum size of terminal nodes.  Setting this number
larger causes smaller trees to be grown (and thus take less time).
Note that the default values are different for classification (1)
and regression (5).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxnodes</code></td>
<td>
<p>Maximum number of terminal nodes trees in the forest
can have.  If not given, trees are grown to the maximum possible
(subject to limits by <code>nodesize</code>).  If set larger than maximum
possible, a warning is issued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>importance</code></td>
<td>
<p>Should importance of predictors be assessed? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localImp</code></td>
<td>
<p>Should casewise importance measure be computed?
(Setting this to <code>TRUE</code> will override <code>importance</code>.) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nPerm</code></td>
<td>
<p>Number of times the OOB data are permuted per tree for
assessing variable importance.  Number larger than 1 gives slightly
more stable estimate, but not very effective.  Currently only
implemented for regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proximity</code></td>
<td>
<p>Should proximity measure among the rows be
calculated?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oob.prox</code></td>
<td>
<p>Should proximity be calculated only on “out-of-bag”
data?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.votes</code></td>
<td>
<p>If <code>TRUE</code> (default), the final result of votes
are expressed as fractions.  If <code>FALSE</code>, raw vote counts are
returned (useful for combining results from different runs).
Ignored for regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.trace</code></td>
<td>
<p>If set to <code>TRUE</code>, give a more verbose output as
<code>RRF</code> is run.  If set to some integer, then running
output is printed for every <code>do.trace</code> trees.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.forest</code></td>
<td>
<p>If set to <code>FALSE</code>, the forest will not be
retained in the output object.  If <code>xtest</code> is given, defaults
to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr.bias</code></td>
<td>
<p>perform bias correction for regression?  Note:
Experimental.  Use at your own risk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.inbag</code></td>
<td>
<p>Should an <code>n</code> by <code>ntree</code> matrix be
returned that keeps track of which samples are “in-bag” in which
trees (but not how many times, if sampling with replacement)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefReg</code></td>
<td>
<p>the coefficient(s) of regularization. A smaller coefficient may lead to a smaller feature subset, i.e. there are fewer variables with non-zero importance scores. coefReg must be either a single value (all 
variables have the same coefficient) or a numeric vector of length equal to the number of predictor variables. default: 0.8</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flagReg</code></td>
<td>
<p>1: with regularization; 0: without regularization. default: 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>feaIni</code></td>
<td>
<p>initial feature subset, useful only when flagReg = 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional parameters to be passed to the low level function
<code>RRF.default</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>RRF</code>, which is a list with the
following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the original call to <code>RRF</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>one of <code>regression</code>, <code>classification</code>, or
<code>unsupervised</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predicted</code></td>
<td>
<p>the predicted values of the input data based on
out-of-bag samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>importance</code></td>
<td>
<p>a matrix with <code>nclass</code> + 2 (for classification)
or two (for regression) columns.  For classification, the first
<code>nclass</code> columns are the class-specific measures computed as
mean descrease in accuracy.  The <code>nclass</code> + 1st column is the
mean descrease in accuracy over all classes.  The last column is the
mean decrease in Gini index.  For Regression, the first column is
the mean decrease in accuracy and the second the mean decrease in MSE.
If <code>importance=FALSE</code>, the last measure is still returned as a
vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>importanceSD</code></td>
<td>
<p>The “standard errors” of the permutation-based
importance measure.  For classification, a <code>p</code> by <code>nclass
      + 1</code> matrix corresponding to the first <code>nclass + 1</code> columns
of the importance matrix.  For regression, a length <code>p</code> vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>localImp</code></td>
<td>
<p>a p by n matrix containing the casewise importance
measures, the [i,j] element of which is the importance of i-th
variable on the j-th case. <code>NULL</code> if <code>localImp=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ntree</code></td>
<td>
<p>number of trees grown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mtry</code></td>
<td>
<p>number of predictors sampled for spliting at each node.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forest</code></td>
<td>
<p>(a list that contains the entire forest; <code>NULL</code> if
<code>RRF</code> is run in unsupervised mode or if
<code>keep.forest=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>err.rate</code></td>
<td>
<p>(classification only) vector error rates of the
prediction on the input data, the i-th element being the (OOB) error rate
for all trees up to the i-th.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confusion</code></td>
<td>
<p>(classification only) the confusion matrix of the
prediction (based on OOB data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>votes</code></td>
<td>
<p>(classification only) a matrix with one row for each
input data point and one column for each class, giving the fraction
or number of (OOB) ‘votes’ from the random forest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oob.times</code></td>
<td>
<p>number of times cases are ‘out-of-bag’ (and thus used
in computing OOB error estimate)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proximity</code></td>
<td>
<p>if <code>proximity=TRUE</code> when
<code>RRF</code> is called, a matrix of proximity measures among
the input (based on the frequency that pairs of data points are in
the same terminal nodes).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>feaSet</code></td>
<td>
<p>features selected</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mse</code></td>
<td>
<p>(regression only) vector of mean square errors: sum of squared
residuals divided by <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rsq</code></td>
<td>
<p>(regression only) “pseudo R-squared”: 1 - <code>mse</code> /
Var(y).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>if test set is given (through the <code>xtest</code> or additionally
<code>ytest</code> arguments), this component is a list which contains the
corresponding <code>predicted</code>, <code>err.rate</code>, <code>confusion</code>,
<code>votes</code> (for classification) or <code>predicted</code>, <code>mse</code> and
<code>rsq</code> (for regression) for the test set.  If
<code>proximity=TRUE</code>, there is also a component, <code>proximity</code>,
which contains the proximity among the test set as well as proximity
between test and training data.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>For large data sets, especially those with large number of variables, calling RRF via the
formula interface is not advised: There may be too much overhead in handling the formula.
</p>


<h3>Author(s)</h3>

<p>Houtao Deng <a href="mailto:softwaredeng@gmail.com">softwaredeng@gmail.com</a>, based on the randomForest R package by Andy Liaw, Matthew Wiener, Leo Breiman and Adele Cutler.</p>


<h3>References</h3>

<p>Houtao Deng and George C. Runger (2013), <em>Gene Selection with Guided Regularized Random Forest</em>, Pattern Recognition 46(12): 3483-3489.
</p>
<p>Houtao Deng and George C. Runger (2012), <em>Feature Selection via Regularized Trees</em>, the 2012 International Joint Conference on Neural Networks (IJCNN).
</p>
<p>Houtao Deng (2013), <em>Guided Random Forest in the RRF Package</em>, arXiv:1306.0237.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#-----Example 1 -----
library(RRF);set.seed(1)

#only the first feature and last feature are truly useful
X &lt;- matrix(runif(50*50), ncol=50)
class &lt;- (X[,1])^2 + (X[,50])^2  
class[class&gt;median(class)] &lt;- 1;
class[class&lt;=median(class)] &lt;- 0

#ordinary random forest. 
rf &lt;- RRF(X,as.factor(class), flagReg = 0)
impRF &lt;- rf$importance
impRF &lt;- impRF[,"MeanDecreaseGini"]
rf$feaSet

#regularized random forest
rrf &lt;- RRF(X,as.factor(class), flagReg = 1)
rrf$feaSet

#guided regularized random forest
imp &lt;- impRF/(max(impRF))#normalize the importance score
gamma &lt;- 0.5
coefReg &lt;- (1-gamma)+gamma*imp #weighted average
grrf &lt;- RRF(X,as.factor(class),coefReg=coefReg, flagReg=1)
grrf$feaSet

#guided random forest
gamma &lt;- 1
coefReg &lt;- (1-gamma)+gamma*imp 
grf &lt;- RRF(X,as.factor(class),coefReg=coefReg, flagReg=0)
grf$feaSet

#-----Example 2 XOR learning-----
#only the first 3 features are needed
#and each individual feature is not useful
#bSample &lt;- sample(0:1,20000,replace=TRUE)
#X &lt;- matrix(bSample,ncol=40)
#class &lt;- xor(xor(X[,1],X[,2]),X[,3])
</code></pre>


</div>