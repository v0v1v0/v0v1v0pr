<div class="container">

<table style="width: 100%;"><tr>
<td>sofar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse orthogonal factor regression</h2>

<h3>Description</h3>

<p>Compute solution paths of sparse orthogonal factor regression
</p>


<h3>Usage</h3>

<pre><code class="language-R">sofar(
  Y,
  X,
  nrank = 1,
  su = NULL,
  sv = NULL,
  ic.type = c("GIC", "BIC", "AIC", "GCV"),
  modstr = list(),
  control = list(),
  screening = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>response matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>covariate matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrank</code></td>
<td>
<p>an integer specifying the desired rank/number of factors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>su</code></td>
<td>
<p>a scaling vector for U such that <code class="reqn">U^TU = diag(s_u)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sv</code></td>
<td>
<p>a scaling vector for V such that <code class="reqn">V^TV = diag(s_v)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ic.type</code></td>
<td>
<p>select tuning method; the default is GIC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modstr</code></td>
<td>
<p>a list of internal model parameters controlling the model
fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of internal computation parameters controlling
optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>screening</code></td>
<td>
<p>If TRUE, marginal screening via lasso is performed before
sofar fitting.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The model parameters can be specified through argument <code>modstr</code>.
The available elements include
</p>

<ul>
<li>
<p>mu: parameter in the augmented Lagrangian function.
</p>
</li>
<li>
<p>mugamma: increament of mu along iterations to speed up
computation.
</p>
</li>
<li>
<p>WA: weight matrix for A.
</p>
</li>
<li>
<p>WB: weight matrix for B.
</p>
</li>
<li>
<p>Wd: weight matrix for d.
</p>
</li>
<li>
<p>wgamma: power parameter in constructing adaptive weights.
</p>
</li>
</ul>
<p>The model fitting can be controled through argument <code>control</code>.
The avilable elements include
</p>

<ul>
<li>
<p>nlam: number of lambda triplets to be used.
</p>
</li>
<li>
<p>lam.min.factor: set the smallest lambda triplets as a fraction of the
estimation lambda.max triplets.
</p>
</li>
<li>
<p>lam.max.factor: set the largest lambda triplets as a multiple of the
estimation lambda.max triplets.
</p>
</li>
<li>
<p>lam.AB.factor: set the relative penalty level between A/B and D.
</p>
</li>
<li>
<p>penA,penB,penD: if TRUE, penalty is applied.
</p>
</li>
<li>
<p>lamA: sequence of tuning parameters for A.
</p>
</li>
<li>
<p>lamB: sequence of tuning parameters for B.
</p>
</li>
<li>
<p>lamD: sequence of tuning parameters for d.
</p>
</li>
<li>
<p>methodA: penalty for penalizing A.
</p>
</li>
<li>
<p>methodB: penalty for penalizing B.
</p>
</li>
<li>
<p>epsilon: convergence tolerance.
</p>
</li>
<li>
<p>maxit: maximum number of iterations.
</p>
</li>
<li>
<p>innerEpsilon: convergence tolerance for inner subroutines.
</p>
</li>
<li>
<p>innerMaxit: maximum number of iterations for inner subroutines.
</p>
</li>
<li>
<p>sv.tol: tolerance for singular values.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>sofar</code> object containing
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>original function call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>input response matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>input predictor matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Upath</code></td>
<td>
<p>solution path of U</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dpath</code></td>
<td>
<p>solution path of D</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vpath</code></td>
<td>
<p>solution path of D</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rpath</code></td>
<td>
<p>path of estimated rank</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>icpath</code></td>
<td>
<p>path of information criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam.id</code></td>
<td>
<p>ids of selected lambda for GIC, BIC, AIC and GCV</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.index</code></td>
<td>
<p>ids of predictors which passed screening</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q.index</code></td>
<td>
<p>ids of responses which passed screening</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lamA</code></td>
<td>
<p>tuning sequence for A</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lamB</code></td>
<td>
<p>tuning sequence for B</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lamD</code></td>
<td>
<p>tuning sequence for D</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>estimated left singular matrix that is orthogonal (factor weights)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>estimated right singular matrix that is orthogonal (factor loadings)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>estimated singular values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>estimated rank</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Uematsu, Y., Fan, Y., Chen, K., Lv, J., &amp; Lin, W. (2019). SOFAR: large-scale
association network learning. <em>IEEE Transactions on Information
Theory</em>, 65(8), 4924â€“4939.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(rrpack)
## Simulate data from a sparse factor regression model
p &lt;- 100; q &lt;- 50; n &lt;- 100; nrank &lt;- 3
mydata &lt;- rrr.sim1(n, p, q, nrank, s2n = 1,
                   sigma = NULL, rho_X = 0.5, rho_E = 0.3)
Y &lt;- mydata$Y
X &lt;- mydata$X

fit1 &lt;- sofar(Y, X, ic.type = "GIC", nrank = nrank + 2,
              control = list(methodA = "adlasso", methodB = "adlasso"))
summary(fit1)
plot(fit1)

fit1$U
crossprod(fit1$U) #check orthogonality
fit1$V
crossprod(fit1$V) #check orthogonality

## End(Not run)

</code></pre>


</div>