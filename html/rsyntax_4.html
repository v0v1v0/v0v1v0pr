<div class="container">

<table style="width: 100%;"><tr>
<td>annotate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Annotate a tokenlist based on rsyntax queries</h2>

<h3>Description</h3>

<p>This function has been renamed to annotate_tqueries.
</p>


<h3>Usage</h3>

<pre><code class="language-R">annotate(
  tokens,
  column,
  ...,
  block = NULL,
  fill = TRUE,
  overwrite = FALSE,
  block_fill = FALSE,
  copy = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with as_tokenindex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>column</code></td>
<td>
<p>The name of the column in which the annotations are added. The unique ids are added as column_id</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One or multiple tqueries, or a list of queries, as created with tquery. Queries can be given a named by using a named argument, which will be used in the annotation_id to keep track of which query was used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p>Optionally, specify ids (doc_id - sentence - token_id triples) that are blocked from querying and filling (ignoring the id and recursive searches through the id).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>Logical. If TRUE (default) also assign the fill nodes (as specified in the tquery). Otherwise these are ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>If TRUE, existing column will be overwritten. Otherwise (default), the exsting annotations in the column will be blocked, and new annotations will be added. This is identical to using multiple queries.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block_fill</code></td>
<td>
<p>If TRUE (and overwrite is FALSE), the existing fill nodes will also be blocked. In other words, the new annotations will only be added if the</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>copy</code></td>
<td>
<p>If TRUE (default), the data.table is copied. Otherwise, it is changed by reference. Changing by reference is faster and more memory efficient, but is not predictable R style, so is optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If TRUE, report progress (only usefull if multiple queries are given)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Apply queries to extract syntax patterns, and add the results as two columns to a tokenlist.
One column contains the ids for each hit. The other column contains the annotations.
Only nodes that are given a name in the tquery (using the 'label' parameter) will be added as annotation.
</p>
<p>Note that while queries only find 1 node for each labeld component of a pattern (e.g., quote queries have 1 node for "source" and 1 node for "quote"), 
all children of these nodes can be annotated by settting fill to TRUE. If a child has multiple ancestors, only the most direct ancestors are used (see documentation for the fill argument).
</p>


<h3>Value</h3>

<p>The tokenIndex with the annotation columns
</p>


<h3>Examples</h3>

<pre><code class="language-R">## spacy tokens for: Mary loves John, and Mary was loved by John
tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"))

 
tokens = annotate_tqueries(tokens, "clause", pas=passive, act=active)
tokens
if (interactive()) plot_tree(tokens, annotation='clause')

</code></pre>


</div>