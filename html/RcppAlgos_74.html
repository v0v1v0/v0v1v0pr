<div class="container">

<table style="width: 100%;"><tr>
<td>partitionsIter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Partition/Composition Iterator
</h2>

<h3>Description</h3>


<ul>
<li>
<p> Returns an iterator for iterating over partitions/compositions of a numbers.
</p>
</li>
<li>
<p> Supports random access via the <code>[[</code> method.
</p>
</li>
<li>
<p> GMP support allows for exploration of cases where the number of partitions/compositions is large.
</p>
</li>
<li>
<p> Use the <code>next</code> methods to obtain results in lexicographical order.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">partitionsIter(v, m = NULL, ...)
compositionsIter(v, m = NULL, ...)

## Default S3 method:
partitionsIter(v, m = NULL, repetition = FALSE,
               freqs = NULL, target = NULL,
               nThreads = NULL, tolerance = NULL, ...)

## Default S3 method:
compositionsIter(v, m = NULL, repetition = FALSE, freqs = NULL,
                 target = NULL, weak = FALSE, nThreads = NULL,
                 tolerance = NULL, ...)

## S3 method for class 'table'
partitionsIter(
    v, m = NULL, target = NULL, nThreads = NULL, tolerance = NULL, ...
)
## S3 method for class 'table'
compositionsIter(
    v, m = NULL, target = NULL, weak = FALSE, nThreads = NULL, tolerance = NULL, ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. Only integer and numeric vectors are accepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Width of the partition. If <code>m = NULL</code>, the length will be determined by the partitioning case (<em>e.g.</em> When we are generating distinct partitions of <code class="reqn">n</code>, the width will be equal to the smallest <code class="reqn">m</code> such that <code>sum(1:m) &gt;= n</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetition</code></td>
<td>
<p>Logical value indicating whether partitions/compositions should be with or without repetition. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freqs</code></td>
<td>
<p>A vector of frequencies used for producing all partitions of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code>rep</code>. The default value is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>Number to be partitioned. If <code>NULL</code>, <code>max(v)</code> will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weak</code></td>
<td>
<p>(Compositions only) Logical flag indicating whether to allow terms of the sequence to be zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>A numeric value greater than or equal to zero. This parameter is utilized when a constraint is applied on a numeric vector. The default value is 0 when it can be determined that whole values are being utilized, otherwise it is <code>sqrt(.Machine$double.eps)</code> which is approximately <code class="reqn">1.5e-8</code>. N.B. If the input vector is of type integer, this parameter will be ignored and strict equality will be enforced.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Once you initialize a new iterator, the following methods are available:
</p>

<dl>
<dt><code>nextIter</code></dt>
<dd>
<p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt>
<dd>
<p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt>
<dd>
<p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt>
<dd>
<p>Returns the current iteration</p>
</dd>
<dt><code>startOver</code></dt>
<dd>
<p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt>
<dd>
<p>View the source vector</p>
</dd>
<dt><code>summary</code></dt>
<dd>
<p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt>
<dd>
<p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt>
<dd>
<p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>[[</code></dt>
<dd>
<p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>
<h3>Value</h3>


<ul>
<li>
<p> If <code>nextIter</code> is called, a vector is returned
</p>
</li>
<li>
<p> Otherwise, a matrix with <code class="reqn">m</code> columns
</p>
</li>
</ul>
<h3>Note</h3>


<ul>
<li>
<p>If <code>nThreads</code> is utilized, it will only take effect if the number of elements requested is greater than some threshold (determined internally). <em>E.g</em>:
</p>
<pre>serial   &lt;- partitionsIter(1000, 10)
multi    &lt;- partitionsIter(1000, 10, nThreads = 4)
fetch1e6 &lt;- multi@nextNIter(1e6)  ## much faster than serial@nextNIter(1e6)
fetch1e3 &lt;- multi@nextNIter(1e3)  ## only one thread used... same as serial@nextNIter(1e3)

library(microbenchmark)
microbenchmark(multi@nextNIter(1e6), serial@nextNIter(1e6))
microbenchmark(multi@nextNIter(1e3), serial@nextNIter(1e3))</pre>

</li>
<li>
<p><code>nThreads</code> will be ignored in the following cases (i.e. Generating the <code class="reqn">n^{th}</code> partition in these cases are currently unavailable):
</p>

<ul>
<li>
<p>With standard multisets. If zero is the only element with a non-trivial multiplicity, multithreading is possible.
</p>
</li>
<li>
<p>If the source vector is not isomorphic to <code>1:length(v)</code>
</p>
</li>
</ul>
</li>
<li>
<p>The maximum number of partitions/compositions that can be generated at one time is <code class="reqn">2^{31} - 1</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical Order</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">Subset Sum Problem</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (number theory)</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Composition_(combinatorics)">Composition (combinatorics))</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>partitionsGeneral</code>, <code>compositionsGeneral</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">a = partitionsIter(0:10, repetition = TRUE)
a@nextIter()
a@nextNIter(3)
a@front()
a@nextRemaining()
a@summary()
a@back()
a[[5]]
a@summary()
a[[c(1, 17, 3)]]
a@summary()

## Multisets... no random access
b = partitionsIter(40, 5, freqs = rep(1:4, 10), target = 80)
b@nextIter()
b@nextNIter(10)
b@summary()
b@nextIter()
b@currIter()
</code></pre>


</div>