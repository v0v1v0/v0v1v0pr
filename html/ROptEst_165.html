<div class="container">

<table style="width: 100%;"><tr>
<td>getMaxIneff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>getMaxIneff â€“ computation of the maximal inefficiency of an IC</h2>

<h3>Description</h3>

<p>computes the maximal inefficiency of an IC for the radius range [0,Inf).
</p>


<h3>Usage</h3>

<pre><code class="language-R">getMaxIneff(IC, neighbor, biastype = symmetricBias(), 
                        normtype = NormType(), z.start = NULL, 
                        A.start = NULL, maxiter = 50, 
                        tol = .Machine$double.eps^0.4,
                        warn = TRUE, verbose = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>IC</code></td>
<td>
<p>some IC of class <code>IC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>Neighborhood</code>; 
the neighborhood at which to compute the bias. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>biastype</code></td>
<td>
<p>a bias type of class <code>BiasType</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normtype</code></td>
<td>
<p> a norm type of class <code>NormType</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p> logical: print warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to be passed to <code>E</code> </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The maximal inefficiency, i.e.; a number in [1,Inf).</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@fraunhofer.itwm.de">peter.ruckdeschel@fraunhofer.itwm.de</a></p>


<h3>References</h3>

<p>Hampel et al. (1986) <em>Robust Statistics</em>. 
The Approach Based on Influence Functions. New York: Wiley.
</p>
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">N0 &lt;- NormLocationFamily(mean=2, sd=3)
## L_2 family + infinitesimal neighborhood
neighbor &lt;- ContNeighborhood(radius = 0.5)
N0.Rob1 &lt;- InfRobModel(center = N0, neighbor = neighbor)
## OBRE solution (ARE 95%)
N0.ICA &lt;- optIC(model = N0.Rob1, risk = asAnscombe(.95))
## OMSE solution radius 0.5
N0.ICM &lt;- optIC(model=N0.Rob1, risk=asMSE())
## RMX solution 
N0.ICR &lt;- radiusMinimaxIC(L2Fam=N0, neighbor=neighbor,risk=asMSE())

getMaxIneff(N0.ICA,neighbor)
getMaxIneff(N0.ICM,neighbor)
getMaxIneff(N0.ICR,neighbor)

## Don't run to reduce check time on CRAN

N0ls &lt;- NormLocationScaleFamily()
ICsc &lt;- makeIC(list(sin,cos),N0ls)
getMaxIneff(ICsc,neighbor)

</code></pre>


</div>