<div class="container">

<table style="width: 100%;"><tr>
<td>pclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prototype-Based Partitions of Relations</h2>

<h3>Description</h3>

<p>Compute prototype-based partitions of a relation ensemble by minimizing
<code class="reqn">\sum w_b u_{bj}^m d(x_b, p_j)^e</code>, the sum of the case-weighted and
membership-weighted <code class="reqn">e</code>-th powers of the dissimilarities between
the elements <code class="reqn">x_b</code> of the ensemble and the prototypes <code class="reqn">p_j</code>,
for suitable dissimilarities <code class="reqn">d</code> and exponents <code class="reqn">e</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">relation_pclust(x, k, method, m = 1, weights = 1,
                control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an ensemble of relations (see
<code>relation_ensemble()</code>),
or something which can be coerced to this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>an integer giving the number of classes to be used in the
partition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the consensus method to be employed, see
<code>relation_consensus()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a number not less than 1 controlling the softness of the
partition (as the “fuzzification parameter” of the fuzzy
<code class="reqn">c</code>-means algorithm).  The default value of 1 corresponds to
hard partitions obtained from a generalized <code class="reqn">k</code>-means problem;
values greater than one give partitions of increasing softness
obtained from a generalized fuzzy <code class="reqn">c</code>-means problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a numeric vector of non-negative case weights.
Recycled to the number of elements in the ensemble given by <code>x</code>
if necessary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code class="reqn">m = 1</code>, a generalization of the Lloyd-Forgy variant of the
<code class="reqn">k</code>-means algorithm is used, which iterates between reclassifying
objects to their closest prototypes, and computing new prototypes as
consensus relations (generalized “central relations”, Régnier
(1965)) for the classes.  This procedure was proposed in Gaul and
Schader (1988) as the “Clusterwise Aggregation of Relations”
(CAR).
</p>
<p>For <code class="reqn">m &gt; 1</code>, a generalization of the fuzzy <code class="reqn">c</code>-means recipe
is used, which alternates between computing optimal memberships for
fixed prototypes, and computing new prototypes as the consensus
relations for the classes.
</p>
<p>This procedure is repeated until convergence occurs, or the maximal
number of iterations is reached.
</p>
<p>Consensus relations are computed using
<code>relation_consensus()</code>.
</p>
<p>Available control parameters are as follows.
</p>

<dl>
<dt><code>maxiter</code></dt>
<dd>
<p>an integer giving the maximal number of
iterations to be performed.  Defaults to 100.</p>
</dd>
<dt><code>reltol</code></dt>
<dd>
<p>the relative convergence tolerance.  Defaults
to <code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
<dt><code>control</code></dt>
<dd>
<p>control parameters to be used in
<code>relation_consensus()</code>.</p>
</dd>
</dl>
<p>The dissimilarities <code class="reqn">d</code> and exponent <code class="reqn">e</code> are implied by the
consensus method employed, and inferred via a registration mechanism
currently only made available to built-in consensus methods.  For the
time being, all optimization-based consensus methods use the symmetric
difference dissimilarity (see <code>relation_dissimilarity()</code>)
for <code class="reqn">d</code> and <code class="reqn">e = 1</code>.
</p>
<p>The fixed point approach employed is a heuristic which cannot be
guaranteed to find the global minimum.  Standard practice would
recommend to use the best solution found in “sufficiently many”
replications of the base algorithm.
</p>


<h3>Value</h3>

<p>An object of class <code>cl_partition()</code>.
</p>


<h3>References</h3>

<p>S. Régnier (1965).
Sur quelques aspects mathématiques des problèmes de classification
automatique.
<em>ICC Bulletin</em>, <b>4</b>, 175–191.
</p>
<p>W. Gaul and M. Schader (1988).
Clusterwise aggregation of relations.
<em>Applied Stochastic Models and Data Analysis</em>, <b>4</b>, 273–282.
<a href="https://doi.org/10.1002/asm.3150040406">doi:10.1002/asm.3150040406</a>.
</p>


</div>