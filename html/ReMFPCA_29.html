<div class="container">

<table style="width: 100%;"><tr>
<td>remfpca</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A Class for 'ReMFPCA' objects</h2>

<h3>Description</h3>

<p>The 'remfpca' class represents regularized functional principal components components.
</p>
<p>The ‘remfpca' class represents regularized functional principal components (’ReMFPCs') components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Remfpca(
  mvmfd_obj,
  ncomp,
  alpha = NULL,
  centerfns = TRUE,
  alpha_orth = TRUE,
  penalty_type = "coefpen"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mvmfd_obj</code></td>
<td>
<p>An 'mvmfd' object representing the multivariate functional data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>The number of functional principal components to retain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>A list or vector specifying the regularization parameter(s) for each variable.
If NULL, the regularization parameter is estimated internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centerfns</code></td>
<td>
<p>Logical indicating whether to center the functional data before analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_orth</code></td>
<td>
<p>Logical indicating whether to perform orthogonalization of the regularization parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty_type</code></td>
<td>
<p>The type of penalty to be applied on the coefficients. The types "coefpen" and "basispen" is supported. Default is "coefpen".</p>
</td>
</tr>
</table>
<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>pc_mfd</code></dt>
<dd>
<p>an object of class 'mvmfd' where the first indices (fields)
represents harmonics and  second indices represents variables</p>
</dd>
<dt><code>lsv</code></dt>
<dd>
<p>= Left singular values vectors</p>
</dd>
<dt><code>values</code></dt>
<dd>
<p>= the set of eigenvalues</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>= The vector of penalties parameters</p>
</dd>
<dt><code>GCVs</code></dt>
<dd>
<p>= generalized cross validations</p>
</dd>
<dt><code>mean_mfd</code></dt>
<dd>
<p>a multivariate functional data object giving the mean function</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-remfpca-new"><code>remfpca$new()</code></a>
</p>
</li>
<li> <p><a href="#method-remfpca-clone"><code>remfpca$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-remfpca-new"></a>



<h4>Method <code>new()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>remfpca$new(
  mvmfd_obj,
  ncomp,
  alpha = NULL,
  centerfns = TRUE,
  alpha_orth = TRUE,
  penalty_type = "coefpen"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mvmfd_obj</code></dt>
<dd>
<p>An 'mvmfd' object representing the multivariate functional data.</p>
</dd>
<dt><code>ncomp</code></dt>
<dd>
<p>The number of functional principal components to retain.</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>A list or vector specifying the regularization parameter(s) for each variable.
If NULL, the regularization parameter is estimated internally.</p>
</dd>
<dt><code>centerfns</code></dt>
<dd>
<p>Logical indicating whether to center the functional data before analysis.</p>
</dd>
<dt><code>alpha_orth</code></dt>
<dd>
<p>Logical indicating whether to perform orthogonalization of the regularization parameters.</p>
</dd>
<dt><code>penalty_type</code></dt>
<dd>
<p>The type of penalty to be applied on the coefficients. The types "coefpen" and "basispen" is supported. Default is "coefpen".</p>
</dd>
</dl>
</div>


<hr>
<a id="method-remfpca-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>remfpca$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p><code>mvmfd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(fda)
# Brownian Bridge simulation on [0,1]
M &lt;- 110 # number of components
N &lt;- 20 # number of instances
n &lt;- 100 # number of grides
t0 &lt;- seq(0, 1, len = n)
j &lt;- 1:M
alpha1 &lt;- list(a1 = 2^seq(0, 1, length.out = 3), a2 = 2^seq(0, 1, length.out = 3))
psi_1 &lt;- function(t, m) sin(m * pi * t) # eigenfunction of BB
psi_2 &lt;- function(t, m) sin((2 * m - 1) * pi / 2 * t) # eigenfunction of BM
PC_1 &lt;- outer(t0, j, FUN = psi_1) # n by M matrix
PC_2 &lt;- outer(t0, j, FUN = psi_2) # n by M matrix
Z &lt;- matrix(rnorm(N * M), nr = M)
lambda &lt;- matrix(2 / (pi * (2 * j - 1)), nr = M, nc = N)
X_1t &lt;- PC_1 %*% (lambda * Z)
X_2t &lt;- PC_2 %*% (lambda * Z)
noise &lt;- rnorm(n * N, 0, 0.1)
X_1 &lt;- X_1t + noise
X_2 &lt;- X_2t + noise
bs &lt;- create.bspline.basis(c(0, 1), 51)
mdbs &lt;- Basismfd(bs)
mfd1 &lt;- Mfd(X = X_1, mdbs = mdbs)
mfd2 &lt;- Mfd(X = X_2, mdbs = mdbs)
mvmfd_obj &lt;- Mvmfd(mfd1, mfd2)
k &lt;- 2
Re0 &lt;- Remfpca(mvmfd_obj, ncomp = k, alpha = c(0, 0))
fpc0 &lt;- Re0$pc_mfd
scores0 &lt;- inprod_mvmfd(mvmfd_obj, fpc0)
dim(scores0)
Re0$alpha
Re1 &lt;- Remfpca(mvmfd_obj, ncomp = k, alpha = alpha1)
Re1$alpha
Re3 &lt;- Remfpca(mfd1, ncomp = k, alpha = alpha1$a1)
Re3$alpha
</code></pre>


</div>