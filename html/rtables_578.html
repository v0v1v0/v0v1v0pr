<div class="container">

<table style="width: 100%;"><tr>
<td>split_rows_by</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add rows according to levels of a variable</h2>

<h3>Description</h3>

<p>Add rows according to levels of a variable
</p>


<h3>Usage</h3>

<pre><code class="language-R">split_rows_by(
  lyt,
  var,
  labels_var = var,
  split_label = var,
  split_fun = NULL,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  child_labels = c("default", "visible", "hidden"),
  label_pos = "hidden",
  indent_mod = 0L,
  page_by = FALSE,
  page_prefix = split_label,
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lyt</code></td>
<td>
<p>(<code>PreDataTableLayouts</code>)<br> layout object pre-data used for tabulation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>(<code>string</code>)<br> variable name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels_var</code></td>
<td>
<p>(<code>string</code>)<br> name of variable containing labels to be displayed for the values of <code>var</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_label</code></td>
<td>
<p>(<code>string</code>)<br> label to be associated with the table generated by the split. Not to be confused
with labels assigned to each child (which are based on the data and type of split during tabulation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_fun</code></td>
<td>
<p>(<code>function</code> or <code>NULL</code>)<br> custom splitting function. See custom_split_funs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>(<code>string</code>, <code>function</code>, or <code>list</code>)<br> format associated with this split. Formats can be declared via
strings (<code>"xx.x"</code>) or function. In cases such as <code>analyze</code> calls, they can be character vectors or lists of
functions. See <code>formatters::list_valid_format_labels()</code> for a list of all available format strings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_str</code></td>
<td>
<p>(<code>string</code>)<br> string that should be displayed when the value of <code>x</code> is missing. Defaults to <code>"NA"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested</code></td>
<td>
<p>(<code>logical</code>)<br> whether this layout instruction should be applied within the existing layout structure
<em>if possible</em> (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split
underneath analyses, which is not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>child_labels</code></td>
<td>
<p>(<code>string</code>)<br> the display behavior for the labels (i.e. label rows) of the children of this
split. Accepts <code>"default"</code>, <code>"visible"</code>, and <code>"hidden"</code>. Defaults to <code>"default"</code> which flags the label row as
visible only if the child has 0 content rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label_pos</code></td>
<td>
<p>(<code>string</code>)<br> location where the variable label should be displayed. Accepts <code>"hidden"</code>
(default for non-analyze row splits), <code>"visible"</code>, <code>"topleft"</code>, and <code>"default"</code> (for analyze splits only). For
<code>analyze</code> calls, <code>"default"</code> indicates that the variable should be visible if and only if multiple variables are
analyzed at the same level of nesting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indent_mod</code></td>
<td>
<p>(<code>numeric</code>)<br> modifier for the default indent position for the structure created by this
function (subtable, content table, or row) <em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>page_by</code></td>
<td>
<p>(<code>flag</code>)<br> whether pagination should be forced between different children resulting from this
split. An error will occur if the selected split does not contain at least one value that is not <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>page_prefix</code></td>
<td>
<p>(<code>string</code>)<br> prefix to be appended with the split value when forcing pagination between
the children of a split/table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>section_div</code></td>
<td>
<p>(<code>string</code>)<br> string which should be repeated as a section divider after each group defined
by this split instruction, or <code>NA_character_</code> (the default) for no section divider.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further layouting functions, and to <code>build_table()</code>.
</p>


<h3>Custom Splitting Function Details</h3>

<p>User-defined custom split functions can perform any type of computation on the incoming data provided that they
meet the requirements for generating "splits" of the incoming data based on the split object.
</p>
<p>Split functions are functions that accept:
</p>

<dl>
<dt>df</dt>
<dd>
<p>a <code>data.frame</code> of incoming data to be split.</p>
</dd>
<dt>spl</dt>
<dd>
<p>a Split object. This is largely an internal detail custom functions will not need to worry about,
but <code>obj_name(spl)</code>, for example, will give the name of the split as it will appear in paths in the resulting
table.</p>
</dd>
<dt>vals</dt>
<dd>
<p>any pre-calculated values. If given non-<code>NULL</code> values, the values returned should match these.
Should be <code>NULL</code> in most cases and can usually be ignored.</p>
</dd>
<dt>labels</dt>
<dd>
<p>any pre-calculated value labels. Same as above for <code>values</code>.</p>
</dd>
<dt>trim</dt>
<dd>
<p>if <code>TRUE</code>, resulting splits that are empty are removed.</p>
</dd>
<dt>(optional) .spl_context</dt>
<dd>
<p>a <code>data.frame</code> describing previously performed splits which collectively
arrived at <code>df</code>.</p>
</dd>
</dl>
<p>The function must then output a named <code>list</code> with the following elements:
</p>

<dl>
<dt>values</dt>
<dd>
<p>the vector of all values corresponding to the splits of <code>df</code>.</p>
</dd>
<dt>datasplit</dt>
<dd>
<p>a list of <code>data.frame</code>s representing the groupings of the actual observations from <code>df</code>.</p>
</dd>
<dt>labels</dt>
<dd>
<p>a character vector giving a string label for each value listed in the <code>values</code> element above.</p>
</dd>
<dt>(optional) extras</dt>
<dd>
<p>if present, extra arguments are to be passed to summary and analysis functions
whenever they are executed on the corresponding element of <code>datasplit</code> or a subset thereof.</p>
</dd>
</dl>
<p>One way to generate custom splitting functions is to wrap existing split functions and modify either the incoming
data before they are called or their outputs.
</p>


<h3>Note</h3>

<p>If <code>var</code> is a factor with empty unobserved levels and <code>labels_var</code> is specified, it must also be a factor
with the same number of levels as <code>var</code>. Currently the error that occurs when this is not the case is not very
informative, but that will change in the future.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class="language-R">lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE", split_fun = drop_split_levels) %&gt;%
  analyze("AGE", mean, var_labels = "Age", format = "xx.xx")

tbl &lt;- build_table(lyt, DM)
tbl

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE") %&gt;%
  analyze("AGE", mean, var_labels = "Age", format = "xx.xx")

tbl2 &lt;- build_table(lyt2, DM)
tbl2

lyt3 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by("SEX") %&gt;%
  summarize_row_groups(label_fstr = "Overall (N)") %&gt;%
  split_rows_by("RACE",
    split_label = "Ethnicity", labels_var = "ethn_lab",
    split_fun = drop_split_levels
  ) %&gt;%
  summarize_row_groups("RACE", label_fstr = "%s (n)") %&gt;%
  analyze("AGE", var_labels = "Age", afun = mean, format = "xx.xx")

lyt3


library(dplyr)

DM2 &lt;- DM %&gt;%
  filter(SEX %in% c("M", "F")) %&gt;%
  mutate(
    SEX = droplevels(SEX),
    gender_lab = c(
      "F" = "Female", "M" = "Male",
      "U" = "Unknown",
      "UNDIFFERENTIATED" = "Undifferentiated"
    )[SEX],
    ethn_lab = c(
      "ASIAN" = "Asian",
      "BLACK OR AFRICAN AMERICAN" = "Black or African American",
      "WHITE" = "White",
      "AMERICAN INDIAN OR ALASKA NATIVE" = "American Indian or Alaska Native",
      "MULTIPLE" = "Multiple",
      "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER" =
        "Native Hawaiian or Other Pacific Islander",
      "OTHER" = "Other", "UNKNOWN" = "Unknown"
    )[RACE]
  )

tbl3 &lt;- build_table(lyt3, DM2)
tbl3

</code></pre>


</div>