<div class="container">

<table style="width: 100%;"><tr>
<td>rem.dyad</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Fit a Relational Event Model to Dyadic Data </h2>

<h3>Description</h3>

<p>Fits a relational event model to dyadic edgelist data, using either the ordinal or temporal likelihood.  Maximum likelihood, posterior mode, and posterior importance resampling methods are supported.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rem.dyad(edgelist, n, effects = NULL, ordinal = TRUE, acl = NULL,
    cumideg = NULL, cumodeg = NULL, rrl = NULL, covar = NULL, ps = NULL,
    tri = NULL, optim.method = "BFGS", optim.control = list(), 
    coef.seed = NULL, hessian = FALSE, sample.size = Inf, verbose = TRUE, 
    fit.method = c("BPM", "MLE", "BSIR"), conditioned.obs = 0, 
    prior.mean = 0, prior.scale = 100, prior.nu = 4, sir.draws = 500, 
    sir.expand = 10, sir.nu = 4, gof = TRUE)
## S3 method for class 'rem.dyad'
print(x, ...)
## S3 method for class 'rem.dyad'
summary(object, ...) 
## S3 method for class 'rem.dyad'
simulate(object, nsim = object$m, seed = NULL, 
    coef = NULL, covar = NULL, edgelist = NULL, redraw.timing = FALSE,
    redraw.events = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>edgelist</code></td>
<td>
<p> a three-column edgelist matrix, with each row containing (in order) the time/order, sender, and receiver for the event in question, or <code>NULL</code> to create a model skeleton (useful for simulation). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> number of senders/receivers. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effects</code></td>
<td>
<p> a character vector indicating which effects to use; see below for specification. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordinal</code></td>
<td>
<p> logical; should the ordinal likelihood be used?  (If <code>FALSE</code>, the temporal likelihood is used instead.) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acl</code></td>
<td>
<p> optionally, a pre-computed acl structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumideg</code></td>
<td>
<p> optionally, a pre-computed cumulative indegree structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumodeg</code></td>
<td>
<p> optionally, a pre-computed cumulative outdegree stucture. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rrl</code></td>
<td>
<p> optionally, a pre-computed recency-ranked communications list. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar</code></td>
<td>
<p> an optional list of sender/receiver/event covariates. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ps</code></td>
<td>
<p> optionally, a pre-computed p-shift matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tri</code></td>
<td>
<p> optionally, a pre-computed triad statistic structure. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.method</code></td>
<td>
<p> the method to be used by <code>optim</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim.control</code></td>
<td>
<p> additional control parameters to <code>optim</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.seed</code></td>
<td>
<p>an optional vector of coefficients to use as the starting point for the optimization process; if <code>edgelist==NULL</code>, this is the vector of embedded coefficients for the model skeleton.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p> logical; compute the hessian of the log-likelihood/posterior surface? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample.size</code></td>
<td>
<p> sample size to use when estimating the sum of event rates. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical; deliver progress reports? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.method</code></td>
<td>
<p> method to use when fitting the model. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditioned.obs</code></td>
<td>
<p> the number of initial observations on which to condition when fitting the model (defaults to 0).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mean</code></td>
<td>
<p> for Bayesian estimation, location vector for prior distribution (multivariate-t).  (Can be a single value.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.scale</code></td>
<td>
<p> for Bayesian estimation, scale vector for prior distribution.  (Can be a single value.) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.nu</code></td>
<td>
<p> for Bayesian estimation, degrees of freedom for prior distribution. (Setting this to <code>Inf</code> results in a Gaussian prior.) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sir.draws</code></td>
<td>
<p> for sampling importance resampling method, the number of posterior draws to take (post-resampling). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sir.expand</code></td>
<td>
<p> for sampling importance resampling method, the expansion factor to use in the initial (pre-resampling) sample; sample size is <code>sir.expand*sir.draws</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sir.nu</code></td>
<td>
<p> for sampling importance resampling method, the degrees of freedom for the t distribution used to obtain initial (pre-resampling) sample. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gof</code></td>
<td>
<p>logical; calculate goodness-of-fit information?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> an object of class <code>rem.dyad</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> an object of class <code>rem.dyad</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p> number of events to simulate (defaults to the observed sequence length in the fitted model). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p> random number seed to use for simulation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p> optional vector of coefficients to override those in the fitted model object, for simulation purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redraw.timing</code></td>
<td>
<p> logical; should any prespecified events in <code>edgelist</code> have their timings redrawn during simulation? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redraw.events</code></td>
<td>
<p> logical; should any prespecified events in <code>edgelist</code> have their senders and receivers redrawn during simulation? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>rem.dyad</code> fits a (dyadic) relational event model to an event sequence, using either the full temporal or ordinal data likelihoods.  Three estimation methods are currently supported: maximum likelihood estimation, Bayesian posterior mode estimation, and Bayesian sampling importance resampling.  For the Bayesian methods, an adjustable multivariate-t (or, if <code>prior.nu==Inf</code>, Gaussian) prior is employed.  In the case of Bayesian sampling importance resampling, the posterior mode (and the hessian of the posterior about it) is used as the basis for a multivariate-t sample, which is then resampled via SIR methods to obtain an approximate set of posterior draws.  While this approximation is not guaranteed to work well, it is generally more robust than pure mode approximations (or, in the case of the MLE, estimates of uncertainty derived from the inverse hessian matrix).
</p>
<p>Whether Bayesian or frequentist methods are used, the relevant likelihood is either based entirely on the order of events (<code>ordinal=TRUE</code>) or on the realized event times (<code>ordinal=FALSE</code>).  In the latter case, all event times are understood to be relative to the onset of observation (i.e., observation starts at time 0), and the last event time given is taken to be the end of the observation period.  (If an event is also specified, this event is ignored.)
</p>
<p>Effects to be fit by <code>rem.dyad</code> are determined by the eponymous <code>effects</code> argument, a character vector which lists the effects to be used.  These are as follows:
</p>

<ul>
<li> <p><code>NIDSnd</code>: Normalized indegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future sending rate
</p>
</li>
<li> <p><code>NIDRec</code>: Normalized indegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future receiving rate
</p>
</li>
<li> <p><code>NODSnd</code>: Normalized outdegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future sending rate
</p>
</li>
<li> <p><code>NODRec</code>: Normalized outdegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future receiving rate
</p>
</li>
<li> <p><code>NTDegSnd</code>: Normalized total degree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future sending rate
</p>
</li>
<li> <p><code>NTDegRec</code>: Normalized total degree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future receiving rate
</p>
</li>
<li> <p><code>FrPSndSnd</code>: Fraction of <code class="reqn">v</code>'s past actions directed to <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>FrRecSnd</code>: Fraction of <code class="reqn">v</code>'s past receipt of actions from <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>RRecSnd</code>: Recency of receipt of actions from <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>RSndSnd</code>: Recency of sending to <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>CovSnd</code>: Covariate effect for outgoing actions (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>CovRec</code>: Covariate effect for incoming actions (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>CovInt</code>: Covariate effect for both outgoing and incoming actions (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>CovEvent</code>: Covariate effect for each <code class="reqn">(v,v')</code> action (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>OTPSnd</code>: Number of outbound two-paths from <code class="reqn">v</code> to <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>ITPSnd</code>: Number of incoming two-paths from <code class="reqn">v'</code> to <code class="reqn">v</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>OSPSnd</code>: Number of outbound shared partners for <code class="reqn">v</code> and <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>ISPSnd</code>: Number of inbound shared partners for <code class="reqn">v</code> and <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>FESnd</code>: Fixed effects for outgoing actions
</p>
</li>
<li> <p><code>FERec</code>: Fixed effects for incoming actions
</p>
</li>
<li> <p><code>FEInt</code>: Fixed effects for both outgoing and incoming actions
</p>
</li>
<li> <p><code>PSAB-BA</code>: P-Shift effect (turn receiving) – AB-&gt;BA (dyadic)
</p>
</li>
<li> <p><code>PSAB-B0</code>: P-Shift effect (turn receiving) – AB-&gt;B0 (non-dyadic)
</p>
</li>
<li> <p><code>PAAB-BY</code>: P-Shift effect (turn receiving) – AB-&gt;BY (dyadic)
</p>
</li>
<li> <p><code>PSA0-X0</code>: P-Shift effect (turn claiming) – A0-&gt;X0 (non-dyadic)
</p>
</li>
<li> <p><code>PSA0-XA</code>: P-Shift effect (turn claiming) – A0-&gt;XA (non-dyadic)
</p>
</li>
<li> <p><code>PSA0-XY</code>: P-Shift effect (turn claiming) – A0-&gt;XY (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-X0</code>: P-Shift effect (turn usurping) – AB-&gt;X0 (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-XA</code>: P-Shift effect (turn usurping) – AB-&gt;XA (dyadic)
</p>
</li>
<li> <p><code>PSAB-XB</code>: P-Shift effect (turn usurping) – AB-&gt;XB (dyadic)
</p>
</li>
<li> <p><code>PSAB-XY</code>: P-Shift effect (turn usurping) – AB-&gt;XY (dyadic)
</p>
</li>
<li> <p><code>PSA0-AY</code>: P-Shift effect (turn continuing) – A0-&gt;AY (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-A0</code>: P-Shift effect (turn continuing) – AB-&gt;A0 (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-AY</code>: P-Shift effect (turn continuing) – AB-&gt;AY (dyadic)
</p>
</li>
</ul>
<p>Note that not all effects may lead to identified models in all cases - it is up to the user to ensure that the postulated model makes sense.
</p>
<p>Data to be used by <code>rem.dyad</code> must consist of an edgelist matrix, whose rows contain information on successive events.  This matrix must have three columns, containing (respectively) the event times, sender IDs (as integers from 1 to <code>n</code>), and receiver IDs (also from 1 to <code>n</code>).  As already noted, event times should be relative to onset of observation where the temporal likelihood is being used; otherwise, only event order is employed.  In the temporal likelihood case, the last row should contain the time for the termination of the observation period – any event on this row is ignored.  If <code>conditioned.obs&gt;0</code>, the relevant number of initial observations is taken as fixed, and the likelihood of the remaining sequence is calculated conditional on these values; this can be useful when analyzing an event history with no clear starting point.
</p>
<p>If covariates effects are indicated, then appropriate covariate values must be supplied as a list in argument <code>covar</code>.  The elements of <code>covar</code> should be given the same name as the effect type to which they correspond (e.g., <code>CovSnd</code>, <code>CovRec</code>, etc.); any other elements will be ignored.  The format of a given covariate element depends both on the effect type and on the number of covariates specified.  The basic cases are as follows:
</p>

<ul>
<li>
<p> Single covariate, time invariant: For <code>CovSnd</code>, <code>CovRec</code>, or <code>CovInt</code>, a vector or single-column matrix/array.  For <code>CovEvent</code>, an <code>n</code> by <code>n</code> matrix or array.
</p>
</li>
<li>
<p> Multiple covariates, time invariant: For <code>CovSnd</code>, <code>CovRec</code>, or <code>CovInt</code>, a two-dimensional <code>n</code> by <code>p</code> matrix/array whose columns contain the respective covariates.  For <code>CovEvent</code>, a <code>p</code> by <code>n</code> by <code>n</code> array, whose first dimension indexes the covariate matrices.
</p>
</li>
<li>
<p> Single or multiple covariates, time varying: For <code>CovSnd</code>, <code>CovRec</code>, or <code>CovInt</code>, an <code>m</code> by <code>p</code> by n array whose respective dimensions index time (i.e., event number), covariate, and actor.  For <code>CovEvent</code>, a <code>m</code> by <code>p</code> by <code>n</code> by <code>n</code> array, whose dimensions are analogous to the previous case.
</p>
</li>
</ul>
<p>Note that “time varying” covariates may only change values when events transpire; thus, they should be regarded as temporally endogenous.  (See the reference below for details.) 
</p>
<p>If called with <code>edgelist==NULL</code>, <code>rem.dyad</code> will produce a “model skeleton” object containing the effects and other information, but no model fit.  (The seed coefficients, if given, are entered as the coefficients in the model, or else an uninteresting default set is used.)  The main purpose for this object is to set up an <em>ab initio</em> simulation, as described below: once the skeleton is created, the <code>simulate</code> method can be used to generate draws from that model (without fitting to a data set).
</p>
<p>A <code>simulate</code> method is provided for <code>rem.dyad</code> objects, which allows simulation of new event sequences from a fitted or skeleton model.  By default, a new sequence of length equal to the original sequence to which the model object was fitted is simulated (if applicable), but other lengths may be chosen using <code>nsim</code>.  Although the coefficients in the model object are used by default, this may also be altered by specifying <code>coef</code>.  Note that any covariates used must be passed to the simulate command via <code>covar</code> (using the same format as in the original model); this is in part because <code>rem.dyad</code> objects do not currently save their input data, and in part because dynamic covariates must always be the length of the simulated sequence (and hence must be factored when a non-default <code>nsim</code> value is used).  For models fit using <code>ordinal=TRUE</code>, the overall pacing of events will be arbitrary (more specifically, the simulation will tacitly assume that each event has a unit base hazard), but the relative timing is not.  See below for examples of both simulation using a fitted model object and <em>ab initio</em> simulation without fitting a model to data.
</p>
<p>For simulation, it is possible to fix the first portion of the event history by passing an event list matrix to the <code>edgelist</code> argument; this must be compatible with the target model (i.e., the vertex IDs must match), and it cannot contain <code>NA</code> values.  (Thus, if starting with an exact timing seqence with a last line containing <code>NA</code>s, this must be removed.)  If the input event list contains <code>m</code> events, then these are assumed to supply the first <code>m</code> events of the target sequence; if <code>m&gt;nsim</code>, then any excess events are discarded.  By default, the input events are taken as fixed.  However, specifying <code>redraw.timing=TRUE</code> will lead the event timings to be redrawn, and <code>redraw.events</code> will lead the sender/reciver pairs to be redrawn.  This allows e.g. for an observed ordinal time sequence to be given a simulated exact time realization, by setting <code>nsim</code> to the event list length and setting <code>redraw.timing=TRUE</code>.  The more obvious use case is to simply extend an observed sequence, in which case one should use <code>nsim</code> greater than the input sequence length (i.e., the input length plus the number of new events to generate) and leave the <code>redraw</code> paraeters set to <code>FALSE</code>.  
</p>


<h3>Value</h3>

<p>For <code>rem.dyad</code>, an object of class <code>rem.dyad</code>.  For the <code>simulate</code> method, an event list.





</p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p> Butts, C.T.  (2008).  “A Relational Event Framework for Social Action.”  <em>Sociological Methodology</em>, 38(1). </p>


<h3>See Also</h3>

 <p><code>rem</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#Generate some simple sample data based on fixed effects
roweff&lt;-rnorm(10)                                     #Build rate matrix
roweff&lt;-roweff-roweff[1]                   #Adjust for later convenience
coleff&lt;-rnorm(10)
coleff&lt;-coleff-coleff[1]
lambda&lt;-exp(outer(roweff,coleff,"+"))
diag(lambda)&lt;-0
ratesum&lt;-sum(lambda)
esnd&lt;-as.vector(row(lambda))                  #List of senders/receivers
erec&lt;-as.vector(col(lambda))
time&lt;-0
edgelist&lt;-vector()
while(time&lt;15){                   # Observe the system for 15 time units
  drawsr&lt;-sample(1:100,1,prob=as.vector(lambda))        #Draw from model
  time&lt;-time+rexp(1,ratesum)
  if(time&lt;=15)                                             #Censor at 15
    edgelist&lt;-rbind(edgelist,c(time,esnd[drawsr],erec[drawsr]))
  else
    edgelist&lt;-rbind(edgelist,c(15,NA,NA))
}

#Fit the model, ordinal BPM
effects&lt;-c("FESnd","FERec")
fit.ord&lt;-rem.dyad(edgelist,10,effects=effects,hessian=TRUE)
summary(fit.ord)
par(mfrow=c(1,2))                                #Check the coefficients
plot(roweff[-1],fit.ord$coef[1:9],asp=1)
abline(0,1)
plot(coleff[-1],fit.ord$coef[10:18],asp=1)
abline(0,1)

#Now, find the temporal BPM
fit.time&lt;-rem.dyad(edgelist,10,effects=effects,ordinal=FALSE,hessian=TRUE)
summary(fit.time)
plot(fit.ord$coef,fit.time$coef,asp=1)                  #Similar results
abline(0,1)

#Finally, try the BSIR method (note: a much larger expansion factor
#is recommended in practice)
fit.bsir&lt;-rem.dyad(edgelist,10,effects=effects,fit.method="BSIR",
    sir.draws=100,sir.expand=5)
summary(fit.bsir)
par(mfrow=c(3,3))   #Examine the approximate posterior marginals
for(i in 1:9){
  hist(fit.bsir$post[,i],main=names(fit.bsir$coef)[i],prob=TRUE)
  abline(v=roweff[i+1],col=2,lwd=3)
}
for(i in 10:18){
  hist(fit.bsir$post[,i],main=names(fit.bsir$coef)[i],prob=TRUE)
  abline(v=coleff[i-8],col=2,lwd=3)
}

#Simulate an event sequence from the temporal model
sim&lt;-simulate(fit.time,nsim=50000) #Simulate 50000 events
head(sim)                          #Show the event list
par(mfrow=c(1,2))                  #Check the behavior
esnd&lt;-exp(c(0,fit.time$coef[1:9]))
esnd&lt;-esnd/sum(esnd)*5e4           #Expected sending count
erec&lt;-exp(c(0,fit.time$coef[10:18]))
erec&lt;-erec/sum(erec)*5e4           #Expected sending count
plot(esnd,tabulate(sim[,2]),xlab="Expected Out-events",ylab="Out-events")
abline(0,1,col=2)
plot(erec,tabulate(sim[,3]),xlab="Expected In-events",ylab="In-events")
abline(0,1,col=2)

#Keep the first 10 events of the simulated sequence, and produce 10 more
sim.pre&lt;-sim[1:10,]
sim2&lt;-simulate(fit.time,nsim=20,edgelist=sim.pre)
sim.pre                            #See the first 10 events
sim2                               #First 10 events preserved
all(sim2[1:10,]==sim.pre)          #All TRUE

#Repeat, but redrawing part of the input sequence
sim2.t&lt;-simulate(fit.time,nsim=20,edgelist=sim.pre,redraw.timing=TRUE)
sim2.e&lt;-simulate(fit.time,nsim=20,edgelist=sim.pre,redraw.events=TRUE)
sim2.t                             #Events kept, timings not
sim2.t[1:10,]==sim.pre             #Second two columns TRUE
sim2.e                             #Timing kept, events not
sim2.e[1:10,]==sim.pre             #(Note: some events may repeat by chance!)

## End(Not run)
</code></pre>


</div>