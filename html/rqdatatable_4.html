<div class="container">

<table style="width: 100%;"><tr>
<td>ex_data_table_parallel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Execute an <code>rquery</code> pipeline with <code>data.table</code> in parallel.</h2>

<h3>Description</h3>

<p>Execute an <code>rquery</code> pipeline with <code>data.table</code> in parallel, partitioned by a given column.
Note: usually the overhead of partitioning and distributing the work will by far overwhelm any parallel speedup.
Also <code>data.table</code> itself already seems to exploit some thread-level parallelism (one often sees user time &gt; elapsed time).
Requires the <code>parallel</code> package.  For a worked example with significant speedup please see <a href="https://github.com/WinVector/rqdatatable/blob/master/extras/Parallel_rqdatatable.md">https://github.com/WinVector/rqdatatable/blob/master/extras/Parallel_rqdatatable.md</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ex_data_table_parallel(
  optree,
  partition_column,
  cl = NULL,
  ...,
  tables = list(),
  source_limit = NULL,
  debug = FALSE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>optree</code></td>
<td>
<p>relop operations tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partition_column</code></td>
<td>
<p>character name of column to partition work by.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a cluster object, created by package parallel or by package snow. If NULL, use the registered default cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tables</code></td>
<td>
<p>named list map from table names used in nodes to data.tables and data.frames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>source_limit</code></td>
<td>
<p>if not null limit all table sources to no more than this many rows (used for debugging).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>logical if TRUE use lapply instead of parallel::clusterApplyLB.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>environment to look for values in.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Care must be taken that the calculation partitioning is course enough to ensure a correct calculation.  For example: anything
one is joining on, aggregating over, or ranking over must be grouped so that all elements affecting a given result row are
in the same level of the partition.
</p>


<h3>Value</h3>

<p>resulting data.table (intermediate tables can sometimes be mutated as is practice with data.table).
</p>


</div>