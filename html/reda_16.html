<div class="container">

<table style="width: 100%;"><tr>
<td>mcf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mean Cumulative Function (MCF)</h2>

<h3>Description</h3>

<p>An S4 class generic function that returns the mean cumulative function (MCF)
estimates from a fitted model or returns the nonparametric MCF estimates (by
Nelson-Aalen estimator or Cook-Lawless cumulative sample mean estimator)
from the sample data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcf(object, ...)

## S4 method for signature 'formula'
mcf(
  object,
  data,
  subset,
  na.action,
  variance = c("LawlessNadeau", "Poisson", "bootstrap", "CSV", "none"),
  logConfInt = FALSE,
  adjustRiskset = TRUE,
  level = 0.95,
  control = list(),
  ...
)

## S4 method for signature 'rateReg'
mcf(
  object,
  newdata,
  groupName,
  groupLevels,
  level = 0.95,
  na.action,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object used to dispatch a method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame, list or environment containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, usually the environment from which the
function is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>A function that indicates what should the procedure do if
the data contains <code>NA</code>s.  The default is set by the na.action
setting of <code>options</code>.  The "factory-fresh" default is
<code>na.omit</code>.  Other possible values inlcude
<code>na.fail</code>, <code>na.exclude</code>, and <code>na.pass</code>.
<code>help(na.fail)</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance</code></td>
<td>
<p>A character specifying the method for variance estimates.
The available options are <code>"LawlessNadeau"</code> (the default) for
Lawless and Nadeau (1995) method, <code>"Poisson"</code> for Poisson process
method, <code>"bootstrap"</code> for bootstrap method, <code>"CSV"</code> for
variance estimates of the corresponding cumulative sample mean function
(CSM) by the cumulative sample variance method (Cook and Lawless, 2007),
and <code>"none"</code> for no variance estimates.  Partial matching on the
names is allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logConfInt</code></td>
<td>
<p>A logical value. If <code>FALSE</code> (the default), the
confidence interval are constructed based on the normality of the MCF
estimates. Otherwise, the confidence intervals of given level are
constucted based on the normality of logarithm of the MCF estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjustRiskset</code></td>
<td>
<p>A logical value indicating whether to adjust the size
of risk-set.  If <code>TRUE</code> by default, the size of risk-set will be
adjusted based on at-risk indicators and Nelson-Aalen estimator will be
returned.  Otherwise, the cumulative sample mean (CSM) function given by
Cook and Lawless (2007) will be returned without adjustment on size of
risk-set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>An optional numeric value indicating the confidence level
required. The default value is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>An optional named list specifying other options.  For
<code>rateReg</code> object, it can be used to specify the time grid where the
MCF is estimated. The available named elements are given as follows:
</p>

<ul>
<li> <p><code>grid</code>: The time grid where MCF is estimated. A dense
grid is suggested for further using the plot method.
</p>
</li>
<li> <p><code>length.out</code>: The length of grid points. The dafault
value is 1,000.
</p>
</li>
<li> <p><code>from</code>: The starting point of grid. The default value is
the left boundary knots (for <code>rateReg</code> object).
</p>
</li>
<li> <p><code>to</code>: The endpoint of grid. The default value is the
right boundary knots (for <code>rateReg</code> object).
</p>
</li>
</ul>
<p>The option <code>length.out</code>, <code>from</code>, <code>to</code> will be ignored if
<code>grid</code> is specified directly. Otherwise, the grid will be generated
by function <code>seq.int</code> with specified <code>from</code>,
<code>to</code> and <code>length.out</code>.
</p>
<p>For formula method, the available named elements are given as follows:
</p>

<ul>
<li> <p><code>B</code>: The number of bootstrap replicates for using
bootstrap method for variance estimates of sample MCF estimates.
The default value is 200.
</p>
</li>
<li> <p><code>se.method</code>: The method used for SE estimates for
bootstrap. The available methods include <code>"sample.se"</code>
(the default) and <code>"normality"</code>. The former takes the
sample SE of point estimates from bootstrap samples; The latter
estimates SE based on interquantile and normality assumption.
</p>
</li>
<li> <p><code>ci.method</code>: The method used for confidence interval (CI)
for bootstrap. The available options include <code>"normality"</code>
(the default) and <code>"percentile"</code>. The former estimates the
CI based on SE estimates and normality assumption; The latter
takes percentiles of the bootstrap estimates.
</p>
</li>
<li> <p><code>keep.data</code>: A logical value specifying whether to keep the
processed data in the output object. If <code>TRUE</code>
(the default), the processed data will be kept in the output and
available for later usage. Otherwise, an empty data
frame object will be returned in the <code>data</code> slot.
<code>FALSE</code> may be set when the memory consumption is
of concern and we only need MCF estimates. For example, the
function <code>mcfDiff</code> and <code>mcfDiff.test</code> will not be
applicable for the <code>mcf.formula</code> object with an empty
<code>data</code> slot.
</p>
</li>
<li> <p><code>verbose</code>: A logical value. The default value is
<code>TRUE</code>. If <code>FALSE</code>, possible data checking messages
(not including warnings or errors) will be suppressed.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>An optional data frame. If specified, the data frame should
have the same column names as the covariate names appearing in the
formula of original fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupName</code></td>
<td>
<p>An optional length-one charactor vector to specify the name
for grouping each unique row in <code>newdata</code>, such as "gender" for
"male" and "female". The default value is "Group".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupLevels</code></td>
<td>
<p>An optional charactor vector to specify the levels for
each unique row in <code>newdata</code>, such as "treatment" and "control".
The default values are <code>"Level"</code> followed by a numeric sequence
with length of number of levels.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code>formula</code> object with <code>Recur</code> object as response, the
covariate specified at the right hand side of the formula should be either
<code>1</code> or any "linear" conbination of categorical variable in the data.
The former computes the overall sample MCF.  The latter computes the sample
MCF for each level of the combination of the categorical variable(s)
specified, respectively.
</p>
<p>The MCF estimates are computed on each unique time point of the sample data.
By default, the size of risk set is adjusted over time based on the at-risk
indicators, which results in the Nelson-Aalen nonparametric estimator
(Nelson 2003).  If the size of risk set remains a constant (total number of
processes) over time (specified by <code>adjustRiskset = FALSE</code>), the
cumulative sample mean (CSM) function introduced in Chapter 1 of Cook and
Lawless (2007) will be computed instead.  The point estimate of sample MCF
at each time point does not assume any particular underlying model. The
variance estimates at each time point is computed following the Lawless and
Nadeau method (LawLess and Nadeau 1995), the Poisson process method, or the
bootstrap methods.  The approximate confidence intervals are provided as
well, which are constructed based on the asymptotic normality of the MCF
itself (by default) or the logarithm of MCF.
</p>
<p>For <code>rateReg</code> object, <code>mcf</code> estimates the baseline MCF and its
confidence interval at each time grid if argument <code>newdata</code> is not
specified.  Otherwise, <code>mcf</code> estimates MCF and its confidence interval
for the given <code>newdata</code> based on Delta-method.
</p>


<h3>Value</h3>

<p>A <code>mcf.formula</code> or <code>mcf.rateReg</code> object.
</p>
<p>A brief description of the slots of a <code>mcf.formula</code> object is given as
follows:
</p>

<ul>
<li> <p><code>formula</code>: Model Formula.
</p>
</li>
<li> <p><code>data</code>: Processed data based on the model formula or an
empty data frame if <code>keep.data</code> is set to be <code>FALSE</code>.
</p>
</li>
<li> <p><code>MCF</code>: A data frame containing estimates for sample MCF.
</p>
</li>
<li> <p><code>origin</code>: Time origins.
</p>
</li>
<li> <p><code>multiGroup</code>: A logical value indicating whether MCF
is estimated for different groups respectively.
</p>
</li>
<li> <p><code>logConfInt</code>: A logical value indicating whether the
variance estimates are based on the normality of logarithm of
the MCF estimates.
</p>
</li>
<li> <p><code>level</code>: Confidence level specified.
</p>
</li>
</ul>
<p>Most slots of a <code>mcf.rateReg</code> object are inherited from the input
<code>rateReg</code> object. A brief description of other slots is given as
follows:
</p>

<ul>
<li> <p><code>newdata</code>: Given dataset used to estimate MCF.
</p>
</li>
<li> <p><code>MCF</code>: A data frame containing MCF estimates.
</p>
</li>
<li> <p><code>level</code>: Confidence level specified.
</p>
</li>
<li> <p><code>na.action</code>: The way handling missing values.
</p>
</li>
<li> <p><code>control</code>: The control list.
</p>
</li>
<li> <p><code>multiGroup</code>: A logical value indicating whether MCF
is estimated for different groups respectively.
</p>
</li>
</ul>
<h3>Functions</h3>


<ul>
<li> <p><code>mcf,formula-method</code>: Sample MCF from data.
</p>
</li>
<li> <p><code>mcf,rateReg-method</code>: Estimated MCF from a fitted model.
</p>
</li>
</ul>
<h3>References</h3>

<p>Cook, R. J., and Lawless, J. (2007). <em>The statistical analysis of
recurrent events</em>, Springer Science &amp; Business Media.
</p>
<p>Lawless, J. F. and Nadeau, C. (1995). Some Simple Robust Methods for the
Analysis of Recurrent Events. <em>Technometrics</em>, 37, 158–168.
</p>
<p>Nelson, W. B. (2003). <em>Recurrent Events Data Analysis for Product
Repairs, Disease Recurrences, and Other Applications</em> (Vol. 10). SIAM.
</p>


<h3>See Also</h3>

<p><code>rateReg</code> for model fitting;
<code>mcfDiff</code> for comparing two-sample MCFs.
<code>plot-method</code> for plotting MCF.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(reda)

### sample MCF
## Example 1. valve-seat data
## the default variance estimates by Lawless and Nadeau (1995) method
valveMcf0 &lt;- mcf(Recur(Days, ID, No.) ~ 1, data = valveSeats)
plot(valveMcf0, conf.int = TRUE, mark.time = TRUE, addOrigin = TRUE) +
    ggplot2::xlab("Days") + ggplot2::theme_bw()

## variance estimates following Poisson process model
valveMcf1 &lt;- mcf(Recur(Days, ID, No.) ~ 1,
                 data = valveSeats, variance = "Poisson")
## variance estimates by bootstrap method (with 1,000 bootstrap samples)
set.seed(123)
valveMcf2 &lt;- mcf(Recur(Days, ID, No.) ~ 1,
                 data = valveSeats, variance = "bootstrap",
                 control = list(B = 200))

## comparing the variance estimates from different methods
library(ggplot2)
ciDat &lt;- rbind(cbind(valveMcf0@MCF, Method = "Lawless &amp; Nadeau"),
               cbind(valveMcf1@MCF, Method = "Poisson"),
               cbind(valveMcf2@MCF, Method = "Bootstrap"))
ggplot(ciDat, aes(x = time, y = se)) +
    geom_step(aes(color = Method, linetype = Method)) +
    xlab("Days") + ylab("SE estimates") + theme_bw()

## comparing the confidence interval estimates from different methods
ggplot(ciDat, aes(x = time)) +
    geom_step(aes(y = MCF)) +
    geom_step(aes(y = lower, color = Method, linetype = Method)) +
    geom_step(aes(y = upper, color = Method, linetype = Method)) +
    xlab("Days") + ylab("Confidence intervals") + theme_bw()


## Example 2. the simulated data
simuMcf &lt;- mcf(Recur(time, ID, event) ~ group + gender,
               data = simuDat, ID %in% 1 : 50)
plot(simuMcf, conf.int = TRUE, lty = 1 : 4,
     legendName = "Treatment &amp; Gender")

### estimate MCF difference between two groups
## one sample MCF object of two groups
mcf0 &lt;- mcf(Recur(time, ID, event) ~ group, data = simuDat)
## two-sample pseudo-score tests
mcfDiff.test(mcf0)
## difference estimates over time
mcf0_diff &lt;- mcfDiff(mcf0, testVariance = "none")
plot(mcf0_diff)

## or explicitly ask for the difference of two sample MCF
mcf1 &lt;- mcf(Recur(time, ID, event) ~ 1, data = simuDat,
            subset = group %in% "Contr")
mcf2 &lt;- mcf(Recur(time, ID, event) ~ 1, data = simuDat,
            subset = group %in% "Treat")
## perform two-sample tests and estimate difference at the same time
mcf12_diff1 &lt;- mcfDiff(mcf1, mcf2)
mcf12_diff2 &lt;- mcf1 - mcf2   # or equivalently using the `-` method
stopifnot(all.equal(mcf12_diff1, mcf12_diff2))
mcf12_diff1
plot(mcf12_diff1)

### For estimated MCF from a fitted model,
### see examples given in function rateReg.
</code></pre>


</div>