<div class="container">

<table style="width: 100%;"><tr>
<td>r</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ReQL root</h2>

<h3>Description</h3>

<p>Creates ReQL root for building a query.
</p>


<h3>Usage</h3>

<pre><code class="language-R">r(db, table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>db</code></td>
<td>
<p>DB name; this is optional, and is just a syntax sugar for <code>r()$db(db)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>Table name; this is optional, requires db to be given, and is just a syntax sugar for <code>r()$db(db)$table(table)</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>ReQL root; use <code>$</code> (or <code>[[]]</code>) to chain query terms (like <code>r()$db("test")$table("test")</code>).
In general, anonymous attributes are passed as attributes while named as term options.
In context of term arguments, named lists are treated as JSON objects (following <code>rjson</code> package heuristics), unnamed lists and simple vectors as JSON arrays; classes and attributes are ignored.
Term options should be called in the snake case form (for instance <code>return_changes</code> not <code>returnChanges</code>), as documented for the original Python driver.
To finalise, use <code>$run</code> or <code>$runAsync</code>.
For a comprehensive description of all terms, see RethinkDB API reference; here we give an overview of some:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>run(connection,...)</code></td>
<td>
<p>Evaluate the query; the function will block until first response from RethinkDB to this query will be received.
May return cursor, an object representing a stream of data on which <code>cursorNext</code> and <code>cursorToList</code> can be used to extract actual information.
<code>...</code> may be used to specify run options, like <code>profile</code>, <code>durability</code> or <code>read_mode</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>runAsync(connection,callback,...)</code></td>
<td>
<p>Evaluate the query; for each datum received <code>x</code>, run <code>callback(x)</code>.
Callback should return <code>TRUE</code> to be re-evaluated on proceeding data; any other response will cause the query to be dropped immediately.
This function returns immediately; to ask R to start evaluating async queries, run <code>drainConnection</code>.
Note that callbacks can be also called while <code>$run()</code> blocks waiting for other query to execute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bracket(...)</code></td>
<td>
<p>Implementation of the JavaScript <code>(...)</code> and Python <code>[...]</code> operation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>funcall(function,atts)</code></td>
<td>
<p>Implementation of the JavaScript <code>.do()</code>; note that the order of arguments is different.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>ReQL is implemented as an environment, thus is mutable unlike most R objects.
To this end, you can use variables for chaining like this <code>r()-&gt;query;</code> <code>query$db("a");</code> <code>query$table("b")</code>; but consequently you can't use variables to make a re-usable stub, i.e., this is invalid: <code>r()-&gt;query;</code> <code>query$db("a")$table("aa")$run(...)</code> <code>query$db("b")$table("bb")$run(...);</code>.
</p>
<p>If you get "trying to apply non-function" error, you likely have misspelled term name or trying to use a non-existent one.
</p>
<p>To view raw AST (at any depth), use <code>$query</code>.
</p>


<h3>Author(s)</h3>

<p>Miron B. Kursa
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#Connect to the RethinkDB instance
cn&lt;-openConnection()

#Get document count in some_db's some_table
r()$db("some_db")$table("some_table")$count()$run(cn)
#...same can be done shorter
r("some_db","some_table")$count()$run(cn)

#Fetch 5 random docs from some_db's some_table...
r("some_db","some_table")$sample(5)$run(cn)-&gt;cursor
#...and present as a list`
cursorToList(cursor)

#Insert an element
r("some_db","some_table")$insert(list(id="new",a=1:10,b=list(c=1,d=2)))$run(cn)

#Close connection
close(cn)

## End(Not run)
</code></pre>


</div>