<div class="container">

<table style="width: 100%;"><tr>
<td>GoodmanWeare</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Goodman-Weare Affine-Invariant Sampling
</h2>

<h3>Description</h3>

<p>Produces a Monte-Carlo Markov ensemble using the affine-invariant method of Goodman &amp; Weare.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GoodmanWeare(ensemble, lnpost, Nsteps, current.lnP=NULL,
 mc.cores=getOption("mc.cores", 1L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ensemble</code></td>
<td>

<p>an Nparam*Nwalkers array holding the initial state of the sampler. Nparam is the dimensionality of the parameter space and Nwalkers is the number of positions in the parameter space comprising the ensemble. Nwalkers must be even, and in practice should be *at minimum* twice Nparam.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lnpost</code></td>
<td>

<p>function taking a vector of parameter values as input, and returning the log-posterior density.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsteps</code></td>
<td>

<p>number of iterations to run the sampler.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>current.lnP</code></td>
<td>

<p>vector holding the log-posterior value corresponding to the initial position of each walker. If not provided, this will be calculated internally.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>number of cores to use for parallelism.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments to pass to lnpost.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing $ensemble: an array of the same dimensionality as ensemble, containing the position of the walkers after Nsteps iterations of the sampler; and $current.lnP: the  log-posterior density for each walker.
</p>


<h3>Note</h3>

<p>By default, the code will attempt to run in parallel (see the ‘parallel’ package). To prevent this, pass mc.cores=1.
</p>


<h3>Author(s)</h3>

<p>Adam Mantz
</p>


<h3>References</h3>

<p>Goodman, J. &amp; Weare, J. (2010, Comm. App. Math. Comp. Sci., 5:6) &lt;DOI:10.2140/camcos.2010.5.65&gt;. This implementation is based on the description given by Foreman-Mackey et al. (2012, arXiv:1202.3665) &lt;DOI:10.1086/670067&gt;.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># In this example, we'll sample from a simple 2D Gaussian

# Define the log-posterior function
lnP = function(x) sum( dnorm(x, c(0,1), c(pi, exp(0.5)), log=TRUE) )

# Initialize an ensemble of 100 walkers
nwalk = 100
ensemble = array(dim=c(2, nwalk))
ensemble[1,] = rnorm(nwalk, 0, 0.1)
ensemble[2,] = rnorm(nwalk, 1, 0.1)

# Run for a bit
ens2 = GoodmanWeare(ensemble, lnP, 100, mc.cores=1)

# Plot the resulting ensemble
plot(t(ens2$ensemble))
# Compare to a direct draw from the posterior distribution
points(rnorm(nwalk, 0, pi), rnorm(nwalk, 1, exp(0.5)), col=2, pch=3)
</code></pre>


</div>