<div class="container">

<table style="width: 100%;"><tr>
<td>clean_source</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cleaning &amp; editing sources</h2>

<h3>Description</h3>

<p>These functions can be used to 'clean' one or more sources or perform search and
replace taks. Cleaning consists of two operations: splitting the source at
utterance markers, and conducting search and replaces using regular expressions.
</p>
<p>These functions can be used to 'clean' one or more sources or perform search and
replace taks. Cleaning consists of two operations: splitting the source at
utterance markers, and conducting search and replaces using regular expressions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">clean_source(
  input,
  output = NULL,
  replacementsPre = rock::opts$get("replacementsPre"),
  replacementsPost = rock::opts$get("replacementsPost"),
  extraReplacementsPre = NULL,
  extraReplacementsPost = NULL,
  removeNewlines = FALSE,
  removeTrailingNewlines = TRUE,
  rlWarn = rock::opts$get(rlWarn),
  utteranceSplits = rock::opts$get("utteranceSplits"),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)

clean_sources(
  input,
  output,
  outputPrefix = "",
  outputSuffix = "_cleaned",
  recursive = TRUE,
  filenameRegex = ".*",
  replacementsPre = rock::opts$get(replacementsPre),
  replacementsPost = rock::opts$get(replacementsPost),
  extraReplacementsPre = NULL,
  extraReplacementsPost = NULL,
  removeNewlines = FALSE,
  utteranceSplits = rock::opts$get(utteranceSplits),
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)

search_and_replace_in_source(
  input,
  replacements = NULL,
  output = NULL,
  preventOverwriting = TRUE,
  encoding = "UTF-8",
  rlWarn = rock::opts$get(rlWarn),
  silent = FALSE
)

search_and_replace_in_sources(
  input,
  output,
  replacements = NULL,
  outputPrefix = "",
  outputSuffix = "_postReplacing",
  preventOverwriting = rock::opts$get("preventOverwriting"),
  recursive = TRUE,
  filenameRegex = ".*",
  encoding = rock::opts$get("encoding"),
  silent = rock::opts$get("silent")
)

wordwrap_source(
  input,
  output = NULL,
  length = 60,
  removeNewlines = FALSE,
  removeTrailingNewlines = TRUE,
  rlWarn = rock::opts$get(rlWarn),
  preventOverwriting = rock::opts$get("preventOverwriting"),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent),
  utteranceMarker = rock::opts$get("utteranceMarker")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>For <code>clean_source</code> and <code>search_and_replace_in_source</code>, either a character
vector containing the text of the relevant source <em>or</em> a path to a file that contains
the source text; for <code>clean_sources</code> and <code>search_and_replace_in_sources</code>, a path to a
directory that contains the sources to clean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>For <code>clean_source</code> and <code>search_and_replace_in_source</code>, if not <code>NULL</code>,
this is the name (and path) of the file in which to save the processed source (if it
<em>is</em> <code>NULL</code>, the result will be returned visibly). For <code>clean_sources</code> and
<code>search_and_replace_in_sources</code>, <code>output</code> is mandatory and is the path to the
directory where to store the processed sources. This path will be created with a
warning if it does not exist. An exception is if "<code>same</code>" is specified - in that
case, every file will be written to the same directory it was read from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replacementsPre, replacementsPost</code></td>
<td>
<p>Each is a list of two-element vectors,
where the first element in each vector contains a regular expression to search for
in the source(s), and the second element contains the replacement (these are passed
as <code>perl</code> regular expressions; see <code>regex</code> for more information).
Instead of regular expressions, simple words or phrases can also be entered of
course (since those are valid regular expressions). <code>replacementsPre</code> are executed
before the <code>utteranceSplits</code> are applied; <code>replacementsPost</code> afterwards.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extraReplacementsPre, extraReplacementsPost</code></td>
<td>
<p>To perform more replacements
than the default set, these can be conveniently specified in <code>extraReplacementsPre</code>
and <code>extraReplacementsPost</code>. This prevents you from having to
manually copypaste the list of defaults to retain it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeNewlines</code></td>
<td>
<p>Whether to remove all newline characters from the source before
starting to clean them. <strong>Be careful</strong>: if the source contains YAML fragments, these
will also be affected by this, and will probably become invalid!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>removeTrailingNewlines</code></td>
<td>
<p>Whether to remove trailing newline characters
(i.e. at the end of a character value in a character vector);</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlWarn</code></td>
<td>
<p>Whether to let <code>readLines()</code> warn, e.g. if files do not end
with a newline character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>utteranceSplits</code></td>
<td>
<p>This is a vector of regular expressions that specify where to
insert breaks between utterances in the source(s). Such breakes are specified using
<code>utteranceMarker</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>The encoding of the source(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Whether to suppress the warning about not editing the cleaned source.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outputPrefix, outputSuffix</code></td>
<td>
<p>The prefix and suffix to add to the
filenames when writing the processed files to disk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>Whether to search all subdirectories (<code>TRUE</code>) as well or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filenameRegex</code></td>
<td>
<p>A regular expression to match against located files; only
files matching this regular expression are processed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replacements</code></td>
<td>
<p>The strings to search &amp; replace, as a list of two-element vectors,
where the first element in each vector contains a regular expression to search for
in the source(s), and the second element contains the replacement (these are passed
as <code>perl</code> regular expressions; see <code>regex</code> for more information).
Instead of regular expressions, simple words or phrases can also be entered of
course (since those are valid regular expressions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>At how many characters to word wrap.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>utteranceMarker</code></td>
<td>
<p>The character(s) between utterances (i.e. marking where
one utterance ends and the next one starts). By default, this is a line
break, and only change this if you know what you are doing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The cleaning functions, when called with their default arguments, will do the following:
</p>

<ul>
<li>
<p> Double periods (<code>..</code>) will be replaced with single periods (<code>.</code>)
</p>
</li>
<li>
<p> Four or more periods (<code>...</code> or <code>.....</code>) will be replaced with three periods
</p>
</li>
<li>
<p> Three or more newline characters will be replaced by one newline character (which
will become more, if the sentence before that character marks the end of an
utterance)
</p>
</li>
<li>
<p> All sentences will become separate utterances (in a semi-smart manner;
specifically, breaks in speaking, if represented by three periods, are not
considered sentence ends, wheread ellipses ("…" or unicode 2026, see the example) <em>are</em>.
</p>
</li>
<li>
<p> If there are comma's without a space following them, a space will be inserted.
</p>
</li>
</ul>
<p>The cleaning functions, when called with their default arguments, will do the following:
</p>

<ul>
<li>
<p> Double periods (<code>..</code>) will be replaced with single periods (<code>.</code>)
</p>
</li>
<li>
<p> Four or more periods (<code>...</code> or <code>.....</code>) will be replaced with three periods
</p>
</li>
<li>
<p> Three or more newline characters will be replaced by one newline character (which
will become more, if the sentence before that character marks the end of an
utterance)
</p>
</li>
<li>
<p> All sentences will become separate utterances (in a semi-smart manner;
specifically, breaks in speaking, if represented by three periods, are not
considered sentence ends, wheread ellipses ("…" or unicode 2026, see the example) <em>are</em>.
</p>
</li>
<li>
<p> If there are comma's without a space following them, a space will be inserted.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A character vector for <code>clean_source</code>, or a list of character vectors,
for <code>clean_sources</code>.
</p>
<p>A character vector for <code>clean_source</code>, or a list of character vectors,
for <code>clean_sources</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">exampleSource &lt;-
"Do you like icecream?


Well, that depends\u2026 Sometimes, when it's..... Nice. Then I do,
but otherwise... not really, actually."

### Default settings:
cat(clean_source(exampleSource));

### First remove existing newlines:
cat(clean_source(exampleSource,
                 removeNewlines=TRUE));

### Example with a YAML fragment
exampleWithYAML &lt;-
c(
  "Do you like icecream?",
  "",
  "",
  "Well, that depends\u2026 Sometimes, when it's..... Nice.",
  "Then I do,",
  "but otherwise... not really, actually.",
  "",
  "---",
  "This acts as some YAML. So this won't be split.",
  "Not real YAML, mind... It just has the delimiters, really.",
  "---",
  "This is an utterance again."
);

cat(
  rock::clean_source(
    exampleWithYAML
  ),
  sep="\n"
);

exampleSource &lt;-
"Do you like icecream?


Well, that depends\u2026 Sometimes, when it's..... Nice. Then I do,
but otherwise... not really, actually."

### Simple text replacements:
cat(search_and_replace_in_source(exampleSource,
                                 replacements=list(c("\u2026", "..."),
                                                   c("Nice", "Great"))));

### Using a regular expression to capitalize all words following
### a period:
cat(search_and_replace_in_source(exampleSource,
                                 replacements=list(c("\\.(\\s*)([a-z])", ".\\1\\U\\2"))));

exampleSource &lt;-
"Do you like icecream?


Well, that depends\u2026 Sometimes, when it's..... Nice. Then I do,
but otherwise... not really, actually."

### Default settings:
cat(clean_source(exampleSource));

### First remove existing newlines:
cat(clean_source(exampleSource,
                 removeNewlines=TRUE));

### Example with a YAML fragment
exampleWithYAML &lt;-
c(
  "Do you like icecream?",
  "",
  "",
  "Well, that depends\u2026 Sometimes, when it's..... Nice.",
  "Then I do,",
  "but otherwise... not really, actually.",
  "",
  "---",
  "This acts as some YAML. So this won't be split.",
  "Not real YAML, mind... It just has the delimiters, really.",
  "---",
  "This is an utterance again."
);

cat(
  rock::clean_source(
    exampleWithYAML
  ),
  sep="\n"
);

</code></pre>


</div>