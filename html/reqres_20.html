<div class="container">

<table style="width: 100%;"><tr>
<td>parsers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pre-supplied parsing generators</h2>

<h3>Description</h3>

<p>This set of functions can be used to construct parsing functions adhering to
the Request$parse() requirements.
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_json(
  simplifyVector = TRUE,
  simplifyDataFrame = simplifyVector,
  simplifyMatrix = simplifyVector,
  flatten = FALSE
)

parse_plain(sep = "\n")

parse_xml(encoding = "", options = "NOBLANKS", base_url = "")

parse_html(
  encoding = "",
  options = c("RECOVER", "NOERROR", "NOBLANKS"),
  base_url = ""
)

parse_multiform()

parse_queryform()

parse_table(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>simplifyVector</code></td>
<td>
<p>coerce JSON arrays containing only primitives into an atomic vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplifyDataFrame</code></td>
<td>
<p>coerce JSON arrays containing only records (JSON objects) into a data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplifyMatrix</code></td>
<td>
<p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flatten</code></td>
<td>
<p>automatically <code>flatten()</code> nested data frames into a single non-nested data frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>The line separator. Plain text will be split into multiple strings
based on this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>Specify a default encoding for the document. Unless
otherwise specified XML documents are assumed to be in UTF-8 or
UTF-16. If the document is not UTF-8/16, and lacks an explicit
encoding directive, this allows you to supply a default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>Set parsing options for the libxml2 parser. Zero or more of
</p>

<dl>
<dt>RECOVER</dt>
<dd>
<p>recover on errors</p>
</dd>
<dt>NOENT</dt>
<dd>
<p>substitute entities</p>
</dd>
<dt>DTDLOAD</dt>
<dd>
<p>load the external subset</p>
</dd>
<dt>DTDATTR</dt>
<dd>
<p>default DTD attributes</p>
</dd>
<dt>DTDVALID</dt>
<dd>
<p>validate with the DTD</p>
</dd>
<dt>NOERROR</dt>
<dd>
<p>suppress error reports</p>
</dd>
<dt>NOWARNING</dt>
<dd>
<p>suppress warning reports</p>
</dd>
<dt>PEDANTIC</dt>
<dd>
<p>pedantic error reporting</p>
</dd>
<dt>NOBLANKS</dt>
<dd>
<p>remove blank nodes</p>
</dd>
<dt>SAX1</dt>
<dd>
<p>use the SAX1 interface internally</p>
</dd>
<dt>XINCLUDE</dt>
<dd>
<p>Implement XInclude substitition</p>
</dd>
<dt>NONET</dt>
<dd>
<p>Forbid network access</p>
</dd>
<dt>NODICT</dt>
<dd>
<p>Do not reuse the context dictionary</p>
</dd>
<dt>NSCLEAN</dt>
<dd>
<p>remove redundant namespaces declarations</p>
</dd>
<dt>NOCDATA</dt>
<dd>
<p>merge CDATA as text nodes</p>
</dd>
<dt>NOXINCNODE</dt>
<dd>
<p>do not generate XINCLUDE START/END nodes</p>
</dd>
<dt>COMPACT</dt>
<dd>
<p>compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)</p>
</dd>
<dt>OLD10</dt>
<dd>
<p>parse using XML-1.0 before update 5</p>
</dd>
<dt>NOBASEFIX</dt>
<dd>
<p>do not fixup XINCLUDE xml:base uris</p>
</dd>
<dt>HUGE</dt>
<dd>
<p>relax any hardcoded limit from the parser</p>
</dd>
<dt>OLDSAX</dt>
<dd>
<p>parse using SAX2 interface before 2.7.0</p>
</dd>
<dt>IGNORE_ENC</dt>
<dd>
<p>ignore internal document encoding hint</p>
</dd>
<dt>BIG_LINES</dt>
<dd>
<p>Store big lines numbers in text PSVI field</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base_url</code></td>
<td>
<p>When loading from a connection, raw vector or literal
html/xml, this allows you to specify a base url for the document. Base
urls are used to turn relative urls into absolute urls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters passed on to <code>read.table()</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A function accepting a raw vector and a named list of directives
</p>


<h3>See Also</h3>

<p>formatters for converting <code>Response</code> bodies into compatible types
</p>
<p>default_parsers for a list that maps the most common mime types
to their respective parsers
</p>


<h3>Examples</h3>

<pre><code class="language-R">fake_rook &lt;- fiery::fake_request(
  'http://example.com/test',
  content = '[1, 2, 3, 4]',
  headers = list(
    Content_Type = 'application/json'
  )
)

req &lt;- Request$new(fake_rook)
req$parse(json = parse_json())
req$body

# Cleaning up connections
rm(fake_rook, req)
gc()

</code></pre>


</div>