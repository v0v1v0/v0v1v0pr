<div class="container">

<table style="width: 100%;"><tr>
<td>igapfill</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform SSA gapfilling via iterative reconstruction</h2>

<h3>Description</h3>

<p>Perform iterative gapfilling of the series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class '1d.ssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'cssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'toeplitz.ssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
## S3 method for class 'nd.ssa'
igapfill(x, groups, fill = NULL, tol = 1e-6, maxiter = 0,
          norm = function(x) sqrt(max(x^2)),
          base = c("original", "reconstructed"), ..., trace = FALSE,
          drop = TRUE, drop.attributes = FALSE, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Shaped SSA object holding the decomposition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>list, the grouping of eigentriples to be used in the forecast</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>initial values for missed entries, recycled if necessary;
if missed, then average of the series will be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance for reconstruction iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>upper bound for the number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>distance function used for covergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>series used as a 'seed' for gapfilling: original or
reconstructed according to the value of <code>groups</code> argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>reconstruct</code>
routines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical, indicates whether the convergence process should be traced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>logical, if 'TRUE' then the result is coerced to series
itself, when possible (length of 'groups' is one)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop.attributes</code></td>
<td>
<p>logical, if 'TRUE' then the attributes of the input series
are not copied to the reconstructed ones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache</code></td>
<td>
<p>logical, if 'TRUE' then intermediate results will be
cached in the SSA object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Iterative gapfilling starts from filling missed entries with initial
values, then the missed values are imputed from the successive
reconstructions. This process continues until convergence up to a
stationary point (e.g. filling / reconstruction does not change missed
values at all).
</p>
<p>Details of the used algorithm see in Golyandina et al (2018), 
Algorithms 3.7.
</p>


<h3>Value</h3>

<p>List of objects with gaps filled in. Elements of the list have the
same names as elements of <code>groups</code>. If group is unnamed,
corresponding component gets name ‘Fn’, where ‘n’ is its index in
<code>groups</code> list.
</p>
<p>Or, the forecasted object itself, if length of groups is one and 'drop = TRUE'.
</p>


<h3>Note</h3>

<p>The method is very sensitive to the initial value of missed entries
('fill' argument). If the series are not stationary (e.g. contains
some trend) than the method may be prohibitely slow, or even fail to
converge or produce bogus results.
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Kondrashov, D. &amp; Ghil, M. (2006) <em>Spatio-temporal filling of
missing points in geophysical data sets</em>. Nonlinear Processes In
Geophysics, Vol. 13(2), pp. 151-159.
</p>


<h3>See Also</h3>

<p><code>Rssa</code> for an overview of the package, as well as,
<code>gapfill</code>,
<code>clplot</code>,
<code>summarize.gaps</code>,
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Produce series with gaps
F &lt;- co2; F[100:200] &lt;- NA
# Perform shaped SSA
s &lt;- ssa(F, L = 72)
# Fill in gaps using the trend and 2 periodicty components
# Due to trend, provide a linear filler to speedup the process
fill &lt;- F; fill[100:200] &lt;- F[99] + (1:101)/101*(F[201] - F[99])
g &lt;- igapfill(s, groups = list(1:6), fill = fill, maxit = 50)
# Compare the result
plot(g)
lines(co2, col = "red")
</code></pre>


</div>