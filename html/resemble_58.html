<div class="container">

<table style="width: 100%;"><tr>
<td>ortho_projection</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Orthogonal projections using principal component analysis and partial
least squares</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>Functions to perform orthogonal projections of high dimensional data matrices
using principal component analysis (pca) and partial least squares (pls).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ortho_projection(Xr, Xu = NULL,
                 Yr = NULL,
                 method = "pca",
                 pc_selection = list(method = "var", value = 0.01),
                 center = TRUE, scale = FALSE, ...)

pc_projection(Xr, Xu = NULL, Yr = NULL,
              pc_selection = list(method = "var", value = 0.01),
              center = TRUE, scale = FALSE,
              method = "pca",
              tol = 1e-6, max_iter = 1000, ...)

pls_projection(Xr, Xu = NULL, Yr,
               pc_selection = list(method = "opc", value = min(dim(Xr), 40)),
               scale = FALSE, method = "pls",
               tol = 1e-6, max_iter = 1000, ...)

## S3 method for class 'ortho_projection'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xr</code></td>
<td>
<p>a matrix of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xu</code></td>
<td>
<p>an optional matrix containing data of a second set of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Yr</code></td>
<td>
<p>if the method used in the <code>pc_selection</code> argument is <code>"opc"</code>
or if <code>method = "pls"</code>, then it must be a matrix
containing the side information corresponding to the spectra in <code>Xr</code>.
It is equivalent to the <code>side_info</code> parameter of the <code>sim_eval</code>
function. In case <code>method = "pca"</code>, a matrix (with one or more
continuous variables) can also be used as input. The root mean square of
differences (rmsd) is used for assessing the similarity between the observations
and their corresponding most similar observations in terms of the side information
provided. A single discrete variable of class factor can also be passed. In
that case, the kappa index is used. See <code>sim_eval</code> function for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the method for projecting the data. Options are:
</p>

<ul>
<li>
<p><code>"pca"</code>: principal component analysis using the singular value
decomposition algorithm.
</p>
</li>
<li>
<p><code>"pca.nipals"</code>: principal component analysis using the
non-linear iterative partial least squares algorithm.
</p>
</li>
<li>
<p><code>"pls"</code>: partial least squares.
</p>
</li>
<li>
<p><code>"mpls"</code>: modified partial least squares. See details.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pc_selection</code></td>
<td>
<p>a list of length 2 which specifies the method to be used
for optimizing the number of components (principal components or pls factors)
to be retained. This list must contain two elements (in the following order):
<code>method</code> (a character indicating the method for selecting the number of
components) and <code>value</code> (a numerical value that complements the selected
method). The methods available are:
</p>

<ul>
<li>
<p><code>"opc"</code>: optimized principal component selection based on
Ramirez-Lopez et al. (2013a, 2013b). The optimal number of components
of a given set of observations is the one for which its distance matrix
minimizes the differences between the <code>Yr</code> value of each
observation and the <code>Yr</code> value of its closest observation. In this
case <code>value</code> must be a value (larger than 0 and
below <code>min(nrow(Xr)</code> <code>+ nrow(Xu),</code> <code>ncol(Xr))</code> indicating
the maximum number of principal components to be tested. See details.
</p>
</li>
<li>
<p><code>"cumvar"</code>: selection of the principal components based
on a given cumulative amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of cumulative variance that the
combination of retained components should explain.
</p>
</li>
<li>
<p><code>"var"</code>: selection of the principal components based
on a given amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of variance that a single component should
explain in order to be retained.
</p>
</li>
<li>
<p><code>"manual"</code>: for manually specifying a fix number of
principal components. In this case, <code>value</code> must be a value
(larger than 0 and
below the minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code>
combined).
indicating the minimum amount of variance that a component should
explain in order to be retained.
</p>
</li>
</ul>
<p>The list <code>list(method = "var", value = 0.01)</code> is the default.
Optionally, the <code>pc_selection</code> argument admits <code>"opc"</code> or
<code>"cumvar"</code> or <code>"var"</code> or <code>"manual"</code> as a single character
string. In such a case the default <code>"value"</code> when either <code>"opc"</code> or
<code>"manual"</code> are used is 40. When <code>"cumvar"</code> is used the default
<code>"value"</code> is set to 0.99 and when <code>"var"</code> is used, the default
<code>"value"</code> is set to 0.01.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>a logical indicating if the data <code>Xr</code> (and <code>Xu</code> if
specified) must be centered. If <code>Xu</code> is specified the data is centered
on the basis of \(Xr \cup Xu\). NOTE: This argument only applies to the
principal components projection. For pls projections the data is always
centered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical indicating if <code>Xr</code> (and <code>Xu</code> if specified)
must be scaled. If <code>Xu</code> is specified the data is scaled on the basis of
\(Xr \cup Xu\).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed
to <code>pc_projection</code> or <code>pls_projection</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>tolerance limit for convergence of the algorithm in the nipals
algorithm (default is 1e-06). In the case of PLS this applies only to Yr with
more than one variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>maximum number of iterations (default is 1000). In the case of
<code>method = "pls"</code> this applies only to <code>Yr</code> matrices with more than
one variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>object of class <code>"ortho_projection"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>an optional data frame or matrix in which to look for variables
with which to predict. If omitted, the scores are used. It must contain the
same number of columns, to be used in the same order.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the case of <code>method = "pca"</code>, the algorithm used is the singular value
decomposition in which a given data matrix (\(X\)) is factorized as follows:
</p>
\[X = UDV^{T}\]
<p>where \(U\) and \(V\) are orthogonal matrices, being the left and right
singular vectors of \(X\) respectively, \(D\) is a diagonal matrix
containing the singular values of \(X\) and \(V\) is the is a matrix of
the right singular vectors of \(X\).
The matrix of principal component scores is obtained by a matrix
multiplication of \(U\) and \(D\), and the matrix of principal component
loadings is equivalent to the matrix \(V\).
</p>
<p>When <code>method = "pca.nipals"</code>, the algorithm used for principal component
analysis is the non-linear iterative partial least squares (nipals).
</p>
<p>In the case of the of the partial least squares projection (a.k.a projection
to latent structures) the nipals regression algorithm is used by default.
Details on the "nipals" algorithm are presented in Martens (1991). Another
method called modified pls (<code>'mpls'</code>) can also be used. The modified
pls was proposed Shenk and Westerhaus (1991, see also Westerhaus, 2014) and it
differs from the standard pls method in the way the weights of the <code>Xr</code>
(used to compute the matrix of scores) are obtained. While pls uses the covariance
between  <code>Yr</code> and <code>Xr</code> (and later their deflated versions
corresponding at each pls component iteration) to obtain these weights, the modified pls
uses the correlation as weights. The authors indicate that by using correlation,
a larger potion of the response variable(s) can be explained.
</p>
<p>When <code>method = "opc"</code>, the selection of the components is carried out by
using an iterative method based on the side information concept
(Ramirez-Lopez et al. 2013a, 2013b). First let be \(P\) a sequence of
retained components (so that \(P = 1, 2, ...,k \)).
At each iteration, the function computes a dissimilarity matrix retaining
\(p_i\) components. The values in this side information variable are
compared against the side information values of their most spectrally similar
observations (closest <code>Xr</code> observation).
The optimal number of components retrieved by the function is the one that
minimizes the root mean squared differences (RMSD) in the case of continuous
variables, or maximizes the kappa index in the case of categorical variables.
In this process, the <code>sim_eval</code> function is used.
Note that for the <code>"opc"</code> method <code>Yr</code> is required (i.e. the
side information of the observations).
</p>


<h3>Value</h3>

<p>a <code>list</code> of class <code>ortho_projection</code> with the following
components:
</p>

<ul>
<li>
<p><code>scores</code>: a matrix of scores corresponding to the observations in
<code>Xr</code> (and <code>Xu</code> if it was provided). The components retrieved
correspond to the ones optimized or specified.
</p>
</li>
<li>
<p><code>X_loadings</code>: a matrix of loadings corresponding to the
explanatory variables. The components retrieved correspond to the ones
optimized or specified.
</p>
</li>
<li>
<p><code>Y_loadings</code>: a matrix of partial least squares loadings
corresponding to <code>Yr</code>. The components retrieved  correspond to the
ones optimized or specified.
This object is only returned if the partial least squares algorithm was used.
</p>
</li>
<li>
<p><code>weigths</code>: a matrix of partial least squares ("pls") weights.
This object is only returned if the "pls" algorithm was used.
</p>
</li>
<li>
<p><code>projection_mat</code>: a matrix that can be used to project new data
onto a "pls" space. This object is only returned if the "pls" algorithm was
used.
</p>
</li>
<li>
<p><code>variance</code>: a list with information on the original variance and
the explained variances. This list contains a matrix indicating the amount of
variance explained by each component (var), the ratio between explained
variance by each single component and the original variance (explained_var) and
the cumulative ratio of explained variance (cumulative_explained_var).
The amount of variance explained by each component is computed by multiplying
its score vector by its corresponding loading vector and calculating the
variance of the result. These values are computed based on the observations
used to create the projection matrices. For example if the "pls" method was
used, then these values are computed  based only on the data that contains
information on <code>Yr</code> (i.e. the  <code>Xr</code> data). If the principal
component method is used, the this data is  computed on the basis of
<code>Xr</code> and <code>Xu</code> (if it applies) since both  matrices are employed in
the computation of the projection matrix (loadings  in this case).
</p>
</li>
<li>
<p><code>sdv</code>: the standard deviation of the retrieved scores. This vector
can be different from the "sd" in <code>variance</code>.
</p>
</li>
<li>
<p><code>n_components</code>: the number of components (either principal
components or partial least squares components) used for computing the
global dissimilarity scores.
</p>
</li>
<li>
<p><code>opc_evaluation</code>: a matrix containing the statistics computed
for optimizing the number of principal components based on the variable(s)
specified in the <code>Yr</code> argument. If <code>Yr</code> was a continuous  was a
continuous vector or matrix then this object indicates the root mean square
of differences (rmse) for each number of components. If <code>Yr</code> was a
categorical variable this object indicates the kappa values for each number
of components. This object is returned only if <code>"opc"</code> was used within
the <code>pc_selection</code> argument. See the <code>sim_eval</code> function for
more details.
</p>
</li>
<li>
<p><code>method</code>: the <code>ortho_projection</code> method used.
</p>
</li>
</ul>
<p><code>predict.ortho_projection</code>, returns a matrix of scores proprojected for
<code>newdtata</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
</p>


<h3>References</h3>

<p>Martens, H. (1991). Multivariate calibration. John Wiley &amp; Sons.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex data sets. Geoderma 195-196, 268-279.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Viscarra Rossel, R., Dematte,
J. A. M.,  Scholten, T. 2013b. Distance and similarity-search metrics for use
with soil vis-NIR spectra. Geoderma 199, 43-53.
</p>
<p>Shenk, J. S., &amp; Westerhaus, M. O. 1991. Populations structuring of
near infrared spectra and modified partial least squares regression.
Crop Science, 31(6), 1548-1555.
</p>
<p>Shenk, J., Westerhaus, M., and Berzaghi, P. 1997. Investigation of a LOCAL
calibration procedure for near infrared instruments. Journal of Near Infrared
Spectroscopy, 5, 223-232.
</p>
<p>Westerhaus, M. 2014. Eastern Analytical Symposium Award for outstanding
Wachievements in near infrared spectroscopy: my contributions to
Wnear infrared spectroscopy. NIR news, 25(8), 16-20.
</p>


<h3>See Also</h3>

<p><code>ortho_diss</code>, <code>sim_eval</code>, <code>mbl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(prospectr)
data(NIRsoil)

# Proprocess the data using detrend plus first derivative with Savitzky and
# Golay smoothing filter
sg_det &lt;- savitzkyGolay(
  detrend(NIRsoil$spc,
    wav = as.numeric(colnames(NIRsoil$spc))
  ),
  m = 1,
  p = 1,
  w = 7
)
NIRsoil$spc_pr &lt;- sg_det

# split into training and testing sets
test_x &lt;- NIRsoil$spc_pr[NIRsoil$train == 0 &amp; !is.na(NIRsoil$CEC), ]
test_y &lt;- NIRsoil$CEC[NIRsoil$train == 0 &amp; !is.na(NIRsoil$CEC)]

train_y &lt;- NIRsoil$CEC[NIRsoil$train == 1 &amp; !is.na(NIRsoil$CEC)]
train_x &lt;- NIRsoil$spc_pr[NIRsoil$train == 1 &amp; !is.na(NIRsoil$CEC), ]

# A principal component analysis using 5 components
pca_projected &lt;- ortho_projection(train_x, pc_selection = list("manual", 5))
pca_projected

# A principal components projection using the "opc" method
# for the selection of the optimal number of components
pca_projected_2 &lt;- ortho_projection(
  Xr = train_x, Xu = test_x, Yr = train_y,
  method = "pca",
  pc_selection = list("opc", 40)
)
pca_projected_2
plot(pca_projected_2)

# A partial least squares projection using the "opc" method
# for the selection of the optimal number of components
pls_projected &lt;- ortho_projection(
  Xr = train_x, Xu = test_x, Yr = train_y,
  method = "pls",
  pc_selection = list("opc", 40)
)
pls_projected
plot(pls_projected)

# A partial least squares projection using the "cumvar" method
# for the selection of the optimal number of components
pls_projected_2 &lt;- ortho_projection(
  Xr = train_x, Xu = test_x, Yr = train_y,
  method = "pls",
  pc_selection = list("cumvar", 0.99)
)

</code></pre>


</div>