<div class="container">

<table style="width: 100%;"><tr>
<td>build_format_regex</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build format regular expression</h2>

<h3>Description</h3>

<p>Allow <code>glue</code>-style formatting using keyworded regular expressions. The
original <code>glue</code> string (anything that isn't expanded by <code>glue</code>) is treated as
a string literal, whereas the contents of populated values can be regular
expressions, allowing for a more user-friendly way to construct complicated
regular expressions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">build_format_regex(
  format,
  format_re,
  ...,
  type = re_backticked(),
  description = re_any()
)

re_backticked()

re_any()

escape_non_glue_re(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>(<code>character[1]</code>) A <code>glue</code>-style format string. Expanded whisker values are used as a
shorthand for capture groups, where ellipsis arguments can be provided
for additional capture group patterns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format_re</code></td>
<td>
<p>(<code>character[1]</code>) Alternatively, provide a standard regular expression directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments provide keyworded capture groups for <code>format</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>(<code>character[1]</code>) A regular expression to use to match a type signature. By default, matches
within backticks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>description</code></td>
<td>
<p>(<code>character[1]</code>) A regular expression to use to match a parameter description. By default,
matches any string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(<code>character[1]</code>) A string to escape.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>To bypass glue entirely and use a standard regular expression, use
<code>format_re</code>.
</p>
<p>The provided regular expression must match all characters from the start of a
string to the end. The string also matches using "dot all" syntax, meaning
that the <code>.</code> expression will also match newline characters.
</p>


<h3>Value</h3>

<p>(<code style="white-space: pre;">⁠character[1]:⁠</code>) A regular expression string, built from component sub-expressions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>re_backticked()</code>: Match within backticks
</p>
</li>
<li> <p><code>re_any()</code>: Match any
</p>
</li>
<li> <p><code>escape_non_glue_re()</code>: Escape all regular expression special characters
</p>
<p>In addition, avoid escaping <code>{}</code>'s that appear to be used as <code>glue</code> keywords.
Handles only simple cases, and does not handle recusive curly nesting.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">re &lt;- roxytypes:::build_format_regex(
  "{as}{any}{bs}",
  as = "a+",
  bs = "b+",
  any = ".*?"
)

roxytypes:::regex_capture(re, "aaaa\n\nbb", perl = TRUE)

text &lt;- "@param (`test(\")\")`)"

pattern &lt;- sprintf("`%s`", re_backticked())

m &lt;- regexec(pattern, text, perl = TRUE)
regmatches(text, m)[[1]]
# [1] "`test(\")\")`"

# curlies escaped, as this does not appear to be a glue-style usage
roxytypes:::escape_non_glue_re(".{1,3}")

# curlies not escaped, as this is a glue-style usage
roxytypes:::escape_non_glue_re("this is a {test}")

</code></pre>


</div>