<div class="container">

<table style="width: 100%;"><tr>
<td>spde.matern.operators</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rational approximations of non-stationary Gaussian SPDE Matern random fields</h2>

<h3>Description</h3>

<p><code>spde.matern.operators</code> is used for computing a rational SPDE
approximation of a Gaussian random
fields on <code class="reqn">R^d</code> defined as a solution to the SPDE
</p>
<p style="text-align: center;"><code class="reqn">(\kappa(s) - \Delta)^\beta (\tau(s)u(s)) = W.</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">spde.matern.operators(
  kappa = NULL,
  tau = NULL,
  theta = NULL,
  B.tau = matrix(c(0, 1, 0), 1, 3),
  B.kappa = matrix(c(0, 0, 1), 1, 3),
  B.sigma = matrix(c(0, 1, 0), 1, 3),
  B.range = matrix(c(0, 0, 1), 1, 3),
  alpha = NULL,
  nu = NULL,
  parameterization = c("spde", "matern"),
  G = NULL,
  C = NULL,
  d = NULL,
  graph = NULL,
  mesh = NULL,
  range_mesh = NULL,
  loc_mesh = NULL,
  m = 1,
  type = c("covariance", "operator"),
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>Vector with the, possibly spatially varying, range parameter
evaluated at the locations of the mesh used for the finite element
discretization of the SPDE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Vector with the, possibly spatially varying, precision
parameter evaluated at the locations
of the mesh used for the finite element discretization of the SPDE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>Theta parameter that connects B.tau and B.kappa to tau and kappa through a log-linear regression, in case the parameterization is <code>spde</code>,
and that connects B.sigma and B.range to tau and kappa in case the parameterization is <code>matern</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.tau</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\tau</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.kappa</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\kappa</code>. Will be used if <code>parameterization = 'spde'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.sigma</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\sigma</code>. Will be used if <code>parameterization = 'matern'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.range</code></td>
<td>
<p>Matrix with specification of log-linear model for <code class="reqn">\rho</code>, which is a range-like parameter (it is exactly the range parameter in the stationary case). Will be used if <code>parameterization = 'matern'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>smoothness parameter. Will be used if the parameterization is 'spde'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Shape parameter of the covariance function. Will be used if the parameterization is 'matern'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and nu (smoothness). The default is <code>matern</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization of
the domain of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>The mass matrix of a finite element discretization of the
domain of interest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>The dimension of the domain. Does not need to be given if
<code>mesh</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>An optional inla mesh. <code>d</code>, <code>C</code> and <code>G</code>
must be given if <code>mesh</code> is not given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of the rational approximation. The options are
"covariance" and "operator". The default is "covariance".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
"chebfun", "brasil" or "chebfunLB".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The approximation is based on a rational approximation of the
fractional operator <code class="reqn">(\kappa(s)^2 -\Delta)^\beta</code>, where
<code class="reqn">\beta = (\nu + d/2)/2</code>. This results in an approximate model
on the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>
<p> where <code class="reqn">P_j = p_j(L)</code> are
non-fractional operators defined in terms of polynomials <code class="reqn">p_j</code> for
<code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given by <code>m</code> and the order
of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code> where <code class="reqn">m_\beta</code> is the integer
part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and <code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code>
and <code class="reqn">Q = P_l^T C^{-1} P_l</code>. Note that the matrices <code class="reqn">P_r</code> and
<code class="reqn">Q</code> may be be ill-conditioned for <code class="reqn">m&gt;1</code>.
In this case, the metehods in <code>operator.operations()</code>
should be used for operations involving the matrices, since
these methods are more numerically stable.
</p>


<h3>Value</h3>

<p><code>spde.matern.operators</code> returns an object of
class "rSPDEobj. This object contains the
quantities listed in the output of <code>fractional.operators()</code>
as well as the smoothness parameter <code class="reqn">\nu</code>.
</p>


<h3>See Also</h3>

<p><code>fractional.operators()</code>,
<code>spde.matern.operators()</code>,
<code>matern.operators()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Sample non-stationary Matern field on R
tau &lt;- 1
nu &lt;- 0.8

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# define a non-stationary range parameter
kappa &lt;- seq(from = 2, to = 20, length.out = length(x))
alpha &lt;- nu + 1/2
# compute rational approximation
op &lt;- spde.matern.operators(
  kappa = kappa, tau = tau, alpha = alpha,
  G = fem$G, C = fem$C, d = 1
)

# sample the field
u &lt;- simulate(op)

# plot the sample
plot(x, u, type = "l", ylab = "u(s)", xlab = "s")

</code></pre>


</div>