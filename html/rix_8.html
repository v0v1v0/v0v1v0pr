<div class="container">

<table style="width: 100%;"><tr>
<td>with_nix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evaluate function in R or shell command via <code>nix-shell</code> environment</h2>

<h3>Description</h3>

<p>This function needs an installation of Nix. <code>with_nix()</code> has two effects
to run code in isolated and reproducible environments.
</p>

<ol>
<li>
<p> Evaluate a function in R or a shell command via the <code>nix-shell</code>
environment (Nix expression for custom software libraries; involving pinned
versions of R and R packages via Nixpkgs)
</p>
</li>
<li>
<p> If no error, return the result object of <code>expr</code> in <code>with_nix()</code> into the
current R session.
</p>
</li>
</ol>
<h3>Usage</h3>

<pre><code class="language-R">with_nix(
  expr,
  program = c("R", "shell"),
  project_path = ".",
  message_type = c("simple", "quiet", "verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>Single R function or call, or character vector of length one with
shell command and possibly options (flags) of the command to be invoked.
For <code>program = R</code>, you can both use a named or an anonymous function.
The function provided in <code>expr</code> should not evaluate when you pass arguments,
hence you need to wrap your function call like
<code>function() your_fun(arg_a = "a", arg_b = "b")</code>, to avoid evaluation and make
sure <code>expr</code> is a function (see details and examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>program</code></td>
<td>
<p>String stating where to evaluate the expression. Either <code>"R"</code>,
the default, or <code>"shell"</code>. <code>where = "R"</code> will evaluate the expression via
<code>RScript</code> and <code>where = "shell"</code> will run the system command in <code>nix-shell</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>project_path</code></td>
<td>
<p>Path to the folder where the <code>default.nix</code> file resides.
The default is <code>"."</code>, which is the working directory in the current R
session. This approach also useful when you have different subfolders
with separate software environments defined in different <code>default.nix</code> files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message_type</code></td>
<td>
<p>String how detailed output is. Currently, there is
either <code>"simple"</code> (default), <code style="white-space: pre;">⁠"quiet⁠</code> or <code>"verbose"</code>, which shows the script
that runs via <code>nix-shell</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>with_nix()</code> gives you the power of evaluating a main function <code>expr</code>
and its function call stack that are defined in the current R session
in an encapsulated nix-R session defined by Nix expression (<code>default.nix</code>),
which is located in at a distinct project path (<code>project_path</code>).
</p>
<p><code>with_nix()</code> is very convenient because it gives direct code feedback in
read-eval-print-loop style, which gives a direct interface to the very
reproducible infrastructure-as-code approach offered by Nix and Nixpkgs. You
don't need extra efforts such as setting up DevOps tooling like Docker and
domain specific tools like {renv} to control complex software environments
in R and any other language. It is for example useful for the following
purposes.
</p>

<ol>
<li>
<p> test compatibility of custom R code and software/package dependencies in
development and production environments
</p>
</li>
<li>
<p> directly stream outputs (returned objects), messages and errors from any
command line tool offered in Nixpkgs into an R session.
</p>
</li>
<li>
<p> Test if evolving R packages change their behavior for given unchanged
R code, and whether they give identical results or not.
</p>
</li>
</ol>
<p><code>with_nix()</code> can evaluate both R code from a nix-R session within
another nix-R session, and also from a host R session (i.e., on macOS or
Linux) within a specific nix-R session. This feature is useful for testing
the reproducibility and compatibility of given code across different software
environments. If testing of different sets of environments is necessary, you
can easily do so by providing Nix expressions in custom <code>.nix</code> or
<code>default.nix</code> files in different subfolders of the project.
</p>
<p><code>rix_init()</code> is run automatically to generate a custom <code>.Rprofile</code>
file for the subshell in <code>project_dir</code>. The defaults in that file ensure
that only R packages from the Nix store, that are defined in the subshell
<code>.nix</code> file are loaded and system's libraries are excluded.
</p>
<p>To do its job, <code>with_nix()</code> heavily relies on patterns that manipulate
language expressions (aka computing on the language) offered in base R as
well as the {codetools} package by Luke Tierney.
</p>
<p>Some of the key steps that are done behind the scene:
</p>

<ol>
<li>
<p> recursively find, classify, and export global objects (globals) in the
call stack of <code>expr</code> as well as propagate R package environments found.
</p>
</li>
<li>
<p> Serialize (save to disk) and deserialize (read from disk) dependent
data structures as <code>.Rds</code> with necessary function arguments provided,
any relevant globals in the call stack, packages, and <code>expr</code> outputs
returned in a temporary directory.
</p>
</li>
<li>
<p> Use pure <code>nix-shell</code> environments to execute a R code script
reconstructed catching expressions with quoting; it is launched by commands
like this via <code>{sys}</code> by Jeroen Ooms:
<code style="white-space: pre;">⁠nix-shell --pure --run "Rscript --vanilla"⁠</code>.
</p>
</li>
</ol>
<h3>Value</h3>


<ul>
<li>
<p> if <code>program = "R"</code>, R object returned by function given in <code>expr</code>
when evaluated via the R environment in <code>nix-shell</code> defined by Nix
expression.
</p>
</li>
<li>
<p> if <code>program = "shell"</code>, list with the following elements:
</p>

<ul>
<li> <p><code>status</code>: exit code
</p>
</li>
<li> <p><code>stdout</code>: character vector with standard output
</p>
</li>
<li> <p><code>stderr</code>: character vector with standard error
of <code>expr</code> command sent to a command line interface provided by a Nix package.
</p>
</li>
</ul>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# create an isolated, runtime-pure R setup via Nix
project_path &lt;- "./sub_shell"
rix_init(
  project_path = project_path,
  rprofile_action = "create_missing"
)
# generate nix environment in `default.nix`
rix(
  r_ver = "4.2.0",
  project_path = project_path
)
# evaluate function in Nix-R environment via `nix-shell` and `Rscript`,
# stream messages, and bring output back to current R session
out &lt;- with_nix(
  expr = function(mtcars) nrow(mtcars),
  program = "R", project_path = project_path,
  message_type = "simple"
)

# There no limit in the complexity of function call stacks that `with_nix()`
# can possibly handle; however, `expr` should not evaluate and
# needs to be a function for `program = "R"`. If you want to pass the
# a function with arguments, you can do like this
get_sample &lt;- function(seed, n) {
  set.seed(seed)
  out &lt;- sample(seq(1, 10), n)
  return(out)
}

out &lt;- with_nix(
  expr = function() get_sample(seed = 1234, n = 5),
  program = "R",
  project_path = ".",
  message_type = "simple"
)

## You can also attach packages with `library()` calls in the current R
## session, which will be exported to the nix-R session.
## Other option: running system commands through `nix-shell` environment.

## End(Not run)
</code></pre>


</div>