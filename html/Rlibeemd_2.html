<div class="container">

<table style="width: 100%;"><tr>
<td>bemd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bivariate EMD decomposition</h2>

<h3>Description</h3>

<p>Function <code>bemd</code> implements the Bivariate EMD (Scheme 2 in the cited article).
</p>


<h3>Usage</h3>

<pre><code class="language-R">bemd(input, directions = 64L, num_imfs = 0L, num_siftings = 50L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>Complex vector of length N. The input signal to decompose.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directions</code></td>
<td>
<p>Vector of directional angles (in radians) to use for the decomposition, 
or an integer defining the number of equally spaced angles to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_imfs</code></td>
<td>
<p>Number of Intrinsic Mode Functions (IMFs) to compute. If num_imfs is set to zero, a value of
num_imfs = emd_num_imfs(N) will be used, which corresponds to a maximal number of
IMFs. Note that the final residual is also counted as an IMF in this
respect, so you most likely want at least num_imfs=2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_siftings</code></td>
<td>
<p>Use a maximum number of siftings as a stopping criterion. If
<code>num_siftings</code> is zero, this stopping criterion is ignored. Default is 50.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Time series object of class <code>"mts"</code> where series corresponds to
IMFs of the input signal, with the last series being the final residual.
@references
</p>

<ol><li>
<p>G. Rilling, P. Flandrin, P. Goncalves and J. M. Lilly,
"Bivariate Empirical Mode Decomposition",
IEEE Signal Processing Letters, Vol. 14 (2007) 936â€“939
</p>
</li></ol>
<h3>Examples</h3>

<pre><code class="language-R">N &lt;- 512 
t &lt;- 2 * pi * (0:(N-1))/N
input &lt;- cos(0.3 * t) * exp(2i * t) + 0.3 * abs(sin(2.3 * t)) * exp(17i * t)

# Use evenly spaced angles as directions
num_directions &lt;- 64
directions &lt;- 2 * pi * 1:num_directions / num_directions
imfs &lt;- bemd(input, directions, num_imfs = 4, num_siftings = 10)

# plot the data
plot(Re(input), Im(input), xlim = c(-1, 2))
# plot signal and the imfs
for(i in 1:4)
  points(Re(imfs[,i]), Im(imfs[,i]), col = 1 + i)
legend("bottomright", col = 1:5, legend = c("signal", paste0("IMF ",1:4)), pch = 1)

data("float")
plot(float, type = "l")
signal &lt;- float[, 1] + float[, 2] * 1i
imfs &lt;- bemd(signal, num_siftings = 10, num_imfs = 4)

# plot the data and the imfs
oldpar &lt;- par()
par(mfrow = c(5, 1), mar = c(0.5, 4.5, 0.5, 0.5), oma = c(4, 0, 2, 0))
ts.plot(float, col = 1:2, lty = 1:2, ylab = "signal", gpars = list(xaxt = "n"))
for(i in 1:4) {
  ts.plot(Re(imfs[, i]), Im(imfs[, i]), col = 1:2, lty = 1:2, 
    ylab = if(i &lt; 4) paste("IMF", i) else "residual", gpars = list(xaxt = "n"))
 }
axis(1)
title(xlab = "Time (days)", main = "Bivariate EMD decomposition", outer = TRUE)
par(oldpar)
</code></pre>


</div>