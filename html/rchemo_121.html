<div class="container">

<table style="width: 100%;"><tr>
<td>kplsrda</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>KPLSR-DA models</h2>

<h3>Description</h3>

<p>Discrimination (DA) based on kernel PLSR (KPLSR)
</p>


<h3>Usage</h3>

<pre><code class="language-R">
kplsrda(X, y, weights = NULL, nlv, kern = "krbf", ...)

## S3 method for class 'Kplsrda'
predict(object, X, ..., nlv = NULL) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>For main function: Training X-data (<code class="reqn">n, p</code>). — For auxiliary function: New X-data (<code class="reqn">m, p</code>) to consider.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Training class membership (<code class="reqn">n</code>). <b>Note:</b> If <code>y</code> is a factor, it is replaced by a character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Weights (<code class="reqn">n</code>) to apply to the training observations for the PLS2. Internally, weights are "normalized" to sum to 1. Default to <code>NULL</code> (weights are set to <code class="reqn">1 / n</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlv</code></td>
<td>
<p>For main function: The number(s) of LVs to calculate. — For auxiliary function: The number(s) of LVs to consider.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kern</code></td>
<td>
<p>Name of the function defining the considered kernel for building the Gram matrix. See <code>krbf</code> for syntax, and other available kernel functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments to pass in the kernel function defined in <code>kern</code> (e.g. <code>gamma</code> for <code>krbf</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>For auxiliary function: A fitted model, output of a call to the main functions.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The training variable <code class="reqn">y</code> (univariate class membership) is transformed to a dummy table containing <code class="reqn">nclas</code> columns, where <code class="reqn">nclas</code> is the number of classes present in <code class="reqn">y</code>. Each column is a dummy variable (0/1). Then, a kernel PLSR (KPLSR) is run on the <code class="reqn">X-</code>data and the dummy table, returning predictions of the dummy variables. For a given observation, the final prediction is the class corresponding to the dummy variable for which the prediction is the highest.
</p>


<h3>Value</h3>

<p>For <code>kplsrda</code>: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fm</code></td>
<td>
<p>list with the kplsrda model: (<code>X</code>): the training X-data (<code class="reqn">n, p</code>); (<code>Kt</code>): the Gram matrix; (<code>T</code>): X-scores matrix; (<code>C</code>): The Y-loading weights matrix; (<code>U</code>): intermediate output; (<code>R</code>): The PLS projection matrix (p,nlv); (<code>ymeans</code>): the centering vector of Y (q,1); (<code>weights</code>): vector of observation weights; (<code>kern</code>): kern function; (<code>dots</code>): Optional arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lev</code></td>
<td>
<p>y levels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ni</code></td>
<td>
<p>number of observations by level of y</p>
</td>
</tr>
</table>
<p>For <code>predict.Kplsrda</code>: 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>predicted class for each observation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posterior</code></td>
<td>
<p>calculated probability of belonging to a class for each observation</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 50 ; p &lt;- 8
Xtrain &lt;- matrix(rnorm(n * p), ncol = p)
ytrain &lt;- sample(c(1, 4, 10), size = n, replace = TRUE)
m &lt;- 5
Xtest &lt;- Xtrain[1:m, ] ; ytest &lt;- ytrain[1:m]

nlv &lt;- 2
fm &lt;- kplsrda(Xtrain, ytrain, nlv = nlv)
names(fm)
predict(fm, Xtest)

pred &lt;- predict(fm, Xtest)$pred
err(pred, ytest)

predict(fm, Xtest, nlv = 0:nlv)$posterior
predict(fm, Xtest, nlv = 0)$posterior

predict(fm, Xtest, nlv = 0:nlv)$pred
predict(fm, Xtest, nlv = 0)$pred

</code></pre>


</div>