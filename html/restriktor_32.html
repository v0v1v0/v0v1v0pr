<div class="container">

<table style="width: 100%;"><tr>
<td>conTestScore</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Score-bar test for iht</h2>

<h3>Description</h3>

<p><code>conTestScore</code> tests linear equality and/or 
inequality restricted hypotheses for (robust) linear models by score-tests. It can be 
used directly and is called by the <code>conTest</code> function if <code>test = "score"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">
## S3 method for class 'conLM'
conTestScore(object, type = "A", neq.alt = 0, 
           boot = "no", R = 9999, p.distr = rnorm, 
           parallel = "no", ncpus = 1L, cl = NULL, seed = 1234, 
           verbose = FALSE, control = NULL, ...)

## S3 method for class 'conRLM'
conTestScore(object, type = "A", neq.alt = 0, 
           boot = "no", R = 9999, p.distr = rnorm,  
           parallel = "no", ncpus = 1L, cl = NULL, seed = 1234, 
           verbose = FALSE, control = NULL, ...)

## S3 method for class 'conGLM'
conTestScore(object, type = "A", neq.alt = 0, 
           boot = "no", R = 9999, p.distr = rnorm,  
           parallel = "no", ncpus = 1L, cl = NULL, seed = 1234, 
           verbose = FALSE, control = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>conLM</code>, <code>conRLM</code> or <code>conGLM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>hypothesis test type "A", "B", "C", "global", or 
"summary" (default). See details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neq.alt</code></td>
<td>
<p>integer: number of equality constraints that 
are maintained under the alternative hypothesis (for hypothesis 
test type "B"), see example 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot</code></td>
<td>
<p>the null-distribution of these test-statistics 
(except under type "C", see details) takes the form of a mixture of 
F-distributions. The tail probabilities can be computed directly 
via bootstrapping; if <code>"parametric"</code>, the p-value is 
computed based on the parametric bootstrap. By default, samples 
are drawn from a normal distribution with mean zero and varance 
one. See <code>p.distr</code> for other distributional options. If 
<code>"model.based"</code>, a model-based bootstrap method is used. 
Instead of computing the p-value via simulation, the p-value
can also be computed using the chi-bar-square weights. If 
<code>"no"</code>, the p-value is computed based on the weights 
obtained via simulation (<code>mix_weights = "boot"</code>) or using the 
multivariate normal distribution function (<code>mix_weights = "pmvnorm"</code>).
Note that, these weights are already available in the restriktor objected and
do not need to be estimated again. However, there are two exception for objects 
of class <code>conRLM</code>, namely for computing the p-value for the robust 
<code>test</code> = <code>"Wald"</code> and the robust <code>"score"</code>. In these cases 
the weights need to be recalculated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>integer; number of bootstrap draws for <code>boot</code>. 
The default value is set to 9999.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.distr</code></td>
<td>
<p>random generation distribution for the parametric bootstrap. For 
all available distributions see <code>?distributions</code>. For example, 
if <code>rnorm</code>, samples are drawn from the normal distribution (default) 
with mean zero and variance one. If <code>rt</code>, samples are drawn from 
a t-distribution. If <code>rchisq</code>, samples are drawn from a chi-square 
distribution. The random generation distributional parameters will 
be passed in via ....</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>the type of parallel operation to be used 
(if any). If missing, the default is set "no".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel 
operation: typically one would chose this to the number of 
available CPUs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>an optional parallel or snow cluster for use if 
parallel = "snow". If not supplied, a cluster on the local 
machine is created for the duration of the conTest call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>seed value. The default value is set to 1234.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical; if TRUE, information is shown at each 
bootstrap draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list of control arguments: 
</p>

<ul>
<li> <p><code>absval</code> tolerance criterion for convergence 
(default = sqrt(.Machine$double.eps)). Only used for model 
of class lm.
</p>
</li>
<li> <p><code>maxit</code> the maximum number of iterations for the 
optimizer (default = 10000). Only used for model of class 
mlm (not yet supported). 
</p>
</li>
<li> <p><code>tol</code> numerical tolerance value. Estimates 
smaller than <code>tol</code> are set to 0.
</p>
</li>
<li> <p><code>chunk_size</code> the chi-bar-square weights are computed for samples 
of size <code>chunk_size = 5000L</code>. This process is repeated iteratively 
until the weights converges (see <code>convergenge_crit</code>) or the maximum 
is reached, i.e., mix_weights_bootstrap_limit.
</p>
</li>
<li> <p><code>convergence_crit</code> the convergence criterion for the iterative 
process. The default is 1e-03.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments that can be passed to the p.distr function, 
or arguments for the restriktor or iht function. Consider, for example, the 
mix_weights_bootstrap_limit argument, which specifies the maximum number of 
bootstrap draws (default is 100.000) used to compute the chi-bar-square weights. 
If mix_weights_bootstrap_limit is set to 100.000, then in each iteration, a 
sample of size 5000 is added until the weights converge, or the maximum limit 
is reached.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following hypothesis tests are available:
</p>

<ul>
<li>
<p> Type A: Test H0: all constraints with equalities ("=") 
active against HA: at least one inequality restriction ("&gt;") 
strictly true.
</p>
</li>
<li>
<p> Type B: Test H0: all constraints with inequalities ("&gt;") 
(including some equalities ("=")) active against HA: at least 
one restriction false (some equality constraints may be 
maintained).
</p>
</li>
<li>
<p> Type C: Test H0: at least one restriction false ("&lt;") 
against HA: all constraints strikty true ("&gt;"). This test is 
based on the intersection-union principle (Silvapulle and Sen, 
2005, chp 5.3). Note that, this test only makes sense in case 
of no equality constraints.
</p>
</li>
<li>
<p> Type global: equal to Type A but H0 contains additional 
equality constraints. This test is analogue to the global 
F-test in lm, where all coefficients but the intercept equal 0.
</p>
</li>
</ul>
<p>The null-distribution of hypothesis test Type C is based on a 
t-distribution (one-sided). Its power can be poor in case of many 
inequalty constraints. Its main role is to prevent wrong 
conclusions from significant results from hypothesis test Type A.
</p>
<p>The exact finite sample distributions of the non-robust F-, 
score- and LR-test statistics based on restricted OLS estimates 
and normally distributed errors, are a mixture of F-distributions 
under the null hypothesis (Wolak, 1987). In agreement with 
Silvapulle (1992), we found that the results based on these 
mixtures of F-distributions approximate the tail probabilities of 
the robust tests better than their asymptotic distributions. 
Therefore, all p-values for hypothesis test Type <code>"A"</code>, 
<code>"B"</code> and <code>"global"</code> are computed based on mixtures of 
F-distributions. 
</p>


<h3>Value</h3>

<p>An object of class conTest, for which a print is available. 
More specifically, it is a list with the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>CON</code></td>
<td>
<p>a list with useful information about the constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Amat</code></td>
<td>
<p>constraints matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bvec</code></td>
<td>
<p>vector of right-hand side elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meq</code></td>
<td>
<p>number of equality constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meq.alt</code></td>
<td>
<p>same as input neq.alt.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iact</code></td>
<td>
<p>number of active constraints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>same as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>same as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ts</code></td>
<td>
<p>test-statistic value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvalue</code></td>
<td>
<p>tail probability for <code>Ts</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.eqrestr</code></td>
<td>
<p>equality restricted regression coefficients. 
Only available for <code>type = "A"</code> and <code>type = "global"</code>, 
else <code>b.eqrestr = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.unrestr</code></td>
<td>
<p>unrestricted regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.restr</code></td>
<td>
<p>restricted regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b.restr.alt</code></td>
<td>
<p>restricted regression coefficients under HA 
if some equality constraints are maintained. Only available for 
<code>type = "B"</code> else <code>b.restr.alt = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>variance-covariance matrix of unrestricted model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2.org</code></td>
<td>
<p>unrestricted R-squared, not available for objects of class <code>conGLM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2.reduced</code></td>
<td>
<p>restricted R-squared, not available for objects of class <code>conGLM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot</code></td>
<td>
<p>same as input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.org</code></td>
<td>
<p>original model.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Leonard Vanbrabant and Yves Rosseel</p>


<h3>References</h3>

<p>Silvapulle, M. and Silvapulle, P. (1995). A score test against 
one-sided alternatives. <em>American statistical association</em>, 
<b>90</b>, 342–349.
</p>
<p>Silvapulle, M. (1996) Robust bounded influence tests against 
one-sided hypotheses in general parametric models. 
<em>Statistics and probability letters</em>, <b>31</b>, 45–50.
</p>
<p>Silvapulle, M.J. and Sen, P.K. (2005). <em>Constrained 
Statistical Inference</em>. Wiley, New York
</p>


<h3>See Also</h3>

 
<p>quadprog, 
<code>conTest</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## example 1:
# the data consist of ages (in months) at which an 
# infant starts to walk alone.

# prepare data
DATA1 &lt;- subset(ZelazoKolb1972, Group != "Control")

# fit unrestricted linear model
fit1.lm &lt;- lm(Age ~ -1 + Group, data = DATA1)

# the variable names can be used to impose constraints on
# the corresponding regression parameters.
coef(fit1.lm)

# constraint syntax: assuming that the walking 
# exercises would not have a negative effect of increasing the 
# mean age at which a child starts to walk. 
myConstraints1 &lt;- ' GroupActive  &lt; GroupPassive; 
                    GroupPassive &lt; GroupNo '

iht(fit1.lm, myConstraints1, test = "score")


# another way is to first fit the restricted model
fit.restr1 &lt;- restriktor(fit1.lm, constraints = myConstraints1)

iht(fit.restr1, test = "score")


# Or in matrix notation.
Amat1 &lt;- rbind(c(-1, 0,  1),
               c( 0, 1, -1))
myRhs1 &lt;- rep(0L, nrow(Amat1)) 
myNeq1 &lt;- 0

iht(fit1.lm, constraints = Amat1, test = "score", rhs = myRhs1, neq = myNeq1)


#########################
## Artificial examples ##
#########################
# generate data
n &lt;- 10
means &lt;- c(1,2,1,3)
nm &lt;- length(means)
group &lt;- as.factor(rep(1:nm, each = n))
y &lt;- rnorm(n * nm, rep(means, each = n))
DATA2 &lt;- data.frame(y, group)

# fit unrestricted linear model
fit2.lm &lt;- lm(y ~ -1 + group, data = DATA2)
coef(fit2.lm)

## example 2: increasing means
myConstraints2 &lt;- ' group1 &lt; group2 &lt; group3 &lt; group4 '

# compute F-test for hypothesis test Type A and compute the tail 
# probability based on the parametric bootstrap. We only generate 9 
# bootstrap samples in this example; in practice you may wish to 
# use a much higher number.
iht(fit2.lm, constraints = myConstraints2, type = "A", test = "score",
    boot = "parametric", R = 9)


# or fit restricted linear model
fit2.con &lt;- restriktor(fit2.lm, constraints = myConstraints2)

conTest(fit2.con, test = "score")


# increasing means in matrix notation.
Amat2 &lt;- rbind(c(-1, 1, 0, 0),
               c( 0,-1, 1, 0),
               c( 0, 0,-1, 1))
myRhs2 &lt;- rep(0L, nrow(Amat2)) 
myNeq2 &lt;- 0

iht(fit2.con, constraints = Amat2, rhs = myRhs2, neq = myNeq2, 
    type = "A", test = "score", boot = "parametric", R = 9)

## example 3:
# combination of equality and inequality constraints.
myConstraints3 &lt;- ' group1  = group2
                    group3  &lt; group4 '

iht(fit2.lm, constraints = myConstraints3, type = "B", test = "score", neq.alt = 1)

# fit resticted model and compute model-based bootstrapped 
# standard errors. We only generate 9 bootstrap samples in this 
# example; in practice you may wish to use a much higher number.
# Note that, a warning message may be thrown because the number of 
# bootstrap samples is too low.
fit3.con &lt;- restriktor(fit2.lm, constraints = myConstraints3, 
                       se = "boot.model.based", B = 9)
iht(fit3.con, type = "B", test = "score", neq.alt = 1)


## example 4:
# restriktor can also be used to define effects using the := operator 
# and impose constraints on them. For example, is the 
# average effect (AVE) larger than zero?
# generate data
n &lt;- 30
b0 &lt;- 10; b1 = 0.5; b2 = 1; b3 = 1.5
X &lt;- c(rep(c(0), n/2), rep(c(1), n/2))
set.seed(90) 
Z &lt;- rnorm(n, 16, 5)
y &lt;- b0 + b1*X + b2*Z + b3*X*Z + rnorm(n, 0, sd = 10) 
DATA3 = data.frame(cbind(y, X, Z))

# fit linear model with interaction
fit4.lm &lt;- lm(y ~ X*Z, data = DATA3)

# constraint syntax
myConstraints4 &lt;- ' AVE := X + 16.86137*X.Z; 
                    AVE &gt; 0 '

iht(fit4.lm, constraints = myConstraints4, test = "score")

# or
fit4.con &lt;- restriktor(fit4.lm, constraints = ' AVE := X + 16.86137*X.Z; 
                                                AVE &gt; 0 ')
iht(fit4.con, test = "score")
</code></pre>


</div>