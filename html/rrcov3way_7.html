<div class="container">

<table style="width: 100%;"><tr>
<td>cp_als</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Alternating Least Squares (ALS) for Candecomp/Parafac (CP)</h2>

<h3>Description</h3>

<p>Alternating Least Squares (ALS) algorithm with optional
constraints for the minimization of the Candecomp/Parafac (CP) loss
function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cp_als(
  X,
  n,
  m,
  p,
  ncomp,
  const = "none",
  start = "random",
  conv = 1e-06,
  maxit = 10000,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A three-way array or a matrix. If <code>X</code> is a matrix
(matricised threeway array), <code>n</code>, <code>m</code> and <code>p</code> must be
given and are the number of A-, B- and C-mode entities respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of A-mode entities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of B-mode entities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Number of C-mode entities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>Number of components to extract</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>Optional constraints for each mode. Can be a three element
character vector or a single character, one of <code>"none"</code> for no
constraints (default), <code>"orth"</code> for orthogonality constraints,
<code>"nonneg"</code> for nonnegativity constraints or
<code>"zerocor"</code> for zero correlation between the extracted factors.
For example, <code>const="orth"</code> means orthogonality constraints for
all modes, while <code>const=c("orth", "none", "none")</code> sets the
orthogonality constraint only for mode A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be
<code>"svd"</code> for starting point of the algorithm from SVD's,
<code>"random"</code> for random starting point (orthonormalized
component matrices or nonnegative matrices in case of nonnegativity
constraint), or a list containing user specified components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>Convergence criterion, default is <code>conv=1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Maximum number of iterations, default is <code>maxit=10000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Logical, provide trace output.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The result of the decomposition as a list with the following
elements:
</p>

<ul>
<li> <p><code>fit</code> Value of the loss function
</p>
</li>
<li> <p><code>fp</code> Fit value expressed as a percentage
</p>
</li>
<li> <p><code>ss</code> Sum of squares
</p>
</li>
<li> <p><code>A</code> Component matrix for the A-mode
</p>
</li>
<li> <p><code>B</code> Component matrix for the B-mode
</p>
</li>
<li> <p><code>C</code> Component matrix for the C-mode
</p>
</li>
<li> <p><code>iter</code> Number of iterations
</p>
</li>
<li> <p><code>tripcos</code> Minimal triple cosine between two components
across the three component matrices, used to inspect degeneracy
</p>
</li>
<li> <p><code>mintripcos</code> Minimal triple cosine during the iterative
algorithm observed at every 10 iterations, used to inspect degeneracy
</p>
</li>
<li> <p><code>ftiter</code> Matrix containing in each row the function value
and the minimal triple cosine at every 10 iterations
</p>
</li>
<li> <p><code>const</code> Optional constraints (same as the input parameter
<code>const</code>)
</p>
</li>
</ul>
<h3>Note</h3>

<p>The argument <code>const</code> should be a three element character vector.
Set <code>const[j]="none"</code> for unconstrained update in j-th mode weight
matrix (the default),
<code>const[j]="orth"</code> for orthogonal update in j-th mode weight matrix,
<code>const[j]="nonneg"</code> for non-negative constraint on j-th mode or
<code>const[j]="zerocor"</code> for zero correlation between the extracted
factors.
The default is unconstrained update for all modes.
</p>
<p>The loss function to be minimized is <code class="reqn">sum(k)|| X(k) - A D(k) B' ||^2</code>,
where <code class="reqn">D(k)</code> is a diagonal matrix holding the <code>k</code>-th row of
<code>C</code>.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Harshman, R.A. (1970). Foundations of Parafac procedure:
models and conditions for an "explanatory" multi-mode factor
analysis. <em>UCLA Working Papers in Phonetics</em>, 16: 1–84.
</p>
<p>Harshman, R. A., &amp; Lundy, M. E. (1994). PARAFAC: Parallel factor analysis.
Computational Statistics and Data Analysis, 18, 39–72.
</p>
<p>Lawson CL, Hanson RJ (1974). Solving Least Squares Problems.
Prentice Hall, Englewood Cliffs, NJ.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
## Example with the OECD data
 data(elind)
 dim(elind)

 res &lt;- cp_als(elind, ncomp=3)
 res$fp
 res$fp
 res$iter

 res &lt;- cp_als(elind, ncomp=3, const="nonneg")
 res$A

## End(Not run)
</code></pre>


</div>