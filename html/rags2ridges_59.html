<div class="container">

<table style="width: 100%;"><tr>
<td>pooledS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the pooled covariance or precision matrix estimate</h2>

<h3>Description</h3>

<p>Compute the pooled covariance or precision matrix estimate from a <code>list</code>
of covariance matrices or precision matrices.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pooledS(Slist, ns, subset = rep(TRUE, length(ns)), mle = TRUE)

pooledP(Plist, ns, subset = rep(TRUE, length(ns)), mle = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Slist</code></td>
<td>
<p>A <code>list</code> of length <code class="reqn">G</code> of <code>numeric</code> covariance
matrices of the same size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ns</code></td>
<td>
<p>A <code>numeric</code> vector for length <code class="reqn">G</code> giving the sample sizes
in the corresponding entries of <code>Slist</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p><code>logical</code> vector of the same length as <code>Slist</code> giving
the classes to pool. Default is all classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mle</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the (biased) MLE is given. If
<code>FALSE</code>, the biased corrected estimate is given. Default is
<code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Plist</code></td>
<td>
<p>A <code>list</code> of length <code class="reqn">G</code> of invertible <code>numeric</code>
precision matrices of the same size.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When <code>mle</code> is <code>FALSE</code> the given covariance/precision matrices is
assumed to have been computed using the denominator <code>ns[i] - 1</code>. Hence,
the sum of all <code>ns</code> minus <code class="reqn">G</code> is used a the denominator of the
pooled estimate. Conversely, when <code>mle</code> is <code>TRUE</code> the total sum of
the sample sizes <code>ns</code> is used as the denominator in the pooled estimate.
</p>
<p>The function <code>pooledP</code> is equivalent to a wrapper for <code>pooledS</code>.
That is, it inverts all the precision matrices in <code>Plist</code>, applies
<code>pooledS</code>, and inverts the resulting matrix.
</p>


<h3>Value</h3>

<p><code>pooledS</code> returns the pooled covariance matrix, that is a
<code>numeric</code> matrix with the same size as the elements of <code>Slist</code>.
Similarly, <code>pooledP</code> returns the pooled precision matrix, i.e. a
<code>numeric</code> matrix with the same size as the elements of <code>Plist</code>.
</p>


<h3>Author(s)</h3>

<p>Anders Ellern Bilgrau, Carel F.W. Peeters &lt;carel.peeters@wur.nl&gt;,
Wessel N. van Wieringen
</p>


<h3>Examples</h3>

<pre><code class="language-R">ns &lt;- c(4, 6, 8)
Slist &lt;- createS(ns, p = 6)

pooledS(Slist, ns)
pooledS(Slist, ns, mle = FALSE)

# Pool the first two classes only, leave out the remaning
pooledS(Slist, ns, subset = c(TRUE, TRUE, FALSE))
pooledS(Slist, ns, subset = ns &gt; 5) # Pool studies with sample size &gt; 5

# Pooled precision matrices
ns &lt;- c(7, 8, 9)
Plist &lt;- lapply(createS(ns, p = 6), solve)
pooledS(Plist, ns)

</code></pre>


</div>