<div class="container">

<table style="width: 100%;"><tr>
<td>retel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularized exponentially tilted empirical likelihood</h2>

<h3>Description</h3>

<p>Computes regularized exponentially tilted empirical likelihood.
</p>


<h3>Usage</h3>

<pre><code class="language-R">retel(fn, x, par, mu, Sigma, tau, type = "full", opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>An estimating function that takes the data <code>x</code> and parameter value
<code>par</code> as its arguments, returning a numeric matrix. Each row is the return
value from the corresponding row in <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric matrix, or an object that can be coerced to a numeric
matrix. Each row corresponds to an observation. The number of rows must be
greater than the number of columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>A numeric vector of parameter values to be tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>A numeric vector of parameters for regularization. See 'Details' for more
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigma</code></td>
<td>
<p>A numeric matrix, or an object that can be coerced to a numeric matrix,
of parameters for regularization. See 'Details' for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>A single numeric parameter for regularization. See 'Details' for more
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A single character indicating the type of regularized exponentially tilted
empirical likelihood. It must be either <code>"full"</code> or <code>"reduced"</code>. Defaults
to <code>"full"</code>.  See 'Details' for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>An optional list with optimization options for <code>nloptr()</code>.
Defaults to <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">\{\bm{X}_i\}_{i = 1}^n</code> denote independent <code class="reqn">d_x</code>-dimensional
observations from a complete probability space
<code class="reqn">{(\mathcal{X}, \mathcal{F}, P)}</code> satisfying the moment condition:
</p>
<p style="text-align: center;"><code class="reqn">\textnormal{E}_P[\bm{g}(\bm{X}_i, \bm{\theta})] = \bm{0},</code>
</p>

<p>where <code class="reqn">{\bm{g}}:
  {\mathbb{R}^{d_x} \times \Theta} \mapsto {\mathbb{R}^p}</code> is an estimating
function with the true parameter value
<code class="reqn">{\bm{\theta}_0} \in {\Theta} \subset \mathbb{R}^p</code>.
</p>
<p>For a given parameter value <code class="reqn">\bm{\theta}</code>, regularized exponentially
tilted empirical likelihood solves the following optimization problem:
</p>
<p style="text-align: center;"><code class="reqn">
    \min_{\bm{\lambda} \in \mathbb{R}^p}
      \left\{
        d_n\left(\bm{\theta}, \bm{\lambda}\right) +
        p_n\left(\bm{\theta}, \bm{\lambda}\right)
      \right\},
  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
    d_n\left(\bm{\theta}, \bm{\lambda}\right) =
    \frac{1}{n + \tau_n}
    \sum_{i = 1}^n \exp
      \left(
        \bm{\lambda}^\top \bm{g}\left(\bm{X}_i, \bm{\theta}\right)
      \right)
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    p_n\left(\bm{\theta}, \bm{\lambda}\right) =
    \frac{\tau_n}{n + \tau_n}
    \exp
      \left(
        \bm{\lambda}^\top\bm{\mu}_{n, \bm{\theta}} +
        \frac{1}{2}
        \bm{\lambda}^\top\bm{\Sigma}_{n, \bm{\theta}}\bm{\lambda}
      \right).
  </code>
</p>

<p>Here, <code class="reqn">{\tau_n} &gt; {0}</code>, <code class="reqn">\bm{\mu}_{n, \bm{\theta}}</code>,
<code class="reqn">\bm{\Sigma}_{n, \bm{\theta}}</code> are all tuning parameters that control
the strength of <code class="reqn">{p_n(\bm{\theta}, \bm{\lambda})}</code> as a penalty.
</p>
<p>Once we have determined the solution <code class="reqn">{\bm{\lambda}_{RET}}</code>, we define
the likelihood ratio function as follows:
</p>
<p style="text-align: center;"><code class="reqn">
    R_{RET}\left(\bm{\theta}\right) =
    \left(
      \frac{n + \tau_n}{\tau_n}p_c\left(\bm{\theta}\right)\right)
      \prod_{i = 1}^n \left(n + \tau_n\right)p_i\left(\bm{\theta}
    \right),
  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
    p_i\left(\bm{\theta}\right) =
    \frac{\exp
      \left(
        {\bm{\lambda}_{RET}}^\top\bm{g}\left(\bm{X}_i, \bm{\theta}\right)
      \right)
    }{c_n\left(\bm{\theta}, \bm{\lambda}_{RET}\right)
    } \quad \left(i = 1, \dots, n\right),\quad
    p_c\left(\bm{\theta}\right) =
    \frac{p_n
      \left(\bm{\theta}, \bm{\lambda}_{RET}\right)
    }{c_n\left(\bm{\theta}, \bm{\lambda}_{RET}\right)
    },
  </code>
</p>

<p>and
<code class="reqn">
    c_n\left(\bm{\theta}, \bm{\lambda}_{RET}\right) =
    d_n\left(\bm{\theta}, \bm{\lambda}_{RET}\right) +
    p_n\left(\bm{\theta}, \bm{\lambda}_{RET}\right)
  </code>. The reduced version of the likelihood ratio function is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    \widetilde{R}_{RET}\left(\bm{\theta}\right) =
    \prod_{i = 1}^n \left(n + \tau_n\right)p_i\left(\bm{\theta}\right).
  </code>
</p>

<p>See the references below for more details on derivation, interpretation,
and properties.
</p>


<h3>Value</h3>

<p>A single numeric value representing the log-likelihood ratio. It contains
the optimization results as the attribute <code>optim</code>.
</p>


<h3>References</h3>

<p>Kim E, MacEachern SN, Peruggia M (2023).
"Regularized Exponentially Tilted Empirical Likelihood for Bayesian
Inference." <a href="https://doi.org/10.48550/arXiv.2312.17015">doi:10.48550/arXiv.2312.17015</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate data
set.seed(63456)
x &lt;- rnorm(100)

# Define an estimating function (ex. mean)
fn &lt;- function(x, par) {
  x - par
}

# Set parameter value
par &lt;- 0

# Set regularization parameters
mu &lt;- 0
Sigma &lt;- 1
tau &lt;- 1

# Call the retel function
retel(fn, x, par, mu, Sigma, tau)
</code></pre>


</div>