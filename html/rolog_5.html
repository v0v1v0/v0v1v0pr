<div class="container">

<table style="width: 100%;"><tr>
<td>once</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Invoke a query once</h2>

<h3>Description</h3>

<p>Invoke a query once
</p>


<h3>Usage</h3>

<pre><code class="language-R">once(
  query = call("member", expression(X), list(quote(a), "b", 3L, 4, TRUE, expression(Y))),
  options = list(portray = FALSE),
  env = globalenv()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>query</code></td>
<td>
<p>an R call. The R call consists of symbols, integers and real numbers,
character strings, boolean values, expressions, lists, and other calls.
Vectors of booleans, integers, floating point numbers, and strings with
length <em>N</em> &gt; 1 are translated to prolog compounds !/N, %/N, #/N and $$/N,
respectively. The names can be modified with the options below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>This is a list of options controlling translation from and to prolog.
</p>

<ul>
<li> <p><em>boolvec</em> (see option rolog.boolvec, default is !) is the name of the
prolog compound for vectors of booleans.
</p>
</li>
<li> <p><em>intvec</em>, <em>realvec</em>, <em>charvec</em> define the compound names for vectors of
integers, doubles and strings, respectively (defaults are %, # and $$).
</p>
</li>
<li>
<p> If <em>scalar</em> is <code>TRUE</code> (default), vectors of length 1 are translated to
scalar prolog elements. If <em>scalar</em> is <code>FALSE</code>, vectors of length 1 are
also translated to compounds.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>The R environment in which the query is run (default: globalenv()). This is
mostly relevant for r_eval/2.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If the query fails, <code>FALSE</code> is returned. If the query succeeds, a
(possibly empty) list is returned that includes the bindings required to
satisfy the query.
</p>


<h3>See Also</h3>

<p><code>findall()</code>
for querying all solutions
</p>
<p><code>query()</code>, <code>submit()</code>, and <code>clear()</code> for fine-grained control over
non-deterministic queries
</p>
<p><code>rolog_options()</code>
for options controlling R to prolog translation
</p>


<h3>Examples</h3>

<pre><code class="language-R"># This query returns FALSE
once(call("member", 1, list(quote(a), quote(b), quote(c))))

# This query returns an empty list meaning yes, it works
once(call("member", 3, list(1, 2, 3)))

# This query returns a list stating that it works if X = 1
once(call("member", 1, list(quote(a), expression(X))))

# The same query using simplified syntax
q = quote(member(1, ""[a, .X]))
once(as.rolog(q))

# This query returns a list stating that X = 1 and Z = expression(Y)
once(call("=", list(expression(X), expression(Y)), list(1, expression(Z))))

# This works for X = [1 | _]; i.e. something like [|](1, expression(_6330))
once(call("member", 1, expression(X)))

# This returns S = '1.0' (scalar)
once(call("format", call("string", expression(S)), "~w", list(1)), options=list(scalar=TRUE))
  
# This returns S = '#(1.0)' (vector), because the 1 is translated to #(1.0). 
# To prevent "~w" from being translated to $$("~w"), it is given as an atom.
once(call("format", call("string", expression(S)), as.symbol("~w"), list(1)), 
  options=list(scalar=FALSE))

</code></pre>


</div>