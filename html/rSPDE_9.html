<div class="container">

<table style="width: 100%;"><tr>
<td>fractional.operators</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rational approximations of fractional operators</h2>

<h3>Description</h3>

<p><code>fractional.operators</code> is used for computing an approximation,
which can be used for inference and simulation, of the fractional SPDE
</p>
<p style="text-align: center;"><code class="reqn">L^\beta (\tau u(s)) = W.</code>
</p>

<p>Here <code class="reqn">L</code> is a differential operator, <code class="reqn">\beta&gt;0</code> is
the fractional power, <code class="reqn">\tau</code> is a positive scalar or vector that
scales the variance of the solution <code class="reqn">u</code>, and <code class="reqn">W</code> is white noise.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fractional.operators(L, beta, C, scale.factor, m = 1, tau = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>A finite element discretization of the operator <code class="reqn">L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The positive fractional power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>The mass matrix of the finite element discretization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.factor</code></td>
<td>
<p>A constant <code class="reqn">c</code> is a lower bound for the the smallest
eigenvalue of the non-discretized operator <code class="reqn">L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.
Higer values gives a more accurate approximation, which are more
computationally expensive to use for inference. Currently, the largest value
of m that is implemented is 4.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The constant or vector that scales the variance of the solution.
The default value is 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The approximation is based on a rational approximation of
the fractional operator, resulting in an
approximate model on the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>

<p>where <code class="reqn">P_j = p_j(L)</code> are non-fractional operators defined in terms of
polynomials <code class="reqn">p_j</code> for <code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given by
<code>m</code> and the order of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code>
where <code class="reqn">m_\beta</code> is the integer part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and
<code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code> and <code class="reqn">Q = P_l^T C^{-1} P_l</code>.
Note that the matrices <code class="reqn">P_r</code> and <code class="reqn">Q</code> may be be ill-conditioned
for <code class="reqn">m&gt;1</code>. In this case, the methods in <code>operator.operations()</code>
should be used for operations involving the matrices, since these methods
are more numerically stable.
</p>


<h3>Value</h3>

<p><code>fractional.operators</code> returns an object of class "rSPDEobj".
This object contains the following quantities:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Pl</code></td>
<td>
<p>The operator <code class="reqn">P_l</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pr</code></td>
<td>
<p>The operator <code class="reqn">P_r</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The order of the rational approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The fractional power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>The matrix <code>t(Pl) %*% solve(C,Pl)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pl.factors</code></td>
<td>
<p>List with elements that can be used to assemble <code class="reqn">P_l</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Pr.factors</code></td>
<td>
<p>List with elements that can be used to assemble <code class="reqn">P_r</code>.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>matern.operators()</code>, <code>spde.matern.operators()</code>,
<code>matern.operators()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compute rational approximation of a Gaussian process with a
# Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
tau &lt;- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *
  (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))
op &lt;- fractional.operators(
  L = fem$G + kappa^2 * fem$C, beta = (nu + 1 / 2) / 2,
  C = fem$C, scale.factor = kappa^2, tau = tau
)

v &lt;- t(rSPDE.A1d(x, 0.5))
c.approx &lt;- Sigma.mult(op, v)

# plot the result and compare with the true Matern covariance
plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c.approx, col = 2)

</code></pre>


</div>