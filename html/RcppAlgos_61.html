<div class="container">

<table style="width: 100%;"><tr>
<td>divisorsSieve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate Complete Factorization for Numbers in a Range
</h2>

<h3>Description</h3>

<p>Sieve that generates the complete factorization of all numbers between <code>bound1</code> and <code>bound2</code> (if supplied) or all numbers up to <code>bound1</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">divisorsSieve(bound1, bound2 = NULL, namedList = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namedList</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named list is returned. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is useful when many complete factorizations are needed. Instead of generating the complete factorization on the fly, one can reference the indices/names of the generated list.
</p>
<p>This algorithm benefits greatly from the fast integer division library 'libdivide'. The following is from <a href="https://libdivide.com/">https://libdivide.com/</a>:
</p>
<ul><li>
<p>“<em>libdivide allows you to replace expensive integer divides with comparatively cheap multiplication and bitshifts. Compilers usually do this, but only when the divisor is known at compile time. libdivide allows you to take advantage of it at runtime. The result is that integer division can become faster - a lot faster.</em>”</p>
</li></ul>
<h3>Value</h3>

<p>Returns a named/unnamed list of integer vectors if <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, or a list of numeric vectors otherwise.
</p>


<h3>Note</h3>

<p>The maximum value for either of the bounds is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Divisor">Divisor</a>
</p>
</li>
<li>
<p><a href="https://ridiculousfish.com/">ridiculousfish (author of libdivide)</a>
</p>
</li>
<li>
<p><a href="https://github.com/ridiculousfish/libdivide">github.com/ridiculousfish/libdivide</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>divisorsRcpp</code>, <code>primeFactorizeSieve</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate some random data
set.seed(33550336)
mySamp &lt;- sample(10^5, 5*10^4)

## Generate complete factorizations up
## to 10^5 (max element from mySamp)
system.time(allFacs &lt;- divisorsSieve(10^5))

## Use generated complete factorization for further
## analysis by accessing the index of allFacs
for (s in mySamp) {
    myFac &lt;- allFacs[[s]]
    ## Continue algorithm
}

## Generating complete factorizations over
## a range is efficient as well
system.time(divisorsSieve(10^12, 10^12 + 10^5))

## Use nThreads for improved efficiency
system.time(divisorsSieve(10^12, 10^12 + 10^5, nThreads = 2))

## Set 'namedList' to TRUE to return a named list
divisorsSieve(27, 30, namedList = TRUE)

## Using nThreads
system.time(divisorsSieve(1e5, 2e5, nThreads = 2))
</code></pre>


</div>