<div class="container">

<table style="width: 100%;"><tr>
<td>kStepEstimator</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function for the computation of k-step estimates</h2>

<h3>Description</h3>

<p>Function for the computation of k-step estimates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kStepEstimator(x, IC, start = NULL, steps = 1L,
      useLast = getRobAStBaseOption("kStepUseLast"),
      withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
      IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
      withICList = getRobAStBaseOption("withICList"),
      withPICList = getRobAStBaseOption("withPICList"),
      na.rm = TRUE, startArgList = NULL, ...,
      withLogScale = TRUE, withEvalAsVar = TRUE,
      withMakeIC = FALSE, E.argList = NULL, diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> sample </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC</code></td>
<td>
<p> object of class <code>"IC"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p> initial estimate (for full parameter,i.e. in dimension <code class="reqn">k</code> respective
joint length of main and nuisance part of the parameter):
either a numerical value, or an object of class <code>"Estimate"</code> or
a function producing either a numerical value, or an object of class <code>"Estimate"</code>
when evaluated at <code>x,...</code>; if missing or <code>NULL</code>, we use slot <code>startPar</code>
of the L2family <code>L2Fam</code> from within <code>IC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p> integer: number of steps </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useLast</code></td>
<td>
<p> which parameter estimate (initial estimate or
k-step estimate) shall be used to fill the slots <code>pIC</code>,
<code>asvar</code> and <code>asbias</code> of the return value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withUpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC.UpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startArgList</code></td>
<td>
<p>a list of arguments to be given to argument <code>start</code> if the latter
is a function; this list by default already starts with two unnamed items,
the sample <code>x</code>, and the model <code>eval(CallL2Fam(IC))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withPICList</code></td>
<td>
<p>logical: shall slot <code>pICList</code> of return value
be filled?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withICList</code></td>
<td>
<p>logical: shall slot <code>ICList</code> of return value
be filled?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional parameters </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withLogScale</code></td>
<td>
<p>logical; if <code>TRUE</code>, a scale component (if existing
and found with name <code>scalename</code>) is computed on log-scale and
backtransformed afterwards (default). This avoids crossing 0. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withEvalAsVar</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), tells R to evaluate
the asymptotic variance or just to produces a call to do so.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.argList</code></td>
<td>
<p><code>NULL</code> (default) or a named list of arguments to be passed
to calls to <code>E</code> from <code>kStepEstimator</code>; potential clashes with
arguments of the same name in <code>...</code> are resolved by inserting
the items of argument list <code>E.argList</code> as named items to the argument
lists, so in case of collisions the item of <code>E.argList</code> overwrites the
existing one from <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as an attribute <code>diagnostic</code> of the return value
of <code>kStepEstimator</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given an initial estimation <code>start</code>, a sample <code>x</code> 
and an influence curve <code>IC</code> the corresponding k-step
estimator is computed.
</p>
<p>The default value of argument <code>useLast</code> is set by the
global option <code>kStepUseLast</code> which by default is set to 
<code>FALSE</code>. In case of general models <code>useLast</code> 
remains unchanged during the computations. However, if 
slot <code>CallL2Fam</code> of <code>IC</code> generates an object of 
class <code>"L2GroupParamFamily"</code> the value of <code>useLast</code> 
is changed to <code>TRUE</code>.
Explicitly setting <code>useLast</code> to <code>TRUE</code> should
be done with care as in this situation the influence curve
is re-computed using the value of the one-step estimate
which may take quite a long time depending on the model.
</p>
<p>If <code>useLast</code> is set to <code>TRUE</code> and slot <code>modifyIC</code> 
of <code>IC</code> is filled with some function (which can be 
used to re-compute the IC for a different parameter), the 
computation of <code>asvar</code>, <code>asbias</code> and <code>IC</code> is 
based on the k-step estimate.
</p>
<p>Timings for the several substeps are available as attribute
<code>timings</code> of the return value.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code>showDiagnostic</code> and
<code>getDiagnostic</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br>
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code>IC-class</code>, <code>kStepEstimate-class</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">## don't run to reduce check time on CRAN

if(require(ROptEst)){
## 1. generate a contaminated sample
ind &lt;- rbinom(100, size=1, prob=0.05)
x &lt;- rnorm(100, mean=0, sd=(1-ind) + ind*9)

## 2. Kolmogorov(-Smirnov) minimum distance estimator
(est0 &lt;- MDEstimator(x=x, NormLocationScaleFamily()))

## 3. k-step estimation: radius known
N1 &lt;- NormLocationScaleFamily(mean=estimate(est0)["mean"], sd=estimate(est0)["sd"])
N1.Rob &lt;- InfRobModel(center = N1, neighbor = ContNeighborhood(radius = 0.5))
IC1 &lt;- optIC(model = N1.Rob, risk = asMSE())
(est1 &lt;- kStepEstimator(x, IC1, est0, steps = 3, withPIC = TRUE))
estimate(est1)
ksteps(est1)
pICList(est1)
start(est1)
attr(est1,"timings")

## a transformed model
tfct &lt;- function(x){
    nms0 &lt;- c("mean","sd")
    nms  &lt;- "comb"
    fval0 &lt;- x[1]+2*x[2]
    names(fval0) &lt;- nms
    mat0 &lt;- matrix(c(1,2), nrow = 1, dimnames = list(nms,nms0))
    return(list(fval = fval0, mat = mat0))
}

N1.traf &lt;- N1; trafo(N1.traf) &lt;- tfct
N1R.traf &lt;- N1.Rob; trafo(N1R.traf) &lt;- tfct
IC1.traf &lt;- optIC(model = N1R.traf, risk = asMSE())
(est0.traf &lt;- MDEstimator(x, N1.traf))
(est1.traf &lt;- kStepEstimator(x, IC1.traf, est0, steps = 3,
                withIC = TRUE, withPIC = TRUE, withUpdateInKer = FALSE))
(est1a.traf &lt;- kStepEstimator(x, IC1.traf, est0, steps = 3,
                withIC = TRUE, withPIC = TRUE, withUpdateInKer = TRUE))
estimate(est1.traf)
ksteps(est1.traf)
pICList(est1.traf)
startval(est1.traf)

untransformed.estimate(est1.traf)
uksteps(est1.traf)
ICList(est1.traf)
ustartval(est1.traf)

estimate(est1a.traf)
ksteps(est1a.traf)
pICList(est1a.traf)
startval(est1a.traf)

untransformed.estimate(est1a.traf)
uksteps(est1a.traf)
ICList(est1a.traf)
ustartval(est1a.traf)
}

</code></pre>


</div>