<div class="container">

<table style="width: 100%;"><tr>
<td>knitRev</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Knitr Engine for RevBayes</h2>

<h3>Description</h3>

<p>Creates a knitr engine for evaluating RevBayes code
</p>


<h3>Usage</h3>

<pre><code class="language-R">knitRev()
</code></pre>


<h3>Details</h3>

<p>To use RevBayes in a knitr document, type 'library(Revticulate)' followed by 'knitRev()'
on the next line in the initialization block. The language header for RevBayes chunks is 'rb'.
</p>
<p>The RevBayes knitr engine is built around doRev(), allowing history to persist between chunks.
If a variable 'x &lt;- 10' is defined in one RevBayes chunk, 'x' can then be accessed in a later RevBayes chunk.
Additionally, it could be accessed via doRev() in an R chunk, allowing for quick R analysis of RevBayes variables.
</p>
<p>On top of the standard knitr chunk options, the rb engine provides two extras: rb_eval, and coerce.
</p>
<p>If rb_eval = FALSE, the code in the chunk will be saved to the .Revhistory file, but will not be submitted to RevBayes. This
option is useful for code chunks containing the final loop of an mcmc, which could be saved to an external file
with saveRev() and ran in a terminal with callRevFromTerminal().
</p>
<p>If coerce = TRUE, coerceRev() will attempt to convert RevBayes output into equivalent R formatted objects. The default value
for both coerce and rb_eval is TRUE.
</p>


<h3>Value</h3>

<p>No return. Initiates knitr engine for RevBayes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
```{r setup, include=FALSE}
     knitr::opts_chunk$set(echo = TRUE)
     library(Revticulate)
     knitRev()
```

```{rb rb_eval=TRUE, coerce=FALSE}

x &lt;- simTree(32)

```

```{r}

x &lt;- doRev('x')
plot(x)

```

## End(Not run)


</code></pre>


</div>