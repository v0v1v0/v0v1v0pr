<div class="container">

<table style="width: 100%;"><tr>
<td>peer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct a PEER regression term in a <code>pfr</code> formula</h2>

<h3>Description</h3>

<p>Defines a term <code class="reqn">\int_{T}\beta(t)X_i(t)dt</code> for inclusion in a
<code>{pfr}</code> formula, where <code class="reqn">\beta(t)</code> is estimated with
structured penalties (Randolph et al., 2012).
</p>


<h3>Usage</h3>

<pre><code class="language-R">peer(
  X,
  argvals = NULL,
  pentype = "RIDGE",
  Q = NULL,
  phia = 10^3,
  L = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>functional predictors, typically expressed as an <code>N</code> by <code>J</code> matrix,
where <code>N</code> is the number of columns and <code>J</code> is the number of
evaluation points. May include missing/sparse functions, which are
indicated by <code>NA</code> values. Alternatively, can be an object of class
<code>"fd"</code>; see <code>[fda]{fd}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>indices of evaluation of <code>X</code>, i.e. <code class="reqn">(t_{i1},.,t_{iJ})</code> for
subject <code class="reqn">i</code>. May be entered as either a length-<code>J</code> vector, or as
an <code>N</code> by <code>J</code> matrix. Indices may be unequally spaced. Entering
as a matrix allows for different observations times for each subject. If
<code>NULL</code>, defaults to an equally-spaced grid between 0 or 1 (or within
<code>X$basis$rangeval</code> if <code>X</code> is a <code>fd</code> object.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pentype</code></td>
<td>
<p>the type of penalty to apply, one of <code>"RIDGE"</code>, <code>"D"</code>,
<code>"DECOMP"</code>, or <code>"USER"</code>; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>matrix <code class="reqn">Q</code> used for <code>pentype="DECOMP"</code>; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phia</code></td>
<td>
<p>scalar <code class="reqn">a</code> used for <code>pentype="DECOMP"</code>; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>user-supplied penalty matrix for <code>pentype="USER"</code>; see
Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to be passed to <code>lf</code> (and then
possibly <code>s</code>). Arguments processed by <code>lf</code> include, for example,
<code>integration</code> for specifying the method of numerical integration.
Arguments processed by <code>s</code>
include information related to basis and penalization, such as <code>m</code>
for specifying the order of the difference penalty; See Details.
<code>xt</code>-argument is not allowed for <code>peer</code>-terms and will cause
an error.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>peer</code> is a wrapper for <code>{lf}</code>, which defines linear
functional predictors for any type of basis. It simply calls <code>lf</code>
with the appropriate options for the <code>peer</code> basis and penalty construction.
The type of penalty is determined by the <code>pentype</code> argument. There
are four types of penalties available:
</p>

<ol>
<li> <p><code>pentype=="RIDGE"</code> for a ridge penalty, the default
</p>
</li>
<li> <p><code>pentype=="D"</code> for a difference penalty. The order of the
difference penalty may be specified by supplying an <code>m</code> argument
(default is 2).
</p>
</li>
<li> <p><code>pentype=="DECOMP"</code> for a decomposition-based penalty,
<code class="reqn">bP_Q + a(I-P_Q)</code>, where <code class="reqn">P_Q = Q^t(QQ^t)^{-1}Q</code>. The <code class="reqn">Q</code>
matrix must be specified by <code>Q</code>, and the scalar <code class="reqn">a</code> by
<code>phia</code>. The number of columns of <code>Q</code> must be equal to the
length of the data. Each row represents a basis function where the
functional predictor is expected to lie, according to prior belief.
</p>
</li>
<li> <p><code>pentype=="USER"</code> for a user-specified penalty matrix,
supplied by the <code>L</code> argument.
</p>
</li>
</ol>
<p>The original stand-alone implementation by Madan Gopal Kundu is available in
<code>{peer_old}</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Gellar <a href="mailto:JGellar@mathematica-mpr.com">JGellar@mathematica-mpr.com</a> and
Madan Gopal Kundu <a href="mailto:mgkundu@iupui.edu">mgkundu@iupui.edu</a>
</p>


<h3>References</h3>

<p>Randolph, T. W., Harezlak, J, and Feng, Z. (2012). Structured penalties for
functional linear models - partially empirical eigenvectors for regression.
<em>Electronic Journal of Statistics</em>, 6, 323-353.
</p>
<p>Kundu, M. G., Harezlak, J., and Randolph, T. W. (2012). Longitudinal
functional models with structured penalties (arXiv:1211.4763 [stat.AP]).
</p>


<h3>See Also</h3>

<p><code>{pfr}</code>, <code>{.smooth.spec}</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 
#------------------------------------------------------------------------
# Example 1: Estimation with D2 penalty
#------------------------------------------------------------------------

data(DTI)
DTI = DTI[which(DTI$case == 1),]
fit.D2 = pfr(pasat ~ peer(cca, pentype="D"), data=DTI)
plot(fit.D2)

#------------------------------------------------------------------------
# Example 2: Estimation with structured penalty (need structural
#            information about regression function or predictor function)
#------------------------------------------------------------------------

data(PEER.Sim)
data(Q)
PEER.Sim1&lt;- subset(PEER.Sim, t==0)

# Setting k to max possible value
fit.decomp &lt;- pfr(Y ~ peer(W, pentype="Decomp", Q=Q, k=99), data=PEER.Sim1)
plot(fit.decomp)

## End(Not run)


</code></pre>


</div>