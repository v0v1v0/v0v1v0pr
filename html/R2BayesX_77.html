<div class="container">

<table style="width: 100%;"><tr>
<td>sliceplot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Plot Slices of Bivariate Functions 
</h2>

<h3>Description</h3>

<p>This function plots slices from user defined values of bivariate surfaces.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sliceplot(x, y = NULL, z = NULL, view = 1, c.select = NULL,
  values = NULL, probs = c(0.1, 0.5, 0.9), grid = 100,
  legend = TRUE, pos = "topright", digits = 2, data = NULL,
  rawdata = FALSE, type = "interp", linear = FALSE,
  extrap = FALSE, k = 40, rug = TRUE, rug.col = NULL,
  jitter = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect, typically 
the structure for bivariate functions returned within <code>bayesx</code> and 
<code>read.bayesx.output</code> model term objects is used, also see 
<code>fitted.bayesx</code>. Another possibility is to specify the plot via a <code>formula</code>, 
e.g. for simple plotting of bivariate surfaces <code>z ~ x + y</code>, also see the example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>if <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>if <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors, <code>z</code> defines the surface given by <code class="reqn">z = f(x, y)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>view</code></td>
<td>
<p>which variable should be used for the x-axis of the plot, the other variable will be
used to compute the slices. May also be a <code>character</code> with the name of the corresponding
variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.select</code></td>
<td>
<p><code>integer</code>, selects the column that is used in the resulting matrix to be
used as the <code>z</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>the values of the <code>x</code> or <code>y</code> variable that should be used for computing
the slices, if set to <code>NULL</code>, slices will be constructed according to the quantiles, see
also argument <code>probs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1] to be used within function
<code>quantile</code> to compute the <code>values</code> for plotting the slices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>the grid size of the surface where the slices are generated from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>if set to <code>TRUE</code>, a legend with the <code>values</code> that where used for slicing
will be added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos</code></td>
<td>
<p>the position of the legend, see also function <code>legend</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>the decimal place the legend values should be rounded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>if <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rawdata</code></td>
<td>
<p>if set to <code>TRUE</code>, the data will not be interpolated, only raw data will be
used. This is useful when displaying data on a regular grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character. Which type of interpolation metjod should be used. The default is
<code>type = "interp"</code>, see function <code>interp</code>. The two other options are
<code>type = "mba"</code>, which calls function <code>mba.surf</code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear</code></td>
<td>
<p>logical. Should linear interpolation be used withing function
<code>interp</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrap</code></td>
<td>
<p>logical. Should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>integer. The number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug</code></td>
<td>
<p>add a <code>rug</code> to the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p>if set to <code>TRUE</code> a <code>jitter</code>ed 
<code>rug</code> plot is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rug.col</code></td>
<td>
<p>specify the color of the rug representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters passed to <code>matplot</code> and <code>legend</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Similar to function <code>plot3d</code>, this function first applies bivariate interpolation
on a regular <code>grid</code>, afterwards the slices are computed from the resulting surface. 
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code>plot.bayesx</code>, <code>bayesx</code>, <code>read.bayesx.output</code>,
<code>fitted.bayesx</code>, <code>plot3d</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate some data
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## response
dat$y &lt;- with(dat, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: 
## estimate model
b &lt;- bayesx(y ~ sx(z, w, bs = "te", knots = 5), data = dat, method = "REML")
summary(b)

## plot estimated effect
plot(b, term = "sx(z,w)", sliceplot = TRUE)
plot(b, term = "sx(z,w)", sliceplot = TRUE, view = 2)
plot(b, term = "sx(z,w)", sliceplot = TRUE, view = "w")
plot(b, term = "sx(z,w)", sliceplot = TRUE, c.select = 4)
plot(b, term = "sx(z,w)", sliceplot = TRUE, c.select = 6)
plot(b, term = "sx(z,w)", sliceplot = TRUE, probs = seq(0, 1, length = 10))

## End(Not run)

## another variation
dat$f1 &lt;- with(dat, sin(z) * cos(w))
sliceplot(cbind(z = dat$z, w = dat$w, f1 = dat$f1))

## same with formula 
sliceplot(sin(z) * cos(w) ~ z + w, ylab = "f(z)", data = dat)

## compare with plot3d()
plot3d(sin(z) * 1.5 * w ~ z + w, zlab = "f(z,w)", data = dat)
sliceplot(sin(z) * 1.5 * w ~ z + w, ylab = "f(z)", data = dat)
sliceplot(sin(z) * 1.5 * w ~ z + w, view = 2, ylab = "f(z)", data = dat)
</code></pre>


</div>