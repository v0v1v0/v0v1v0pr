<div class="container">

<table style="width: 100%;"><tr>
<td>ccd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate central-composite designs and associated building blocks</h2>

<h3>Description</h3>

<p>These functions generate central-composite designs, or building blocks thereof.
They allow for flexible choices of replications, aliasing of predictors and fractional blocks, and choices of axis or ‘star’ points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cube(basis, generators, n0 = 4, reps = 1, coding, randomize = TRUE, 
    blockgen, bid = 1, inscribed = FALSE)
star(basis, n0 = 4, alpha = "orthogonal", reps = 1, randomize = TRUE)
dupe(design, randomize = TRUE, coding)
foldover(basis, variables, bid, randomize = TRUE)
ccd(basis, generators, blocks = "Block", n0 = 4, alpha = "orthogonal", 
    wbreps = 1, bbreps = 1, randomize = TRUE, inscribed = FALSE, 
    coding, oneblock = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>basis</code></td>
<td>
<p>In <code>cube</code> and <code>ccd</code>, a formula, or an integer giving the number of variables.  If the formula has a left-hand side, the variables named there are appended to the design and initialized to <code>NA</code>. 
In <code>star</code>, <code>dupe</code>, and <code>foldover</code>, <code>basis</code> is a <code>coded.data</code> object to use as a reference.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>generators</code></td>
<td>
<p>Optional formula or list of formulas to generate aliased variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n0</code></td>
<td>
<p>Integer giving the number of center points. In <code>ccd</code>, this can be a vector of     
two numbers for the numbers of center points in the cube blocks and the star blocks, 
respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reps</code></td>
<td>
<p>Integer number of replications of the cube or the star. (This does <em>not</em> create replicate blocks; use <code>djoin</code> to do that.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coding</code></td>
<td>
<p>List of coding formulas for the design variables (those in <code>basis</code> and <code>generators</code>).  In <code>dupe</code>, <code>coding</code> may be used to change the coding formulas, e.g. in a situation where we want to use the same design as before but center it elsewhere.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>randomize</code></td>
<td>
<p>Logical value determining whether or not to randomize the design.  In <code>ccd</code>, each block is randomized separately.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blockgen</code></td>
<td>
<p>A formula, string, or list thereof. Each element is evaluated, and the distinct combinations define fractional blocks for the design. Unlike <code>ccd</code>, <code>cube</code> returns only one of these blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bid</code></td>
<td>
<p>(For block ID.) An integer index (from 1 to number of blocks) of the fractional block to return. The indexes are defined by the standard ordering of the block generators; e.g. if <code>blockgen</code> is of length 2, the <code>bid</code> values of (1, 2, 3, 4) correspond to generated levels of <code>(--, +-, -+, ++)</code> respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inscribed</code></td>
<td>
<p>Logical value; if <code>FALSE</code>, the cube points are at +/- 1 in each variable.  If <code>TRUE</code>, the entire desgn is scaled down so that the axis points are at +/- 1 and the cube points are at interior positions.  In <code>cube</code> only, <code>inscribed</code> may be given a numeric value: use the value of <code>alpha</code> anticipated when axis points are added; or use ‘<span class="samp">⁠inscribed = TRUE⁠</span>’ to scale in anticipation of ‘<span class="samp">⁠alpha = "spherical"⁠</span>’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>If numeric, the position of the ‘star’ points.  May also be a character string that matches or partially matches one of these:
</p>

<dl>
<dt><code>"orthogonal"</code></dt>
<dd>
<p>the star points are positioned to block the design orthogonally</p>
</dd>
<dt><code>"rotatable"</code></dt>
<dd>
<p>the star points are chosen to make the design rotatable</p>
</dd>
<dt><code>"spherical"</code></dt>
<dd>
<p>the star points are the same distance as the corners of the design cube (alpha is the square root of the number of design factors)</p>
</dd>
<dt><code>"faces"</code></dt>
<dd>
<p>the star points are face-centered (same as ‘<span class="samp">⁠alpha = 1⁠</span>’)</p>
</dd>
</dl>
<p>The user may specify a vector value of <code>alpha</code> if it is desired to vary them on different axes. The values are rotated cyclically as needed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>design</code></td>
<td>
<p>A <code>coded.data</code> object to be duplicated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>blocks</code></td>
<td>
<p>A string or a formula.  If a character string, it is the name of the blocking factor; if a formula, the left-hand side is used as the name of the blocking factor. The formula(s) on the right-hand side are used to generate separate fractional blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>
<p>Character vector of names of variables to fold over.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wbreps</code></td>
<td>
<p>Number(s) of within-block replications.  If this is a vector of length 2, then separate numbers are used for the ‘cube’ and the ‘star’ blocks respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bbreps</code></td>
<td>
<p>Number(s) of between-block replications (i.e., number of repeats of each block).  If this is a vector of length 2, then separate numbers are used for the ‘cube’ and the ‘star’ blocks respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oneblock</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the blocking factor is removed and the whole design is randomized as a single block. Note that the default number of center points may be larger than you anticipated because they are combined.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Central-composite designs (CCDs) are popular designs for use in response-surface exploration.  They are blocked designs consisting of at least one ‘cube’ block (two-level factorial or fractional factorial, plus center points), and at least one ‘star’ block (points along each axis at positions <code>-alpha</code> and <code>+alpha</code>), plus center points.  Everything is put on a coded scale, where the cube portion of the design has values of -1 and 1 for each variable, and the center points are 0.
</p>
<p>The <code>ccd</code> function creates an entire CCD design; however, in practice, we often start with just the cube portion and build from there. Therefore, the functions <code>cube</code>, <code>star</code>, <code>dupe</code>, and <code>foldover</code> are provided, and one may use <code>djoin</code> to combine them.
</p>
<p>In <code>cube</code> and <code>ccd</code>, the <code>basis</code> argument determines a basic design used to create cube blocks.  
For example, ‘<span class="samp">⁠cube(basis = ~ A + B + C)⁠</span>’ would generate a basic design of 8 factorial points plus center points. 
Use <code>generators</code> if you want additional variables in a fractional design; for example, ‘<span class="samp">⁠generators = c(D ~ -A*B, E ~ B*C)⁠</span>’ added to the above would generate a 5-factor design with defining relation <code>I = -ABD = BCE = -ACDE</code>.  For convenience, <code>basis</code> may be an integer instead of a formula, in which case default variable names of <code>x1, x2, ...</code> are used; for example, ‘<span class="samp">⁠cube(3, ~ -x1*x2*x3)⁠</span>’ generates a 1/2 fraction design with added center points.
</p>
<p>If you want the cube points divided into fractional blocks, give the formula(s) in the <code>blockgen</code> argument of <code>cube</code>, or the <code>blocks</code> argument of <code>ccd</code>.  For instance, suppose we call ‘<span class="samp">⁠cube(basis = A+B+C+D+E⁠</span>’, ‘<span class="samp">⁠generators = F~-A*C*D)⁠</span>’.
This design has 32 runs; but adding the argument ‘<span class="samp">⁠blockgen = c("A*B*C","C*D*E")⁠</span>’ will
create a fractional block of 32/4 = 8 runs. (<code>cube</code> is flexible; we could have used a
formula instead, either ‘<span class="samp">⁠blockgen = ~ c(A*B*C, C*D*E)⁠</span>’ or 
‘<span class="samp">⁠blockgen = c(~A*B*C, ~C*D*E)⁠</span>’.) Center points are added to each block as specified. 
In a call to <code>ccd</code> with the same <code>basis</code> and <code>generators</code>, adding 
‘<span class="samp">⁠blocks = Day ~ c(A*B*C, C*D*E)⁠</span>’ would do the same thing, only all 4 blocks will be
included, and a factor named <code>Day</code> distinguishes the blocks.
</p>
<p>The functions <code>star</code>, <code>dupe</code>, and <code>foldover</code> provide for creating new design blocks based on an existing design.  They also provide for delayed evaluation: if the <code>basis</code> argument is missing, these functions simply return the call, <code>djoin</code> will fill-in ‘<span class="samp">⁠basis = design1⁠</span>’ and evaluate it. 
</p>
<p><code>dupe</code> simply makes a copy of the design, and re-randomizes it. Therefore it is also a convenient way to re-randomize a design. If <code>coding</code> is provided, the coding formulas are replaced as well – for example, to re-center the design.
</p>
<p>Use <code>star</code> to generate star (axis) points, which consist of center points plus points at <code>+/- alpha</code> on each coordinate axis.  You may specify the <code>alpha</code> you want, or a character argument to specify a certain criterion be met.  For example, using delayed evaluation, ‘<span class="samp">⁠ccd1 = djoin(cube1, star(alpha="sph"))⁠</span>’ will return a CCD with <code>cube1</code> as the cube block, and with axis points at the same distance as the corners of the cube. Conditions for the criteria on <code>alpha</code> are described in detail in references such as Myers <em>et al.</em> (2009). 
</p>
<p>In <code>star</code>, determinations of orthogonality and rotatability are based on computed design moments of <code>basis</code>, rather than any assumptions about the structure of the design being augmented. Thus, it may be possible to augment an unusual design to obtain a rotatable design. Also, if an orthogonal star block is requested, the value of <code>alpha</code> may vary from axis to axis if that is required to satisfy the condition.
</p>
<p><code>foldover</code> reverses the levels of one or more  design variables (i.e., those that are coded). By default, it reverses them all. However, if the <code>bid</code> argument is supplied, it instead returns the <code>bid</code>th fractional block that <code>cube</code> would have generated. That is, ‘<span class="samp">⁠foldover(des, bid=3)⁠</span>’ is equivalent to ‘<span class="samp">⁠cube(&lt;arguments that created des&gt;, bid=3)⁠</span>’ – only it does so much more efficiently by folding on the appropriate factors.
</p>
<p>In cases where there are constraints on the region of operability, you may want to specify <code>inscribed = TRUE</code>.  This will scale-down the design so that no coded value exceeds 1. If using a building-block approach starting with a first-order design from <code>cube</code>, call <code>cube</code>  with <code>inscribed</code> set to the anticipated value of <code>alpha</code>, or use ‘<span class="samp">⁠inscribed = TRUE⁠</span>’, and then use ‘<span class="samp">⁠alpha = "spherical"⁠</span>’ in the subsequent call to <code>star</code>.
</p>
<p><code>ccd</code> generates an entire CCD. In practice, the building-block approach with <code>cube</code>, <code>star</code>, etc. is usually preferable, but <code>ccd</code> exists for convenience and backward compatibility with pre-2.00 versions of <span class="pkg">rsm</span>. Many of the arguments are the same as those in <code>cube</code>; however, <code>n0</code>, <code>wbreps</code>, <code>bbreps</code> may be single values or vectors; if vectors, the first element is for the cube portions and the second element is for the star portions. In <code>ccd</code>, specifying <code>wbreps</code> is equivalent to specifying <code>reps</code> in a call to <code>cube</code> or <code>star</code>. <code>bbreps</code> refers to replicate blocks in the experiment, so that ‘<span class="samp">⁠bbreps = c(2,3)⁠</span>’ specifies that we join two cube blocks and three blocks of star points.
</p>
<p>If <code>coding</code> is not specified in a new design, default identity codings are created, e.g. ‘<span class="samp">⁠x1 ~ x1.as.is⁠</span>’.
</p>


<h3>Value</h3>

<p>A <code>coded.data</code> object with the generated design, with additional variables <code>run.order</code> and <code>std.order</code>. If a multi-block design, the generated blocking variable will be a <code>factor</code>; all other variables will be numeric. The designs are sorted by blocks and <code>run.order</code> within blocks; and (unlike pre-1.41 versions of <span class="pkg">rsm</span>) the <code>row.names</code> will be integers corresponding to this ordering. The user may sort by block and <code>std.order</code> within block to display the designs in their pre-randomized order.
</p>


<h3>Note</h3>

<p>Poor choices of <code>generators</code> and/or <code>blocks</code> can alias or partially alias some effects needed to estimate a second-order response surface.  It is a good idea to run <code>varfcn</code> before collecting data to examine the prediction capabilities of the design and to ensure that the desired model can be fitted.
</p>
<p>The function <code>ccd.pick</code> is available to help determine good choices for arguments to <code>cube</code>, <code>star</code>, and <code>ccd</code>.
</p>
<p>An alternative to a CCD when you want to go straight to second-order modeling is a Box-Behnken design, generated by <code>bbd</code>.  These designs are not as various or flexible as CCDs, but they can require fewer runs.
</p>
<p>The non-exported function <code>rsm:::.ccd.1.41</code> is provided in case it is needed by other packages for compatibility with old versions of <span class="pkg">rsm</span> (version 1.41 or earlier). Given the same seed, it will also reproduce the randomization as a previously generated design from an old version.
</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) “Response-Surface Methods in R, Using rsm”, 
<em>Journal of Statistical Software</em>, 32(7), 1–17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>
<p>Myers, RH, Montgomery, DC, and Anderson-Cook, CM (2009) 
<em>Response Surface Methodology</em> (3rd ed.), Wiley.
</p>


<h3>See Also</h3>

<p><code>ccd.pick</code>, <code>coded.data</code>, <code>varfcn</code>, <code>bbd</code></p>


<h3>Examples</h3>

<pre><code class="language-R">library(rsm)

### Generate a standard 3-variable first-order design with 8 corner points and 4 center points
( FOdes &lt;- cube (3, n0 = 4, coding = list (
                x1 ~ (Temp - 150)/10, x2 ~ (Pres - 50)/5, x3 ~ Feedrate - 4)) )
                                    
### Add an orthodonal star block with 12 runs to create a second-order CCD
( SOdes &lt;- djoin(FOdes, star(n0=6)) )

### Same as above, except make the whole CCD at once; and make it rotatable
### and inscribed so that no coded value exceeds 1
SOdes2 &lt;- ccd (3, n0 = c(4,6), alpha = "rotatable", inscribed = TRUE, coding = list (
                x1 ~ (Temp - 150)/10, x2 ~ (Pres - 50)/5, x3 ~ Feedrate - 4))

### Make two replicate blocks of FOdes (2nd one randomized differently)
djoin(FOdes, dupe(FOdes))

### Fractional blocking illustration (with no center points)
# Basic design (bid = 1 ---&gt; block generators b1 = -1, b2 = -1)
block1 &lt;- cube (~ x1 + x2 + x3 + x4,  generators = x5 ~ x1 * x2 * x3 * x4,
                n0 = 0, blockgen = ~ c(x1 * x2, x1 * x3), bid = 1)
block1                

# The foldover (on all variables) of block1, in the same order
foldover(block1, randomize=FALSE)

# The 4th fractional block:
( block4 &lt;- foldover(block1, bid = 4) )

</code></pre>


</div>