<div class="container">

<table style="width: 100%;"><tr>
<td>rstandard.seqModel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract standardized residuals from a sequence of regression models</h2>

<h3>Description</h3>

<p>Extract standardized residuals from a sequence of regression models, such as
submodels along a robust or groupwise least angle regression sequence, or
sparse least trimmed squares regression models for a grid of values for the
penalty parameter.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'seqModel'
rstandard(model, s = NA, drop = !is.null(s), ...)

## S3 method for class 'tslars'
rstandard(model, p, ...)

## S3 method for class 'perrySeqModel'
rstandard(model, ...)

## S3 method for class 'sparseLTS'
rstandard(
  model,
  s = NA,
  fit = c("reweighted", "raw", "both"),
  drop = !is.null(s),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>the model fit from which to extract standardize residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>for the <code>"seqModel"</code> method, an integer vector giving the
steps of the submodels for which to extract the standardized residuals (the
default is to use the optimal submodel).  For the <code>"sparseLTS"</code> method,
an integer vector giving the indices of the models for which to extract
standardized residuals.  If <code>fit</code> is <code>"both"</code>, this can be a list
with two components, with the first component giving the indices of the
reweighted fits and the second the indices of the raw fits.  The default is
to use the optimal model for each of the requested estimators.  Note that
the optimal models may not correspond to the same value of the penalty
parameter for the reweighted and the raw estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>a logical indicating whether to reduce the dimension to a
vector in case of only one step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for the <code>"tslars"</code> method, additional arguments to be
passed down to the <code>"seqModel"</code> method.  For the other methods,
additional arguments are currently ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an integer giving the lag length for which to extract standardized
residuals (the default is to use the optimal lag length).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>a character string specifying which standardized residuals to
extract.  Possible values are <code>"reweighted"</code> (the default) for the
standardized residuals from the reweighted estimator, <code>"raw"</code> for the
standardized residuals from the raw estimator, or <code>"both"</code> for the
standardized residuals from both estimators.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector or matrix containing the requested standardized residuals.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code>rstandard</code>, <code>residuals</code>
</p>
<p><code>rlars</code>, <code>grplars</code>, <code>rgrplars</code>,
<code>tslarsP</code>, <code>rtslarsP</code>, <code>tslars</code>,
<code>rtslars</code>, <code>sparseLTS</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate data
# example is not high-dimensional to keep computation time low
library("mvtnorm")
set.seed(1234)  # for reproducibility
n &lt;- 100  # number of observations
p &lt;- 25   # number of variables
beta &lt;- rep.int(c(1, 0), c(5, p-5))  # coefficients
sigma &lt;- 0.5      # controls signal-to-noise ratio
epsilon &lt;- 0.1    # contamination level
Sigma &lt;- 0.5^t(sapply(1:p, function(i, j) abs(i-j), 1:p))
x &lt;- rmvnorm(n, sigma=Sigma)    # predictor matrix
e &lt;- rnorm(n)                   # error terms
i &lt;- 1:ceiling(epsilon*n)       # observations to be contaminated
e[i] &lt;- e[i] + 5                # vertical outliers
y &lt;- c(x %*% beta + sigma * e)  # response
x[i,] &lt;- x[i,] + 5              # bad leverage points


## robust LARS
# fit model
fitRlars &lt;- rlars(x, y, sMax = 10)
# extract standardized residuals
rstandard(fitRlars)
head(rstandard(fitRlars, s = 1:5))


## sparse LTS over a grid of values for lambda
# fit model
frac &lt;- seq(0.2, 0.05, by = -0.05)
fitSparseLTS &lt;- sparseLTS(x, y, lambda = frac, mode = "fraction")
# extract standardized residuals
rstandard(fitSparseLTS)
head(rstandard(fitSparseLTS, fit = "both"))
head(rstandard(fitSparseLTS, s = NULL))
head(rstandard(fitSparseLTS, fit = "both", s = NULL))
</code></pre>


</div>