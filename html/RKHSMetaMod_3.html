<div class="container">

<table style="width: 100%;"><tr>
<td>grplasso_q</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to fit a solution with q active groups of an RKHS Group Lasso problem.
</h2>

<h3>Description</h3>

<p>Fits a solution of the group lasso problem based on RKHS, with <code class="reqn">q</code> active groups in the obtained solution for the Gaussian regression model. It determines <code class="reqn">\mu_{g}(q)</code>, for which the number of active groups in the solution of the RKHS group lasso problem is equal to <code class="reqn">q</code>, and returns the RKHS meta model associated with <code class="reqn">\mu_{g}(q)</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">grplasso_q(Y, Kv, q, rat, Num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Vector of response observations of size <code class="reqn">n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kv</code></td>
<td>
<p>List of eigenvalues and eigenvectors of positive definite Gram matrices <code class="reqn">K_v</code> and their associated group names. It should have the same format as the output of the function <code>calc_Kv</code> (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>Integer, the number of active groups in the obtained solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rat</code></td>
<td>
<p>Positive scalar, used to restrict the minimum value of <code class="reqn">\mu_g</code>, to be evaluted in the RKHS Group Lasso algorithm, <code class="reqn">\mu_{min}=\mu_{max}/rat</code>. The value <code class="reqn">\mu_{max}</code> is calculated inside the program, see function <code>mu_max</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Num</code></td>
<td>
<p>Integer, used to restrict the number of different values of the penalty parameter <code class="reqn">\mu_g</code> to be evaluated in the RKHS Group Lasso algorithm, until it achieves <code class="reqn">\mu_g(q)</code>: for Num <code class="reqn">= 1</code> the program is done for <code class="reqn">3</code> values of <code class="reqn">\mu_g</code>, <code class="reqn">\mu_{1}=(\mu_{min}+\mu_{max})/2</code>, <code class="reqn">\mu_{2}=(\mu_{min}+\mu_{1})/2</code> or <code class="reqn">\mu_{2}=(\mu_{1}+\mu_{max})/2</code> depending on the value of <code class="reqn">q</code> associated with <code class="reqn">\mu_{1}</code>, <code class="reqn">\mu_{3}=\mu_{min}</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Input Kv should contain the eigenvalues and eigenvectors of positive definite Gram matrices <code class="reqn">K_v</code>. It is necessary to set input "correction" in the function <code>calc_Kv</code> equal to "TRUE".
</p>


<h3>Value</h3>

<p>List of <code class="reqn">4</code> components: "mus", "qs", "mu", "res":
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mus</code></td>
<td>
<p>Vector, values of the evaluated penalty parameters <code class="reqn">\mu_g</code> in the RKHS group lasso algorithm until it achieves <code class="reqn">\mu_{g}(q)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qs</code></td>
<td>
<p>Vector, number of active groups associated with each value of <code class="reqn">\mu_g</code> in mus.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Scalar, value of <code class="reqn">\mu_{g}(q)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>res</code></td>
<td>
<p>An RKHS Group Lasso object:</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Scalar, estimated value of intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>teta</code></td>
<td>
<p>Matrix with vMax rows and <code class="reqn">n</code> columns. Each row of the matrix is the estimated vector <code class="reqn">\theta_{v}</code> for <code class="reqn">v=1,...,</code>vMax.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.v</code></td>
<td>
<p>Matrix with <code class="reqn">n</code> rows and vMax columns. Each row of the matrix is the estimated value of <code class="reqn">f_{v}=K_{v}\theta_{v}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted</code></td>
<td>
<p>Vector of size <code class="reqn">n</code>, indicates the estimator of <code class="reqn">m</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Norm.H</code></td>
<td>
<p>Vector of size vMax, estimated values of the penalty norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>supp</code></td>
<td>
<p>Vector of active groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsupp</code></td>
<td>
<p>Vector of the names of the active groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SCR</code></td>
<td>
<p>Scalar, equals to <code class="reqn">\Vert Y-f_{0}-\sum_{v}K_{v}\theta_{v}\Vert ^{2}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crit</code></td>
<td>
<p>Scalar, indicates the value of the penalized criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MaxIter</code></td>
<td>
<p>Integer, number of iterations until convergence is reached.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>TRUE or FALSE. Indicates whether the algorithm has converged or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RelDiffCrit</code></td>
<td>
<p>Scalar, value of the first convergence criteria at the last iteration, <code class="reqn">\frac{crit_{lastIter}-crit_{lastIter-1}}{crit_{lastIter-1}}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RelDiffPar</code></td>
<td>
<p>Scalar, value of the second convergence criteria at the last iteration, <code class="reqn">\Vert\frac{\theta_{lastIter}-\theta_{lastIter-1}}{\theta_{lastIter-1}}\Vert ^{2}</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Note.
</p>


<h3>Author(s)</h3>

<p>Halaleh Kamari
</p>


<h3>References</h3>

<p>Kamari, H., Huet, S. and Taupin, M.-L. (2019) RKHSMetaMod : An R package to estimate the Hoeffding decomposition of an unknown function by solving RKHS Ridge Group Sparse optimization problem. &lt;arXiv:1905.13695&gt;
</p>


<h3>See Also</h3>

<p><code>calc_Kv</code>, <code>mu_max</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">d &lt;- 3
n &lt;- 50
library(lhs)
X &lt;- maximinLHS(n, d)
c &lt;- c(0.2,0.6,0.8)
F &lt;- 1;for (a in 1:d) F &lt;- F*(abs(4*X[,a]-2)+c[a])/(1+c[a])
epsilon &lt;- rnorm(n,0,1);sigma &lt;- 0.2 
Y &lt;- F + sigma*epsilon
Dmax &lt;- 3
kernel &lt;- "matern"
Kv &lt;- calc_Kv(X, kernel, Dmax, TRUE, TRUE)
result &lt;- grplasso_q(Y,Kv,5,100 ,Num=10)
result$mu
result$res$Nsupp
</code></pre>


</div>