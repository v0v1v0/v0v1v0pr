<div class="container">

<table style="width: 100%;"><tr>
<td>comp_freq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute frequencies from (3 essential) probabilities.</h2>

<h3>Description</h3>

<p><code>comp_freq</code> computes frequencies (typically
as rounded integers) given 3 basic probabilities –
<code>prev</code>, <code>sens</code>, and <code>spec</code> –
for a population of <code>N</code> individuals.
It returns a list of 11 key frequencies <code>freq</code>
as its output.
</p>


<h3>Usage</h3>

<pre><code class="language-R">comp_freq(
  prev = num$prev,
  sens = num$sens,
  spec = num$spec,
  N = num$N,
  round = TRUE,
  sample = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>prev</code></td>
<td>
<p>The condition's prevalence <code>prev</code>
(i.e., the probability of condition being <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sens</code></td>
<td>
<p>The decision's sensitivity <code>sens</code>
(i.e., the conditional probability of a positive decision
provided that the condition is <code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p>The decision's specificity value <code>spec</code>
(i.e., the conditional probability
of a negative decision provided that the condition is <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>The number of individuals in the population.
If <code>N</code> is unknown (<code>NA</code>),
a suitable minimum value is computed by <code>comp_min_N</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round</code></td>
<td>
<p>Boolean value that determines whether frequency values
are rounded to the nearest integer.
Default: <code>round = TRUE</code>.
</p>
<p>Note: Removed <code>n_digits</code> parameter:  Number of digits to which frequency values
are to be rounded when <code>round = FALSE</code>.
Default: <code>n_digits = 5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>Boolean value that determines whether frequency values
are sampled from <code>N</code>, given the probability values of
<code>prev</code>, <code>sens</code>, and <code>spec</code>.
Default: <code>sample = FALSE</code>.
</p>
<p>Note: Sampling uses <code>sample()</code> and returns integer values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In addition to <code>prev</code>, both
<code>sens</code> and <code>spec</code> are necessary arguments.
If only their complements <code>mirt</code> or <code>fart</code>
are known, use the wrapper function <code>comp_freq_prob</code>
which also accepts <code>mirt</code> and <code>fart</code> as inputs
(but requires that the entire set of provided probabilities is
sufficient and consistent).
Alternatively, use <code>comp_complement</code>,
<code>comp_comp_pair</code>, or <code>comp_complete_prob_set</code>
to obtain the 3 essential probabilities.
</p>
<p><code>comp_freq</code> is the frequency counterpart to the
probability function <code>comp_prob</code>.
</p>
<p>By default, <code>comp_freq</code> and its wrapper function
<code>comp_freq_prob</code>
round frequencies to nearest integers to avoid decimal values in
<code>freq</code> (i.e., <code>round = TRUE</code> by default).
When frequencies are rounded, probabilities computed from
<code>freq</code> may differ from exact probabilities.
Using the option <code>round = FALSE</code> turns off rounding.
</p>
<p>Key relationships between probabilities and frequencies:
</p>

<ul>
<li>
<p> Three perspectives on a population:
</p>
<p>A population of <code>N</code> individuals can be split into 2 subsets of frequencies
in 3 different ways:
</p>

<ol>
<li>
<p> by condition:
</p>
<p><code>N = cond_true + cond_false</code>
</p>
<p>The frequency <code>cond_true</code> depends on the prevalence <code>prev</code>
and
the frequency <code>cond_false</code> depends on the prevalence's complement <code>1 - prev</code>.
</p>
</li>
<li>
<p> by decision:
</p>
<p><code>N = dec_pos + dec_neg</code>
</p>
<p>The frequency <code>dec_pos</code> depends on the proportion of positive decisions <code>ppod</code>
and
the frequency <code>dec_neg</code> depends on the proportion of negative decisions <code>1 - ppod</code>.
</p>
</li>
<li>
<p> by accuracy (i.e., correspondence of decision to condition):
</p>
<p><code>N = dec_cor + dec_err</code>
</p>
</li>
</ol>
<p>Each perspective combines 2 pairs of the 4 essential probabilities (hi, mi, fa, cr).
</p>
<p>When providing probabilities, the population size <code>N</code> is a free parameter (independent of the
essential probabilities <code>prev</code>, <code>sens</code>, and <code>spec</code>).
</p>
<p>If <code>N</code> is unknown (<code>NA</code>), a suitable minimum value can be computed by <code>comp_min_N</code>.
</p>
</li>
<li>
<p> Defining probabilities in terms of frequencies:
</p>
<p>Probabilities <em>are</em> – determine, describe, or are defined as – the relationships between frequencies.
Thus, they can be computed as ratios between frequencies:
</p>

<ol>
<li>
<p> prevalence <code>prev</code>:
</p>
<p><code>prev = cond_true/N  =  (hi + mi) / (hi + mi + fa + cr)</code>
</p>
</li>
<li>
<p> sensitivity <code>sens</code>:
</p>
<p><code>sens = hi/cond_true  =  hi / (hi + mi)  =  (1 - mirt)</code>
</p>
</li>
<li>
<p> miss rate <code>mirt</code>:
</p>
<p><code>mirt = mi/cond_true  =  mi / (hi + mi)  =  (1 - sens)</code>
</p>
</li>
<li>
<p> specificity <code>spec</code>:
</p>
<p><code>spec = cr/cond_false  =  cr / (fa + cr)  =  (1 - fart)</code>
</p>
</li>
<li>
<p> false alarm rate <code>fart</code>:
</p>
<p><code>fart = fa/cond_false  =  fa / (fa + cr)  =  (1 - spec)</code>
</p>
</li>
<li>
<p> proportion of positive decisions <code>ppod</code>:
</p>
<p><code>ppod = dec_pos/N  =  (hi + fa) / (hi + mi + fa + cr)</code>
</p>
</li>
<li>
<p> positive predictive value <code>PPV</code>:
</p>
<p><code>PPV = hi/dec_pos  =  hi / (hi + fa)  =  (1 - FDR)</code>
</p>
</li>
<li>
<p> negative predictive value <code>NPV</code>:
</p>
<p><code>NPV = cr/dec_neg  =  cr / (mi + cr)  =  (1 - FOR)</code>
</p>
</li>
<li>
<p> false detection rate <code>FDR</code>:
</p>
<p><code>FDR = fa/dec_pos  =  fa / (hi + fa)  =  (1 - PPV)</code>
</p>
</li>
<li>
<p> false omission rate <code>FOR</code>:
</p>
<p><code>FOR = mi/dec_neg  =  mi / (mi + cr)  =  (1 - NPV)</code>
</p>
</li>
<li>
<p> accuracy <code>acc</code>:
</p>
<p><code>acc = dec_cor/N  =  (hi + cr) / (hi + mi + fa + cr)</code>
</p>
</li>
<li>
<p> rate of hits, given accuracy <code>p_acc_hi</code>:
</p>
<p><code>p_acc_hi = hi/dec_cor = (1 - cr/dec_cor)</code>
</p>
</li>
<li>
<p> rate of false alarms, given inaccuracy <code>p_err_fa</code>:
</p>
<p><code>p_err_fa = fa/dec_err = (1 - mi/dec_err)</code>
</p>
</li>
</ol>
<p>Beware of rounding and sampling issues!
If frequencies are rounded (by <code>round = TRUE</code> in <code>comp_freq</code>)
or sampled from probabilities (by <code>sample = TRUE</code>),
then any probabilities computed from <code>freq</code> may differ
from original and exact probabilities.
</p>
</li>
</ul>
<p>Functions translating between representational formats:
<code>comp_prob_prob</code>, <code>comp_prob_freq</code>,
<code>comp_freq_prob</code>, <code>comp_freq_freq</code>
(see documentation of <code>comp_prob_prob</code> for details).
</p>


<h3>Value</h3>

<p>A list <code>freq</code> containing 11 key frequency values.
</p>


<h3>See Also</h3>

<p><code>comp_freq_prob</code> corresponding wrapper function;
<code>num</code> contains basic numeric variables;
<code>init_num</code> initializes basic numeric variables;
<code>freq</code> contains current frequency information;
<code>prob</code> contains current probability information;
<code>comp_prob</code> computes current probability information;
<code>comp_complement</code> computes a probability's complement;
<code>comp_comp_pair</code> computes pairs of complements;
<code>comp_complete_prob_set</code> completes valid sets of probabilities;
<code>comp_min_N</code> computes a suitable population size <code>N</code> (if missing).
</p>
<p>Other functions computing frequencies: 
<code>comp_freq_freq()</code>,
<code>comp_freq_prob()</code>,
<code>comp_min_N()</code>,
<code>comp_prob_prob()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">comp_freq()          # ok, using current defaults
length(comp_freq())  # 11 key frequencies

# Rounding:
comp_freq(prev = .5, sens = .5, spec = .5, N = 1)   # yields fa = 1 (see ?round for reason)
comp_freq(prev = .1, sens = .9, spec = .8, N = 10)  # 1 hit (TP, rounded)
comp_freq(prev = .1, sens = .9, spec = .8, N = 10, round = FALSE)    # hi = .9
comp_freq(prev = 1/3, sens = 6/7, spec = 2/3, N = 1, round = FALSE)  # hi = 0.2857143

# Sampling (from probabilistic description):
comp_freq_prob(prev = .5, sens = .5, spec = .5, N = 100, sample = TRUE)  # freq values vary

# Extreme cases:
comp_freq(prev = 1, sens = 1, spec = 1, 100)  # ok, N hits (TP)
comp_freq(prev = 1, sens = 1, spec = 0, 100)  # ok, N hits
comp_freq(prev = 1, sens = 0, spec = 1, 100)  # ok, N misses (FN)
comp_freq(prev = 1, sens = 0, spec = 0, 100)  # ok, N misses
comp_freq(prev = 0, sens = 1, spec = 1, 100)  # ok, N correct rejections (TN)
comp_freq(prev = 0, sens = 1, spec = 0, 100)  # ok, N false alarms (FP)

# Watch out for:
comp_freq(prev = 1, sens = 1, spec = 1, N = NA)  # ok, but warning that N = 1 was computed
comp_freq(prev = 1, sens = 1, spec = 1, N =  0)  # ok, but all 0 + warning (extreme case: N hits)
comp_freq(prev = .5, sens = .5, spec = .5, N = 10, round = TRUE)   # ok, rounded (see mi and fa)
comp_freq(prev = .5, sens = .5, spec = .5, N = 10, round = FALSE)  # ok, not rounded

# Ways to fail:
comp_freq(prev = NA,  sens = 1, spec = 1,  100)   # NAs + warning (prev NA)
comp_freq(prev = 1,  sens = NA, spec = 1,  100)   # NAs + warning (sens NA)
comp_freq(prev = 1,  sens = 1,  spec = NA, 100)   # NAs + warning (spec NA)
comp_freq(prev = 8,  sens = 1,  spec = 1,  100)   # NAs + warning (prev beyond range)
comp_freq(prev = 1,  sens = 8,  spec = 1,  100)   # NAs + warning (sens beyond range)

</code></pre>


</div>