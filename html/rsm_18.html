<div class="container">

<table style="width: 100%;"><tr>
<td>contour.lm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Surface plot(s) of a fitted linear model</h2>

<h3>Description</h3>

<p><code>contour</code>, <code>image</code>, and <code>persp</code> methods that display the fitted surface for an <code>lm</code> object 
involving two or more numerical predictors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'lm'
contour(x, form, at, bounds, zlim, xlabs, hook, 
    plot.it = TRUE, atpos = 1, decode = TRUE, image = FALSE, 
    img.col = terrain.colors(50), ...)

## S3 method for class 'lm'
image(x, form, at, bounds, zlim, xlabs, hook, 
    atpos = 1, decode = TRUE, ...)

## S3 method for class 'lm'
persp(x, form, at, bounds, zlim, zlab, xlabs, 
    col = "white", contours = NULL, hook, atpos = 3, decode = TRUE, 
    theta = -25, phi = 20, r = 4, border = NULL, box = TRUE, 
    ticktype = "detailed", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>lm</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>form</code></td>
<td>
<p>A formula, or a list of formulas.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>Optional <em>named</em> list of fixed values to use for surface slices.
For example, if the predictor variables are <code>x1</code>, <code>x2</code>, and <code>x3</code>, the contour plot of <code>x2</code> versus <code>x1</code> would be
based on the fitted surface sliced at the <code>x3</code> value specified in <code>at</code>; the contour plot of <code>x3</code> versus <code>x1</code> would be sliced at the <code>at</code> value for <code>x2</code>; etc.
If not provided, <code>at</code> defaults to the mean value of each numeric variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>Optional <em>named</em> list of bounds or grid values to use for
the variables having the same names.  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlim</code></td>
<td>
<p><code>zlim</code> setting passed to parent methods <code>contour</code>, <code>image</code>, or <code>persp</code>. The same <code>zlim</code> is used in all plots when several are produced.
If not provided, the range of values across all plotted surfaces is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlab</code></td>
<td>
<p>Optional label for the vertical axis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlabs</code></td>
<td>
<p>Alternate labels for predictor axes (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hook</code></td>
<td>
<p>Optional list that can contain functions <code>pre.plot</code> and <code>post.plot</code>.  
May be used to add annotations or to re-route the graphs to separate files (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atpos</code></td>
<td>
<p>Determines where <code>at</code> values are displayed.  A value of 1 (or 2) displays it as part of the <em>x</em> (or <em>y</em>) axis label.
A value of 3 displays it as a subtitle below the plot.  A value of 0 suppresses it.
Any other nonzero value will cause the label to be generated but not displayed; it can be accessed via a <code>hook</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decode</code></td>
<td>
<p>This has an effect only if <code>x</code> is an <code>rsm</code> object or other model object that supports <code>coded.data</code>. In such cases, if <code>decode</code> is <code>TRUE</code>, the coordinate axes are transformed to their decoded values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>image</code></td>
<td>
<p>Set to <code>TRUE</code> if you want an image plot overlaid by contours.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>img.col</code></td>
<td>
<p>Color map to use when <code>image=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>
<p>If <code>TRUE</code>, no plot is produced, just the return value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>Color or colors used for facets in the perspective plot (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contours</code></td>
<td>
<p>If non-<code>NULL</code>, specifications for added contour lines in perspective plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta, phi</code></td>
<td>
<p>Viewing angles passed to <code>persp</code> (different defaults).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Viewing distance passed to <code>persp</code> (different default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>border, box</code></td>
<td>
<p>Options passed to <code>persp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ticktype</code></td>
<td>
<p>Option passed to <code>persp</code> (different default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>contour</code>, <code>image</code>, or <code>persp</code>. Note, however, that a <code>ylab</code> is ignored, with a message to Use <code>xlabs</code> instead.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>form</code> may be a single formula or a list of formulas.  A simple formula like
<code>x2 ~ x1</code> will produce a contour plot of the fitted regression surface
for combinations of <code>x2</code> (vertical axis) and <code>x1</code> (horizontal axis).
A list of several such simple formulas will produce a contour plot for each formula.
A two-sided formula produces contour plots for each left-hand variable versus each
right-hand variable (except when they are the same); for example, 
<code>x1+x3 ~ x2+x3</code> is equivalent to 
<code>list(x1~x2, x3~x2, x1~x3)</code>.  
A one-sided formula produces contour plots for each pair of variables.  For example,
<code>~ x1+x2+x3</code> is equivalent to 
<code>list(x2~x1, x3~x1, x3~x2)</code>. 
</p>
<p>For any variables not in the <code>bounds</code> argument, a grid of 26 equally-spaced 
values in the observed range of that variable is used.  If you specify a vector of 
length 2, it is interpreted as the desired range for that variable and a grid of 26
equally-spaced points is generated.  If it is a vector of length 3, the first two elements are used
as the range, and the third as the number of grid points.
If it is a vector of length 4 or more, those
values are used directly as the grid values.
</p>
<p>The results are based on the predicted values of the linear model over the specified grid. If there are <code>factor</code>s among the predictors, the predictions are made over all levels (or combinations of levels) of those factors, and then averaged together. (However, the user may include factors in <code>at</code> to restrict this behavior.)
</p>
<p>By default, the predictor axes are labeled using the variable names in <code>form</code>,
unless <code>x</code> is an <code>rsm</code> or other object that supports <code>coded.data</code>, in which case either the decoded variable names or the variable-coding formulas are used to generate axis labels, depending on whether <code>decode</code> is <code>TRUE</code> or <code>FALSE</code>.
These axis labels are replaced by the entries in <code>xlabs</code> if provided.  One must be careful using this
to make sure that the names are mapped correctly.  The entries in <code>xlabs</code>
should match the respective unique variable names in <code>form</code>, <em>after sorting them in 
(case-insensitive) alphabetical order</em> (not necessarily in order of appearance).  Note that if <code>form</code> is changed, it may also
be necessary to change <code>xlabs</code>.
</p>
<p>Please note that with models fitted to coded data, coded values should be used in <code>at</code> or <code>bounds</code>, regardless of whether <code>decode</code> is <code>TRUE</code> or <code>FALSE</code>. However, any elements that are added afterward via <code>points</code>, <code>lines</code>, etc., must be specified in terms of whatever coordinate system is present in the plots.
</p>
<p>In <code>persp</code>, contour lines may be added via the <code>contours</code> argument.  It may be a boolean or character value, or a <code>list</code>.
If boolean and <code>TRUE</code>, default black contour lines are added to the bottom surface of the box.  Character values of <code>"top"</code>, <code>"bottom"</code>
add black contour lines to the specified surface of the box.  <code>contours = "colors"</code> puts contour lines on the bottom using the same colors as those 
at the same height on the surface.  Other character values of <code>contours</code> are taken to be the desired color of the contour lines, plotted at the bottom.
If <code>contours</code> is a named <code>list</code>, its elements (all are optional) are used as follows:
</p>

<dl>
<dt><code>z</code></dt>
<dd>
<p>Height where the contour lines are plotted.  May be <code>"bottom"</code> (default), <code>"top"</code>, or a numeric value.</p>
</dd>
<dt><code>col</code></dt>
<dd>
<p>Color of the lines.  If not specified, they will be black.  
May be integer color values, color names, or <code>"colors"</code> to match the surface colors.</p>
</dd>
<dt><code>lwd</code></dt>
<dd>
<p>Line width; default is 1.</p>
</dd>
</dl>
<p>Since these functions often produce several plots, the <code>hook</code> argument is provided if special setups or annotations are needed for each plot.  It
should be a list that defines one or both of the functions <code>pre.plot</code> and <code>post.plot</code>.  Both of these functions have one argument, the character 
vector <code>labs</code> for that plot (see Value documentation).
</p>
<p>Additional examples and discussion of these plotting functions is available via <code>vignette("rsm-plots")</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing information that is plotted.  
Each list item is itself a <code>list</code> with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>The values used for the x and y axes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>The matrix of fitted response values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labs</code></td>
<td>
<p>Character vector of length 5: Elements 1 and 2 are the x and y axis labels, 
elements 3 and 4 are their original variable names,
and element 5 is the slice label (empty if <code>atpos</code> is 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlim</code></td>
<td>
<p>The computed or provided <code>zlim</code> values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transf</code></td>
<td>
<p>(<code>persp</code> only) The 3D transformation for <code>trans3d</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009) “Response-Surface Methods in R, Using rsm”, 
<em>Journal of Statistical Software</em>, 32(7), 1–17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code>contour</code></p>


<h3>Examples</h3>

<pre><code class="language-R">### Basic example with a linear model:
mpg.lm &lt;- lm(mpg ~ poly(hp, disp, degree = 3), data = mtcars)
contour(mpg.lm, hp ~ disp, image = TRUE)

### Extended example with an rsm model...
heli.rsm &lt;- rsm (ave ~ block + SO(x1, x2, x3, x4), data = heli)

# Plain contour plots
par (mfrow = c(2,3))
contour (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))

# Same but with image overlay, slices at origin and block 2,
# and no slice labeling
contour (heli.rsm, ~x1+x2+x3+x4, at = list(block="2"), 
    atpos = 0, image = TRUE)

# Default perspective views
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))

# Same plots, souped-up with facet coloring and axis labeling
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm),
    contours = "col", col = rainbow(40), zlab = "Flight time",
  xlabs = c("Wing area", "Wing length", "Body width", "Body length"))
  
## Not run: 
### Hints for creating graphics files for use in publications...

# Save perspective plots in one PDF file (will be six pages long)
pdf(file = "heli-plots.pdf")
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm))
dev.off()

# Save perspective plots in six separate PNG files
png.hook = list(
    pre.plot = function(lab) 
        png(file = paste(lab[3], lab[4], ".png", sep = "")),
    post.plot = function(lab)
        dev.off())
persp (heli.rsm, ~x1+x2+x3+x4, at = xs(heli.rsm), hook = png.hook)

## End(Not run) 
</code></pre>


</div>