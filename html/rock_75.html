<div class="container">

<table style="width: 100%;"><tr>
<td>opts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Options for the rock package</h2>

<h3>Description</h3>

<p>The <code>rock::opts</code> object contains three functions to set, get, and reset
options used by the rock package. Use <code>rock::opts$set</code> to set options,
<code>rock::opts$get</code> to get options, or <code>rock::opts$reset</code> to reset specific or
all options to their default values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">opts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Details</h3>

<p>It is normally not necessary to get or set <code>rock</code> options. The defaults implement
the Reproducible Open Coding Kit (ROCK) standard, and deviating from these defaults
therefore means the processed sources and codes are not compatible and cannot be
processed by other software that implements the ROCK. Still, in some cases this
degree of customization might be desirable.
</p>
<p>The following arguments can be passed:
</p>

<dl>
<dt>...</dt>
<dd>
<p>For <code>rock::opts$set</code>, the dots can be used to specify the options
to set, in the format <code>option = value</code>, for example, <code>utteranceMarker = "\n"</code>. For
<code>rock::opts$reset</code>, a list of options to be reset can be passed.</p>
</dd>
<dt>option</dt>
<dd>
<p>For <code>rock::opts$set</code>, the name of the option to set.</p>
</dd>
<dt>default</dt>
<dd>
<p>For <code>rock::opts$get</code>, the default value to return if the
option has not been manually specified.</p>
</dd>
</dl>
<p>Some of the options that can be set (see <code>rock::opts$defaults</code> for the
full list):
</p>

<dl>
<dt>codeRegexes</dt>
<dd>
<p>A named character vector with one or more regular
expressions that specify how to extract the codes (that were used to code the
sources). These regular expressions <em>must</em> each contain one capturing group
to capture the codes.</p>
</dd>
<dt>idRegexes</dt>
<dd>
<p>A named character vector with one or more regular
expressions that specify how to extract the different types of
identifiers. These regular expressions <em>must</em> each contain one capturing group
to capture the identifiers.</p>
</dd>
<dt>sectionRegexes</dt>
<dd>
<p>A named character vector with one or more regular
expressions that specify how to extract the different types of sections.</p>
</dd>
<dt>autoGenerateIds</dt>
<dd>
<p>The names of the <code>idRegexes</code> that, if missing, should receive
autogenerated identifiers (which consist of 'autogenerated_' followed by an
incrementing number).</p>
</dd>
<dt>noCodes</dt>
<dd>
<p>This regular expression is matched with all codes after they have been
extracted using the <code>codeRegexes</code> regular expression (i.e. they're matched against the
codes themselves without, for example, the square brackets in the default code regex). Any
codes matching this <code>noCodes</code> regular expression will be <strong>ignored</strong>, i.e., removed from the
list of codes.</p>
</dd>
<dt>inductiveCodingHierarchyMarker</dt>
<dd>
<p>For inductive coding, this marker is used to indicate
hierarchical relationships between codes. The code at the left hand side of this marker will
be considered the parent code of the code on the right hand side. More than two levels
can be specified in one code (for example, if the <code>inductiveCodingHierarchyMarker</code> is '&gt;',
the code <code style="white-space: pre;">⁠grandparent&gt;child&gt;grandchild⁠</code> would indicate codes at three levels.</p>
</dd>
<dt>attributeContainers</dt>
<dd>
<p>The name of YAML fragments containing case attributes (e.g.
metadata, demographic variables, quantitative data about cases, etc).</p>
</dd>
<dt>codesContainers</dt>
<dd>
<p>The name of YAML fragments containing (parts of) deductive coding
trees.</p>
</dd>
<dt>delimiterRegEx</dt>
<dd>
<p>The regular expression that is used to extract the YAML fragments.</p>
</dd>
<dt>codeDelimiters</dt>
<dd>
<p>A character vector of two elements
specifying the opening and closing delimiters of codes (conform
the default ROCK convention, two square brackets). The square
brackets will be escaped; other characters will not, but will
be used as-is.</p>
</dd>
<dt>ignoreRegex</dt>
<dd>
<p>The regular expression that is used to delete lines before any other
processing. This can be used to enable adding comments to sources, which are then ignored
during analysis.</p>
</dd>
<dt>includeBootstrap</dt>
<dd>
<p>Whether to include the default bootstrap CSS.</p>
</dd>
<dt>utteranceMarker</dt>
<dd>
<p>How to specify breaks between utterances in the source(s). The
ROCK convention is to use a newline (<code style="white-space: pre;">⁠\\n⁠</code>).</p>
</dd>
<dt>coderId</dt>
<dd>
<p>A regular expression specifying the coder identifier, specified
similarly to the codeRegexes.</p>
</dd>
<dt>idForOmittedCoderIds</dt>
<dd>
<p>The identifier to use for utterances that do not
have a coder id (i.e. utterance that occur in a source that does not specify
a coder id, or above the line where a coder id is specified).</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">### Get the default utteranceMarker
rock::opts$get(utteranceMarker);

### Set it to a custom version, so that every line starts with a pipe
rock::opts$set(utteranceMarker = "\n|");

### Check that it worked
rock::opts$get(utteranceMarker);

### Reset this option to its default value
rock::opts$reset(utteranceMarker);

### Check that the reset worked, too
rock::opts$get(utteranceMarker);

</code></pre>


</div>