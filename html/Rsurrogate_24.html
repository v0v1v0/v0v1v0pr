<div class="container">

<table style="width: 100%;"><tr>
<td>R.multiple.surv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

Calculates the proportion of treatment effect explained by multiple surrogate markers measured at a specified time and primary outcome information up to that specified time
</h2>

<h3>Description</h3>


<p>This function calculates the proportion of treatment effect on the primary outcome explained by multiple surrogate markers measured at <code class="reqn">t_0</code> and primary outcome information up to <code class="reqn">t_0</code>.  The user can also request a variance estimate, estimated using perturbating-resampling, and a 95% confidence interval. If a confidence interval is requested three versions are provided: a normal approximation based interval, a quantile based interval and Fieller's confidence interval, all using perturbation-resampling. The user can also request an estimate of the incremental value of the surrogate marker information. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">R.multiple.surv(xone, xzero, deltaone, deltazero, sone, szero, type =1, t, 
weight.perturb = NULL, landmark, extrapolate = FALSE, transform = FALSE, 
conf.int = FALSE, var = FALSE, incremental.value = FALSE, approx = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xone</code></td>
<td>


<p>numeric vector, the observed event times in the treatment group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xzero</code></td>
<td>


<p>numeric vector, the observed event times in the control group, X = min(T,C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltaone</code></td>
<td>


<p>numeric vector, the event indicators for the treatment group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deltazero</code></td>
<td>


<p>numeric vector, the event indicators for the control group, D = I(T&lt;C) where T is the time of the primary outcome and C is the censoring time.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sone</code></td>
<td>


<p>matrix of numeric values; surrogate marker measurements at <code class="reqn">t_0</code> for treated observations. If <code class="reqn">X_{1i}&lt;t_0</code>, then the surrogate marker measurements should be NA. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>szero</code></td>
<td>


<p>matrix of numeric values; surrogate marker measurements at <code class="reqn">t_0</code> for control observations. If <code class="reqn">X_{0i}&lt;t_0</code>, then the surrogate marker measurements should be NA.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>


<p>type of estimate; options are 1 = two-stage robust estimator, 2 = weighted two-stage robust estimator, 3 = double-robust estimator, 4 = two-stage model-based estimator, 5 = weighted estimator, 6 = double-robust model-based estimator; default is 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>


<p>the time of interest.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.perturb</code></td>
<td>


<p>weights used for perturbation resampling.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>landmark</code></td>
<td>


<p>the landmark time <code class="reqn">t_0</code> or time of surrogate marker measurement.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extrapolate</code></td>
<td>


<p>TRUE or FALSE; indicates whether the user wants to use extrapolation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>


<p>TRUE or FALSE; indicates whether the user wants to use a transformation for the surrogate marker pseudo-score. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>


<p>TRUE or FALSE; indicates whether a 95% confidence interval for delta is requested, default is FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>


<p>TRUE or FALSE; indicates whether a variance estimate is requested, default is FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incremental.value</code></td>
<td>


<p>TRUE or FALSE; indicates whether the user would like to see the incremental value of the surrogate marker information, default is FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approx</code></td>
<td>

<p>TRUE or FALSE indicating whether an approximation should be used when calculating the probability of censoring; most relevant in settings where the survival time of interest for the primary outcome is greater than the last observed event but before the last censored case, default is TRUE.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">G \in \{A, B\}</code> be the binary treatment indicator and we assume that subjects are randomly assigned to either treatment group <code class="reqn">A</code> or <code class="reqn">B</code> at baseline. Let <code class="reqn">T</code> denote the time to the occurrence of the primary outcome, death for example, and <code class="reqn">S = (S_1,S_2,...,S_k)^{T}</code> denote the vector of <code class="reqn">k</code> surrogate markers measured at a given time <code class="reqn">t_0</code>. Let <code class="reqn">T^{(g)}</code> and <code class="reqn">S^{(g)}</code> denote the counterfactual  event time and surrogate marker measurements under treatment <code class="reqn">G = g</code> for <code class="reqn">g \in \{A, B\}</code>.  In practice, we only observe <code class="reqn">(T, S)=(T^{(A)}, S^{(A)})</code> or <code class="reqn">(T^{(B)}, S^{(B)})</code> depending on whether <code class="reqn">G=A</code> or <code class="reqn">B.</code> The treatment effect, <code class="reqn">\Delta(t)</code>, is the treatment difference in survival rates at time <code class="reqn">t &gt; t_0</code>,
<code class="reqn">\Delta(t)=E\{ I(T^{(A)}&gt;t)\} - E\{I(T^{(B)}&gt;t)\} = P(T^{(A)}&gt;t) - P(T^{(B)}&gt;t)</code>
where <code class="reqn">I(\cdot)</code> is the indicator function. For individuals who are censored or experience the primary outcome before <code class="reqn">t_0</code>, we assume that their <code class="reqn">S</code> information is not available.
</p>
<p>The surrogate marker information at time <code class="reqn">t_0</code> is defined as a combination of the observed information on <code class="reqn">I(T &gt;t_0)</code> and the observed <code class="reqn">S</code> at <code class="reqn">t_0</code>, denoted by <code class="reqn">Q_{t_0}  = \{Q_{t_0}^{(g)}, g = A, B\}</code>, where 
<code class="reqn">Q_{t_0} ^{(g)} = \{ T ^{(g)} \wedge  t_0, S ^{(g)} I(T ^{(g)} &gt; t_0)\}</code>. With information on <code class="reqn">Q_{t_0}</code>, the residual treatment effect is defined as:
<code class="reqn">\Delta_{S}(t,t_0) = E\{ I(T ^{(A)} &gt; t) - I(T ^{(B)}&gt;t)  \mid Q_{t_0}^{(A)} = Q_{t_0}^{(B)} \}
 =P(T^{(B)} &gt; t_0) \int_{S}  \psi_A(t \mid S, t_0) dF_{B}(S \mid t_0) -P(T^{(B)}&gt; t)</code>
where <code class="reqn">S = (s_1, ..., s_k)^{T}</code>, 
<code class="reqn">F_{g}(S \mid t_0)  = P(S^{(g)}\le S \mid T^{(g)}&gt;t_0),</code>  
<code class="reqn">\psi_g(t\mid S,t_0) = P(T^{(g)}&gt; t\mid S^{(g)}=S, T^{(g)}&gt; t_0).</code> The proportion of the treatment effect on the primary outcome that is explained by the treatment effect on <code class="reqn">Q_{t_0}</code>  is <code class="reqn">R_{S}(t,t_0)=1-\Delta_{S}(t,t_0)/\Delta</code>. This function provides 6 different estimators for <code class="reqn">R_{S}(t,t_0)</code> using censored data. 
</p>
<p>Due to censoring, the observed data consist of <code class="reqn">n</code> observations <code class="reqn">\{(G_i, X_{i}, \delta_{i}, S_{i}I(X_{i} &gt; t_0)), i=1,...,n\}</code> from the two treatment groups, where <code class="reqn">X_{i} = \min(T_{i}, C_{i})</code>, <code class="reqn">\delta_{i} = I(T_{i} &lt; C_{i})</code>,  and <code class="reqn">C_{i}</code> denotes the censoring time for the <code class="reqn">i</code>th subject. We assume independent censoring i.e., <code class="reqn">(T_i, S_i) \perp C_i \mid G_i</code>. For ease of notation, we also let <code class="reqn">\{(X_{gi}, \delta_{gi}, S_{gi}I(X_{gi} &gt; t_0)), i=1,...,n_g\}</code> denote <code class="reqn">n_g = \sum_{i=1}^n I(G_i = g)</code> observations from treatment group <code class="reqn">g \in \{A,B\},</code> where <code class="reqn">X_{gi}=\min(T_{gi}, C_{gi})</code> and <code class="reqn">\delta_{gi}=I(T_{gi}&lt;C_{gi}).</code> Without loss of generality, we assume that <code class="reqn">\bar{\pi}_g = n_g/n \to \pi_g \in (0,1)</code> as <code class="reqn">n\to \infty</code>. Throughout, we estimate the treatment effect <code class="reqn">\Delta(t) =P(T^{(A)}&gt;t) - P(T^{(B)}&gt;t)</code> as
<code class="reqn"> \hat{\Delta}(t)  = n_A^{-1} \sum_{i=1}^{n_A} \frac{I(X_{Ai}&gt;t)}{\hat{W}^C_A(t)} - n_B^{-1} \sum_{i=1}^{n_B} \frac{I(X_{Bi}&gt;t)}{\hat{W}^C_B(t)}</code>
where  <code class="reqn">\hat{W}^C_g(t)</code> is the Kaplan-Meier estimator of <code class="reqn">W^C_g(t) = P(C_{g} &gt; t)</code>. 
</p>
<p>We first describe the two-stage robust estimator which involves a two-stage procedure combining the use of a working model and a nonparametric estimation procedure for <code class="reqn">\Delta_{S}(t,t_0)</code>. The idea is simply to summarize <code class="reqn">S</code> into a univariate score <code class="reqn">U</code> and then construct a nonparametric estimator for <code class="reqn">R_S(t,t_0)</code> treating <code class="reqn">U</code> as <code class="reqn">S</code>. To construct <code class="reqn">U</code>, we approximate the conditional distribution of <code class="reqn">T^{(A)} \mid S^{(A)}, T^{(A)} &gt; t_0</code> by using a working semiparametric  model such as the landmark proportional hazards model <code class="reqn">q_A(S) = P(T^{(A)} &gt;t \mid T^{(A)} &gt;t_0, S^{(A)}) = \exp\{-\Lambda_0(t|t_0) \exp(\beta ^{T} S^{(A)}) \},  t&gt;t_0, </code>
where <code class="reqn"> \Lambda_0(t|t_0)</code> is the unspecified baseline cumulative hazard function for <code class="reqn">T^{(A)}</code> conditional on <code class="reqn">\{T^{(A)} &gt; t_0\}</code> and <code class="reqn">\beta</code> is an unknown vector of coefficients. Let <code class="reqn">\hat{\beta}</code> be the maximizer of the corresponding log partial likelihood function and <code class="reqn">\hat{\Lambda}_0(t|t_0)</code> be the Breslow-type estimate of baseline hazard. If one were to assume that this working model is correctly specified, then a consistent estimate of <code class="reqn">\Delta_{S}(t,t_0)</code> would simply be: <code class="reqn">\hat{\Delta}_{S}^M=n_B^{-1} \sum_{i=1}^{n_B} [ \exp \{ -\hat{\Lambda}_0(t|t_0)\exp(\hat{\beta} ^{T} S_{Bi}) \} \frac{I(X_{Bi} &gt; t_0)}{\hat{W}^C_B(t_0)}  -   \frac{I(X_{Bi} &gt; t)}{\hat{W}^C_B(t)}].</code> We refer to this estimate as the two-stage model-based estimator (option 4 for type).
Instead of relying on correct specification of this model, we use the resulting  score <code class="reqn">U = \beta_0^{T}S</code> as a univariate “pseudo-marker" to summarize the <code class="reqn">k</code> surrogates. In the second stage, to estimate <code class="reqn">\Delta_{S}(t,t_0)</code>, we apply a nonparametric approach with <code class="reqn">S</code> represented by the univariate marker <code class="reqn">U</code>.  Specifically, we use a  kernel Nelson-Aalen estimator to nonparametrically estimate  <code class="reqn">\phi_A(t|u, t_0)=P(T^{(A)}&gt; t\mid U^{(A)}=u, T^{(A)}&gt; t_0) = \exp\{-\Lambda_A(t|u, t_0 )\}</code> as <code class="reqn">\hat \phi_A(t|u, t_0)  = \exp\{-\hat{\Lambda}_A(t|u, t_0) \}</code>, where
<code class="reqn">\hat{\Lambda}_A(t|u, t_0) = \int_{t_0}^t \frac{\sum_{i=1}^{n_A} I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\}dN_{Ai}(z)}{\sum_{i=1}^{n_A}  I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\} Y_{Ai}(z)},</code>
<code class="reqn">\hat{U}_{Ai} = \hat{\beta} ^{T} S_{Ai}</code>, <code class="reqn">\hat{U}_{Bi} = \hat{\beta} ^{T} S_{Bi}</code>, <code class="reqn">Y_{Ai} = I(X_{Ai} \geq t)</code>, <code class="reqn">N_{Ai}(t) = I(X_{Ai} \leq t) \delta_{Ai},  K(\cdot)</code> is a smooth symmetric density function, <code class="reqn">K_h(x) = K(x/h)/h,</code> and <code class="reqn">\gamma(\cdot)</code> is a given monotone transformation function. We then estimate <code class="reqn">\Delta_{S}(t,t_0)</code> as
<code class="reqn">\hat{\Delta}_{S}(t,t_0) = n_B^{-1} \sum_{i=1}^{n_B} [\hat{\phi}_A(t|\hat{U}_{Bi},t_0) \frac{I(X_{Bi} &gt; t_0)}{\hat{W}^C_B(t_0)}  -   \frac{I(X_{Bi} &gt; t)}{\hat{W}^C_B(t)}]</code> and <code class="reqn">\hat{R}_{S}(t,t_0) =1- \hat{\Delta}_{S}(t,t_0)/\hat{\Delta}(t).</code> We refer to this estimate as the two-stage robust estimator (option 1 for type).
</p>
<p>The next estimator borrows ideas from the extensive causal inference literature focusing on double robust estimators  two-stage weighted estimator with a propensity score weight explicitly balancing the two treatment groups with respect to the distribution of <code class="reqn">S</code>. The weighting enables us to “adjust" the distribution of <code class="reqn">S^{(A)}</code> before constructing the conditional survival estimate <code class="reqn">\hat \phi_A(t|u, t_0).</code> This approach results in a double-robust estimator of <code class="reqn">\Delta_{S}(t, t_0)</code>, which is consistent when either <code class="reqn">U^{(A)}</code> captures all the information about the relationship between <code class="reqn">I(T^{(A)}\ge t)</code> and <code class="reqn">S^{(A)}</code> or the propensity score model for <code class="reqn">\pi(S,t_0)=P(G_i=B|S_i=S, T_{i} &gt; t_0)</code> is correctly specified. While <code class="reqn">\pi(S,t_0)</code> depends on <code class="reqn">t_0</code>, for simplicity, we drop <code class="reqn">t_0</code> from our notation and simply use <code class="reqn">\pi(S)</code>.
</p>
<p>Regression models can be imposed to obtain estimates for <code class="reqn">\pi(S)</code>. For example, a simple logistic regression model can be imposed for 
<code class="reqn">\tilde{\pi}(S)=P(G_i=B|S_i=S, X_{i}&gt;t_0)</code> with

<code class="reqn">logit\{\tilde{\pi}(S)\} = \alpha_0 + \alpha_1 ^{T} S,</code>
where <code class="reqn">\alpha_0</code> and <code class="reqn">\alpha_1</code> are estimated only among those with   <code class="reqn">X_{gi} &gt; t_0</code> to account for censoring. The propensity score of interest, <code class="reqn">\pi(S),</code> can be derived from <code class="reqn">\tilde{\pi}(S)</code> directly since 
<code class="reqn">logit\{\pi(S)\}=logit\{\tilde{\pi}(S)\} + \log\{W_A^C(t_0)/W_B^C(t_0)\},</code>
which follows from the assumption that <code class="reqn">(T_{gi}, S_{gi}) \perp C_{gi}.</code> We then modify  the above expression by weighting observations with the estimated <code class="reqn">L(S_{Ai})=\pi(S_{Ai})/\{1-\pi(S_{Ai})\}</code>  and obtain
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Lambda}^w_A(t|u, t_0)  = \int_{t_0}^t \frac{\sum_{i=1}^{n_A} \hat{L}(S_{Ai}) I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\}dN_{Ai}(z)}{\sum_{i=1}^{n_A}  \hat{L}(S_{Ai}) I(X_{Ai}&gt;t_0) K_h\{\gamma(\hat{U}_{Ai}) - \gamma(u)\} Y_{Ai}(z)},</code>
</p>
<p>,
where <code class="reqn">\hat{L}(S_{gi}) = \exp(\hat{\alpha}_0+\hat{\alpha}_1^{T} S_{gi})\hat{W}^C_B(t_0)/\hat{W}^C_A(t_0).</code>
</p>
<p>Subsequently, we define
<code class="reqn">\hat{\Delta}^w_{S}(t,t_0) = n_B^{-1} \sum_{i=1}^{n_B} [\hat{\phi}^w_A(t|\hat{U}_{Bi},t_0) \frac{I(X_{Bi} &gt; t_0)}{\hat{W}^C_B(t_0)}  -   \frac{I(X_{Bi} &gt; t)}{\hat{W}^C_B(t)}]</code> and <code class="reqn">\hat{R}^w_{S}(t,t_0) =1- \hat{\Delta}^w_{S}(t,t_0)/\hat{\Delta}(t)</code>
where <code class="reqn">\hat \phi^w_A(t|t_0,u)  = \exp\{-\hat{\Lambda}^w_A(t|t_0,u) \}.</code> We refer to this estimate as the weighted two-stage robust estimator (option 2 for type).
</p>
<p>While the two-stage weighted estimator reflects one way to enhance the robustness of an initial estimator, the idea of combining a propensity-score type model and a regression-type model has certainly been extensively studied in the causal inference literature and a more familiar double-robust estimator can be constructed as: <code class="reqn">\hat{\Delta}_{S}^{DR}(t,t_0)  = n^{-1} [\sum_{i=1}^{n_A}\frac{I(X_{Ai}&gt;t)}{\hat{W}_{A}^C(t)\bar{\pi}_B} \hat{L}(S_{Ai}) - \sum_{i=1}^{n_B} \frac{I(X_{Bi}&gt;t)}{\hat{W}_{B}^C(t)\bar{\pi}_B}  ]  - n^{-1} [ \sum_{i=1}^{n_A} \frac{ \hat{\phi}_A(t\mid\hat{U}_{Ai},t_0) I(X_{Ai} &gt; t_0) }{\hat{W}_{A}^C(t_0)\bar{\pi}_B}  \hat{L}(S_{Ai}) - \sum_{i=1}^{n_B}\frac{ \hat{\phi}_A(t\mid \hat{U}_{Bi},t_0) I(X_{Bi} &gt; t_0) }{\hat{W}_{B}^C(t_0)\bar{\pi}_B} ] </code>
and <code class="reqn">\hat{R}_{S}^{DR}(t,t_0) =1- \hat{\Delta}_{S}^{DR}(t,t_0)/\hat{\Delta}(t)</code>, where  <code class="reqn">\hat{\phi}_A(t|\hat{U}_{gi},t_0)</code> is the (unweighted) estimate of <code class="reqn">\phi_A(t\mid u,t_0)</code> used in <code class="reqn">\hat{\Delta}_{S}(t,t_0)</code>. We refer to this estimate as the double robust estimator (option 3 for type).
</p>
<p>The weighted estimator (option type 5) is defined as: 
<code class="reqn"> \hat{\Delta}^{PS}_{S}(t,t_0) =  n^{-1} \sum_{i=1}^n  \{\frac{I(X_{i}&gt;t)}{\hat{W}_{G_i}^C(t)\bar{\pi}_B}  [ I(G_i = A)\hat{L}(S_{Ai})   - I(G_i = B )  ]  \} </code>
and <code class="reqn">\hat{R}^{PS}_{S}(t,t_0) =1- \hat{\Delta}^{PS}_{S}(t,t_0)/\hat{\Delta}(t).</code> This estimator  completely relies on the correct specification of <code class="reqn">\pi(S)</code>. The double-robust model-based estimator (option 6 for type) is defined as <code class="reqn">\hat{\Delta}_{S}^{DR2}(t,t_0)</code>  and <code class="reqn">\hat{R}_{S}^{DR2}(t,t_0) =1- \hat{\Delta}_{S}^{DR2}(t,t_0)/\hat{\Delta}(t)</code> which are constructed parallel to the construction of  <code class="reqn">\hat{\Delta}_{S}^{DR}(t,t_0)</code> i.e., a combination of  <code class="reqn">\hat{\Delta}_{S}^M(t,t_0)</code> and <code class="reqn">\hat{R}^{PS}_{S}(t,t_0)</code>.
</p>
<p>Variance estimates are obtained using perturbation resampling. If a confidence interval is requested three versions are provided: a normal approximation based interval, a quantile based interval and Fieller's confidence interval, all using perturbation-resampling. An estimate of the incremental value of the surrogate marker information can also be requested; this essentially compared the proportion explained by the surrogate information vs. the proportion explained by <code class="reqn">T</code> alone up to <code class="reqn">t_0</code>. Details can be found in Parast, L., Cai, T., &amp; Tian, L. (2021). Evaluating multiple surrogate markers with censored data. Biometrics, 77(4), 1315-1327.
</p>


<h3>Value</h3>






<p>A list is returned:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>delta </code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}(t)</code>, described in delta.estimate documentation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.s </code></td>
<td>
<p>the residual treatment effect estimate, <code class="reqn">\hat{\Delta}_S(t,t_0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R.s </code></td>
<td>
<p>the estimated proportion of treatment effect explained by the set of markers, <code class="reqn">\hat{R}_S(t,t_0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.var </code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.s.var </code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R.s.var </code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.normal.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.quantile.delta.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_S(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.normal.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.quantile.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.fieller.R.s</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_S(t,t_0)</code> based on Fieller's approach; if conf.int = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.t </code></td>
<td>
<p>the estimate, <code class="reqn">\hat{\Delta}_T(t,t_0)</code>; if incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R.t </code></td>
<td>
<p>the estimated proportion of treatment effect explained by survival only, <code class="reqn">\hat{R}_T(t,t_0)</code>; if incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incremental.value</code></td>
<td>
<p>the estimate of the incremental value of the surrogate markers, <code class="reqn">\hat{IV}_S(t,t_0)</code>; if incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta.t.var </code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE and  incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R.t.var </code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{R}_T(t,t_0)</code>; if var = TRUE or conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incremental.value.var </code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{IV}_S(t,t_0)</code>; if var = TRUE or conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.normal.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.quantile.delta.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}_T(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.normal.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.quantile.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.fieller.R.t</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{R}_T(t,t_0)</code> based on Fieller's approach; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.normal.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)</code> based on a normal approximation; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int.quantile.iv</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{IV}_S(t,t_0)</code> based on sample quantiles of the perturbed values; if conf.int = TRUE and incremental.vaue = TRUE.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>If the treatment effect is not significant, the user will receive the following message: "Warning: it looks like the treatment effect is not significant; may be difficult to interpret the residual treatment effect in this setting".</p>


<h3>Author(s)</h3>


<p>Layla Parast
</p>


<h3>References</h3>


<p>Parast, L., Cai, T., &amp; Tian, L. (2017). Evaluating surrogate marker information using censored data. Statistics in Medicine, 36(11), 1767-1782.
</p>
<p>Parast, L., Cai, T., &amp; Tian, L. (2021). Evaluating multiple surrogate markers with censored data. Biometrics, 77(4), 1315-1327.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(d_example_multiple)
names(d_example_multiple)
## Not run: 
R.multiple.surv(xone = d_example_multiple$x1, xzero = d_example_multiple$x0, deltaone = 
d_example_multiple$delta1, deltazero = d_example_multiple$delta0, sone = 
as.matrix(d_example_multiple$s1), szero = as.matrix(d_example_multiple$s0), 
type =1, t = 1, landmark=0.5)
R.multiple.surv(xone = d_example_multiple$x1, xzero = d_example_multiple$x0, deltaone = 
d_example_multiple$delta1, deltazero = d_example_multiple$delta0, sone = 
as.matrix(d_example_multiple$s1), szero = as.matrix(d_example_multiple$s0), 
type =1, t = 1, landmark=0.5, conf.int = T)	
R.multiple.surv(xone = d_example_multiple$x1, xzero = d_example_multiple$x0, deltaone = 
d_example_multiple$delta1, deltazero = d_example_multiple$delta0, sone = 
as.matrix(d_example_multiple$s1), szero = as.matrix(d_example_multiple$s0), 
type =3, t = 1, landmark=0.5)

## End(Not run)
</code></pre>


</div>