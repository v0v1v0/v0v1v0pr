<div class="container">

<table style="width: 100%;"><tr>
<td>rq.group.pen.cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Performs cross validation for a group penalty.</h2>

<h3>Description</h3>

<p>Performs cross validation for a group penalty.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rq.group.pen.cv(
  x,
  y,
  tau = 0.5,
  groups = 1:ncol(x),
  lambda = NULL,
  a = NULL,
  cvFunc = NULL,
  nfolds = 10,
  foldid = NULL,
  groupError = TRUE,
  cvSummary = mean,
  tauWeights = rep(1, length(tau)),
  printProgress = FALSE,
  weights = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Matrix of predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector of responses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>Vector of group assignments for the predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Vector of lambda values, if set to NULL they will be generated automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Vector of the other tuning parameter values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvFunc</code></td>
<td>
<p>Function used for cross-validation error, default is quantile loss.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Number of folds used for cross validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>foldid</code></td>
<td>
<p>Fold assignments, if not set this will be randomly created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groupError</code></td>
<td>
<p>If errors are to be reported as a group or as the average for each fold.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cvSummary</code></td>
<td>
<p>The</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tauWeights</code></td>
<td>
<p>Weights for the tau penalty only used in group tau results (gtr).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printProgress</code></td>
<td>
<p>If set to TRUE will print which fold the process is working on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Weights for the quantile loss function. Used in both model fitting and cross-validation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters that will be sent to rq.group.pen().</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Two cross validation results are returned. One that considers the best combination of a and lambda for each quantile. The second considers the best combination of the tuning 
parameters for all quantiles. Let <code class="reqn">y_{b,i}</code>, <code class="reqn">x_{b,i}</code>, and <code class="reqn">m_{b,i}</code> index the response, predictors, and weights of observations in 
fold b. Let <code class="reqn">\hat{\beta}_{\tau,a,\lambda}^{-b}</code> be the estimator for a given quantile and tuning parameters that did not use the bth fold. Let <code class="reqn">n_b</code> be the number of observations in fold
b. Then the cross validation error for fold b is 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{CV}(b,\tau) = \frac{1}{n_b} \sum_{i=1}^{n_b} m_{b,i} \rho_\tau(y_{b,i}-x_{b,i}^\top\hat{\beta}_{\tau,a,\lambda}^{-b}).</code>
</p>

<p>Note that <code class="reqn">\rho_\tau()</code> can be replaced by a different function by setting the cvFunc parameter. The function returns two different cross-validation summaries. The first is btr, by tau results. 
It provides the values of <code>lambda</code> and <code>a</code> that minimize the average, or whatever function is used for <code>cvSummary</code>, of <code class="reqn">\mbox{CV}(b)</code>. In addition it provides the 
sparsest solution that is within one standard error of the minimum results. 
</p>
<p>The other approach is the group tau results, gtr. Consider the case of estimating Q quantiles of <code class="reqn">\tau_1,\ldots,\tau_Q</code> with quantile (tauWeights) of <code class="reqn">v_q</code>. The gtr returns the values of <code>lambda</code> and <code>a</code> that minimizes the average, or again whatever function is used for <code>cvSummary</code>, of 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{q=1}^Q v_q\mbox{CV}(b,\tau_q).</code>
</p>
<p> If only one quantile is modeled then the gtr results can be ignored as they provide the same minimum solution as btr.
</p>


<h3>Value</h3>

<p>An rq.pen.seq.cv object. 
</p>

<dl>
<dt>cverr</dt>
<dd>
<p>Matrix of cvSummary function, default is average, cross-validation error for each model, tau and a combination, and lambda.</p>
</dd>
<dt>cvse</dt>
<dd>
<p>Matrix of the standard error of cverr foreach model, tau and a combination, and lambda.</p>
</dd>
<dt>fit</dt>
<dd>
<p>The rq.pen.seq object fit to the full data.</p>
</dd>
<dt>btr</dt>
<dd>
<p>A data.table of the values of a and lambda that are best as determined by the minimum cross validation error and the one standard error rule, which fixes a. In btr the values of lambda and a are selected seperately for each quantile.</p>
</dd>
<dt>gtr</dt>
<dd>
<p>A data.table for the combination of a and lambda that minimize the cross validation error across all tau.</p>
</dd>
<dt>gcve</dt>
<dd>
<p>Group, across all quantiles, cross-validation error results for each value of a and lambda.</p>
</dd>
<dt>call</dt>
<dd>
<p>Original call to the function.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Ben Sherwood, <a href="mailto:ben.sherwood@ku.edu">ben.sherwood@ku.edu</a> and Shaobo Li <a href="mailto:shaobo.li@ku.edu">shaobo.li@ku.edu</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
x &lt;- matrix(rnorm(100*8,sd=1),ncol=8)
y &lt;- 1 + x[,1] + 3*x[,3] - x[,8] + rt(100,3)
g &lt;- c(1,1,1,1,2,2,3,3)
tvals &lt;- c(.25,.75)
## Not run: 
m1 &lt;- rq.group.pen.cv(x,y,tau=c(.1,.3,.7),groups=g)
m2 &lt;- rq.group.pen.cv(x,y,penalty="gAdLASSO",tau=c(.1,.3,.7),groups=g)
m3 &lt;- rq.group.pen.cv(x,y,penalty="gSCAD",tau=c(.1,.3,.7),a=c(3,4,5),groups=g)
m4 &lt;- rq.group.pen.cv(x,y,penalty="gMCP",tau=c(.1,.3,.7),a=c(3,4,5),groups=g)

## End(Not run)
</code></pre>


</div>