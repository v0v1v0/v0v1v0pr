<div class="container">

<table style="width: 100%;"><tr>
<td>Repository</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Repository Pattern</h2>

<h3>Description</h3>

<p>Mediates between the domain and data mapping layers using a
collection-like interface for accessing domain objects.
</p>


<h3>Details</h3>

<p>&lt;!– One line about what the function does –&gt;
</p>
<p>With <em><strong>Repository</strong></em>, in-memory objects do not need to know whether there is a
database present or absent, they need no SQL interface code, and certainly no
knowledge of the database schema.
</p>


<h4>How It Works</h4>


<ul>
<li> <p><strong>Repository</strong> isolates domain objects from details of the database access
code;
</p>
</li>
<li> <p><strong>Repository</strong> concentrates code of query construction; and
</p>
</li>
<li> <p><strong>Repository</strong> helps to minimize duplicate query logic.
</p>
</li>
</ul>
<p>In R, the simplest form of <strong>Repository</strong> encapsulates <code>data.frame</code> entries
persisted in a data store and the operations performed over them, providing a
more object-oriented view of the persistence layer. From the caller point of
view, the location (locally or remotely), the technology and the interface of
the data store are obscured.
</p>



<h4>When to Use It</h4>


<ul>
<li>
<p> In situations with multiple data sources.
</p>
</li>
<li>
<p> In situations where the real data store, the one that is used in production,
is remote. This allows you to implement a <strong>Repository</strong> mock with identical
queries that runs locally. Then, the mock could be used during development
and testing. The mock itself may comprise a sample of the real data store or
just fake data.
</p>
</li>
<li>
<p> In situations where the real data store doesn't exist. Implementing a mock
<strong>Repository</strong> allows you to defer immature decisions about the database
technology and/or defer its deployment. In this way, the temporary solution
allows you to focus the development effort on the core functionality of the
application.
</p>
</li>
<li>
<p> In situations where using SQL queries can be represented by meaningful
names. For example
<code style="white-space: pre;">⁠Repository$get_efficient_cars() = SELECT * FROM mtcars WHERE mpg &gt; 20⁠</code>
</p>
</li>
<li>
<p> When building <a href="https://www.oreilly.com/library/view/software-architects-handbook/9781788624060/c47a09b6-91f9-4322-a6d4-9bc1604b1bdf.xhtml">stateless microservices</a>.
</p>
</li>
</ul>
<h3>Super class</h3>

<p><code>R6P::Singleton</code> -&gt; <code>Repository</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Repository-new"><code>AbstractRepository$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Repository-add"><code>AbstractRepository$add()</code></a>
</p>
</li>
<li> <p><a href="#method-Repository-del"><code>AbstractRepository$del()</code></a>
</p>
</li>
<li> <p><a href="#method-Repository-get"><code>AbstractRepository$get()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul></ul></details><hr>
<a id="method-Repository-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Instantiate an object
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$new()</pre></div>


<hr>
<a id="method-Repository-add"></a>



<h4>Method <code>add()</code>
</h4>

<p>Add an element to the Repository.
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$add(key, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt>
<dd>
<p>(<code>character</code>) Name of the element.</p>
</dd>
<dt><code>value</code></dt>
<dd>
<p>(<code style="white-space: pre;">⁠?⁠</code>) Value of the element. Note: The values in the
<code>Repository</code> are not necessarily of the same type. That depends on the
implementation of <code>AbstractRepository</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Repository-del"></a>



<h4>Method <code>del()</code>
</h4>

<p>Delete an element from the Repository.
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$del(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt>
<dd>
<p>(<code>character</code>) Name of the element.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-Repository-get"></a>



<h4>Method <code>get()</code>
</h4>

<p>Retrieve an element from the Repository.
</p>


<h5>Usage</h5>

<div class="r"><pre>AbstractRepository$get(key)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt>
<dd>
<p>(<code>character</code>) Name of the element.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R"># See more examples at &lt;https://tidylab.github.io/R6P/articles&gt;

# The following implementation is a Repository of car models with their
# specifications.

# First, we define the class constructor, initialize, to establish a
# transient data storage.

# In this case we use a dictionary from the collections package
# &lt;https://randy3k.github.io/collections/reference/dict.html&gt;

# Second, we define the add, del and get functions that operate on the dictionary.

# As an optional step, we define the NULL object. In this case, rather then
# the reserved word NULL, the NULL object is a data.frame with 0 rows and
# predefined column.

TransientRepository &lt;- R6::R6Class(
    classname = "Repository", inherit = R6P::AbstractRepository, public = list(
        initialize = function() {private$cars &lt;- collections::dict()},
        add = function(key, value){private$cars$set(key, value); invisible(self)},
        del = function(key){private$cars$remove(key); invisible(self)},
        get = function(key){return(private$cars$get(key, default = private$NULL_car))}
    ), private = list(
        NULL_car = cbind(uid  = NA_character_, datasets::mtcars)[0,],
        cars = NULL
))

# Adding customised operations is also possible via the R6 set function.
# The following example, adds a query that returns all the objects in the database

TransientRepository$set("public", "get_all_cars", overwrite = TRUE, function(){
    result &lt;- private$cars$values() %&gt;% dplyr::bind_rows()
    if(nrow(result) == 0) return(private$NULL_car) else return(result)
})

# In this example, we use the mtcars dataset with a uid column that uniquely
# identifies the different cars in the Repository:
mtcars &lt;- datasets::mtcars %&gt;% tibble::rownames_to_column("uid")
head(mtcars, 2)

# Here is how the caller uses the Repository:

## Instantiate a repository object
repository &lt;- TransientRepository$new()

## Add two different cars specification to the repository
repository$add(key = "Mazda RX4", value = dplyr::filter(mtcars, uid == "Mazda RX4"))
repository$add(key = "Mazda RX4 Wag", value = dplyr::filter(mtcars, uid == "Mazda RX4 Wag"))

## Get "Mazda RX4" specification
repository$get(key = "Mazda RX4")

## Get all the specifications in the repository
repository$get_all_cars()

## Delete "Mazda RX4" specification
repository$del(key = "Mazda RX4")

## Get "Mazda RX4" specification
repository$get(key = "Mazda RX4")
</code></pre>


</div>