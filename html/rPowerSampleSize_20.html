<div class="container">

<table style="width: 100%;"><tr>
<td>Psirms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Computation of power for single step (Bonferroni) procedure.
</h2>

<h3>Description</h3>

<p>This function computes the power for an analysis of <code class="reqn">m</code> multiple
tests with a control of the q-gFWER by a Bonferroni procedure.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Psirms(r, m, p = m, nE, nCovernE = 1, delta, SigmaC, SigmaE,
alpha = 0.05, q = 1, asympt = FALSE,
maxpts = 25000, abseps = 0.001, releps = 0, nbcores = 1, LB = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>integer, r = 1, ..., m. Desired number of endpoints to be declared significant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>integer. Number of endpoints.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>integer, p = 1, ..., m. Indicates the number of false null hypotheses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nE</code></td>
<td>
<p>integer. Sample size for the experimental (test) group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCovernE</code></td>
<td>
<p>Ratio of <code>nC</code> over <code>nE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>vector of length <code>m</code> equal to <code>muE - muC - d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SigmaC</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary endpoints in the control group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SigmaE</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary
endpoints in the experimental (test) group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a value which corresponds to the chosen q-gFWER type-I control bound.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>integer. Value of 'q' (q=1,...,m) in the q-gFWER of Romano et
al., which is the probability to make at least <code>q</code> false
rejections. The default value <code>q=1</code> corresponds to the classical FWER control.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asympt</code></td>
<td>
<p>logical. <code>TRUE</code> for the use of the asymptotic approximation by a
multivariate normal distribution or <code>FALSE</code> for the multivariate
Student distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxpts</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>min(25000 * true.complexity, .Machine$integer.max)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code> function. But note that this might considerably increase the
computation time!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>abseps</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>max(0.001 / true.complexity, 1e-08)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code> function. But note that this might considerably increase the
computation time!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>releps</code></td>
<td>
<p>relative error tolerance as double used in the
<code>GenzBretz</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbcores</code></td>
<td>
<p>integer. Number of cores to use for parallel computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LB</code></td>
<td>
<p>logical. Should we use a load balancing parallel computation.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List with two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pow</code></td>
<td>
<p>The computed power.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error</code></td>
<td>
<p>The total sum of the absolute estimated errors for each call
to the <code>pmvt</code> (or <code>pmvnorm</code>) function. The number of such
calls is given (in the non exchangeable case) by the function <code>complexity</code>. Note that in the
exchangeable case, some probabilities are weighted. So an error
committed on such a probability is also inflated with the same weight. Note also that this global error does not take into account
the signs of the individual errors and is thus most certainly higher
than the true error. In other words, you are 99 percent sure that
the true power is between 'pow' - 'error' and 'pow' + 'error', but
it is also probably much closer to 'pow', particularly if the
complexity is large.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Results can differ from one time to another because the results of the
function <code>pmvt</code> are random.  If this is the case, you should
consider increasing <code>maxpts</code> and decreasing <code>abseps</code>.
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to <em>Statistics
in Medicine.</em> 
</p>
<p>Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850â€“1873.
</p>


<h3>See Also</h3>

<p><code>indiv.analysis</code>,
</p>


</div>