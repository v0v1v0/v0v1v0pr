<div class="container">

<table style="width: 100%;"><tr>
<td>ra4bayesmeta-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Reference Analysis for Bayesian Meta-Analysis
</h2>

<h3>Description</h3>

<p>Functionality for performing a principled reference analysis in the Bayesian normal-normal hierarchical model (NNHM) used for Bayesian meta-analysis.
Focuses on the choice of the prior for the between-study (heterogeneity) standard deviation <code class="reqn">\tau</code>.
Implements the methodology proposed in Ott et al. (2021).
</p>
<p>The posterior reference analysis applies the Hellinger distance
to quantify the informativeness
of an actual heterogeneity prior of interest by
comparing the corresponding marginal posteriors
(for different parameters in the NNHM)
with posterior benchmarks.
The prior reference analysis
quantifies the informativeness
of an actual heterogeneity prior given the data by
computing its Hellinger distance to prior benchmarks.
</p>
<p>The main posterior benchmark used is Jeffreys reference posterior
induced by a minimally informative improper reference prior (denoted by J) for the heterogeneity.
Two alternative proposals for additional posterior benchmarks are implemented.
The first, simpler proposal is described in Ott et al. (2021) and uses a benchmark induced by
an anti-conservative half-normal heterogeneity prior (denoted by HN0).
This benchmark allows us to discriminate between anti-conservative and conservative heterogeneity priors with respect to the reference prior.
The second, more involved proposal is introduced in the Supplementary Material of Ott et al. (2021) and uses up to four additional benchmarks induced by proper priors.
These benchmarks allow us to discriminate between strongly anti-conservative, reference affine, and strongly conservative heterogeneity priors.
All four benchmark priors belong to two closely related parametric families, the
so-called "square-root generalized conventional" (SGC) and
"inverse square-root generalized conventional" (SIGC) distributions,
which are derived from prior distributions for variance components
described in Berger &amp; Deely (1988).
Note that most of these prior benchmarks also depend on the data set considered.
</p>
<p>Functions which implement this second proposal use 3 benchmarks for the posterior reference analysis (Jeffreys reference posterior and two additional benchmarks induced by a highly anti-conservative heterogeneity prior SGC(<code class="reqn">m_{inf}</code>) and a highly conservative heterogeneity prior SIGC(<code class="reqn">M_{inf}</code>), respectively) and 5 benchmarks for the prior reference analysis (Jeffreys reference prior and 4 proper priors) and have a corresponding suffix <code>_3bm</code> or <code>_5bm</code>.
The corresponding functions without such a suffix implement the first proposal based on 2 heterogeneity benchmark priors (the half-normal and Jeffreys reference prior).
</p>














<p>The main functions <code>post_RA</code> and <code>post_RA_3bm</code>
perform the reference analysis at the posterior level based on a data frame as input.
The functions <code>fit_models_RA</code> and <code>fit_models_RA_5bm</code> compute the benchmark heterogeneity priors and
corresponding (marginal) posteriors for a given data frame.
The more flexible functions <code>post_RA_fits</code>
and <code>pri_RA_fits</code>
perform
the reference analysis at the posterior level
and prior level
based on the provided benchmark and actual model fits (of class <code>bayesmeta</code>),
so that alternative benchmarks heterogeneity priors can also be used.
Functions for plotting the densities of the heterogeneity priors and
marginal posteriors for different parameters are also provided.
The functions operate on data frames which are compatible with the bayesmeta R package on CRAN.
</p>


<h3>Details</h3>

<p>Package: ra4bayesmeta
</p>
<p>Type: Package
</p>
<p>Title: Reference Analysis for Bayesian Meta-Analysis
</p>
<p>Version: 1.0-8
</p>
<p>Date: 2023-10-06
</p>
<p>Author: Manuela Ott [aut, cre], Malgorzata Roos [aut]
</p>
<p>Maintainer: Manuela Ott &lt;manuela.c.ott@gmail.com&gt;
</p>
<p>Depends: bayesmeta
</p>
<p>License: GPL (&gt;=2)





</p>


<h3>Author(s)</h3>

<p>Manuela Ott, Malgorzata Roos
</p>
<p>Maintainer: Manuela Ott &lt;manuela.c.ott@gmail.com&gt;
</p>


<h3>References</h3>

<p>Ott, M., Plummer, M., Roos, M. (2021). How vague is vague?
How informative is informative? Reference analysis for
Bayesian meta-analysis. <em>Statistics in Medicine</em> <b>40</b>, 4505–4521.
<a href="https://doi.org/10.1002/sim.9076">doi:10.1002/sim.9076</a>
</p>
<p>Ott, M., Plummer, M., Roos, M. (2021). Supplementary Material:
How vague is vague? How informative is informative? Reference analysis for
Bayesian meta-analysis. <em>Statistics in Medicine</em>.
<a href="https://doi.org/10.1002/sim.9076">doi:10.1002/sim.9076</a>
</p>
<p>Berger, J. O., Deely, J. (1988). A Bayesian approach to ranking and selection of
related means with alternatives to analysis-of-variance methodology. <em>Journal of the
American Statistical Association</em> <b>83(402)</b>, 364–373.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># auricular acupuncture (AA) data set
data(aa)

# it takes several seconds to run each of the following functions
# posterior reference analysis
# for standard HN and HC heterogeneity priors
# using the HN0 and J benchmarks
post_RA(df=aa, tau.prior=
               list(function(t)dhalfnormal(t, scale=1),
                    function(t)dhalfcauchy(t, scale=1)))

# posterior reference analysis
# for standard HN and HC heterogeneity priors
# using 3 benchmarks (SGC(m_inf), J and SIGC(M_inf) priors)
post_RA_3bm(df=aa, tau.prior=
                   list(function(t)dhalfnormal(t, scale=1),
                        function(t)dhalfcauchy(t, scale=1)))


# plot the marginal posteriors for the effect mu
# using the HN0 and J benchmarks
plot_RA(df=aa, tau.prior=
               list(function(t)dhalfnormal(t, scale=1),
                    function(t)dhalfcauchy(t, scale=1)),
        type="post.mu", xlim=c(-1,1.5), ylim=c(0,2.5),
        legend=TRUE, legend.tau.prior=c("HN(1)", "HC(1)"))
         
</code></pre>


</div>