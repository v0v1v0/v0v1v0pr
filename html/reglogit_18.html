<div class="container">

<table style="width: 100%;"><tr>
<td>reglogit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Gibbs sampling for regularized logistic regression
</h2>

<h3>Description</h3>

<p>Regularized (multinomial) logistic regression
by Gibbs sampling implementing subtly different 
MCMC schemes with varying efficiency depending on the data type 
(binary v. binomial, say) and the desired estimator (regularized maximum
likelihood, or Bayesian maximum a posteriori/posterior mean, etc.) through a 
unified interface.
</p>


<h3>Usage</h3>

<pre><code class="language-R">reglogit(T, y, X, N = NULL, flatten = FALSE, sigma = 1, nu = 1,
      kappa = 1, icept = TRUE, normalize = TRUE, zzero = TRUE, 
      powerprior = TRUE, kmax = 442, bstart = NULL, lt = NULL, 
      nup = list(a = 2, b = 0.1), save.latents = FALSE, verb = 100)
regmlogit(T, y, X, flatten = FALSE, sigma = 1, nu = 1, kappa = 1, 
      icept=TRUE, normalize = TRUE, zzero = TRUE, powerprior = TRUE, 
      kmax = 442, bstart = NULL, lt = NULL, nup = list(a=2, b=0.1),
      save.latents = FALSE, verb=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>

<p>a positive integer scalar specifying the number of MCMC rounds
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p><code>reglogit</code> requires <code>logical</code> classification labels for Bernoulli 
data, or countsfor Binomial data; for the latter, <code>N</code> must also be specified.
<code>regmlogit</code> requires positive integer class labeels in <code>1:C</code> where
<code>C</code> is the number of classes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>a design <code>matrix</code> of predictors; can be a typical (dense) <code>matrix</code>
or a sparse <code>Matrix</code> object.  When the design matrix
is sparse (and is stored sparsely), this can produce a ~3x-faster execution via
a more efficient update for the beta parameter.  But when it is not sparse
(but is stored sparsely) the execution could be much slower
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>

<p>an optional integer vector of total numbers of replicate trials 
for each <code>X</code>-<code>y</code>, i.e., for Binomial data instead of Bernoulli
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flatten</code></td>
<td>

<p>a scalar <code>logical</code> that is only specified for Binomial data.  It
indicates if pre-processing code should flatten the Binomial
likelihood into a Bernoulli likelihood
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>

<p>weights on the regression coefficients in the lasso penalty.  The
default of <code>1</code> is sensible when <code>normalize = TRUE</code> since
then the estimator for <code>beta</code> is equivariant under rescaling
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>

<p>a non-negative scalar indicating the initial value of the penalty
parameter
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>

<p>a positive scalar specifying the multiplicity;  <code>kappa = 1</code>
provides samples from the Bayesian posterior distribution.  Larger
values of <code>kappa</code> facilitates a simulated annealing approach
to obtaining a regularized point estimator
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>icept</code></td>
<td>

<p>a scalar <code>logical</code> indicating if an (implicit) intercept should
be included in the model
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>

<p>a scalar logical which, if <code>TRUE</code>, causes each variable is standardized
to have unit L2-norm, otherwise it is left alone 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zzero</code></td>
<td>

<p>a scalar <code>logical</code> indicating if the latent <code>z</code> variables to be
sampled.  Therefore this indicator specifies if the cdf
representation (<code>zzero = FALSE</code>) or pdf representation
(otherwise) should be used
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>powerprior</code></td>
<td>

<p>a scalar <code>logical</code> indicating if the prior should be powered up
with multiplicity parameter <code>kappa</code> as well as the likelihood
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmax</code></td>
<td>

<p>a positive integer indicating the number replacing infinity in the
sum for mixing density in the generative expression for
<code>lambda</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bstart</code></td>
<td>

<p>an optional vector of length <code>p = ncol(X)</code> specifying initial
values for the regression coefficients <code>beta</code>.   Otherwise
standard normal deviates are used
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lt</code></td>
<td>

<p>an optional vector of length <code>n = nrow(X)</code> of initial values
for the <code>lambda</code> latent
variables.  Otherwise a vector of ones is used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nup</code></td>
<td>

<p>prior parameters <code>=list(a, b)</code> for the inverse Gamma distribution
prior for <code>nu</code>, or <code>NULL</code>, which causes <code>nu</code> to be fixed
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.latents</code></td>
<td>
<p> a scalar <code>logical</code> indicating wether or not
a trace of latent <code>z</code>, <code>lambda</code> and <code>omega</code> values should be saved
for each iteration.  Specify <code>save.latents=TRUE</code> for very large <code>X</code>
in order to reduce memory swapping on low-RAM machines </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>

<p>A positive integer indicating the number of MCMC rounds after which
a progress statement is printed.  Giving <code>verb = 0</code> causes no
statements to be printed
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These are the main functions in the package.  They support an omnibus
framework for simulation-based regularized logistic regression.  The
default arguments invoke a Gibbs sampling algorithm to sample from the
posterior distribution of a logistic regression model with
lasso-type (double-exponential) priors.  See the paper by Gramacy &amp;
Polson (2012) for details.  Both cdf and pdf implementations are
provided, which use slightly different latent variable
representations, resulting in slightly different Gibbs samplers.  These
methods extend the un-regularized methods of Holmes &amp; Held (2006)
</p>
<p>The <code>kappa</code> parameter facilitates simulated annealing (SA)
implementations in order to help find the MAP, and other point
estimators.  The actual SA algorithm is not provided in the package.
However, it is easy to string calls to this function, using the
outputs from one call as inputs to another, in order to establish a SA
schedule for increasing kappa values.
</p>
<p>The <code>regmlogit</code> function is a wrapper around the Gibbs sampler
inside <code>reglogit</code>, invoking <code>C-1</code> linked chains for <code>C</code>
classes, extending the polychotomous regression scheme outlined by 
Holmes &amp; Held (2006).  For an example with <code>regmlogit</code>, see
<code>predict.regmlogit</code>
</p>


<h3>Value</h3>

<p>The output is a <code>list</code> object of type <code>"reglogit"</code> or 
<code>"regmlogit"</code> containing a subset of the following fields;
for <code>"regmlogit"</code> everyhing is expanded by one dimension into
an <code>array</code> or <code>matrix</code> as appropriate.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>X </code></td>
<td>
<p> the input design <code>matrix</code>, possible adjusted by
normalization or intercept </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y </code></td>
<td>
<p> the input response variable </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta </code></td>
<td>
<p> a <code>matrix</code> of <code>T</code> sampled regression
coefficients on the original input scale </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z </code></td>
<td>
<p> if <code>zzero = FALSE</code> a <code>matrix</code> of latent
variables for the hierarchical cdf representation of the likelihood </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda </code></td>
<td>
<p> a <code>matrix</code> of latent variables for the
hierarchical (cdf or pdf) representation of the likelihood </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpost </code></td>
<td>
<p> a vector of log posterior probabilities of the parameters </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map </code></td>
<td>
<p> the <code>list</code> containing the maximum a' posterior
parameters; <code>out$map$beta</code> is on the original scale of the data  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa </code></td>
<td>
<p> the input multiplicity parameter </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omega </code></td>
<td>
<p> a <code>matrix</code> of latent variables for the
regularization prior</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Robert B. Gramacy <a href="mailto:rbg@vt.edu">rbg@vt.edu</a>
</p>


<h3>References</h3>

<p>R.B. Gramacy, N.G. Polson. “Simulation-based regularized
logistic regression”. (2012) Bayesian Analysis, 7(3), p567-590; 
arXiv:1005.3430; <a href="https://arxiv.org/abs/1005.3430">https://arxiv.org/abs/1005.3430</a>
</p>
<p>C. Holmes, K. Held (2006). “Bayesian Auxilliary Variable Models for
Binary and Multinomial Regression”. Bayesian Analysis, 1(1), p145-168. 
</p>


<h3>See Also</h3>

<p><code>predict.reglogit</code>, <code>predict.regmlogit</code>, 
<code>blasso</code> and <code>regress</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## load in the pima indian data
data(pima)
X &lt;- as.matrix(pima[,-9])
y &lt;- as.numeric(pima[,9])

## pre-normalize to match the comparison in the paper
one &lt;- rep(1, nrow(X))
normx &lt;- sqrt(drop(one %*% (X^2)))
X &lt;- scale(X, FALSE, normx)

## compare to the GLM fit
fit.logit &lt;- glm(y~X, family=binomial(link="logit"))
bstart &lt;- fit.logit$coef

## do the Gibbs sampling
T &lt;- 300 ## set low for CRAN checks; increase to &gt;= 1000 for better results
out6 &lt;- reglogit(T, y, X, nu=6, nup=NULL, bstart=bstart, normalize=FALSE)

## plot the posterior distribution of the coefficients
burnin &lt;- (1:(T/10)) 
boxplot(out6$beta[-burnin,], main="nu=6, kappa=1", ylab="posterior",
        xlab="coefficients", bty="n", names=c("mu", paste("b", 1:8, sep="")))
abline(h=0, lty=2)

## add in GLM fit and MAP with legend
points(bstart, col=2, pch=17)
points(out6$map$beta, pch=19, col=3)
legend("topright", c("MLE", "MAP"), col=2:3, pch=c(17,19))

## simple prediction
p6 &lt;- predict(out6, XX=X)
## hit rate
mean(p6$c == y)

##
## for a polychotomous example, with prediction, 
## see ? predict.regmlogit
##

## Not run: 
## now with kappa=10
out10 &lt;- reglogit(T, y, X, kappa=10, nu=6, nup=NULL, bstart=bstart, 
                            normalize=FALSE)

## plot the posterior distribution of the coefficients
par(mfrow=c(1,2))
boxplot(out6$beta[-burnin,], main="nu=6, kappa=1",  ylab="posterior",
        xlab="coefficients", bty="n",  names=c("mu", paste("b", 1:8, sep="")))
abline(h=0, lty=2) 
points(bstart, col=2, pch=17)
points(out6$map$beta, pch=19, col=3)
legend("topright", c("MLE", "MAP"), col=2:3, pch=c(17,19))
boxplot(out10$beta[-burnin,], main="nu=6, kappa=10",  ylab="posterior",
        xlab="coefficients", bty="n",  names=c("mu", paste("b", 1:8, sep="")))
abline(h=0, lty=2)
## add in GLM fit and MAP with legend
points(bstart, col=2, pch=17)
points(out10$map$beta, pch=19, col=3)
legend("topright", c("MLE", "MAP"), col=2:3, pch=c(17,19))

## End(Not run)

##
## now some binomial data
##

## Not run: 
## synthetic data generation
library(boot)
N &lt;- rep(20, 100)
beta &lt;- c(2, -3, 2, -4, 0, 0, 0, 0, 0)
X &lt;- matrix(runif(length(N)*length(beta)), ncol=length(beta))
eta &lt;- drop(1 + X %*% beta)
p &lt;- inv.logit(eta)
y &lt;- rbinom(length(N), N, p)

## run the Gibbs sampler for the logit -- uses the fast Binomial
## version; for a comparison, try flatten=FALSE
out &lt;- reglogit(T, y, X, N)

## plot the posterior distribution of the coefficients
boxplot(out$beta[-burnin,], main="binomial data",  ylab="posterior", 
       xlab="coefficients", bty="n",
       names=c("mu", paste("b", 1:ncol(X), sep="")))
abline(h=0, lty=2)

## add in GLM fit, the MAP fit, the truth, and a legend
fit.logit &lt;- glm(y/N~X, family=binomial(link="logit"), weights=N)
points(fit.logit$coef, col=2, pch=17)
points(c(1, beta), col=4, pch=16)
points(out$map$beta, pch=19, col=3)
legend("topright", c("MLE", "MAP", "truth"), col=2:4, pch=c(17,19,16))

## also try specifying a larger kappa value to pin down the MAP

## End(Not run)
</code></pre>


</div>