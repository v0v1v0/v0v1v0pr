<div class="container">

<table style="width: 100%;"><tr>
<td>RDLL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The RDLL reference class</h2>

<h3>Description</h3>

<p>The RDLL reference class implements the data structure doubly linked list (DLL).
</p>


<h3>Usage</h3>

<pre><code class="language-R">RDLL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A doubly linked list is an ordered list of elements with multiple operations.
The DLL is a powerful sequantial data structure in the sense that
it can be regarded as the generalized version of the data structures stack, queue, deque.
</p>
<p>The class <code>RDLL</code> inherits the <code>RDeque</code> class,
and therefor it has all the methods that <code>RDeque</code> has.
</p>
<p>The DLL is much more friendly and flexible as it offers more useful methods to help the user get access to its elements
than <code>RStack</code>, <code>RQueue</code> and <code>RDeque</code>.
See below its immutable methods and mutable methods.
</p>
<p>It is worth noting that the classes <code>RSet</code> inherits the RDLL class,
and therefor it has all the methods that the RDLL has.
</p>
<p>The elements in the DLL are not necessarily to be of the same type,
and they can be any R objects.
</p>


<h3>References</h3>

<p>For the details about the DLL data structure, see <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">DLL at Wikipedia</a>.
</p>


<h3>Immutable Methods</h3>

<p>The immutable methods do not change the instance.
</p>

<dl>
<dt><code>show(callback=function(val){print(val)}, ...)</code></dt>
<dd>
<p>The <code>show</code> method takes a funtion input (argument <code>callback</code>)
specifying how to handle the elements in the DLL.
It also takes <code>...</code> as the additional arguments for the <code>callback</code> function if any.
</p>
<p>By default, the <code>show</code> method prints the elements by using the <code>print</code> function.
</p>
<p><code>callback=function(val){print(val)}</code>
</p>
<p>You can see that <code>show</code> is powerful as it makes it possible to freely manipulate the elements in the DLL.
For example, you can define
</p>
<p><code>func &lt;- function(val, arg1, arg2){ do something here on val with arg1 and arg2 }</code>
</p>
<p>and then
</p>
<p><code>instance$show(func, arg1, arg2)</code>
</p>
<p>And you can also store the elements by using instances of reference classes.
For example,
</p>
<p><code>func &lt;- function(val, queue){ queue$enqueue(val) }</code>
</p>
<p>where <code>queue</code> is an instance of <code>RQueue</code>. The code can be
</p>
<p><code>queue &lt;- RQueue$new()</code>
</p>
<p><code>instance$show(func, queue)</code>
</p>
</dd>
<dt><code>elem_at(index)</code></dt>
<dd>
<p>It returns the element (a copy) at position <code>index</code> (a positive integer).
<code>index</code> must be a scalar, and if it is a vector of more than one element,
only the first element will be considered.
If the value of <code>index</code> is out of the bounds of the instance,
a <code>NULL</code> will be returned.
</p>
</dd>
<dt><code>peekleft()</code></dt>
<dd>
<p>See <code>RDeque</code>.
</p>
</dd>
<dt><code>peek()</code></dt>
<dd>
<p>See <code>RDeque</code>.
</p>
</dd>
</dl>
<h3>Mutable Methods</h3>

<p>The mutable methods change the instance.
</p>

<dl>
<dt><code>insert_at(index, val)</code></dt>
<dd>
<p>This function inserts a new element <code>val</code> at position <code>index</code>.
It returns <code>TRUE</code> if the insertion is successful,
and <code>FALSE</code> if the <code>index</code> is out of the bounds.
It will push all the elements at and after <code>index</code> rightward.
</p>
<p>Thus, suppose that <code>instance</code> is an instance of the class.
</p>
<p><code>insert_at(1, val)</code>
</p>
<p>is equivalent to <code>appendleft</code> in <code>RDeque</code>, and
</p>
<p><code>insert_at(instance$size+1, val)</code>
</p>
<p>is equivalent to <code>append</code> in <code>RDeque</code>,
<code>push</code> in <code>RStack</code>, and <code>enqueue</code> in <code>RQueue</code>.
</p>
</dd>
<dt><code>remove_at(index)</code></dt>
<dd>
<p>This function returns and removes the element at position <code>index</code>.
It returns <code>NULL</code> if the <code>index</code> is out of the bounds.
</p>
<p>Thus, suppose that <code>instance</code> is an instance of the class.
</p>
<p><code>remove_at(1, val)</code>
is equivalent to <code>popleft</code> in <code>RDeque</code>, and
</p>
<p><code>remove_at(instance$size, val)</code>
is equivalent to <code>pop</code> in <code>RDeque</code> and <code>RStack</code>,
and <code>dequeue</code> in <code>RQueue</code>.
</p>
</dd>
<dt><code>appendleft(..., collapse=NULL)</code></dt>
<dd>
<p>See <code>RDeque</code>.
</p>
</dd>
<dt><code>append(..., collapse=NULL)</code></dt>
<dd>
<p>See <code>RDeque</code>.
</p>
</dd>
<dt><code>popleft()</code></dt>
<dd>
<p>See <code>RDeque</code>.
</p>
</dd>
<dt><code>pop()</code></dt>
<dd>
<p>See <code>RDeque</code>.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p>RDeque, RSet, and R6DS for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### create a new instance

# to create a new instance of the class
dll &lt;- RDLL$new()

# the previous RDLL instance will be removed if you run
dll &lt;- RDLL$new(0, 1, 2, collapse=list(3, 4))
# the following sentence is equivalent to the above
dll &lt;- RDLL$new(0, 1, 2, 3, 4)
# where the numbers 0, 1, 2, 3, 4 are appended into the DLL

### immutable methods

# show
dll$show()

# elem_at
dll$elem_at(1)

# toList
tmp &lt;- dll$toList

### mutable methods

# insert_at
dll$insert_at(1, -1)
dll$insert_at(dll$size+1, "end")

# remove_at
for(iter in 1:dll$size) dll$remove_at(1)

</code></pre>


</div>