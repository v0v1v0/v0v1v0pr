<div class="container">

<table style="width: 100%;"><tr>
<td>glm.regu.path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularied M-estimation for fitting generalized linear models along a regularization path</h2>

<h3>Description</h3>

<p>This function implements regularized M-estimation for fitting generalized linear models with binary or contiunous responses 
along a regularization path.
</p>


<h3>Usage</h3>

<pre><code class="language-R">glm.regu.path(nrho = NULL, rho.seq = NULL, y, x, iw = NULL,
  loss = "cal", n.iter = 100, eps = 1e-06, tune.fac = 0.5,
  tune.cut = TRUE, ann.init = TRUE, nz.lab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nrho</code></td>
<td>
<p>The number of tuning parameters in a regularization path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho.seq</code></td>
<td>
<p>A vector of tuning parameters in a regularization path. If both <code>nrho</code> and <code>rho.seq</code> are specified, then <code>rho.seq</code> overrides <code>nrho</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">p</code> matix of covariates, excluding a constant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iw</code></td>
<td>
<p>An <code class="reqn">n</code> x <code class="reqn">1</code> weight vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>A loss function, which can be specified as "gaus" for continuous responses, or "ml" or "cal" for binary respones.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.iter</code></td>
<td>
<p>The maximum number of iterations allowed as in <code>glm.regu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>The tolerance used to declare convergence as in <code>glm.regu</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune.fac</code></td>
<td>
<p>The multiplier (factor) used to define rho.seq if only <code>nrho</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tune.cut</code></td>
<td>
<p>Logical; if <code>TRUE</code>, all smaller tuning parameters are skipped once non-convergence is found with a tuning parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ann.init</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the estimates from the previous tuning parameter are used as the inital value when fitting with the current tuning parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nz.lab</code></td>
<td>
<p>A <code class="reqn">p</code> x <code class="reqn">1</code> logical vector (useful for simulations), indicating which covariates are included when calculating the number of nonzero coefficients.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If not specified by users, the sequence of tuning parameters (i.e., the regularization path) is defined as a geometric series 
of length <code>nrho</code>, starting from the value which yields a zero solution, and then decreasing by a factor <code>tune.fac</code> successively.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>The vector of tuning parameters included in the regularization path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>non.conv</code></td>
<td>
<p>A vector indicating the non-convergene status found or imputed if <code>tune.cut=TRUE</code>, along the regularization path. 
For each tuning parameter, 0 indicates convergence, 1 non-convergence if exceeding <code>n.iter</code>, 2 non-convergence if exceeding <code>bt.lim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nz.all</code></td>
<td>
<p>A vector giving the numbers of nonzero coefficients estimated, along the regularization path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bet.all</code></td>
<td>
<p>A matrix giving estimated intercept and coefficients, column by column, along the regularization path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.all</code></td>
<td>
<p>A matrix giving fitted values, column by column, along the regularization path.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Tan, Z. (2020a) Regularized calibrated estimation of propensity scores with model misspecification and high-dimensional data, <em>Biometrika</em>, 107, 137–158.
</p>
<p>Tan, Z. (2020b) Model-assisted inference for treatment effects using regularized calibrated estimation with high-dimensional data, <em>Annals of Statistics</em>, 48, 811–837.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(simu.data)
n &lt;- dim(simu.data)[1]
p &lt;- dim(simu.data)[2]-2

y &lt;- simu.data[,1]
tr &lt;- simu.data[,2]
x &lt;- simu.data[,2+1:p]
x &lt;- scale(x)

### Example 1: linear regression
out.rgaus.path &lt;- glm.regu.path(rho.seq=c(.01, .02, .05, .1, .2, .5), y=y[tr==1], x=x[tr==1,], 
                                loss="gaus")

# the estimated intercept and coefficients; the first 10 are shown
out.rgaus.path$bet.all[1:10,]

### Example 2: logistic regression using likelihood loss
out.rml.path &lt;- glm.regu.path(rho.seq=c(.002, .005, .01, .02, .05, .1), y=tr, x=x, loss="ml")
out.rml.path$bet.all[1:10,]

### Example 3: logistic regression using calibration loss
out.rcal.path &lt;- glm.regu.path(rho.seq=c(.005, .01, .02, .05, .1, .2), y=tr, x=x, loss="cal")
out.rcal.path$bet.all[1:10,]


</code></pre>


</div>