<div class="container">

<table style="width: 100%;"><tr>
<td>ADmatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>AD matrix methods (sparse and dense)</h2>

<h3>Description</h3>

<p>Matrices (<strong>base</strong> package) and sparse matrices (<strong>Matrix</strong> package) can be used inside the <code>RTMB</code> objective function as part of the calculations. Behind the scenes these R objects are converted to AD representations when needed. AD objects have a temporary lifetime, so you probably won't see them / need to know them. The only important thing is which <em>methods</em> work for the objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'advector'
chol(x, ...)

## S3 method for class 'advector'
determinant(x, logarithm = TRUE, ...)

## S4 method for signature 'adcomplex'
eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE)

## S4 method for signature 'advector'
eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE)

## S4 method for signature 'advector'
svd(x, nu, nv, LINPACK = FALSE)

## S3 method for class 'adsparse'
t(x)

## S3 method for class 'adsparse'
x[...]

## S3 replacement method for class 'adsparse'
x[...] &lt;- value

## S4 method for signature 'adsparse,missing,missing'
diag(x)

## S4 method for signature 'advector'
expm(x)

## S4 method for signature 'adsparse'
expm(x)

## S4 method for signature 'adsparse'
dim(x)

## S4 method for signature 'anysparse,ad'
x %*% y

## S4 method for signature 'ad,anysparse'
x %*% y

## S4 method for signature 'adsparse,adsparse'
x %*% y

## S4 method for signature 'ad,ad'
x %*% y

## S4 method for signature 'ad,ad.'
tcrossprod(x, y)

## S4 method for signature 'ad,ad.'
crossprod(x, y)

## S4 method for signature 'advector'
cov2cor(V)

## S4 method for signature 'ad,ad.'
solve(a, b)

## S4 method for signature 'num,num.'
solve(a, b)

## S4 method for signature 'anysparse,ad.'
solve(a, b)

## S4 method for signature 'advector'
colSums(x, na.rm, dims)

## S4 method for signature 'advector'
rowSums(x, na.rm, dims)

## S3 method for class 'advector'
cbind(...)

## S3 method for class 'advector'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>matrix (sparse or dense)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>As cbind</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logarithm</code></td>
<td>
<p>Not used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symmetric</code></td>
<td>
<p>Logical; Is input matrix symmetric (Hermitian) ?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.values</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EISPACK</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nv</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LINPACK</code></td>
<td>
<p>Ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>Replacement value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>matrix (sparse or dense)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>Covariance matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>matrix, vector or missing</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical; Remove NAs while taping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Same as colSums and rowSums.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List (vectors/values) with <code>adcomplex</code> components.
</p>
<p>List (vectors/values) with <code>advector</code> components in symmetric case and <code>adcomplex</code> components otherwise.
</p>
<p>Object of class <code>advector</code> with a dimension attribute for dense matrix operations; Object of class <code>adsparse</code> for sparse matrix operations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>chol(advector)</code>: AD matrix cholesky
</p>
</li>
<li> <p><code>determinant(advector)</code>: AD log determinant
</p>
</li>
<li> <p><code>eigen(adcomplex)</code>: General AD eigen decomposition for complex matrices. Note that argument <code>symmetric</code> is <strong>not</strong> auto-detected so <strong>must</strong> be specified.
</p>
</li>
<li> <p><code>eigen(advector)</code>: AD eigen decomposition for real matrices. The non-symmetric case is redirected to the <code>adcomplex</code> method. Note that argument <code>symmetric</code> is <strong>not</strong> auto-detected so <strong>must</strong> be specified.
</p>
</li>
<li> <p><code>svd(advector)</code>: AD svd decomposition for real matrices.
</p>
</li>
<li> <p><code>t(adsparse)</code>: AD sparse matrix transpose. Re-directs to t,CsparseMatrix-method.
</p>
</li>
<li> <p><code>[</code>: AD sparse matrix subsetting. Re-directs to [-methods.
</p>
</li>
<li> <p><code>`[`(adsparse) &lt;- value</code>: AD sparse matrix subset assignment. Re-directs to [&lt;â€“methods.
</p>
</li>
<li> <p><code>diag(x = adsparse, nrow = missing, ncol = missing)</code>: AD sparse matrix diagonal extract. Re-directs to diag,CsparseMatrix-method.
</p>
</li>
<li> <p><code>expm(advector)</code>: AD matrix exponential
</p>
</li>
<li> <p><code>expm(adsparse)</code>: AD matrix exponential
</p>
</li>
<li> <p><code>dim(adsparse)</code>: AD sparse matrix dimension
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>x %*% y</code>: AD matrix multiply
</p>
</li>
<li> <p><code>tcrossprod(x = ad, y = ad.)</code>: AD matrix multiply
</p>
</li>
<li> <p><code>crossprod(x = ad, y = ad.)</code>: AD matrix multiply
</p>
</li>
<li> <p><code>cov2cor(advector)</code>: AD matrix cov2cor
</p>
</li>
<li> <p><code>solve(a = ad, b = ad.)</code>: AD matrix inversion and solve
</p>
</li>
<li> <p><code>solve(a = num, b = num.)</code>: AD matrix inversion and solve
</p>
</li>
<li> <p><code>solve(a = anysparse, b = ad.)</code>: Sparse AD matrix solve (not yet implemented)
</p>
</li>
<li> <p><code>colSums(advector)</code>: AD matrix (or array) colsums
</p>
</li>
<li> <p><code>rowSums(advector)</code>: AD matrix (or array) rowsums
</p>
</li>
<li> <p><code>cbind(advector)</code>: AD matrix column bind
</p>
</li>
<li> <p><code>rbind(advector)</code>: AD matrix row bind
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">F &lt;- MakeTape(function(x) matrix(1:9,3,3) %*% x, numeric(3))
F$jacobian(1:3)
F &lt;- MakeTape(function(x) Matrix::expm(matrix(x,2,2)), numeric(4))
F$jacobian(1:4)
F &lt;- MakeTape(det, diag(2)) ## Indirectly available via 'determinant'
F$jacobian(matrix(1:4,2))
</code></pre>


</div>