<div class="container">

<table style="width: 100%;"><tr>
<td>use.aux.urng-method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Use auxiliary random number generator for Runuran objects</h2>

<h3>Description</h3>

<p>Some UNU.RAN methods that are based on the rejection method can make
use of a second auxiliary uniform random number generator.
It is only used when a rejection has occurred, see below for details.
This allows to keep two streams of random variates (almost)
synchronized. This is in particular necessary for variance reduction
methods like common or antithetic random variates.
</p>
<p>[Advanced] – Use auxiliary URNG for rejection method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'unuran'
use.aux.urng(unr)
use.aux.urng(unr) &lt;- value
set.aux.seed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>unr</code></td>
<td>
<p>a <code>unuran</code> generator object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p><code>TRUE</code> when an auxiliary URNG is used,
<code>FALSE</code> when no auxiliary URNG is used (the default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>seed for the auxiliary URNG.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Variance reduction techniques like common or antithetic random
variates require correlated streams of non-uniform random variates.
Such streams can be easily created by means of the inversion method
using the same source of uniform random numbers (URNs).
However, the quantile function (inverse CDF) or even the CDF often is
not available in closed form and thus numerical method are required
that are expensive or only return approximate random numbers or both.
</p>
<p>On the other hand two streams of non-uniformly distributed random
variates are completely uncorrelated when the
acceptance-rejection method is used. Then the two streams run
“out-of-sync” when the first rejection occurs. 
</p>
<p>Schmeiser and Kachitvichyanukul, however, have shown that this problem
can be overcome when the proposal point is generated by inversion and
a fixed number <code class="reqn">k</code> of URNs is used for generating one non-uniform
random variate. This can be accomplished by means of a second
auxiliary stream of URNs which is used when the required number of
URNs exceeds <code class="reqn">k</code>.
</p>
<p>By this approach two streams of non-uniform random variates run
synchronized except when a rejection occurs in one of the two streams.
Therefore the two generated streams are respected mixtures of highly
correlated streams and independent streams.
The induced correlation thus decreases when the rejection constants of
the acceptance-rejection algorithms used for generating the two
streams increases.
</p>
<p>In UNU.RAN some of the acceptance-rejection algorithms make use of a
second auxiliary stream of URNs. It is implemented in one of the
following ways:
</p>

<ul>
<li>
<p>The primary uniform random number generator is used for the
first loop of the acceptance-rejection step. When a rejection occurs
the algorithms switches to auxiliary generator until the proposal
point is accepted.
Thus exactly <em>two</em> URNs from the primary generator are used to
generate one non-uniform random variate.
</p>
</li>
<li>
<p>The primary uniform random number generator is used just for the
first proposal point and then switches to the auxiliary generator
until the proposal point is accepted.
Thus exactly <em>one</em> URN from the primary generator is used to
generate one non-uniform random variate.
</p>
</li>
</ul>
<p>The call <code>use.aux.urng(unr)</code> returns <code>FALSE</code> if this feature
is disabled for Runuran generator object <code>unr</code> (the default)
and <code>TRUE</code> if this feature is enabled.
It auxiliary URNs are not supported at all for object <code>unr</code> then
<code>use.aux.urng(unr)</code> returns <code>NA</code>.
</p>
<p>The replacement method
<code>use.aux.urng(unr) &lt;- TRUE</code>
enables this feature for generator <code>unr</code>.
It can be disabled by means of
<code>use.aux.urng(unr) &lt;- FALSE</code>.
(One gets an error if this feature is not supported at all.)
</p>
<p>The seed of the auxiliary uniform random number generator can be set by
means of <code>set.aux.seed(seed)</code>. The auxiliary generator is
a combined multiple recursive generator (MRG31k3p) by
L'Ecuyer and Touzin and is built into package <span class="pkg">Runuran</span>.
Currently it cannot be replaced by some other generator. 
</p>


<h3>Value</h3>

<p><code>use.aux.urng</code> returns <br><code>TRUE</code>, if using the auxiliary generator is enabled, <br><code>FALSE</code>, it is disabled, and <br><code>NA</code>, if this feature does not exist at all.
</p>
<p><code>set.aux.seed</code> returns <code>NULL</code>, invisibly.
</p>


<h3>Methods</h3>

<p>Currently the following UNU.RAN methods support this feature.
(Currently the last four methods are only available via
<code>unuran.new</code>, see the UNU.RAN manual for more details.)
</p>

<table>
<tr>
<td style="text-align: left;">
    method name        </td>
<td style="text-align: left;"> Runuran call          </td>
<td style="text-align: left;"> URN per variate </td>
</tr>
<tr>
<td style="text-align: left;">
    “tdr” (ps)  </td>
<td style="text-align: left;"> <code>tdr.new</code> </td>
<td style="text-align: left;"> 2 </td>
</tr>
<tr>
<td style="text-align: left;">
    “arou” (ia) </td>
<td style="text-align: left;"> --                    </td>
<td style="text-align: left;"> 1 </td>
</tr>
<tr>
<td style="text-align: left;">
    “tabl” (ia=false) </td>
<td style="text-align: left;"> --              </td>
<td style="text-align: left;"> 2 </td>
</tr>
<tr>
<td style="text-align: left;">
    “tdr” (gw)  </td>
<td style="text-align: left;"> --                    </td>
<td style="text-align: left;"> 2 </td>
</tr>
<tr>
<td style="text-align: left;">
    “tdr” (ia)  </td>
<td style="text-align: left;"> --                    </td>
<td style="text-align: left;"> 1 </td>
</tr>
<tr>
<td style="text-align: left;">
    </td>
</tr>
<tr>
<td style="text-align: left;">
    inversion          </td>
<td style="text-align: left;">                       </td>
<td style="text-align: left;"> 1 </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
</tr>
</table>
<h3>Note</h3>

<p>Using an auxiliary uniform random number generator generator is
only useful if the rejection constant is close to 1.</p>


<h3>References</h3>

<p>W. H\"ormann, J. Leydold, and G. Derflinger (2004):
Automatic Nonuniform Random Variate Generation, Sect. 8.4.2.
Springer-Verlag, Berlin Heidelberg
</p>
<p>B. W. Schmeiser and V. Kachitvichyanukul (1986):
Correlation induction without the inverse transformation.
In: Proc. 1986 Winter Simulation Conf.,
J. Wilson, J. Henriksen, S. Roberts (eds.), 266-274.
</p>
<p>B. W. Schmeiser and V. Kachitvichyanukul (1990):
Non-inverse correlation induction: guidelines for algorithm
development.
J. Comput. Appl. Math. 31, 173-180.
</p>
<p>W. H\"ormann and G. Derflinger (1994):
Universal generators for correlation induction.
In: Compstat, Proceedings in Computational Statistics,
R. Dutter and W. Grossmann (eds.), 52-57.
</p>
<p>J. Leydold, E. Janka, and W. H\"ormann (2002):
Variants of Transformed Density Rejection and Correlation Induction.
In: Monte Carlo and Quasi-Monte Carlo Methods 2000,
K.-T. Fang, F. Hickernell, and H. Niederreiter (eds.),
345–356.
</p>
<p>P. L'Ecuyer and R. Touzin (2000):
Fast combined multiple recursive generators with multipliers of the
form a = +/- 2^q +/- 2^r.
In: J.A. Jones, R.R. Barton, K. Kang, and P.A. Fishwick (eds.),
Proc. 2000 Winter Simulation Conference, 683-689.
</p>


<h3>See Also</h3>

<p><code>tdr.new</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Create respective generators for normal and exponential distribution.
## Use method TDR
gen1 &lt;- tdrd.new(udnorm())
gen2 &lt;- tdrd.new(udexp())

## The two streams are independent even we use the same seed
set.seed(123); x1 &lt;- ur(gen1,1e5)
set.seed(123); x2 &lt;- ur(gen2,1e5)
cor(x1,x2)

## We can enable the auxiliary URNG and get correlated streams
use.aux.urng(gen1) &lt;- TRUE
use.aux.urng(gen2) &lt;- TRUE
set.seed(123); x1 &lt;- ur(gen1,1e5)
set.seed(123); x2 &lt;- ur(gen2,1e5)
cor(x1,x2)

## This feature can be disabled again
use.aux.urng(gen1)
use.aux.urng(gen1) &lt;- FALSE
use.aux.urng(gen2) &lt;- FALSE

## Notice that TDR cannot simply mixed with an inversion method
## as the number of URNG per random point differs
gen3 &lt;- pinvd.new(udexp())
set.seed(123); x3 &lt;- ur(gen3,1e5)
cor(x1,x3)

## But a trick would do this
set.seed(123); x3 &lt;- ur(gen3,2*1e5)
x3 &lt;- x3[seq(1,2*1e5,2)]
cor(x1,x3)
## or ...
set.seed(123); u3 &lt;- runif(2*1e5); u3 &lt;- u3[seq(1,2*1e5,2)]
x3 &lt;- uq(gen3,u3)
cor(x1,x3)

## Maybe method AROU is more appropriate
gen4 &lt;- unuran.new(udnorm(), "arou")
use.aux.urng(gen4) &lt;- TRUE
set.seed(123); x3 &lt;- ur(gen3,1e5)
set.seed(123); x4 &lt;- ur(gen4,1e5)
cor(x3,x4)

</code></pre>


</div>