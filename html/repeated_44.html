<div class="container">

<table style="width: 100%;"><tr>
<td>gar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Autoregression Models</h2>

<h3>Description</h3>

<p><code>gar</code> fits a first- or second-order generalized autoregression,
possibly with Kalman update over time (first-order only).
</p>


<h3>Usage</h3>

<pre><code class="language-R">gar(
  response = NULL,
  distribution = "normal",
  times = NULL,
  totals = NULL,
  censor = NULL,
  delta = NULL,
  mu = NULL,
  shape = NULL,
  depend = NULL,
  shfn = FALSE,
  common = FALSE,
  preg = NULL,
  pshape = NULL,
  pdepend = NULL,
  parch = NULL,
  arch = "square",
  transform = "identity",
  link = "identity",
  autocorr = "exponential",
  order = 1,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>A list of two or three column matrices with responses,
corresponding times, and possibly a censor indicator, for each individual,
one matrix or dataframe of responses, or an object of class,
<code>response</code> (created by <code>restovec</code>) or
<code>repeated</code> (created by <code>rmna</code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>The distribution to be fitted: binomial, Poisson,
exponential, negative binomial, mult Poisson, double Poisson, Consul
generalized Poisson, beta binomial, mult binomial, double binomial, normal,
inverse Gauss, logistic, gamma, Weibull, Cauchy, Laplace, Levy, Pareto,
beta, simplex, two-sided power, gen(eralized) gamma, gen(eralized)
logistic, Hjorth, Burr, gen(eralized) Weibull, gen(eralized) extreme value,
gen(eralized) inverse Gauss, power exponential, power variance function
Poisson, skew Laplace, or Student t. (For definitions of distributions, see
the corresponding [dpqr]distribution help.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>When response is a matrix, a vector of possibly unequally
spaced times when they are the same for all individuals or a matrix of
times. Not necessary if equally spaced. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>totals</code></td>
<td>
<p>An appropriate scalar, vector, or matrix of binomial totals
(only applicable for binomial, beta binomial, mult binomial, double
binomial). Ignored if response has class, <code>response</code> or
<code>repeated</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censor</code></td>
<td>
<p>If response is a matrix, a matrix of the same size containing
the censor indicator: 1=uncensored, 0=right-censored, -1=left-censored.
Ignored if response has class, <code>response</code> or <code>repeated</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement for each
response value, set to unity by default. For example, if a response is
measured to two decimals, <code>delta=0.01</code>. If the response has been
pretransformed, this must be multiplied by the Jacobian. This
transformation cannot contain unknown parameters. For example, with a log
transformation, <code>delta=1/y</code>. (The delta values for the censored
response are ignored.) The jacobian is calculated automatically for the
transform option. Ignored if response has class, <code>response</code> or
<code>repeated</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>A user-specified function of <code>pmu</code> giving the regression
equation for the location. It may also be a formula beginning with ~,
specifying either a linear regression function for the location parameter
in the Wilkinson and Rogers notation or a general function with named
unknown parameters. It must yield a value for each observation on each
individual.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>
<p>An optional user-specified shape regression function; this may
depend on the location (function) through its second argument, in which
case, <code>shfn</code> must be set to TRUE. It may also be a formula beginning
with ~, specifying either a linear regression function for the shape
parameter in the Wilkinson and Rogers notation or a general function with
named unknown parameters. If it contains unknown parameters, the keyword
<code>mu</code> may be used to specify a function of the location parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>depend</code></td>
<td>
<p>An optional user-specified regression function for the log
dependence parameter. It may also be a formula beginning with ~, specifying
either a linear regression function for the dependence parameter in the
Wilkinson and Rogers notation or a general function with named unknown
parameters. If used, <code>order</code> must be one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shfn</code></td>
<td>
<p>If TRUE, the supplied shape function depends on the location
function. The name of this location function must be the last argument of
the shape function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common</code></td>
<td>
<p>If TRUE, <code>mu</code> and <code>shape</code> must both be either
functions with, as argument, a vector of parameters having some or all
elements in common between them so that indexing is in common between them
or formulae with unknowns. All parameter estimates must be supplied in
<code>preg</code>. If FALSE, parameters are distinct between the two functions
and indexing starts at one in each function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preg</code></td>
<td>
<p>The initial parameter estimates for the location regression
function. If <code>mu</code> is a formula with unknown parameters, their
estimates must be supplied either in their order of appearance in the
expression or in a named list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pshape</code></td>
<td>
<p>Zero to two estimates for the shape parameters, depending on
the distribution, if <code>shape</code> is not a function; otherwise, estimates
for the parameters in this function, with one extra at the end for
three-parameter distributions. If <code>shape</code> is a formula with unknown
parameters, their estimates must be supplied either in their order of
appearance in the expression or in a named list (only for two-parameter
distributions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdepend</code></td>
<td>
<p>One or two estimates of the dependence parameters for the
Kalman update. With one, it is Markovian and, with two, it is
nonstationary. For the latter, the <code>order</code> must be one. If
<code>depend</code> is a function or formula, the corresponding number of
estimates must be supplied. Either pdepend or parch or both must be
supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parch</code></td>
<td>
<p>Estimate for an ARCH model where the shape parameter depends
on the square of the previous residual. Either pdepend or parch or both
must be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arch</code></td>
<td>
<p>If <code>square</code>, then <code>shape+parch^diff*residual^2</code>; if
<code>absolute value</code>, then <code>shape+parch^diff*|residual|</code>; if
<code>exponential</code>, then <code>shape*exp(parch*residual^2*diff)</code>, where
<code>diff</code> is the length of time since the previous observation and
<code>residual</code> is the previous residual or innovation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>Transformation of the response variable: <code>identity</code>,
<code>exp</code>, <code>square</code>, <code>sqrt</code>, or <code>log</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>Link function for the mean: <code>identity</code>, <code>exp</code>,
<code>square</code>, <code>sqrt</code>, <code>log</code>, <code>logit</code>, <code>cloglog</code> or
<code>loglog</code> (last three only for binary/binomial-type data).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autocorr</code></td>
<td>
<p>The form of the (second if two) dependence function:
<code>exponential</code> is the usual <code class="reqn">\rho^{|t_i-t_j|}</code>;
<code>gaussian</code> is <code class="reqn">\rho^{(t_i-t_j)^2}</code>;
<code>cauchy</code> is <code class="reqn">1/(1+\rho(t_i-t_j)^2)</code>;
<code>spherical</code> is
<code class="reqn">((|t_i-t_j|\rho)^3-3|t_i-t_j|\rho+2)/2</code>
for <code class="reqn">|t_i-t_j|\leq1/\rho</code> and zero otherwise;
<code>IOU</code> is the integrated Ornstein-Uhlenbeck process, <code class="reqn">(2\rho
\min(t_i,t_j)+\exp(-\rho t_i) </code><code class="reqn">+\exp(-\rho t_j)-1
-\exp(\rho|ti-t_j|))/2\rho^3</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>First- or second-order stationary autoregression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code>finterp</code>.)
</p>
<p>Marginal and individual profiles can be plotted using
<code>mprofile</code> and <code>iprofile</code> and
residuals with <code>plot.residuals</code>.
</p>
<p>When the dispersion parameter is not constant over time, <code>volatility</code>
extracts the square root of the dispersion parameter for a fitted model.
</p>


<h3>Value</h3>

<p>A list of classes <code>gar</code> and <code>recursive</code> is returned that
contains all of the relevant information calculated, including error codes.
</p>
<p>The volatility vector for models with a shape regression function and ARCH
models contains the square root of the dispersion parameter at each time
point.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>References</h3>

<p>Lindsey, J.K. (1997) Applying Generalized Linear Models.
Springer, pp.\ 93–101
</p>
<p>Lambert, P. (1996) Statistics in Medicine 15, 1695-1708
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# first-order one-compartment model
# data objects for formulae
dose &lt;- c(2,5)
dd &lt;- tcctomat(dose)
times &lt;- matrix(rep(1:20,2), nrow=2, byrow=TRUE)
tt &lt;- tvctomat(times)
# vector covariates for functions
dose &lt;- c(rep(2,20),rep(5,20))
times &lt;- rep(1:20,2)
# functions
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
                                    (exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
# response
conc &lt;- matrix(rgamma(40,shape(log(c(0.1,0.4))),
                      scale=mu(log(c(1,0.3,0.2))))/shape(log(c(0.1,0.4))),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
                                                   ncol=20,byrow=TRUE)[,1:19])
conc &lt;- restovec(ifelse(conc&gt;0,conc,0.01),name="conc")
reps &lt;- rmna(conc, ccov=dd, tvcov=tt)
# constant shape parameter
gar(conc, dist="gamma", times=1:20, mu=mu,
    preg=log(c(1,0.4,0.1)), pdepend=0.5, pshape=1)
## Not run: # or
gar(conc, dist="gamma", times=1:20, mu=~exp(absorption-volume)*
      dose/(exp(absorption)-exp(elimination))*
      (exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
    preg=list(absorption=1,elimination=log(0.4),volume=log(0.1)),
    pdepend=0.5, pshape=1, envir=reps)
# generalized gamma distribution
gar(conc, dist="gen gamma", times=1:20, mu=mu,
    preg=log(c(1,0.4,0.1)), pdepend=0.3, pshape=c(.1,1))
# (if the covariates contained NAs, reps would have to be used as
# response instead of conc)
#
# time dependent shape parameter
gar(conc, dist="gamma", times=1:20, mu=mu, shape=shape,
    preg=log(c(1,0.4,0.1)), pdepend=0.25, pshape=c(exp(-2),exp(-.57)))
# or
gar(conc, dist="gamma", times=1:20, mu=~exp(absorption-volume)*
      dose/(exp(absorption)-exp(elimination))*
      (exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
    shape=~exp(b1-b2)*times*dose*exp(-exp(b1)*times),
    preg=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
    pdepend=0.3, pshape=list(b1=exp(-2),b2=exp(-.57)), envir=reps)
# generalized gamma distribution
gar(conc, dist="gen gamma", times=1:20, mu=mu, shape=shape,
    preg=log(c(1,0.4,0.1)), pdepend=0.5,
    pshape=c(exp(-2),exp(-.57),2))
#
# shape function depends on location parameter
shape &lt;- function(p, mu) p[1]+p[2]*mu
gar(conc, dist="gamma", times=1:20, mu=mu, shape=shape, shfn=TRUE,
    preg=log(c(1,0.4,.10)), pdepend=0.15, pshape=c(1,2))
# or
gar(conc, dist="gamma", times=1:20, mu=mu, shape=~a+d*mu, shfn=TRUE,
    preg=log(c(1,0.4,.10)), pdepend=0.15, pshape=c(1,2))


## End(Not run)    
</code></pre>


</div>