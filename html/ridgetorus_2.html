<div class="container">

<table style="width: 100%;"><tr>
<td>ridge_curve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fourier-fitted ridge curve and related utilities</h2>

<h3>Description</h3>

<p>Given the angles <code>theta</code> in <code class="reqn">[-\pi, \pi)</code>,
<code>ridge_curve</code> computes the Fourier-fitted ridge curve
<code class="reqn">(\theta, r_1(\theta))</code> or <code class="reqn">(r_2(\theta), \theta)</code>, where
</p>
<p style="text-align: center;"><code class="reqn">r_j(\theta):=\mathrm{atan2}(S_m (\theta),
C_m (\theta))</code>
</p>
<p> with <code class="reqn">C_m(x) :=
a_0/2 + \sum_{k=1}^m a_k \cos(kx)</code> and <code class="reqn">S_m(x) :=
\sum_{k=1}^m b_k \sin(kx)</code> for <code class="reqn">j = 1,2</code>. <code>der_ridge_curve</code> and
<code>dist_ridge_curve</code> compute the derivatives of and the distances along
these curves, respectively. <code>alpha_ridge_curve</code> provides a uniform
grid of the ridge curve using the arc-length parametrization.
<code>proj_ridge_curve</code> gives the ridge's <code class="reqn">\theta</code> for which the curve
is closer to any point on <code class="reqn">[-\pi, \pi)^2</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ridge_curve(
  theta,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  at2 = TRUE
)

der_ridge_curve(
  theta,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  norm = NULL,
  at2 = TRUE
)

dist_ridge_curve(
  alpha,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  der = TRUE,
  shortest = TRUE,
  at2 = TRUE
)

arclength_ridge_curve(
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  L = 500,
  at2 = TRUE
)

proj_ridge_curve(
  x,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  ridge_curve_grid = NULL,
  arclength = FALSE,
  at2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>vector <code class="reqn">\theta</code> of size <code>nth</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a vector of size <code>2</code> giving <code class="reqn">(\mu_1, \mu_2)</code>. Defaults
to <code>c(0, 0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>list of coefficients <code>cos_a</code> (<code class="reqn">a_k</code>) and
<code>sin_b</code> (<code class="reqn">b_k</code> giving the Fourier fit of the ridge curve.
Defaults to <code>list(cos_a = c(0, 0), sin_b = 0)</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_var</code></td>
<td>
<p>index <code class="reqn">j</code> of the variable that parametrizes the ridge.
Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at2</code></td>
<td>
<p>do the <code>atan2</code> fit instead of the sine fit (only using
<code class="reqn">S_m</code>)? Defaults to <code>TRUE</code>. <code>at2 = FALSE</code> is not
recommended to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>normalize tangent vectors? If different from <code>NULL</code>
(the default), the vectors are normalized to have the given <code>norm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a vector of size <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of discretization points for approximating curve lengths.
Defaults to <code>5e2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>der</code></td>
<td>
<p>use derivatives to approximate curve lengths? Defaults to
<code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shortest</code></td>
<td>
<p>return the shortest possible distance? Defaults to
<code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>number of discretization points for computing the arc-length
parametrization curve lengths. Defaults to <code>5e2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of size <code>c(nx, 2)</code> with angular coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ridge_curve_grid</code></td>
<td>
<p>if provided, the <code>ridge_curve</code> evaluated at
a grid of size <code>N</code>. If not provided, it is computed internally.
Useful for saving computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arclength</code></td>
<td>
<p>use the arc-length parametrization to compute the
projections? This yields a more uniform grid for searching the projections.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li> <p><code>ridge_curve</code>: a matrix of size <code>c(nth, 2)</code> with the ridge
curve evaluated at <code>theta</code>.
</p>
</li>
<li> <p><code>der_ridge_curve</code>: a matrix of size <code>c(nth, 2)</code> with the
derivatives of the ridge curve evaluated at <code>theta</code>.
</p>
</li>
<li> <p><code>dist_ridge_curve</code>: the distance between two points along
the ridge curve, a non-negative scalar.
</p>
</li>
<li> <p><code>proj_ridge_curve</code>: a list with (1) the <code>theta</code>'s that
give the points in the ridge curve that are the closest (in the flat torus
distance) to <code>x</code> (a matrix of size <code>c(nx, 2)</code>); (2) the indexes
of <code>ridge_curve_grid</code> in which those <code>theta</code>'s were obtained.
</p>
</li>
<li> <p><code>arclength_ridge_curve</code>: a vector of size <code>N</code> giving the
<code>theta</code> angles that yield a uniform-length grid of the ridge curve.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">mu &lt;- c(-0.5, 1.65)
th &lt;- seq(-pi, pi, l = 200)
K &lt;- 5
coefs &lt;- list(cos_a = 1 / (1:(K + 1))^3, sin_b = 1 / (1:K)^3)
rid1 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 1)
rid2 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 2)
plot(mu[1], mu[2], xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
     xlab = expression(theta[1]), ylab = expression(theta[2]),
     pch = "*", col = 5, cex = 3)
sdetorus::linesTorus(rid1[, 1], rid1[, 2], col = 1)
sdetorus::linesTorus(rid2[, 1], rid2[, 2], col = 2)
abline(v = mu[1], lty = 3, col = 5)
abline(h = mu[2], lty = 3, col = 5)
points(ridge_curve(theta = mu[1], mu = mu, coefs = coefs, ind_var = 1),
       col = 1)
points(ridge_curve(theta = mu[2], mu = mu, coefs = coefs, ind_var = 2),
       col = 2)
sdetorus::torusAxis()

## der_ridge_curve

th &lt;- seq(-pi, pi, l = 10)
mu &lt;- c(0.5, 1.5)
K &lt;- 5
coefs &lt;- list(cos_a = 1 / (1:(K + 1))^3, sin_b = 1 / (1:K)^3)
rid1 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 1)
rid2 &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 2)
v1 &lt;- der_ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 1,
                      norm = 0.5)
v2 &lt;- der_ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = 2,
                      norm = 0.5)
points(rid1, pch = 16, col = 1)
points(rid2, pch = 16, col = 2)
arrows(x0 = rid1[, 1], y0 = rid1[, 2],
       x1 = (rid1 + v1)[, 1], y1 = (rid1 + v1)[, 2],
       col = 3, angle = 5, length = 0.1)
arrows(x0 = rid2[, 1], y0 = rid2[, 2],
       x1 = (rid2 + v2)[, 1], y1 = (rid2 + v2)[, 2],
       col = 4, angle = 5, length = 0.1)

## dist_ridge_curve

# Distances accuracy
a &lt;- c(-pi / 2, pi)
mu &lt;- c(-pi / 2, pi / 2)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = TRUE, N = 1e6)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = FALSE, N = 1e6)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = TRUE, N = 1e2)
dist_ridge_curve(alpha = a, mu = mu, coefs = coefs, der = FALSE, N = 1e2)

## arclength_ridge_curve

mu &lt;- c(-pi / 2, pi / 2)
alpha &lt;- arclength_ridge_curve(mu = mu, coefs = coefs, ind_var = 1, N = 25)
alpha &lt;- sdetorus::toPiInt(c(alpha, alpha[1]))
rid &lt;- ridge_curve(theta = alpha, mu = mu, coefs = coefs, ind_var = 1)
plot(mu[1], mu[2], pch = "*", col = 5, cex = 3, xlim = c(-pi, pi),
     ylim = c(-pi, pi), axes = FALSE, xlab = expression(theta[1]),
     ylab = expression(theta[2]))
sdetorus::linesTorus(rid[, 1], rid[, 2], col = 1, pch = 16)
points(rid[, 1], rid[, 2], pch = 16, col = 1)
abline(v = mu[1], lty = 3, col = 5)
abline(h = mu[2], lty = 3, col = 5)
sdetorus::torusAxis()

## proj_ridge_curve

mu &lt;- c(0, 0)
n &lt;- 25
x &lt;- matrix(runif(2 * n, -pi, pi), nrow = n, ncol = 2)
col &lt;- rainbow(n)
th &lt;- seq(-pi, pi, l = 100)
old_par &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
for (j in 1:2) {

  plot(x, xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
       xlab = expression(theta[1]), ylab = expression(theta[2]), col = col)
  rid &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = j)
  sdetorus::linesTorus(x = rid[, 1], y = rid[, 2], lwd = 2)
  abline(v = mu[1], lty = 3)
  abline(h = mu[2], lty = 3)
  points(mu[1], mu[2], pch = "*", cex = 3)
  sdetorus::torusAxis()
  theta_projs &lt;- proj_ridge_curve(x = x, mu = mu, coefs = coefs, ind_var = j,
                                  ridge_curve_grid = rid)$theta_proj
  projs &lt;- ridge_curve(theta = theta_projs, mu = mu, coefs = coefs,
                       ind_var = j)
  points(projs, col = col, pch = 3)
  for (i in 1:n) {

    sdetorus::linesTorus(x = c(x[i, 1], projs[i, 1]),
                         y = c(x[i, 2], projs[i, 2]), col = col[i], lty = 3)

  }

}
par(old_par)
</code></pre>


</div>