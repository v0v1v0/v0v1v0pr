<div class="container">

<table style="width: 100%;"><tr>
<td>RRphylo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evolutionary rates computation along phylogenies</h2>

<h3>Description</h3>

<p>The function <code>RRphylo</code> (<cite>Castiglione et al.
2018</cite>) performs the phylogenetic ridge regression. It takes a tree and a
vector of tip data (phenotypes) as entries, calculates the regularization
factor, produces the matrices of tip to root (<code>makeL</code>), and
node to root distances (<code>makeL1</code>), the vector of ancestral
state estimates, the vector of predicted phenotypes, and the rates vector
for all the branches of the tree. For multivariate data, rates are given as
both one vector per variable, and as a multivariate vector obtained by
computing the Euclidean Norm of individual rate vectors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RRphylo(tree,y,cov=NULL,rootV=NULL,aces=NULL,x1=NULL,
  aces.x1=NULL,clus=0.5,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>a phylogenetic tree. The tree needs not to be ultrametric or
fully dichotomous.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>either a single vector variable or a multivariate dataset. In any
case, <code>y</code> must be named. In case of categorical variable, this should
be supplied to the function as a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>the covariate to be indicated if its effect on the rates must be
accounted for. In this case residuals of the covariate versus the rates are
used as rates. <code>'cov'</code> must be as long as the number of nodes plus the
number of tips of the tree, which can be obtained by running <code>RRphylo</code>
on the covariate as well, and taking the vector of ancestral states and tip
values to form the covariate, as in the example below. See
<a href="../doc/RRphylo.html#covariate">RRphylo vignette - covariate</a> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rootV</code></td>
<td>
<p>phenotypic value (values if multivariate) at the tree root. If
<code>rootV=NULL</code> the function 'learns' about the root value from the 10%
tips being closest in time to the tree root, weighted by their temporal
distance from the root itself (close tips phenotypes weigh more than more
distant tips).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aces</code></td>
<td>
<p>a named vector (or matrix if <code>y</code> is multivariate) of
ancestral character values at nodes. Names correspond to the nodes in the
tree. See <a href="../doc/RRphylo.html#aces">RRphylo vignette - aces</a> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>the additional predictor(s) to be indicated to perform the multiple
version of <code>RRphylo</code>. <code>'x1'</code> vector/matrix must be as long as the
number of nodes plus the number of tips of the tree, which can be obtained
by running <code>RRphylo</code> on the predictors (separately for each predictor)
as well, and taking the vector of ancestral states and tip values to form
the <code>x1</code>. See <a href="../doc/RRphylo.html#predictor">RRphylo vignette -
predictor</a> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aces.x1</code></td>
<td>
<p>a named vector/matrix of ancestral character values at nodes
for <code>x1</code>. It must be indicated if both <code>aces</code> and <code>x1</code> are
specified. Names/rownames correspond to the nodes in the tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clus</code></td>
<td>
<p>the proportion of clusters to be used in parallel computing.
Default is 0.5. To run the single-threaded version of <code>RRphylo</code> set
<code>clus</code> = 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical indicating whether a "RRlog.txt" printing progresses
should be stored into the working directory.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><strong>tree</strong> the tree used by <code>RRphylo</code>. The fully dichotomous
version of the tree argument. For trees with polytomies, the tree is
resolved by using <code>multi2di</code> function in the package <span class="pkg">ape</span>. Note,
tip labels are ordered according to their position in the tree.
</p>
<p><strong>tip.path</strong> a <code class="reqn">n * m</code> matrix, where n=number of tips and
m=number of branches (i.e. 2*n-1). Each row represents the branch lengths
along a root-to-tip path.
</p>
<p><strong>node.path</strong> a <code class="reqn">n * n</code> matrix, where n=number of internal
branches. Each row represents the branch lengths along a root-to-node path.
</p>
<p><strong>rates</strong> single rate values computed for each branch of the
tree. If <code>y</code> is a single vector variable, rates are equal to
multiple.rates. If <code>y</code> is a multivariate dataset, rates are computed
as the square root of the sum of squares of each row of
<code>$multiple.rates</code>.
</p>
<p><strong>aces</strong> the phenotypes reconstructed at nodes.
</p>
<p><strong>predicted.phenotypes</strong> the vector of estimated tip values. It
is a matrix in the case of multivariate data.
</p>
<p><strong>multiple.rates</strong> a <code class="reqn">n * m</code> matrix, where n= number of
branches (i.e. n*2-1) and m = number of variables. For each branch, the
column entries represent the evolutionary rate.
</p>
<p><strong>lambda</strong> the regularization factor fitted within
<code>RRphylo</code> by the inner function <code>optL</code>. With multivariate data,
several <code>optL</code> runs are performed. Hence, the function provides a
single lambda for each individual variable.
</p>
<p><strong>ace.values</strong> if <code>aces</code> are specified, the function
returns a dataframe containing the corresponding node number on the
<code>RRphylo</code> tree  for each node , along with estimated values.
</p>
<p><strong>x1.rate</strong> if <code>x1</code> is specified, the function returns the
partial regression coefficient for <code>x1</code>.
</p>


<h3>Author(s)</h3>

<p>Pasquale Raia, Silvia Castiglione, Carmela Serio, Alessandro
Mondanaro, Marina Melchionna, Mirko Di Febbraro, Antonio Profico, Francesco
Carotenuto
</p>


<h3>References</h3>

<p>Castiglione, S., Tesone, G., Piccolo, M., Melchionna, M.,
Mondanaro, A., Serio, C., Di Febbraro, M., &amp; Raia, P.(2018). A new method
for testing evolutionary rate variation and shifts in phenotypic evolution.
<em>Methods in Ecology and Evolution</em>, 9:
974-983.doi:10.1111/2041-210X.12954
</p>
<p>Serio, C., Castiglione, S., Tesone, G., Piccolo, M., Melchionna,
M., Mondanaro, A., Di Febbraro, M., &amp; Raia, P.(2019). Macroevolution of
toothed whales exceptional relative brain size. <em>Evolutionary
Biology</em>, 46: 332-342. doi:10.1007/s11692-019-09485-7
</p>
<p>Melchionna, M., Mondanaro, A., Serio, C., Castiglione, S., Di
Febbraro, M., Rook, L.,Diniz-Filho,J.A.F., Manzi, G., Profico, A.,
Sansalone, G., &amp; Raia, P.(2020).Macroevolutionary trends of brain mass in
Primates. <em>Biological Journal of the Linnean Society</em>, 129: 14-25.
doi:10.1093/biolinnean/blz161
</p>
<p>Castiglione, S., Serio, C., Mondanaro, A., Melchionna, M.,
Carotenuto, F., Di Febbraro, M., Profico, A., Tamagnini, D., &amp; Raia, P.
(2020). Ancestral State Estimation with Phylogenetic Ridge Regression.
<em>Evolutionary Biology</em>, 47: 220-232. doi:10.1007/s11692-020-09505-x
</p>
<p>Castiglione, S., Serio, C., Piccolo, M., Mondanaro, A.,
Melchionna, M., Di Febbraro, M., Sansalone, G., Wroe, S., &amp; Raia, P.
(2020). The influence of domestication, insularity and sociality on the
tempo and mode of brain size evolution in mammals. <em>Biological Journal
of the Linnean Society</em>,132: 221-231. doi:10.1093/biolinnean/blaa186
</p>


<h3>Examples</h3>

<pre><code class="language-R"> ## Not run: 
data("DataOrnithodirans")
DataOrnithodirans$treedino-&gt;treedino
DataOrnithodirans$massdino-&gt;massdino
cc&lt;- 2/parallel::detectCores()

# Case 1. "RRphylo" without accounting for the effect of a covariate
RRphylo(tree=treedino,y=massdino,clus=cc)-&gt;RRcova

# Case 2. "RRphylo" accounting for the effect of a covariate
# "RRphylo" on the covariate in order to retrieve ancestral state values
c(RRcova$aces,massdino)-&gt;cov.values
c(rownames(RRcova$aces),names(massdino))-&gt;names(cov.values)

RRphylo(tree=treedino,y=massdino,cov=cov.values,clus=cc)-&gt;RR

# Case 3. "RRphylo" specifying the ancestral states
data("DataCetaceans")
DataCetaceans$treecet-&gt;treecet
DataCetaceans$masscet-&gt;masscet
DataCetaceans$brainmasscet-&gt;brainmasscet
DataCetaceans$aceMyst-&gt;aceMyst

RRphylo(tree=treecet,y=masscet,aces=aceMyst,clus=cc)-&gt;RR

# Case 4. Multiple "RRphylo"
library(ape)
drop.tip(treecet,treecet$tip.label[-match(names(brainmasscet),treecet$tip.label)])-&gt;treecet.multi
masscet[match(treecet.multi$tip.label,names(masscet))]-&gt;masscet.multi

RRphylo(tree=treecet.multi, y=masscet.multi,clus=cc)-&gt;RRmass.multi
RRmass.multi$aces[,1]-&gt;acemass.multi
c(acemass.multi,masscet.multi)-&gt;x1.mass

RRphylo(tree=treecet.multi,y=brainmasscet,x1=x1.mass,clus=cc)-&gt;RR

# Case 5. Categorical and multiple "RRphylo" with 2 additional predictors
library(phytools)

set.seed(1458)
rtree(50)-&gt;tree
fastBM(tree)-&gt;y
jitter(y)*10-&gt;y1
rep(1,length(y))-&gt;y2
y2[sample(1:50,20)]&lt;-2
names(y2)&lt;-names(y)

c(RRphylo(tree,y1,clus=cc)$aces[,1],y1)-&gt;x1

RRphylo(tree,y2,clus=cc)-&gt;RRcat ### this is the RRphylo on the categorical variable
c(RRcat$aces[,1],y2)-&gt;x2

cbind(c(jitter(mean(y1[tips(tree,83)])),1),
      c(jitter(mean(y1[tips(tree,53)])),2))-&gt;acex
c(jitter(mean(y[tips(tree,83)])),jitter(mean(y[tips(tree,53)])))-&gt;acesy
names(acesy)&lt;-rownames(acex)&lt;-c(83,53)

RRphylo(tree,y,aces=acesy,x1=cbind(x1,x2),aces.x1 = acex,clus=cc)

    
## End(Not run)
</code></pre>


</div>