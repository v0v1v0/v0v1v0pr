<div class="container">

<table style="width: 100%;"><tr>
<td>arfimacv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
ARFIMAX time series cross validation
</h2>

<h3>Description</h3>

<p>Implements a cross validation method for ARFIMAX models
</p>


<h3>Usage</h3>

<pre><code class="language-R">arfimacv(data, indexin, indexout, ar.max = 2, ma.max = 2, 
criterion = c("rmse","mae","berkowitzp"),berkowitz.significance = 0.05, 
arfima = FALSE, include.mean = NULL, distribution.model = "norm",
cluster = NULL, external.regressors = NULL, solver = "solnp", 
solver.control=list(), fit.control=list(), return.best=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>A univariate xts vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indexin</code></td>
<td>

<p>A list of the training set indices
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indexout</code></td>
<td>

<p>A list of the testing set indices, the same list length as that of indexin. This should be a numeric index
of points immediately after those in the equivalent indexin slot and contiguous (for time series cross validation).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar.max</code></td>
<td>

<p>Maximum AR order to test for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ma.max</code></td>
<td>

<p>Maximum MA order to test for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>

<p>The cv criterion on which the forecasts will be tested against the realized values. Currently “rmse”,
“mae” and experimentally “berkowitzp” are implemented. The latter is the Berkowitz test p-value
(maximized) and should not be used if your indexout set is very small.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>berkowitz.significance</code></td>
<td>

<p>The significance level at which the Berkowitz test is evaluated at (this has no value at the moment since
we are only looking at the p-values, but may be used in futures to instead aggregate across pass-fail).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arfima</code></td>
<td>

<p>Can be TRUE, FALSE or NULL in which case it is tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.mean</code></td>
<td>

<p>Can be TRUE, FALSE or NULL in which case it is tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>external.regressors</code></td>
<td>
<p>An xts matrix object containing the pre-lagged external regressors to 
include in the mean equation with the same indices as those of the data supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution.model</code></td>
<td>

<p>The distribution density to use for the innovations (defaults to Normal).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>One of either “nlminb”, “solnp”, “gosolnp”
or “nloptr”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.best</code></td>
<td>

<p>On completion of the cross-validation, should the best model be re-estimated on the complete dataset
and returned (defaults to TRUE).
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function evaluates all possible combinations of the ARFIMAX model for all the training and testing
sets supplied. For the ARMA orders, the orders are evaluated fully (e.g. for ar.max=2, all possible combinations
are evaluated including AR(0,0), AR(0,1), AR(0,2), AR(1,0), AR(2,0) AR(1,2), AR(2,1), and AR(2,2)). For each training
set in indexin, all model combinations are evaluated and the 1-ahead rolling forecast for the indexout testing set 
is produced and compared to the realized values under the 3 criteria listed. Once all training/testing is done on all
model combinations, the criteria are averaged across all the sets for each combination and the results returned.
</p>


<h3>Value</h3>

<p>A list with the following items:<br></p>
<table>
<tr style="vertical-align: top;">
<td><code>bestmodel</code></td>
<td>
<p> The best model based on the criterion chosen is re-estimated on the complete data set and returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv_matrix</code></td>
<td>
<p> The model combinations and their average criteria statistics across the training/testing sets.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Use a cluster...this is an expensive computation, particularly for large ar.max and ma.max orders. The indexin and indexout
lists are left to the user to decide how to implement.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
require(xts)
require(parallel)
data(sp500ret)
spx = as.xts(sp500ret)
nn = nrow(spx)
nx = nn-round(0.9*nn,0)
if(nx
h = (nx/50)-1
indexin = lapply(1:h, function(j){ tail(seq(1,(nn-nx)+j*50, by=1),250) })
indexout = lapply(indexin, function(x){ (tail(x,1)+1):(tail(x,1)+50) })
cl = makePSOCKcluster(5)
mod = arfimacv(spx, indexin, indexout, ar.max = 2, ma.max = 2, 
criterion = c("rmse","mae","berkowitzp")[1],
berkowitz.significance = 0.05, arfima = FALSE, include.mean = NULL, 
distribution.model = "norm", cluster = cl, external.regressors = NULL, 
solver = "solnp")
stopCluster(cl)

## End(Not run)
</code></pre>


</div>