<div class="container">

<table style="width: 100%;"><tr>
<td>som_pam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rasterization of Self-Organizing Map and Partitioning Around Medoids</h2>

<h3>Description</h3>

<p>Creation of a rasterized representation of the outputs from the
self-organizing map (SOM) and partitioning around medoids (PAM). Given a
reference raster layer, each winning unit of the SOM and clustering value
from the PAM will be mapped on the corresponding cell in the reference layer
and across the geographic space supported by such layer. Note that this
function is a follow-up of the <code>som_gap</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">som_pam(ref.rast, kohsom, k, metric = "manhattan", stand = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ref.rast</code></td>
<td>
<p>SpatRaster, as in <code>rast</code>. This raster
layer will serve as a reference of the index of valid cells and the
geographic support for the rasterized representation of SOM's winning units
and PAM's clustering. See <em>Details</em> for some notes about efficiency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kohsom</code></td>
<td>
<p>SOM Object of class <strong>kohonen</strong>, see
<code>supersom</code>. The following components must be present
in the SOM object (1) <em>unit.classif</em> = winning units for all
observations, and (2) <em>codes</em> = matrix of codebook vectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Integer (positive value). Number of clusters to form from the
codebook vectors of the SOM, where <em>k &lt; SOM's codebook vectors</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>Character. Distance function for PAM. Options are "euclidean",
and "manhattan". Default: "manhattan"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>
<p>Boolean. For the PAM function, do SOM's codebook vectors need to
be standardized? Default: FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments as for <code>pam</code>. See
<strong>Details</strong>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>As in <code>som_gap</code>, this function calls <code>pam</code>
to perform the clustering of SOM's codebook vectors. The SOM object must
belong to the class <strong>kohonen</strong>, as in <code>supersom</code>.
</p>
<p>Note that in order for <code>som_pam</code> to perform efficiently, the
reference SpatRaster <em>ref.rast</em> must be a single-layer SpatRaster with
the same cell size, number of rows, number of columns, and index of valid
cells as those in the multi-layer SpatRaster object used in
<code>som_gap</code>. If a multi-layer SpatRaster (with each layer possibly
having a different index of valid cells) is used as the <em>ref.rast</em>, the
efficiency of <code>som_pam</code> (i.e., running time and/or memory
allocation) may be degraded when handling large SpatRaster objects.
</p>
<p>For this function to work as intended, the additional argument
<em>cluster.only</em> in <code>pam</code> must remain as FALSE, which
is the default.
</p>


<h3>Value</h3>

<p><strong>sompam</strong>: Object of class <strong>pam</strong>. See ?pam.object for details.
</p>
<p><strong>sompam.rast</strong>: Multi-layer SpatRaster, as in
<code>rast</code>. The first raster layer corresponds to the SOM's
winning units. The second raster layer corresponds to the clustered SOM's
codebook vectors by PAM.
</p>


<h3>See Also</h3>

<p>Other Functions for Landscape Stratification: 
<code>som_gap()</code>,
<code>strata()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">require(terra)
# Multi-layer SpatRaster with topographic variables
p &lt;- system.file("exdat", package = "rassta")
ft &lt;- list.files(path = p, pattern = "^height|^slope|^wetness",
                 full.names = TRUE
                )
t &lt;- rast(ft)
# Scale topographic variables (mean = 0, StDev = 1)
ts &lt;- scale(t)
# Self-organizing map and gap statistic for optimum k
set.seed(963)
tsom &lt;- som_gap(var.rast = ts, xdim = 8, ydim = 8, rlen = 150,
               mode = "online", K.max = 6, B = 300, spaceH0 = "original",
               method = "globalSEmax"
              )
# Optimum k
tsom$Kopt
# PAM clustering of topographic SOM's codebook vectors
tpam &lt;- som_pam(ref.rast = t[[1]], kohsom = tsom$SOM, k = tsom$Kopt)
# Plot topographic variables, SOM grid and PAM clustering
if(interactive()){plot(c(t, tpam$sompam.rast))}

</code></pre>


</div>