<div class="container">

<table style="width: 100%;"><tr>
<td>Connection</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Abstract Class for Connections</h2>

<h3>Description</h3>

<p>An R6::R6Class object implementing the base <code>Connection</code>
class for affine connections.
</p>


<h3>Super class</h3>

<p><code>rgeomstats::PythonClass</code> -&gt; <code>Connection</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>dim</code></dt>
<dd>
<p>An integer value specifying the dimension of the underlying
manifold.</p>
</dd>
<dt><code>shape</code></dt>
<dd>
<p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt>
<dd>
<p>A string specifying the coordinate type.
Choices are <code>extrensic</code> or <code>intrinsic</code>. Dedaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>default_point_type</code></dt>
<dd>
<p>A string specifying the point type. Choices are
<code>vector</code> or <code>matrix</code>. It is automatically determined depending on the
manifold.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Connection-new"><code>Connection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-christoffels"><code>Connection$christoffels()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-geodesic_equation"><code>Connection$geodesic_equation()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-exp"><code>Connection$exp()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-log"><code>Connection$log()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-ladder_parallel_transport"><code>Connection$ladder_parallel_transport()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-curvature"><code>Connection$curvature()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-directional_curvature"><code>Connection$directional_curvature()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-curvature_derivative"><code>Connection$curvature_derivative()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-directional_curvature_derivative"><code>Connection$directional_curvature_derivative()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-geodesic"><code>Connection$geodesic()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-parallel_transport"><code>Connection$parallel_transport()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-injectivity_radius"><code>Connection$injectivity_radius()</code></a>
</p>
</li>
<li> <p><a href="#method-Connection-clone"><code>Connection$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="get_python_class"><a href="../../rgeomstats/html/PythonClass.html#method-PythonClass-get_python_class"><code>rgeomstats::PythonClass$get_python_class()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rgeomstats" data-topic="PythonClass" data-id="set_python_class"><a href="../../rgeomstats/html/PythonClass.html#method-PythonClass-set_python_class"><code>rgeomstats::PythonClass$set_python_class()</code></a></span></li>
</ul></details><hr>
<a id="method-Connection-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>The <code>Connection</code> class constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$new(
  dim,
  shape = NULL,
  default_coords_type = "intrinsic",
  py_cls = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dim</code></dt>
<dd>
<p>An integer value specifying the dimension of the manifold.</p>
</dd>
<dt><code>shape</code></dt>
<dd>
<p>An integer vector specifying the shape of one element of the
manifold. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>default_coords_type</code></dt>
<dd>
<p>A string specifying the coordinate type.
Choices are <code>extrensic</code> or <code>intrinsic</code>. Defaults to <code>intrinsic</code>.</p>
</dd>
<dt><code>py_cls</code></dt>
<dd>
<p>A Python object of class <code>Connection</code>. Defaults to <code>NULL</code>
in which case it is instantiated on the fly using the other input
arguments.</p>
</dd>
<dt><code>metric</code></dt>
<dd>
<p>A <code>RiemannianMetric</code> object specifying the metric to use
on the manifold. Defaults to <code>NULL</code>.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An object of class <code>Connection</code>.
</p>


<hr>
<a id="method-Connection-christoffels"></a>



<h4>Method <code>christoffels()</code>
</h4>

<p>Christoffel symbols associated with the connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$christoffels(base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>c(dim, dim, dim)</code> storing the
Christoffel symbols, with the contravariant index on the first
dimension.
</p>


<hr>
<a id="method-Connection-geodesic_equation"></a>



<h4>Method <code>geodesic_equation()</code>
</h4>

<p>Computes the geodesic ODE associated with the connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$geodesic_equation(state, .time)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a tangent vector
to the manifold at the position specified by <code>.time</code>.</p>
</dd>
<dt><code>.time</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a point on the
manifold at which to compute the geodesic ODE.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the value of the vector
field to be integrated at position.
</p>


<hr>
<a id="method-Connection-exp"></a>



<h4>Method <code>exp()</code>
</h4>

<p>Exponential map associated to the affine connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$exp(tangent_vec, base_point, n_steps = 100, step = "euler")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a tangent vector
at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>n_steps</code></dt>
<dd>
<p>An integer value specifying the number of discrete time steps
to take in the integration. Defaults to <code>100L</code>.</p>
</dd>
<dt><code>step</code></dt>
<dd>
<p>A string specifying which numerical scheme to use for
integration. Choices are <code>euler</code> or <code>rk4</code>. Defaults to <code>euler</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Exponential map at base_point of tangent_vec computed by
integration of the geodesic equation (initial value problem), using the
christoffel symbols.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the exponential of the
input tangent vector, which lies on on the manifold.
</p>


<hr>
<a id="method-Connection-log"></a>



<h4>Method <code>log()</code>
</h4>

<p>Logarithm map associated to the affine connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$log(
  point,
  base_point,
  n_steps = 100,
  step = "euler",
  max_iter = 25,
  verbose = FALSE,
  tol = gs$backend$atol
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a point on the
manifold.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>n_steps</code></dt>
<dd>
<p>An integer value specifying the number of discrete time steps
to take in the integration. Defaults to <code>100L</code>.</p>
</dd>
<dt><code>step</code></dt>
<dd>
<p>A string specifying which numerical scheme to use for
integration. Choices are <code>euler</code> or <code>rk4</code>. Defaults to <code>euler</code>.</p>
</dd>
<dt><code>max_iter</code></dt>
<dd>
<p>An integer value specifying the number of iterations.
Defaults to <code>25L</code>.</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>A boolean specifying whether the optimizer should display
intermediate messages pertaining to its convergence. Defaults to
<code>FALSE</code>.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>A numeric value specifying the absolute tolerance for
optimization convergence. Defaults to <code>gs$backend$atol</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Solves the boundary value problem associated to the geodesic
equation using the Christoffel symbols and conjugate gradient descent.
</p>



<h5>Returns</h5>

<p>A numeric array of shape <code>dim</code> storing the exponential of the
input tangent vector, which lies on on the manifold.
</p>


<hr>
<a id="method-Connection-ladder_parallel_transport"></a>



<h4>Method <code>ladder_parallel_transport()</code>
</h4>

<p>Approximate parallel transport using the pole ladder scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$ladder_parallel_transport(
  tangent_vec,
  base_point,
  direction,
  n_rungs = 1,
  scheme = "pole",
  alpha = 1,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a tangent vector
at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>direction</code></dt>
<dd>
<p>Tangent vector at base point specifying the initial
speed of the geodesic along which to transport.</p>
</dd>
<dt><code>n_rungs</code></dt>
<dd>
<p>A scalar integer specifying the Number of steps of the
ladder. Defaults to <code>1L</code>.</p>
</dd>
<dt><code>scheme</code></dt>
<dd>
<p>A string specifying the scheme to use for the construction
of the ladder at each step. Choices are either <code>pole</code> or <code>schild</code>.
Defaults to <code>pole</code>.</p>
</dd>
<dt><code>alpha</code></dt>
<dd>
<p>A numeric value specifying the exponent for the scaling of
the vector to transport. Must be greater or equal to 1 and
Guigui and Pennec (2022) proved that <code>alpha = 2</code> is optimal. Defaults to <code>2</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Extra arguments to be passed to calls to <code style="white-space: pre;">⁠$exp()⁠</code> and <code style="white-space: pre;">⁠$log()⁠</code>
in auxiliary single ladder step functions.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Approximate parallel transport using either the pole ladder or
the Schild's ladder scheme
(Lorenzi and Pennec 2014). Pole ladder is exact in
symmetric spaces and of order two in general while Schild's ladder is a
first order approximation (Guigui and Pennec 2022).
Both schemes are available on any affine connection manifolds whose
exponential and logarithm maps are implemented. <code>tangent_vec</code> is
transported along the geodesic starting at the <code>base_point</code> with
initial tangent vector <code>direction</code>.
</p>


<h6>References</h6>

<p>Guigui N, Pennec X (2022).
“Numerical accuracy of ladder schemes for parallel transport on manifolds.”
<em>Foundations of Computational Mathematics</em>, <b>22</b>(3), 757–790.<br><br> Lorenzi M, Pennec X (2014).
“Efficient parallel transport of deformations in time series of images: from Schild’s to pole ladder.”
<em>Journal of mathematical imaging and vision</em>, <b>50</b>(1), 5–17.
</p>




<h5>Returns</h5>

<p>A named list with 3 components:
</p>

<ul>
<li> <p><code>transported_tangent_vector</code>: Approximation of the parallel transport
of the input tangent vector.
</p>
</li>
<li> <p><code>trajectory</code> : A list of length <code>n_steps</code> storing the geodesics of the
construction, only if <code>return_geodesics = TRUE</code> in the step function. The
geodesics are methods of the class connection.
</p>
</li>
<li> <p><code>end_point</code>:
</p>
</li>
</ul>
<hr>
<a id="method-Connection-curvature"></a>



<h4>Method <code>curvature()</code>
</h4>

<p>Computes the curvature.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$curvature(tangent_vec_a, tangent_vec_b, tangent_vec_c, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_c</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For three vector fields <code class="reqn">X|_P = \mathrm{tangent\_vec\_a}</code>,
<code class="reqn">Y|_P = \mathrm{tangent\_vec\_b}</code>, <code class="reqn">Z|_P =
  \mathrm{tangent\_vec\_c}</code> with tangent vector specified in argument at
the base point <code class="reqn">P</code>, the curvature is defined by </p>
<p style="text-align: center;"><code class="reqn">R(X,Y)Z =
  \nabla_{[X,Y]}Z - \nabla_X\nabla_Y Z + \nabla_Y\nabla_X Z.</code>
</p>




<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-directional_curvature"></a>



<h4>Method <code>directional_curvature()</code>
</h4>

<p>Computes the directional curvature (tidal force operator).
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$directional_curvature(tangent_vec_a, tangent_vec_b, base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For two vector fields <code class="reqn">X|_P = \mathrm{tangent\_vec\_a}</code> and
<code class="reqn">Y|_P = \mathrm{tangent\_vec\_b}</code> with tangent vector specified in
argument at the base point <code class="reqn">P</code>, the directional curvature, better
known in relativity as the tidal force operator, is defined by
</p>
<p style="text-align: center;"><code class="reqn">R_Y(X) = R(Y,X)Y.</code>
</p>




<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-curvature_derivative"></a>



<h4>Method <code>curvature_derivative()</code>
</h4>

<p>Computes the covariant derivative of the curvature.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$curvature_derivative(
  tangent_vec_a,
  tangent_vec_b,
  tangent_vec_c,
  tangent_vec_d,
  base_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_c</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_d</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For four vector fields <code class="reqn">H|_P = \mathrm{tangent\_vec\_a}</code>,
<code class="reqn">X|_P = \mathrm{tangent\_vec\_b}</code>, <code class="reqn">Y|_P =
  \mathrm{tangent\_vec\_c}</code>, <code class="reqn">Z|_P = \mathrm{tangent\_vec\_d}</code> with
tangent vector value specified in argument at the base point <code class="reqn">P</code>,
the covariant derivative of the curvature <code class="reqn">(\nabla_H R)(X, Y) Z
  |_P</code> is computed at the base point <code class="reqn">P</code>.
</p>



<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-directional_curvature_derivative"></a>



<h4>Method <code>directional_curvature_derivative()</code>
</h4>

<p>Computes the covariant derivative of the directional
curvature.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$directional_curvature_derivative(
  tangent_vec_a,
  tangent_vec_b,
  base_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec_a</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>tangent_vec_b</code></dt>
<dd>
<p>Tangent vector at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>For two vector fields <code class="reqn">X|_P = \mathrm{tangent\_vec\_a}</code>,
<code class="reqn">Y|_P = \mathrm{tangent\_vec\_b}</code> with tangent vector value
specified in argument at the base point <code class="reqn">P</code>, the covariant
derivative (in the direction <code class="reqn">X</code>) <code class="reqn">(\nabla_X R_Y)(X) |_P =
  (\nabla_X R)(Y, X) Y |_P</code> of the directional curvature (in the
direction <code class="reqn">Y</code>) <code class="reqn">R_Y(X) = R(Y, X) Y</code> is a quadratic tensor in
<code class="reqn">X</code> and <code class="reqn">Y</code> that plays an important role in the computation of
the moments of the empirical Fréchet mean
(Pennec 2019).
</p>


<h6>References</h6>

<p>Pennec X (2019).
“Curvature effects on the empirical mean in Riemannian and affine Manifolds: a non-asymptotic high concentration expansion in the small-sample regime.”
<em>arXiv preprint arXiv:1906.07418</em>.
</p>




<h5>Returns</h5>

<p>Tangent vector at <code>base_point</code>.
</p>


<hr>
<a id="method-Connection-geodesic"></a>



<h4>Method <code>geodesic()</code>
</h4>

<p>Generates parametrized function for the geodesic curve.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$geodesic(
  initial_point,
  end_point = NULL,
  initial_tangent_vec = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>initial_point</code></dt>
<dd>
<p>Point on the manifold specifying the initial point
of the geodesic.</p>
</dd>
<dt><code>end_point</code></dt>
<dd>
<p>Point on the manifold specifying the end point of the
geodesic. Defaults to <code>NULL</code>, in which case an initial tangent vector
must be given.</p>
</dd>
<dt><code>initial_tangent_vec</code></dt>
<dd>
<p>Tangent vector at base point specifying the
initial speed of the geodesics. Defaults to <code>NULL</code>, in which case an
end point must be given and a logarithm is computed.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Geodesic curve defined by either:
</p>

<ul>
<li>
<p> an initial point and an initial tangent vector,
</p>
</li>
<li>
<p> an initial point and an end point.
</p>
</li>
</ul>
<h5>Returns</h5>

<p>A function representing the time-parametrized geodesic curve. If
a list of initial conditions is passed, the output list will contain,
for each time point, a list with the geodesic values each initial
condition.
</p>


<hr>
<a id="method-Connection-parallel_transport"></a>



<h4>Method <code>parallel_transport()</code>
</h4>

<p>Computes the parallel transport of a tangent vector.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$parallel_transport(
  tangent_vec,
  base_point,
  direction = NULL,
  end_point = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tangent_vec</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a tangent vector
at <code>base_point</code>.</p>
</dd>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
<dt><code>direction</code></dt>
<dd>
<p>Tangent vector at base point specifying the point along
which the parallel transport is computed. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>end_point</code></dt>
<dd>
<p>Point on the manifold specifying the point to transport
to. Defaults to <code>NULL</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Closed-form solution for the parallel transport of a tangent
vector along the geodesic between two points <code>base_point</code> and
<code>end_point</code> or alternatively defined by <code class="reqn">t \mapsto
  \exp_\mathrm{base_point} (t \mathrm{direction})</code>.
</p>



<h5>Returns</h5>

<p>Tangent vector transported at <code class="reqn">t \mapsto
  \exp_\mathrm{base_point} (t \mathrm{direction})</code>.
</p>


<hr>
<a id="method-Connection-injectivity_radius"></a>



<h4>Method <code>injectivity_radius()</code>
</h4>

<p>Computes the radius of the injectivity domain.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$injectivity_radius(base_point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>base_point</code></dt>
<dd>
<p>A numeric array of shape <code>dim</code> specifying a base point on
the manifold.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This is is the supremum of radii r for which the exponential
map is a diffeomorphism from the open ball of radius r centered at the
base point onto its image.
</p>



<h5>Returns</h5>

<p>A numeric value representing the injectivity radius.
</p>


<hr>
<a id="method-Connection-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Connection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Author(s)</h3>

<p>Nicolas Guigui
</p>


</div>