<div class="container">

<table style="width: 100%;"><tr>
<td>tuneForceRatio</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Method to compute optimal ratio between repulsive and attractive forces for Freeviz.</h2>

<h3>Description</h3>

<p>Method to compute optimal ratio between repulsive and attractive forces for Freeviz.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tuneForceRatio(
  x,
  classes,
  law = 0,
  steps = 10,
  springs = NULL,
  multilevel = TRUE,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Dataframe or matrix, with observations as rows and attributes as columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>Vector with class labels of the observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>law</code></td>
<td>
<p>Integer, specifying how forces change with distance: 0 = (inverse) linear, 1 = (inverse) square</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>Number of iterations of the algorithm before re-considering convergence criterion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>springs</code></td>
<td>
<p>Numeric matrix with initial anchor coordinates. When <code>NULL</code> (=default), springs are initialized by <code>make.S</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multilevel</code></td>
<td>
<p>Logical, indicating whether multi-level computation should be used. Setting it to TRUE can speed up computations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print</code></td>
<td>
<p>Logical, indicating whether information on the iterative procedure should be printed in the R console</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Running Freeviz, it is hard to know what weights to specify for the attractive and repulsive forces to optimize the projection result. This function runs an iterative procedure
to find the optimal force ratio. First, a logarithmic grid search is performed, followed by 1D optimization on the refined interval. This approach is less prone to getting stuck in 
a suboptimal local optimum, and requires less Freeviz evaluations than direct 1D optimization
</p>


<h3>Value</h3>

<p>Value of the optimal force ratio (attractive force in the nominator)
</p>


<h3>Author(s)</h3>

<p>Nicolas Sauwen
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(iris)
das &lt;- c('Sepal.Length','Sepal.Width','Petal.Length','Petal.Width')
S &lt;- make.S(das)
rv &lt;- do.radviz(iris,S)
plot(rv,anchors.only=FALSE)
forceRatio &lt;- tuneForceRatio(x = iris[,das], classes = iris$Species)
new.S &lt;- do.optimFreeviz(x = iris[,das], classes = iris$Species, attractG = forceRatio, repelG = 1)
new.rv &lt;- do.radviz(iris,new.S)
plot(new.rv,anchors.only=FALSE)

</code></pre>


</div>