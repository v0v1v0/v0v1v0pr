<div class="container">

<table style="width: 100%;"><tr>
<td>SolrPromise-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SolrPromise</h2>

<h3>Description</h3>

<p><code>SolrPromise</code> is a vector-like representation of a deferred
computation within Solr. It may promise to simply return a field, to
perform arithmetic on a combination of fields, to aggregate a field,
etc. Methods on <code>SolrPromise</code> allow the R user to
manipulate Solr data with the ordinary R API. The typical way to
fulfill a promise is to explicitly coerce the promise to a
materialized data type, such as an R vector.
</p>


<h3>Details</h3>

<p>In general, <code>SolrPromise</code> acts just like an R vector. It supports
all of the basic vector manipulations, including the
<code>Logic</code>, <code>Compare</code>, <code>Arith</code>,
<code>Math</code>, and <code>Summary</code> group generics, as well
as <code>length</code>, <code>lengths</code>, <code>%in%</code>,
<code>complete.cases</code>, <code>is.na</code>, <code>[</code>, <code>grepl</code>,
<code>grep</code>, <code>round</code>, <code>signif</code>, <code>ifelse</code>,
<code>pmax</code>, <code>pmin</code>,
<code>cut</code>, <code>mean</code>, <code>quantile</code>, <code>median</code>,
<code>weighted.mean</code>, <code>IQR</code>, <code>mad</code>, <code>anyNA</code>. All of
these functions are lazy, in that they return another promise.
</p>
<p>The promise is really only known to rsolr, as all actual Solr queries
are eager. <code>SolrPromise</code> does its best to defer computations, but
the computations will be forced if one performs an operation that is
not supported by Solr.
</p>
<p>These functions are also supported, but they are eager: <code>cbind</code>,
<code>rbind</code>, <code>summary</code>, <code>window</code>,
<code>head</code>, <code>tail</code>, <code>unique</code>, <code>intersect</code>,
<code>setdiff</code>, <code>union</code>, <code>table</code> and <code>ftable</code>. These
functions from the <code>Math</code> group generic are eager: <code>cummax</code>,
<code>cummin</code>, <code>cumprod</code>, <code>cumsum</code>, <code>log2</code>, and
<code>*gamma</code>.
</p>
<p>The <code>[&lt;-</code> function will be lazy as long as both <code>x</code> and
<code>i</code> are promises. <code>i</code> is assumed to represent a logical
subscript. Otherwise, <code>[&lt;-</code> is eager.
</p>
<p><code>SolrPromise</code> also extends the R API with some new operations:
<code>nunique</code> (number of unique elements), <code>rescale</code> (rescale
to within a min/max), <code>ndoc</code>, <code>windows</code>,
<code>heads</code>, <code>tails</code>.
</p>


<h3>Limitations</h3>

<p>This section outlines some limitations of <code>SolrPromise</code> methods,
compared to the base vector implementation. The primary limitation is
that binary operations generally only work between two promises that
derive from the same data source, including all pending manipulations
(filters, ordering, etc). Operations between a promise and an ordinary
vector usually only work if the vector is of length one (a scalar).
</p>
<p>Some specific notes:
</p>

<ul>
<li>
<p><code>x[i]</code>: The index <code>i</code> is ideally a promise. The
return value will be restricted such that it will only combine
with promises with the same restriction.

</p>
</li>
<li>
<p><code>x %in% table</code>: The <code>x</code> argument must always
refer to a simple field, and the <code>table</code> argument should be
either a field, potentially predicated via <code>table[i]</code> (where
the index <code>i</code> is a promise), or a “short” vector.

</p>
</li>
<li>
<p><code>grepl(pattern, x, fixed = FALSE)</code>: Applies when
<code>x</code> is a promise. Besides <code>pattern</code>, only the
<code>fixed</code> argument is supported from the base function.

</p>
</li>
<li>
<p><code>grep(pattern, x, value = FALSE, fixed = FALSE, invert
      = FALSE)</code>: One must always set <code>value=TRUE</code>. Beyond that,
only <code>fixed</code> and <code>invert</code> are supported from the base
function.

</p>
</li>
<li>
<p><code>cut(x, breaks, include.lowest = FALSE, right = TRUE)</code>:
Only supports uniform (constant separation) breaks.

</p>
</li>
<li>
<p><code>mad(x, center = median(x, na.rm=na.rm), constant =
        1.4826, na.rm = FALSE, low = FALSE, high = FALSE)</code>: The
<code>low</code> and <code>high</code> parameters must be <code>FALSE</code>. If
there any NAs, then <code>na.rm</code> must be <code>TRUE</code>. Does not
work when the context is grouped.

</p>
</li>
</ul>
<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code>SolrFrame</code>, which yields promises when it is
<code>defer</code>red.
</p>


</div>