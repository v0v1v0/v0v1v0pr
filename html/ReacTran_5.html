<div class="container">

<table style="width: 100%;"><tr>
<td>fiadeiro</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Advective Finite Difference Weights
</h2>

<h3>Description</h3>

<p>Weighing coefficients used in the finite difference scheme for advection
calculated according to Fiadeiro and Veronis (1977).
</p>
<p>This particular AFDW (advective finite difference weights) scheme switches
from backward differencing (in advection dominated conditions; large Peclet
numbers) to central differencing (under diffusion dominated conditions;
small Peclet numbers).
</p>
<p>This way it forms a compromise between stability, accuracy and reduced
numerical dispersion.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fiadeiro(v, D, dx.aux = NULL, grid = list(dx.aux = dx.aux))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v </code></td>
<td>
<p>advective velocity; either one value or a vector of length N+1,
with N the number of grid cells [L/T]
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D </code></td>
<td>
<p>diffusion coefficient; either one value or a vector of length N+1
[L2/T]
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx.aux </code></td>
<td>
<p>auxiliary vector containing the distances between the
locations where the concentration is defined (i.e. the grid cell centers
and the two outer interfaces);
either one value or a vector of length N+1 [L]
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid </code></td>
<td>
<p>discretization grid as calculated by <code>setup.grid.1D</code>
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Fiadeiro and Veronis (1977) scheme adapts the differencing method to
the local situation (checks for advection or diffusion dominance).
</p>
<p>Finite difference schemes are based on following rationale:
</p>

<ul>
<li>
<p> When using forward differences (AFDW = 0), the scheme is first
order accurate, creates a low level of (artificial) numerical dispersion,
but is highly unstable (state variables may become negative).
</p>
</li>
<li>
<p> When using backward differences (AFDW = 1), the scheme is first
order accurate, is universally stable (state variables always remain
positive), but the scheme creates high levels of numerical dispersion.
</p>
</li>
<li>
<p> When using central differences (AFDW = 0.5), the scheme is second
order accurate, is not universally stable, and has a moderate level of
numerical dispersion, but state variables may become negative.
</p>
</li>
</ul>
<p>Because of the instability issue, forward schemes should be avoided.
Because of the higher accuracy, the central scheme is preferred over the
backward scheme.
</p>
<p>The central scheme is stable when sufficient physical dispersion is present,
it may become unstable when advection is the only transport process.
</p>
<p>The Fiadeiro and Veronis (1977) scheme takes this into account: it uses
central differencing when possible (when physical dispersion is high enough),
and switches to backward differing when needed (when advection dominates).
The switching is determined by the Peclet number
</p>
<p><code>Pe = abs(v)*dx.aux/D</code>
</p>

<ul>
<li>
<p> the higher the diffusion <code>D</code> (<code>Pe &gt; 1</code>), the closer the
AFDW coefficients are to 0.5 (central differencing)
</p>
</li>
<li>
<p> the higher the advection <code>v</code> (<code>Pe &lt; 1</code>), the closer the
AFDW coefficients are to 1 (backward differencing)
</p>
</li>
</ul>
<h3>Value</h3>

<p>the Advective Finite Difference Weighing (AFDW) coefficients as used in 
the transport routines <code>tran.1D</code> and <code>tran.volume.1D</code>;
either one value or a vector of length N+1 [-]
</p>


<h3>Note</h3>


<ul>
<li>
<p> If the state variables (concentrations) decline in the direction
of the 1D axis, then the central difference scheme will be stable.
If this is known a prioiri, then central differencing is
preferred over the fiadeiro scheme.
</p>
</li>
<li>
<p> Each scheme will always create some numerical diffusion. This
principally depends on the resolution of the grid (i.e. larger 
<code>dx.aux</code> values create higher numerical diffusion). In order to reduce numerical dispersion, one should
increase the grid resolution (i.e. decrease <code>dx.aux</code>).
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Filip Meysman &lt;filip.meysman@nioz.nl&gt;,
</p>
<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>


<ul>
<li>
<p> Fiadeiro ME and Veronis G (1977) Weighted-mean schemes for
finite-difference approximation to advection-diffusion equation.
Tellus 29, 512-522.
</p>
</li>
<li>
<p> Boudreau (1997) Diagnetic models and their implementation.
Chapter 8: Numerical Methods. Springer.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">#============================================
# Model formulation (differential equations)
#============================================

# This is a test model to evaluate the different finite difference schemes 
# and evaluate their effect on munerical diffusion. The model describes the
# decay of organic carbon (OC) as it settles through the ocean water column.

model &lt;- function (time, OC, pars, AFDW = 1) {
  dOC &lt;- tran.1D(OC, flux.up = F_OC, D = D.eddy, 
                 v = v.sink, AFDW = AFDW, dx = dx)$dC - k*OC
  return(list(dOC))
}
#============================================
# Parameter set
#============================================

L &lt;- 1000         # water depth model domain [m]
x.att &lt;- 200      # attenuation depth of the sinking velocity [m]
v.sink.0 &lt;- 10    # sinking velocity at the surface [m d-1]
D.eddy &lt;- 10      # eddy diffusion coefficient [m2 d-1]
F_OC &lt;- 10        # particle flux [mol m-2 d-1]
k &lt;- 0.1          # decay coefficient [d-1]

## =============================================================================
## Model solution for a coarse grid (10 grid cells)
## =============================================================================

# Setting up the grid
N &lt;- 10                               # number of grid layers 
dx &lt;- L/N                             # thickness of boxes [m]
dx.aux &lt;- rep(dx, N+1)                # auxilliary grid vector
x.int &lt;- seq(from = 0, to = L, by = dx)    # water depth at box interfaces [m]
x.mid &lt;- seq(from = dx/2, to = L, by = dx) # water depth at box centres [m]

# Exponentially declining sink velocity
v.sink &lt;- v.sink.0 * exp(-x.int/x.att) # sink velocity [m d-1]
Pe &lt;- v.sink * dx/D.eddy               # Peclet number

# Calculate the weighing coefficients
AFDW &lt;- fiadeiro(v = v.sink, D = D.eddy, dx.aux = dx.aux)

par(mfrow = c(2, 1), cex.main = 1.2, cex.lab = 1.2)

# Plot the Peclet number over the grid 

plot(Pe, x.int, log = "x", pch = 19, ylim = c(L,0), xlim = c(0.1, 1000), 
     xlab = "", ylab = "depth [m]", 
     main = "Peclet number", axes = FALSE)
abline(h = 0)
axis(pos = NA, side = 2)
axis(pos = 0, side = 3)

# Plot the AFDW coefficients over the grid 

plot(AFDW, x.int, pch = 19, ylim = c(L, 0), xlim = c(0.5, 1), 
     xlab = "", ylab = "depth [m]", main = "AFDW coefficient", axes = FALSE)
abline(h = 0)
axis(pos = NA, side = 2)
axis(pos = 0, side = 3)

# Three steady-state solutions for a coarse grid based on:
# (1) backward differences (BD)
# (2) central differences (CD)
# (3) Fiadeiro &amp; Veronis scheme (FV)

BD &lt;- steady.1D(y = runif(N), func = model, AFDW = 1.0, nspec = 1)
CD &lt;- steady.1D(y = runif(N), func = model, AFDW = 0.5, nspec = 1)
FV &lt;- steady.1D(y = runif(N), func = model, AFDW = AFDW, nspec = 1)

# Plotting output - use rootSolve's plot method
plot(BD, CD, FV, grid = x.mid, xyswap = TRUE, mfrow = c(1,2), 
     xlab = "", ylab = "depth [m]", main = "conc (Low resolution grid)")

legend("bottomright", col = 1:3, lty = 1:3,
       legend = c("backward diff", "centred diff", "Fiadeiro&amp;Veronis"))


## =============================================================================
## Model solution for a fine grid (1000 grid cells)
## =============================================================================

# Setting up the grid
N &lt;- 1000                            # number of grid layers 
dx &lt;- L/N                            # thickness of boxes[m]
dx.aux &lt;- rep(dx, N+1)              # auxilliary grid vector
x.int &lt;- seq(from = 0, to = L, by = dx)      # water depth at box interfaces [m]
x.mid &lt;- seq(from = dx/2, to = L, by = dx)   # water depth at box centres [m]

# Exponetially declining sink velocity
v.sink &lt;- v.sink.0 * exp(-x.int/x.att) # sink velocity [m d-1]
Pe &lt;- v.sink * dx/D.eddy               # Peclet number

# Calculate the weighing coefficients
AFDW &lt;- fiadeiro(v = v.sink, D = D.eddy, dx.aux = dx.aux)

# Three steady-state solutions for a coarse grid based on:
# (1) backward differences (BD)
# (2) centered differences (CD)
# (3) Fiadeiro &amp; Veronis scheme (FV)

BD &lt;- steady.1D(y = runif(N), func = model, AFDW = 1.0, nspec = 1)
CD &lt;- steady.1D(y = runif(N), func = model, AFDW = 0.5, nspec = 1)
FV &lt;- steady.1D(y = runif(N), func = model, AFDW = AFDW, nspec = 1)

# Plotting output
plot(BD, CD, FV, grid = x.mid, xyswap = TRUE, mfrow = NULL, 
     xlab = "", ylab = "depth [m]", main = "conc (High resolution grid)")

legend("bottomright", col = 1:3, lty = 1:3,
       legend = c("backward diff", "centred diff", "Fiadeiro&amp;Veronis"))

# Results and conclusions:
# - For the fine grid, all three solutions are identical
# - For the coarse grid, the BD and FV solutions show numerical dispersion
#   while the CD provides more accurate results
</code></pre>


</div>