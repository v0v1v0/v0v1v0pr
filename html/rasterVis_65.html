<div class="container">

<table style="width: 100%;"><tr>
<td>vectorplot-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Vector plots of Raster objects.</h2>

<h3>Description</h3>

<p><code>vectorplot</code> displays vector fields from Raster
objects using arrows.
</p>
<p><code>streamplot</code> displays streamlines with a procedure inspired by
the FROLIC algorithm (see references): for each point (<em>droplet</em>)
of a jittered regular grid, a short streamline portion
(<em>streamlet</em>) is calculated by integrating the underlying vector
field at that point. The main color of each streamlet indicates local
vector magnitude (<em>slope</em>). Streamlets are composed of points
whose sizes, positions and color degradation encode the local vector
direction (<em>aspect</em>).  </p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'Raster'
vectorplot(object, layers,
            narrows=2e3, lwd.arrows=0.6, col.arrows='black',
            length=unit(1e-2, 'npc'),
            maxpixels=1e5, region=TRUE, margin=FALSE,  
            isField=FALSE, reverse=FALSE,
            unit='radians', scaleSlope=TRUE,
            aspX=0.08, aspY=aspX,
            key.arrow = NULL,
            ...)

## S4 method for signature 'RasterStack'
vectorplot(object, layers,
            narrows=2e3, lwd.arrows=0.6, col.arrows='black',
            length=unit(1e-2, 'npc'),
            maxpixels=1e5, region=TRUE, margin=FALSE,
            isField=FALSE, reverse=FALSE,
            unit='radians', scaleSlope=TRUE,
            aspX=0.08, aspY=aspX,
            key.arrow = NULL,
            uLayers, vLayers, ...)

## S4 method for signature 'Raster'
streamplot(object, layers,
            droplet = list(), streamlet = list(),
            par.settings = streamTheme(),
            colorkey = FALSE,
            isField = FALSE, reverse = FALSE, 
            parallel = TRUE, mc.cores = detectCores(), cl = NULL,
            ...)

## S4 method for signature 'RasterStack'
streamplot(object, layers,
            droplet = list(), streamlet = list(),
            par.settings=streamTheme(),
            colorkey = FALSE,
            isField = FALSE, reverse = FALSE, 
            parallel = TRUE, mc.cores = detectCores(), cl = NULL,
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A Raster object. If <code>isField=FALSE</code> the vector
field is calculated internally from the result of
<code>terrain</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layers</code></td>
<td>
<p>A numeric or character which should indicate the layers
to be displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxpixels</code></td>
<td>
<p>A numeric, number of cells to be shown if
<code>region=TRUE</code> or if <code>region</code> is a <code>Raster*</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>narrows</code></td>
<td>
<p>A numeric, number of arrows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd.arrows</code></td>
<td>
<p>Numeric, width of the lines of the arrows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col.arrows</code></td>
<td>
<p>character, color of the arrows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>Unit, extent of the arrow head.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>
<p>Logical, if TRUE two marginal graphics show the summaries
of the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleSlope</code></td>
<td>
<p>Logical or numeric. If TRUE the slope (vector
magnitude) is scaled (but not centered) with its standard
deviation. If it is a numeric, the slope is scaled with this value.
It is not used if <code>isField='dXY'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aspX, aspY</code></td>
<td>
<p>Numeric. Multipliers to convert the slope values into
horizontal (<code>aspX</code>) and vertical (<code>aspY</code>) displacements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key.arrow</code></td>
<td>
<p>A reference (or legend) vector. If is not NULL, it is a list with two named
components, <code>size</code>, a numeric to define the length of the arrow
(default 1), and <code>label</code>, a character to define the label
(default <code>''</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uLayers, vLayers</code></td>
<td>
<p>Numeric, indexes of layers with horizontal and
vertical components, respectively, when <code>isField='dXY'</code> and the
<code>RasterStack</code> has more than 2 layers.  If missing, the horizontal
components are the layers of the first half of the object, and the
vertical components are the layers of the second half.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>droplet</code></td>
<td>
<p>A list whose elements define the droplet
configuration:</p>

<ul>
<li>
<p> cropExtent: Percentage of the object
extent to be cropped (default .97) to avoid droplets at boundaries
</p>
</li>
<li>
<p> pc: A numeric. It is the percentage of cells used to compute
droplets. Its default value is 0.5. Therefore, only the 0.5% of the
cells are used. For example, if you use a Raster with 180 rows and 360
columns (64800 cells), with this default value <code>streamplot</code> will
produce 324 droplets.</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>streamlet</code></td>
<td>
<p>A list whose elements define the streamlet
configuration:</p>

<ul>
<li>
<p> L: length of the streamlet (number of
points, default 10)
</p>
</li>
<li>
<p> h: streamlet calculation step (default
<code>mean(res(object))</code>).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.settings</code></td>
<td>
<p>A list to define the graphical parameters. For
<code>streamplot</code> there is an specific theme, <code>streamTheme</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorkey</code></td>
<td>
<p>A logical specifying whether a color key is to be drawn
alongside the plot (default is <code>FALSE</code>), or a list describing
the color key (see the <code>colorkey</code> section of the help page of
<code>levelplot</code> for details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical, TRUE (default) to use <code>parallel</code>
package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>a cluster object. Read the help page of
<code>parLapply</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>
<p>The number of cores to use if <code>parallel=TRUE</code> and
no <code>cl</code> is provided. Read the help page of <code>mclapply</code>
for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>region</code></td>
<td>
<p>Logical, if <code>TRUE</code> the region is displayed as the
background  using <code>levelplot</code>. It can be a <code>Raster*</code> with
the same extent and resolution as <code>object</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isField</code></td>
<td>
<p>If <code>TRUE</code> the object is a vector field. Thus,
<code>object</code> must be a Raster* with two layers, slope (local vector
magnitude) and aspect (local vector direction), in this order. The
aspect angle, following the conventions of
<code>raster::terrain</code>, must be computed clockwise from 0 (due
north). The slope layer will be used as the background if <code>region</code>
is <code>TRUE</code>.
</p>
<p>If <code>isField='dXY'</code> <code>object</code> must be a Raster* with two
layers representing the horizontal and the vertical components,
respectively. The slope is computed and used as the background if
<code>region</code> is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>Character, angle units of the <code>aspect</code> layer if
<code>isField=TRUE</code>: 'radians' or 'degrees'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reverse</code></td>
<td>
<p>Logical, if <code>isField=TRUE</code> and <code>reverse=TRUE</code>,
arrows or streamlets go against the direction of the gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for <code>levelplot</code></p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro</p>


<h3>References</h3>

<p>R. Wegenkittl and E. Gröller, Fast Oriented Line Integral Convolution for Vector Field
Visualization via the Internet, Proceedings IEEE Visualization ’97, 1997, <a href="http://www.cg.tuwien.ac.at/research/vis-dyn-syst/frolic/frolic_crc.pdf">http://www.cg.tuwien.ac.at/research/vis-dyn-syst/frolic/frolic_crc.pdf</a>
</p>


<h3>See Also</h3>

<p><code>panel.arrows</code>,
<code>levelplot</code>,
<code>terrain</code>,
<code>mclapply</code>,
<code>parLapply</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(raster)

proj &lt;- CRS('+proj=longlat +datum=WGS84')

df &lt;- expand.grid(x=seq(-2, 2, .01), y=seq(-2, 2, .01))
df$z &lt;- with(df, (3*x^2 + y)*exp(-x^2-y^2))
r1 &lt;- rasterFromXYZ(df, crs=proj)
df$z &lt;- with(df, x*exp(-x^2-y^2))
r2 &lt;- rasterFromXYZ(df, crs=proj)
df$z &lt;- with(df, y*exp(-x^2-y^2))
r3 &lt;- rasterFromXYZ(df, crs=proj)
s &lt;- stack(r1, r2, r3)
names(s) &lt;- c('R1', 'R2', 'R3')

vectorplot(r1)
vectorplot(r2, par.settings=RdBuTheme())
vectorplot(r3, par.settings=PuOrTheme())

## scaleSlope, aspX and aspY
vectorplot(r1, scaleSlope=FALSE)
vectorplot(r1, scaleSlope=1e-5)
vectorplot(r1, scaleSlope=5e-6, alpha=0.6)
vectorplot(r1, scaleSlope=TRUE, aspX=0.1, alpha=0.6)
vectorplot(r1, scaleSlope=TRUE, aspX=0.3, alpha=0.3)


## Reference vector
# Default size (1)
vectorplot(r1, region = FALSE,
           key.arrow = list(label = 'm/s'))
vectorplot(r1, region = FALSE,
           key.arrow = list(size = 2, label = 'm/s'))

## A vector field defined with horizontal and vertical components
u &lt;- v &lt;- raster(xmn=0, xmx=2, ymn=0, ymx=2, ncol=1e3, nrow=1e3)
x &lt;- raster::init(u, fun='x')
y &lt;- raster::init(u, fun='y')
u &lt;- y * cos(x)
v &lt;- y * sin(x) 
field &lt;- stack(u, v)
names(field) &lt;- c('u', 'v')

vectorplot(field, isField='dXY', narrows=5e2)

## We can display both components as the background
vectorplot(field, isField='dXY', narrows=5e2, region=field)

## It is also possible to use a RasterStack
## with more than 2 layers when isField='dXY'
u1 &lt;- cos(y) * cos(x)
v1 &lt;- cos(y) * sin(x)
u2 &lt;- sin(y) * sin(x)
v2 &lt;- sin(y) * cos(x)
field &lt;- stack(u, u1, u2, v, v1, v2)
names(field) &lt;- c('u', 'u1', 'u2', 'v', 'v1', 'v2')

vectorplot(field, isField='dXY',
           narrows=300, lwd.arrows=.4,
           par.settings=BTCTheme(),
           layout=c(3, 1))

## uLayer and vLayer define which layers contain
## horizontal and vertical components, respectively
vectorplot(field, isField='dXY',
           narrows=300,
           uLayer=1:3,
           vLayer=6:4)

##################################################################
## Streamplot
##################################################################
## If no cluster is provided, streamplot uses parallel::mclapply except
## with Windows. Therefore, next code could spend a long time under
## Windows.
streamplot(r1)

## With a cluster
hosts &lt;- rep('localhost', 4)
cl &lt;- parallel::makeCluster(hosts)
palRed &lt;- RColorBrewer::brewer.pal(n = 5, name = 'Reds')
streamplot(r2, cl=cl,
           par.settings=streamTheme(symbol= palRed))
parallel::stopCluster(cl)

## Without parallel
palGreen &lt;- RColorBrewer::brewer.pal(n = 5, name = 'Greens')
streamplot(r3, parallel=FALSE,
           par.settings=streamTheme(symbol = palGreen))

## Configuration of droplets and streamlets
streamplot(s, layout=c(1, 3), droplet=list(pc=.2), streamlet=list(L=20),
           par.settings=streamTheme(cex=.6))

## End(Not run)

</code></pre>


</div>