<div class="container">

<table style="width: 100%;"><tr>
<td>comboGeneral</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate Combinations and Permutations of a Vector with/without Constraints
</h2>

<h3>Description</h3>


<ul>
<li>
<p> Generate combinations or permutations of a vector with or without constraints.
</p>
</li>
<li>
<p> Produce results in parallel using the <code>Parallel</code> or <code>nThreads</code> arguments. You can also apply each of the five compiled functions given by the argument <code>constraintFun</code> in parallel.
</p>
</li>
<li>
<p> The arguments <code>lower</code> and <code>upper</code> make it possible to generate combinations/permutations in chunks allowing for parallelization via the <code>parallel-package</code>. This is convenient when you want to apply a custom function to the output in parallel.
</p>
</li>
<li>
<p> Attack integer partition and general subset sum problems.
</p>
</li>
<li>
<p> GMP support allows for exploration of combinations/permutations of vectors with many elements.
</p>
</li>
<li>
<p> The output is in lexicographical order.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">comboGeneral(v, m = NULL, ...)
permuteGeneral(v, m = NULL, ...)

## S3 method for class 'numeric'
comboGeneral(v, m = NULL, repetition = FALSE, freqs = NULL,
             lower = NULL, upper = NULL, constraintFun = NULL,
             comparisonFun = NULL, limitConstraints = NULL,
             keepResults = NULL, FUN = NULL, Parallel = FALSE,
             nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'numeric'
permuteGeneral(v, m = NULL, repetition = FALSE, freqs = NULL,
               lower = NULL, upper = NULL, constraintFun = NULL,
               comparisonFun = NULL, limitConstraints = NULL,
               keepResults = NULL, FUN = NULL, Parallel = FALSE,
               nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'factor'
comboGeneral(
    v, m = NULL, repetition = FALSE, freqs = NULL, lower = NULL, upper = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)
## S3 method for class 'factor'
permuteGeneral(
    v, m = NULL, repetition = FALSE, freqs = NULL, lower = NULL, upper = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)

## Default S3 method:
comboGeneral(v, m = NULL, repetition = FALSE,
             freqs = NULL, lower = NULL, upper = NULL,
             FUN = NULL, FUN.VALUE = NULL, ...)
## Default S3 method:
permuteGeneral(v, m = NULL, repetition = FALSE,
               freqs = NULL, lower = NULL, upper = NULL,
               FUN = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'table'
comboGeneral(
    v, m = NULL, lower = NULL, upper = NULL, constraintFun = NULL,
    comparisonFun = NULL, limitConstraints = NULL, keepResults = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, tolerance = NULL,
    FUN.VALUE = NULL, ...
)
## S3 method for class 'table'
permuteGeneral(
    v, m = NULL, lower = NULL, upper = NULL, constraintFun = NULL,
    comparisonFun = NULL, limitConstraints = NULL, keepResults = NULL,
    FUN = NULL, Parallel = FALSE, nThreads = NULL, tolerance = NULL,
    FUN.VALUE = NULL, ...
)

## S3 method for class 'list'
comboGeneral(v, m = NULL, repetition = FALSE,
             freqs = NULL, lower = NULL, upper = NULL, ...)
## S3 method for class 'list'
permuteGeneral(v, m = NULL, repetition = FALSE,
               freqs = NULL, lower = NULL, upper = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code>is.atomic</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of elements to choose.  If <code>repetition = TRUE</code> or <code>freqs</code> is utilized, <code>m</code> can exceed the length of <code>v</code>. If <code>m = NULL</code>, the length will default to <code>length(v)</code> or <code>sum(freqs)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code>rep</code>. The default value is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>The lower bound. Combinations/permutations are generated lexicographically, thus utilizing this argument will determine which specific combination/permutation to start generating from (<em>e.g.</em> <code>comboGeneral(5, 3, lower = 6)</code> is equivalent to <code>comboGeneral(5, 3)[6:choose(5, 3), ]</code>). This argument along with <code>upper</code> is very useful for generating combinations/permutations in chunks allowing for easy parallelization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>The upper bound. Similar to <code>lower</code>, however this parameter allows the user to <em>stop</em> generation at a specific combination/permutation (<em>e.g.</em> <code>comboGeneral(5, 3, upper = 5)</code> is equivalent to <code>comboGeneral(5, 3)[1:5, ]</code>)
</p>
<p>If the output is constrained and <code>lower</code> isn't supplied, <code>upper</code> serves as a cap for how many results will be returned that meet the criteria (<em>e.g.</em> setting <code>upper = 100</code> alone will return the first 100 results that meet the criteria, while setting <code>lower = 1</code> and <code>upper = 100</code> will test the first 100 results against the criteria).
</p>
<p>In addition to the benefits listed for <code>lower</code>, this parameter is useful when the total number of combinations/permutations without constraint is large and you expect/need a small number of combinations/permutations that meet a certain criteria. Using <code>upper</code> can improve run time if used judiciously as we call the member function <a href="https://en.cppreference.com/w/cpp/container/vector/reserve">reserve</a> of <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>. See examples below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraintFun</code></td>
<td>
<p>Function to be applied to the elements of <code>v</code> that should be passed as a string (<em>e.g.</em> <code>constraintFun = "sum"</code>). The possible constraint functions are: <code>"sum"</code>, <code>"prod"</code>, <code>"mean"</code>, <code>"max"</code>, &amp; <code>"min"</code>. The default is <code>NULL</code>, meaning no function is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparisonFun</code></td>
<td>
<p>Comparison operator that will be used to compare <code>limitConstraints</code> with the result of <code>constraintFun</code> applied to <code>v</code>. It should be passed as a string or a vector of two strings (<em>e.g.</em> <code>comparisonFun = "&lt;="</code> or  <code>comparisonFun = c("&gt;","&lt;")</code>). The possible comparison operators are: <code>"&lt;"</code>, <code>"&gt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"=="</code>. The default is <code>NULL</code>.
</p>
<p>When <code>comparisonFun</code> is a vector of two comparison strings, <em>e.g</em> <code>comparisonFun = c(comp1, comp2)</code>, and <code>limitConstraints</code> is a vector of two numerical values, <em>e.g</em> <code>limitConstraints = c(x1, x2)</code>, the combinations/permutations will be filtered in one of the following two ways:
</p>

<ol>
<li>
<p>When <code>comp1</code> is one of the 'greater-than' operators (<em>i.e.</em> "&gt;=" or "&gt;"), <code>comp2</code> is one of the 'less-than' operators (<em>i.e.</em> "&lt;=" or "&lt;"), and <code>x1 &lt; x2</code>, the combinations/permutations that are returned will have a value (after <code>constraintFun</code> has been applied) between <code>x1</code> and <code>x2</code>.
</p>
</li>
<li>
<p>When <code>comp1</code> and <code>comp2</code> are defined as in #1 and <code>x1 &gt; x2</code>, the combinations/permutations that are returned will have a value outside the range of <code>x1</code> and <code>x2</code>. See the examples below.
</p>
</li>
</ol>
<p>In other words, the first comparison operator is applied to the first limit and the second operator is applied to the second limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limitConstraints</code></td>
<td>
<p>This is the value(s) that will be used for comparison. Can be passed as a single value or a vector of two numerical values. The default is <code>NULL</code>. See the definition of <code>comparisonFun</code> as well as the examples below for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepResults</code></td>
<td>
<p>A logical flag indicating if the result of <code>constraintFun</code> applied to <code>v</code> should be displayed; if <code>TRUE</code>, an additional column of results will be added to the resulting matrix. The default is <code>FALSE</code>. If user is only applying <code>constraintFun</code>, <code>keepResults</code> will default to <code>TRUE</code>.
</p>
<p><em>E.g</em>. The following are equivalent and will produce a <code class="reqn">4^{th}</code> column of row sums:
</p>

<ul>
<li> <p><code>comboGeneral(5, 3 constraintFun = "sum", keepResults = TRUE)</code>
</p>
</li>
<li> <p><code>comboGeneral(5, 3 constraintFun = "sum")</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>Function to be applied to each combination/permutation. The default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Parallel</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be generated in parallel using <code class="reqn">n - 1</code> threads, where <code class="reqn">n</code> is the maximum number of threads. The default is <code>FALSE</code>. If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>A numeric value greater than or equal to zero. This parameter is utilized when a constraint is applied on a numeric vector. The default value is 0 when it can be determined that whole values are being utilized, otherwise it is <code>sqrt(.Machine$double.eps)</code> which is approximately <code class="reqn">1.5e-8</code>. N.B. If the input vector is of type integer, this parameter will be ignored and strict equality will be enforced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN.VALUE</code></td>
<td>
<p>A template for the return value from <code>FUN</code>. See 'Details' of <code>vapply</code> for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the general case, finding all combinations/permutations with constraints is optimized by organizing them in such a way that when <code>constraintFun</code> is applied, a <em>partially</em> monotonic sequence is produced. Combinations/permutations are added successively, until a particular combination exceeds the given constraint value for a given constraint/comparison function combo. After this point, we can safely skip several combinations knowing that they will exceed the given constraint value.
</p>
<p>There are special cases where more efficient algorithms are dyncamically deployed. These cases center around the subject of integer partitions. See <code>partitionsGeneral</code> for more information.
</p>
<p>When there are any negative values in <code>v</code> and <code>constraintFun = "prod"</code>, producing a monotonic set is non-trivial for the general case. As a result, performance will suffer as all combinations/permutations must be tested against the constraint criteria.
</p>


<h3>Value</h3>


<ul>
<li>
<p> In general, a matrix with <code class="reqn">m</code> or <code class="reqn">m + 1</code> columns, depending on the value of <code>keepResults</code>
</p>
</li>
<li>
<p> If <code>FUN</code> is utilized and <code>FUN.VALUE = NULL</code>, a list is returned
</p>
</li>
<li>
<p> When both <code>FUN</code> and <code>FUN.VALUE</code> are not <code>NULL</code>, the return is modeled after the return of <code>vapply</code>. See the 'Value' section of <code>vapply</code>.
</p>
</li>
</ul>
<h3>Note</h3>


<ul>
<li> <p><code>Parallel</code> and <code>nThreads</code> will be ignored in the following cases:
</p>

<ul>
<li>
<p> When the output is constrained (except for most partitions cases)
</p>
</li>
<li>
<p> If the class of the vector passed is <code>character</code>, <code>raw</code>, and <code>complex</code> (N.B. <code>Rcpp::CharacterMatrix</code> is not thread safe). Alternatively, you can generate an indexing matrix in parallel.
</p>
</li>
<li>
<p> If <code>FUN</code> is utilized.
</p>
</li>
</ul>
</li>
<li>
<p> If either <code>constraintFun</code>, <code>comparisonFun</code> or <code>limitConstraints</code> is <code>NULL</code> –or– if the class of the vector passed is <code>logical</code>, <code>character</code>, <code>raw</code>, <code>factor</code>, or <code>complex</code>, the constraint check will not be carried out. This is equivalent to simply finding all combinations/permutations of <code class="reqn">v</code> choose <code class="reqn">m</code>.
</p>
</li>
<li>
<p> The maximum number of combinations/permutations that can be generated at one time is <code class="reqn">2^{31} - 1</code>. Utilizing <code>lower</code> and <code>upper</code> makes it possible to generate additional combinations/permutations.
</p>
</li>
<li>
<p> Factor vectors are accepted. Class and level attributes are preserved except when <code>FUN</code> is used.
</p>
</li>
<li>
<p> Lexicographical ordering isn't guaranteed for permutations if <code>lower</code> isn't supplied and the output is constrained.
</p>
</li>
<li>
<p> If <code>lower</code> is supplied and the output is constrained, the combinations/permutations that will be tested will be in the lexicographical range <code>lower</code> to <code>upper</code> or up to the total possible number of results if <code>upper</code> is not given. See the second paragraph for the definition of <code>upper</code>.
</p>
</li>
<li> <p><code>FUN</code> will be ignored if the constraint check is satisfied.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://gallery.rcpp.org/articles/passing-cpp-function-pointers/">Passing user-supplied C++ functions</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Monotonic_function">Monotonic Sequence</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Multiset">Multiset</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical Order</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Subset_sum_problem">Subset Sum Problem</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Partition_(number_theory)">Partition (Number Theory)</a>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">comboGeneral(4, 3)
permuteGeneral(3)

permuteGeneral(factor(letters[1:3]), repetition = TRUE)

## permutations of the multiset :
## c(1,1,1,2,2,3)
permuteGeneral(table(c(1,1,1,2,2,3)))

## Example with list
comboGeneral(
    v = list(
        p1 = matrix(1:10, ncol = 2),
        p2 = data.frame(a = letters, b = 1:26),
        p3 = as.complex(1:10)
    ),
    m = 2
)

#### Examples using "upper" and "lower":
## See specific range of permutations
permuteGeneral(75, 10, freqs = rep(1:3, 25),
               lower = 1e12, upper = 1e12 + 10)

## Researcher only needs 10 7-tuples of mySamp
## such that the sum is greater than 7200.
## Generate some random data
set.seed(1009)
mySamp = rnorm(75, 997, 23)
comboGeneral(mySamp, 7, constraintFun = "sum",
             comparisonFun = "&gt;", limitConstraints = 7200, upper = 10)

## Similarly, you can use "lower" to obtain the last rows.
## Generate the last 10 rows
comboGeneral(mySamp, 7, lower = choose(75, 7) - 9)

## Or if you would like to generate a specific chunk,
## use both "lower" and "upper". E.g. Generate one
## million combinations starting with the 900,000,001
## lexicographic combination.
t1 = comboGeneral(mySamp, 7,
                  lower = 9*10^8 + 1,
                  upper = 9*10^8 + 10^6)

## class of the source vector is preserved
class(comboGeneral(5,3)[1,]) == class(1:5)
class(comboGeneral(c(1,2:5),3)[1,]) == class(c(1,2:5))
class(comboGeneral(factor(month.name),3)[1,]) == class(factor(month.name))

## Using keepResults will add a column of results
comboGeneral(-3, 6, TRUE,
             constraintFun = "sum",
             comparisonFun = "==",
             limitConstraints = -8,
             keepResults = TRUE)

## Using multiple constraints:

## Get combinations such that the product
## is between 3000 and 4000 inclusive
comboGeneral(5, 7, TRUE, constraintFun = "prod",
             comparisonFun = c("&gt;=","&lt;="),
             limitConstraints = c(3000, 4000),
             keepResults = TRUE)

## Or, get the combinations such that the
## product is less than or equal to 10 or
## greater than or equal to 40000
comboGeneral(5, 7, TRUE, constraintFun = "prod",
             comparisonFun = c("&lt;=","&gt;="),
             limitConstraints = c(10, 40000),
             keepResults = TRUE)

#### General subset sum problem
set.seed(516781810)
comboGeneral(runif(100, 0, 42), 5, constraintFun = "mean",
             comparisonFun = "==", limitConstraints = 30,
             tolerance = 0.0000002)


#### Integer Partitions
comboGeneral(0:5, 5, TRUE, constraintFun = "sum",
             comparisonFun = "==", limitConstraints = 5)


## Using FUN
comboGeneral(10000, 5, lower = 20, upper = 22,
             FUN = function(x) {
                 which(cummax(x) %% 2 == 1)
             })

## Not run: 
## Parallel example generating more than 2^31 - 1 combinations.
library(parallel)
numCores = detectCores() - 1

## 10086780 evenly divides choose(35, 15) and is "small enough" to
## generate quickly in chunks.
system.time(mclapply(seq(1, comboCount(35, 15), 10086780), function(x) {
    a = comboGeneral(35, 15, lower = x, upper = x + 10086779)
    ## do something
    x
}, mc.cores = numCores))


## Find 13-tuple combinations of 1:25 such
## that the mean is less than 10
system.time(myComb &lt;- comboGeneral(25, 13, FALSE,
                                   constraintFun = "mean",
                                   comparisonFun = "&lt;",
                                   limitConstraints = 10))

## Alternatively, you must generate all combinations and subsequently
## subset to obtain the combinations that meet the criteria
system.time(myComb2 &lt;- combn(25, 13))
system.time(myCols &lt;- which(colMeans(myComb2) &lt; 10))
system.time(myComb2 &lt;- myComb2[, myCols])

## Any variation is much slower
system.time(myComb2 &lt;- combn(25, 13)[,combn(25, 13, mean) &lt; 10])

## Test equality with myComb above
all.equal(myComb, t(myComb2))

## Fun example... see stackoverflow:
## https://stackoverflow.com/q/22218640/4408538
system.time(permuteGeneral(seq(0L,100L,10L), 8, TRUE,
                           constraintFun = "sum",
                           comparisonFun = "==",
                           limitConstraints = 100))

## These are called weak integer compositions. Below, we call
## compositionsGeneral which gives the same output except it
## in lexicographical order. See 'Note' above
system.time(compositionsGeneral(seq(0L,100L,10L), 8, TRUE, weak = TRUE))

## End(Not run)
</code></pre>


</div>