<div class="container">

<table style="width: 100%;"><tr>
<td>REBMIX-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
REBMIX Algorithm for Univariate or Multivariate Finite Mixture Estimation
</h2>

<h3>Description</h3>

<p>Returns as default the REBMIX algorithm output for mixtures of conditionally independent normal, lognormal, Weibull, gamma, Gumbel, binomial, Poisson, Dirac, uniform or von Mises component densities. If <code>model</code> equals <code>"REBMVNORM"</code> output for mixtures of multivariate normal component densities with unrestricted variance-covariance matrices is returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'REBMIX'
REBMIX(model = "REBMIX", Dataset = list(), Preprocessing = character(),
       cmax = 15, cmin = 1, Criterion = "AIC", pdf = character(), 
       theta1 = numeric(), theta2 = numeric(), theta3 = numeric(), K = "auto", 
       ymin = numeric(), ymax = numeric(), ar = 0.1, 
       Restraints = "loose", Mode = "outliersplus", EMcontrol = NULL, ...)
## ... and for other signatures
## S4 method for signature 'REBMIX'
summary(object, ...)
## ... and for other signatures
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>see Methods section below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dataset</code></td>
<td>

<p>a list of length <code class="reqn">n_{\mathrm{D}}</code> of data frames or objects of class <code>Histogram</code>. 
Data frames should have size <code class="reqn">n \times d</code> containing <em>d</em>-dimensional datasets. Each of the <code class="reqn">d</code>
columns represents one random variable. Numbers of observations <code class="reqn">n</code> equal the number of rows in the datasets.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Preprocessing</code></td>
<td>

<p>a character giving the preprocessing type. One of <code>"histogram"</code>, <br><code>"kernel density estimation"</code> or <code>"k-nearest neighbour"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmax</code></td>
<td>

<p>maximum number of components <code class="reqn">c_{\mathrm{max}} &gt; 0</code>. The default value is <code>15</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cmin</code></td>
<td>

<p>minimum number of components <code class="reqn">c_{\mathrm{min}} &gt; 0</code>. The default value is <code>1</code>. If <code class="reqn">c_{\mathrm{min}} &gt; 1</code>, it may happen that no solution is found,
and an error is returned by the method.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Criterion</code></td>
<td>

<p>a character giving the information criterion type. One of default Akaike <code>"AIC"</code>, <code>"AIC3"</code>, <code>"AIC4"</code> or <code>"AICc"</code>,
Bayesian <code>"BIC"</code>, consistent Akaike <code>"CAIC"</code>, Hannan-Quinn <code>"HQC"</code>, minimum description length <code>"MDL2"</code> or <code>"MDL5"</code>,
approximate weight of evidence <code>"AWE"</code>, classification likelihood <code>"CLC"</code>,
integrated classification likelihood <code>"ICL"</code> or <code>"ICL-BIC"</code>, partition coefficient <code>"PC"</code>,
total of positive relative deviations <code>"D"</code> or sum of squares error <code>"SSE"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdf</code></td>
<td>

<p>a character vector of length <code class="reqn">d</code> containing continuous or discrete parametric family types. One of <code>"normal"</code>, <code>"lognormal"</code>, <code>"Weibull"</code>, <code>"gamma"</code>, <code>"Gumbel"</code>, <code>"binomial"</code>, <code>"Poisson"</code>, <code>"Dirac"</code>, <code>"uniform"</code> or <code>"vonMises"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta1</code></td>
<td>

<p>a vector of length <code class="reqn">d</code> containing initial component parameters. One of <code class="reqn">n_{il} = \textrm{number of categories} - 1</code> for <code>"binomial"</code> distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta2</code></td>
<td>

<p>a vector of length <code class="reqn">d</code> containing initial component parameters. Currently not used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta3</code></td>
<td>

<p>a vector of length <code class="reqn">d</code> containing initial component parameters. One of <code class="reqn">\xi_{il} \in \{-1, \textrm{NA}, 1\}</code> for <code>"Gumbel"</code> distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>

<p>a character or a vector or a matrix of size <code class="reqn">n_{\mathrm{D}} \times d</code> containing numbers of bins <code class="reqn">v</code> or <code class="reqn">v_{1}, \ldots, v_{d}</code> for the histogram and the kernel density estimation or numbers of nearest
neighbours <code class="reqn">k</code> for the <em>k</em>-nearest neighbour. There is no genuine rule to identify <code class="reqn">v</code> or <code class="reqn">k</code>. Consequently,
the REBMIX algorithm identifies them from the set <code>K</code> of input values by
minimizing the information criterion. The Sturges rule <code class="reqn">v = 1 + \mathrm{log_{2}}(n)</code>, <code class="reqn">\mathrm{Log}_{10}</code> rule <code class="reqn">v = 10 \mathrm{log_{10}}(n)</code> or RootN
rule <code class="reqn">v = 2 \sqrt{n}</code> can be applied to estimate the limiting numbers of bins
or the rule of thumb <code class="reqn">k = \sqrt{n}</code> to guess the intermediate number of nearest neighbours. If, e.g., <code>K = c(10, 20, 40, 60)</code> and minimum <code>IC</code> coincides, e.g., <code>40</code>, brackets are set to <code>20</code> and <code>60</code> and the golden section is applied to refine the minimum search. 
If, e.g., <code>K = matrix(c(10, 15, 18, 5, 7, 9), byrow = TRUE, ncol = 3)</code> than <code class="reqn">d = 3</code> and the list <code>Dataset</code> contains <code class="reqn">n_{\mathrm{D}} = 2</code> frames. Hence, different numbers of bins can be assigned to <code class="reqn">y_{1}, \ldots, y_{d}</code>.
See also <code>kseq</code> for sequence of bins or nearest neighbours generation. The default value is <code>"auto"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ymin</code></td>
<td>

<p>a vector of length <code class="reqn">d</code> containing minimum observations. The default value is <code>numeric()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ymax</code></td>
<td>

<p>a vector of length <code class="reqn">d</code> containing maximum observations. The default value is <code>numeric()</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ar</code></td>
<td>

<p>acceleration rate <code class="reqn">0 &lt; a_{\mathrm{r}} \leq 1</code>. The default value is <code>0.1</code> and in most cases does not have to be altered.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Restraints</code></td>
<td>

<p>a character giving the restraints type. One of <code>"rigid"</code> or default <code>"loose"</code>.
The rigid restraints are obsolete and applicable for well separated components only.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mode</code></td>
<td>

<p>a character giving the mode type. One of <code>"all"</code>, <code>"outliers"</code> or default <code>"outliersplus"</code>. The modes are determined in decreasing order of magnitude from all observations if <code>Mode = "all"</code>.
If <code>Mode = "outliers"</code>, the modes are determined in decreasing order of magnitude from outliers only. In the meantime, some outliers are reclassified as inliers. Finally, when all observations are inliers, the procedure is completed.
If <code>Mode = "outliersplus"</code>, the modes are determined in decreasing magnitude from the outliers only. In the meantime, some outliers are reclassified as inliers. Finally, if all observations are inliers, they are converted to outliers and the mode determination procedure is continued.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>EMcontrol</code></td>
<td>

<p>an object of class <code>EM.Control</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>see Methods section below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>currently not used.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns an object of class <code>REBMIX</code> or <code>REBMVNORM</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "REBMIX")</code></dt>
<dd>
<p>a character giving the default class name <code>"REBMIX"</code> for mixtures of conditionally independent normal, lognormal, Weibull, gamma, Gumbel, binomial, Poisson, Dirac, uniform or von Mises component densities.</p>
</dd>
<dt><code>signature(model = "REBMVNORM")</code></dt>
<dd>
<p>a character giving the class name <code>"REBMVNORM"</code> for mixtures of multivariate normal component densities with unrestricted variance-covariance matrices.</p>
</dd>
<dt><code>signature(object = "REBMIX")</code></dt>
<dd>
<p>an object of class <code>REBMIX</code>.</p>
</dd>
<dt><code>signature(object = "REBMVNORM")</code></dt>
<dd>
<p>an object of class <code>REBMVNORM</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Marko Nagode</p>


<h3>References</h3>

<p>H. A. Sturges. The choice of a class interval. Journal of American Statistical Association, 21(153):
65-66, 1926. https://www.jstor.org/stable/2965501.<br><br>
P. F. Velleman. Interactive computing for exploratory data analysis I: display algorithms. Proceedings of the Statistical Computing Section,
American Statistical Association, 1976.<br><br>
W. J. Dixon and R. A. Kronmal. The Choice of origin and scale for graphs. Journal of the ACM, 12(2):
259-261, 1965. <a href="https://doi.org/10.1145/321264.321277">doi:10.1145/321264.321277</a>.<br><br>
M. Nagode and M. Fajdiga. A general multi-modal probability density function suitable for the
rainflow ranges of stationary random processes. International Journal of Fatigue, 20(3):211-223,
1998. <a href="https://doi.org/10.1016/S0142-1123%2897%2900106-0">doi:10.1016/S0142-1123(97)00106-0</a>.<br><br>
M. Nagode and M. Fajdiga. An improved algorithm for parameter estimation suitable for mixed
weibull distributions. International Journal of Fatigue, 22(1):75-80, 2000. <a href="https://doi.org/10.1016/S0142-1123%2899%2900112-7">doi:10.1016/S0142-1123(99)00112-7</a>.<br><br>
M. Nagode, J. Klemenc and M. Fajdiga. Parametric modelling and scatter prediction of rainflow
matrices. International Journal of Fatigue, 23(6):525-532, 2001. <a href="https://doi.org/10.1016/S0142-1123%2801%2900007-X">doi:10.1016/S0142-1123(01)00007-X</a>.<br><br>
M. Nagode and M. Fajdiga. An alternative perspective on the mixture estimation problem. Reliability
Engineering &amp; System Safety, 91(4):388-397, 2006. <a href="https://doi.org/10.1016/j.ress.2005.02.005">doi:10.1016/j.ress.2005.02.005</a>.<br><br>
M. Nagode and M. Fajdiga. The rebmix algorithm for the univariate finite mixture estimation.
Communications in Statistics - Theory and Methods, 40(5):876-892, 2011a. <a href="https://doi.org/10.1080/03610920903480890">doi:10.1080/03610920903480890</a>.<br><br>
M. Nagode and M. Fajdiga. The rebmix algorithm for the multivariate finite mixture estimation.
Communications in Statistics - Theory and Methods, 40(11):2022-2034, 2011b. <a href="https://doi.org/10.1080/03610921003725788">doi:10.1080/03610921003725788</a>.<br><br>
M. Nagode. Finite mixture modeling via REBMIX.
Journal of Algorithms and Optimization, 3(2):14-28, 2015. <a href="https://repozitorij.uni-lj.si/Dokument.php?id=127674&amp;lang=eng">https://repozitorij.uni-lj.si/Dokument.php?id=127674&amp;lang=eng</a>.<br><br>
B. Panic, J. Klemenc, M. Nagode. Improved initialization of the EM algorithm for mixture model parameter estimation.
Mathematics, 8(3):373, 2020.
<a href="https://doi.org/10.3390/math8030373">doi:10.3390/math8030373</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate and plot univariate normal dataset.

n &lt;- c(998, 263, 1086, 487)

Theta &lt;- new("RNGMIX.Theta", c = 4, pdf = "normal")

a.theta1(Theta) &lt;- c(688, 265, 30, 934)
a.theta2(Theta) &lt;- c(72, 54, 34, 28)

normal &lt;- RNGMIX(Dataset.name = "complex1",
  rseed = -1,
  n = n,
  Theta = a.Theta(Theta))

normal

a.Dataset(normal, 1)[1:20,]

# Estimate number of components, component weights and component parameters.

normalest &lt;- REBMIX(Dataset = a.Dataset(normal),
  Preprocessing = "h",
  cmax = 8,
  Criterion = "BIC",
  pdf = "n")

normalest

BIC(normalest)

logL(normalest)

# Plot finite mixture.

plot(normalest, nrow = 2, what = c("pdf", "marginal cdf"), npts = 1000)

# EM algorithm utilization

# Load iris data.

data(iris)

Dataset &lt;- list(data.frame(iris[, c(1:4)]))

# Create EM.Control object.

EM &lt;- new("EM.Control", 
  strategy = "exhaustive", 
  variant = "EM", 
  acceleration = "fixed", 
  tolerance = 1e-4, 
  acceleration.multiplier = 1.0, 
  maximum.iterations = 1000)

# Mixture parameter estimation using REBMIX and EM algorithm.

irisest &lt;- REBMIX(model = "REBMVNORM", 
  Dataset = Dataset, 
  Preprocessing = "histogram",
  cmax = 10,
  Criterion = "BIC",
  EMcontrol = EM)

irisest

# Print total number of EM iterations used in Ehxaustive strategy from summary.EM slot.

a.summary.EM(irisest, col.name = "total.iterations.nbr", pos = 1)
</code></pre>


</div>