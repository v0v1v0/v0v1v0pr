<div class="container">

<table style="width: 100%;"><tr>
<td>as.npregbw</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convert an rdd_reg object to a  <code>npreg</code> object</h2>

<h3>Description</h3>

<p>Convert an rdd_object to a non-parametric regression <code>npreg</code> from package <code>np</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">as.npregbw(x, ...)

as.npreg(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object of class <code>rdd_reg</code> created by <code>rdd_reg_np</code> or <code>rdd_reg_lm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to the <code>npregbw</code> or <code>npreg</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function converts an rdd_reg object into an <code>npreg</code> object from package <code>np</code>
Note that the output won't be the same, since <code>npreg</code> does not offer a triangular kernel, but a Gaussian or Epanechinkov one. 
Another reason why estimates might differ slightly is that <code>npreg</code> implements a multivariate kernel, while rdd_reg 
proceeds as if the kernel was univariate. A simple solution to make the multivariate kernel similar to the  univariate one 
is to set the bandwidth for x and Dx to a large number, so that they converge towards a constant, and one obtains back the univariate kernel.
</p>


<h3>Value</h3>

<p>An object of class <code>npreg</code> or <code>npregbw</code>
</p>


<h3>See Also</h3>

<p><code>as.lm</code> which converts <code>rdd_reg</code> objects into <code>lm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Estimate ususal rdd_reg:
 data(house)
 house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
 reg_nonpara &lt;- rdd_reg_np(rdd_object=house_rdd)

## Convert to npreg:
 reg_nonpara_np &lt;- as.npreg(reg_nonpara)
 reg_nonpara_np
 rdd_coef(reg_nonpara_np, allCo=TRUE, allInfo=TRUE)

## Compare with result obtained with a Gaussian kernel:
 bw_lm &lt;- dnorm(house_rdd$x, sd=rddtools:::getBW(reg_nonpara))
 reg_nonpara_gaus &lt;- rdd_reg_lm(rdd_object=house_rdd, w=bw_lm)
 all.equal(rdd_coef(reg_nonpara_gaus),rdd_coef(reg_nonpara_np)) 
</code></pre>


</div>