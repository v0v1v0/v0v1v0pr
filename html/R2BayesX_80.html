<div class="container">

<table style="width: 100%;"><tr>
<td>sx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Construct BayesX Model Terms in A Formula
</h2>

<h3>Description</h3>

<p>Function <code>sx</code> is a model term constructor function for terms used within the <code>formula</code>
argument of function <code>bayesx</code>. The function does not evaluate matrices etc., the 
behavior is similar to function <code>s</code> from package <code>mgcv</code>. It 
purely exists to build a basic setup for the model term which can be processed by function 
<code>bayesx.construct</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sx(x, z = NULL, bs = "ps", by = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the covariate the model term is a function of.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>a second covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs</code></td>
<td>
<p>a <code>character</code> string, specifying the basis/type which is used for this model 
term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>a <code>numeric</code> or <code>factor</code> variable of the same dimension as each 
covariate. In the <code>numeric</code> vector case the elements multiply the smooth, evaluated at the 
corresponding covariate values (a ‘varying coefficient model’ results). In the <code>factor</code> 
case the term is replicated for each <code>factor</code> level. Note that centering of the term may be 
needed, please see the notes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>special controlling arguments or objects used for the model term, see also 
the examples and function <code>bayesx.term.options</code> for all possible optional 
parameters.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following term types may be specified using argument <code>bs</code>:
</p>

<ul>
<li> <p><code>"rw1"</code>, <code>"rw2"</code>: Zero degree P-splines: Defines a zero degree P-spline with first or
second order difference penalty. A zero degree P-spline typically
estimates for every distinct covariate value in the dataset a separate
parameter. Usually there is no reason to prefer zero degree P-splines
over higher order P-splines. An exception are ordinal covariates or
continuous covariates with only a small number of different values.
For ordinal covariates higher order P-splines are not meaningful while
zero degree P-splines might be an alternative to modeling nonlinear
relationships via a dummy approach with completely unrestricted
regression parameters.
</p>
</li>
<li> <p><code>"season"</code>: Seasonal effect of a time scale. 
</p>
</li>
<li> <p><code>"ps"</code>, <code>"psplinerw1"</code>, <code>"psplinerw2"</code>: P-spline with first or second order 
difference penalty. 
</p>
</li>
<li> <p><code>"te"</code>, <code>"pspline2dimrw1"</code>: Defines a two-dimensional P-spline based on the tensor
product of one-dimensional P-splines with a two-dimensional first order random walk
penalty for the parameters of the spline. 
</p>
</li>
<li> <p><code>"kr"</code>, <code>"kriging"</code>: Kriging with stationary Gaussian random fields.  
</p>
</li>
<li> <p><code>"gk"</code>, <code>"geokriging"</code>: Geokriging with stationary Gaussian random fields: Estimation
is based on the centroids of a map object provided in
boundary format (see function <code>read.bnd</code> and <code>shp2bnd</code>) as an additional
argument named <code>map</code> within function <code>sx</code>, or supplied within argument
<code>xt</code> when using function <code>s</code>, e.g., <code>xt = list(map = MapBnd)</code>. 
</p>
</li>
<li> <p><code>"gs"</code>, <code>"geospline"</code>: Geosplines based on two-dimensional P-splines with a
two-dimensional first order random walk penalty for the parameters of the spline.	
Estimation is based on the coordinates of the centroids of the regions
of a map object provided in boundary format (see function <code>read.bnd</code> and
<code>shp2bnd</code>) as an additional argument named <code>map</code> (see above). 
</p>
</li>
<li> <p><code>"mrf"</code>, <code>"spatial"</code>: Markov random fields: Defines a Markov random field prior for a
spatial covariate, where geographical information is provided by a map object in
boundary or graph file format (see function <code>read.bnd</code>, <code>read.gra</code> and
<code>shp2bnd</code>), as an additional argument named <code>map</code> (see above).
</p>
</li>
<li> <p><code>"bl"</code>, <code>"baseline"</code>: Nonlinear baseline effect in hazard regression or multi-state
models: Defines a P-spline with second order random walk penalty for the parameters of
the spline for the log-baseline effect <code class="reqn">log(\lambda(time))</code>. 
</p>
</li>
<li> <p><code>"factor"</code>: Special <span class="pkg">BayesX</span> specifier for factors, especially meaningful if
<code>method = "STEP"</code>, since the factor term is then treated as a full term,
which is either included or removed from the model. 
</p>
</li>
<li> <p><code>"ridge"</code>, <code>"lasso"</code>, <code>"nigmix"</code>: Shrinkage of fixed effects: defines a
shrinkage-prior for the corresponding parameters
<code class="reqn">\gamma_j</code>, <code class="reqn">j = 1, \ldots, q</code>, <code class="reqn">q \geq 1</code> of the
linear effects <code class="reqn">x_1, \ldots, x_q</code>. There are three
priors possible: ridge-, lasso- and Normal Mixture
of inverse Gamma prior.
</p>
</li>
<li> <p><code>"re"</code>: Gaussian i.i.d. Random effects of a unit or cluster identification covariate.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>list</code> of class <code>"xx.smooth.spec"</code>, where <code>"xx"</code> is a basis/type identifying code
given by the <code>bs</code> argument of <code>f</code>. 
</p>


<h3>Note</h3>

<p>Some care has to be taken with the identifiability of varying coefficients terms. The standard in
<span class="pkg">BayesX</span> is to center nonlinear main effects terms around zero whereas varying coefficient terms are
not centered. This makes sense since main effects nonlinear terms are not identifiable and varying
coefficients terms are usually identifiable. However, there are situations where a varying
coefficients term is not identifiable. Then the term must be centered. Since centering is not
automatically accomplished it has to be enforced by the user by adding option
<code>center = TRUE</code> in function <code>f</code>. To give an example, the varying coefficient terms in 
<code class="reqn">\eta = \ldots + g_1(z_1)z + g_2(z_2)z + \gamma_0 + \gamma_1 z + \ldots</code> are not
identified, whereas in <code class="reqn">\eta = \ldots + g_1(z_1)z + \gamma_0 + \ldots</code>, the varying 
coefficient term is identifiable. In the first case, centering is necessary, in the second case, 
it is not.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code>bayesx</code>, <code>bayesx.term.options</code>, <code>s</code>,
<code>bayesx.construct</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## funktion sx() returns a list
## which is then processed by function
## bayesx.construct to build the
## BayesX model term structure
sx(x)

bayesx.construct(sx(x))
bayesx.construct(sx(x, bs = "rw1"))
bayesx.construct(sx(x, bs = "factor"))
bayesx.construct(sx(x, bs = "offset"))
bayesx.construct(sx(x, z, bs = "te"))

## varying coefficients
bayesx.construct(sx(x1, by = x2))
bayesx.construct(sx(x1, by = x2, center = TRUE))

## using a map for markov random fields
data("FantasyBnd")
plot(FantasyBnd)
bayesx.construct(sx(id, bs = "mrf", map = FantasyBnd))

## random effects
bayesx.construct(sx(id, bs = "re"))

## examples using optional controlling
## parameters and objects
bayesx.construct(sx(x, bs = "ps", knots = 20))
bayesx.construct(sx(x, bs = "ps", nrknots = 20))
bayesx.construct(sx(x, bs = "ps", knots = 20, nocenter = TRUE))

## use of bs with original 
## BayesX syntax 
bayesx.construct(sx(x, bs = "psplinerw1"))
bayesx.construct(sx(x, bs = "psplinerw2"))
bayesx.construct(sx(x, z, bs = "pspline2dimrw2"))

bayesx.construct(sx(id, bs = "spatial", map = FantasyBnd))
bayesx.construct(sx(x, z, bs = "kriging"))
bayesx.construct(sx(id, bs = "geospline", map = FantasyBnd, nrknots = 5))
bayesx.construct(sx(x, bs = "catspecific"))


## Not run: 
## generate some data
set.seed(111)
n &lt;- 200

## regressor
dat &lt;- data.frame(x = runif(n, -3, 3))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + rnorm(n, sd = 0.6))

## estimate models with
## bayesx REML and MCMC
b1 &lt;- bayesx(y ~ sx(x), method = "REML", data = dat)

## increase inner knots
## decrease degree of the P-spline
b2 &lt;- bayesx(y ~ sx(x, knots = 30, degree = 2), method = "REML", data = dat)


## compare reported output
summary(c(b1, b2))

## plot the effect for both models
plot(c(b1, b2), residuals = TRUE)


## more examples
set.seed(111)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, -3, 3),
  w = runif(n, 0, 6), fac = factor(rep(1:10, n/10)))

## response
dat$y &lt;- with(dat, 1.5 + sin(x) + cos(z) * sin(w) +
  c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac] + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x) + sx(z, w, bs = "te") + fac,
  data = dat, method = "MCMC")

summary(b)
plot(b)


## now a mrf example
## note: the regional identification
## covariate and the map regionnames
## should be coded as integer
set.seed(333)
     
## simulate some geographical data
data("MunichBnd")
N &lt;- length(MunichBnd); n &lt;- N*5
names(MunichBnd) &lt;- 1:N
     
## regressors
dat &lt;- data.frame(x1 = runif(n, -3, 3),
  id = as.factor(rep(names(MunichBnd), length.out = n)))
dat$sp &lt;- with(dat, sort(runif(N, -2, 2), decreasing = TRUE)[id])
     
## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + sp + rnorm(n, sd = 1.2))

## estimate models with
## bayesx MCMC and REML
b &lt;- bayesx(y ~ sx(x1) + sx(id, bs = "mrf", map = MunichBnd), 
  method = "REML", data = dat)

## summary statistics
summary(b)

## plot the effects
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))
plot(b, term = "sx(id)", map = MunichBnd, 
  main = "bayesx() estimate")
plotmap(MunichBnd, x = dat$sp, id = dat$id, 
  main = "Truth")
par(op)


## model with random effects
set.seed(333)
N &lt;- 30
n &lt;- N*10

## regressors
dat &lt;- data.frame(id = sort(rep(1:N, n/N)), x1 = runif(n, -3, 3))
dat$re &lt;- with(dat, rnorm(N, sd = 0.6)[id])

## response
dat$y &lt;- with(dat, 1.5 + sin(x1) + re + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x1, bs = "psplinerw1") + sx(id, bs = "re"), data = dat)
summary(b)
plot(b)

## extract estimated random effects
## and compare with true effects
plot(fitted(b, term = "sx(id)")$Mean ~ unique(dat$re))

## End(Not run)
</code></pre>


</div>