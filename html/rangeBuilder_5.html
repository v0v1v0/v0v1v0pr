<div class="container">

<table style="width: 100%;"><tr>
<td>filterByLand</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter occurrences based on land vs ocean</h2>

<h3>Description</h3>

<p>Identifies occurrence records that do not occur on land.
</p>


<h3>Usage</h3>

<pre><code class="language-R">filterByLand(coords, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coords</code></td>
<td>
<p>coordinates in the form of a 2 column numeric matrix,
data.frame, numeric vector, or spatial points object (sf or sp). 
If spatial object, crs must be defined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>crs of input coords. Ignored if input coords are
spatial object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses a rasterized version of the GSHHG (global
self-consistent, hierarchical, high-resolution geography database,
<a href="https://www.soest.hawaii.edu/pwessel/gshhg/">https://www.soest.hawaii.edu/pwessel/gshhg/</a>), that has been buffered
by 2 km.
</p>


<h3>Value</h3>

<p>returns a logical vector where <code>TRUE</code> means the point falls on
land.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(crotalus)

#identify points that fall off land
filterByLand(crotalus[,c('decimallongitude','decimallatitude')])


# testing different input options
samp &lt;- sample(1:nrow(crotalus), 10)
xy &lt;- crotalus[samp, c('decimallongitude', 'decimallatitude')]
sfpts &lt;- sf::st_as_sf(xy, coords = c('decimallongitude', 'decimallatitude'), crs = 4326)
sfptsEA &lt;- sf::st_transform(sfpts, crs = '+proj=eqearth')
spPts &lt;- as(sfpts, 'Spatial')
filterByLand(xy)
filterByLand(sfpts)
filterByLand(sfptsEA)
filterByLand(spPts)

</code></pre>


</div>