<div class="container">

<table style="width: 100%;"><tr>
<td>bayesx.construct</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Construct BayesX Model Term Objects
</h2>

<h3>Description</h3>

<p>The function <code>bayesx.construct</code> is used to provide a flexible framework to implement 
new model term objects in <code>bayesx</code> within the <span class="pkg">BayesX</span> syntax. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">bayesx.construct(object, dir, prg, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>is a smooth, shrinkage or random specification object in a STAR <code>formula</code>,
generated by the <code>R2BayesX</code> model term constructor functions <code>sx</code>
(or using the constructor functions <code>s</code> and
<code>te</code> of the <code>mgcv</code> package). Objects generated by
these functions have class <code>"xx.smooth.spec"</code> where <code>"xx"</code> is determined by the
<code>"bs"</code> argument of <code>sx</code> (and <code>s</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dir</code></td>
<td>
<p><code>character</code>, a directory where possible data should be stored, e.g. in
<code>bayesx</code> models, if <code>bs = "gk"</code>, <code>bs = "gs"</code> or <code>bs = "mrf"</code> is
choosen, the corresponding map will be  written as a <code>"bnd"</code> or <code>"gra"</code> file (see
<code>read.bnd</code> and <code>read.gra</code>) to this directory, so <span class="pkg">BayesX</span> can use
this spatial object for estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prg</code></td>
<td>
<p>if additional data handling must be applied, e.g. storing maps (<code>"bnd"</code>) objects
in the directory specified in <code>dir</code>, <code>write.bayesx.input</code> needs to write the
extra commands in a program file provided with argument <code>prg</code>, i.e. this may all be handled 
within a <code>bayesx.construct</code> constructor function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>if additional data is needed to setup the <span class="pkg">BayesX</span> term it is found here.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main idea of these constructor functions is to provide a flexible framework to implement new 
model term objects in the <span class="pkg">BayesX</span> syntax within <code>bayesx</code>, i.e. for any smooth or 
random term in <span class="pkg">R2BayesX</span> a constructor function like 
<code>bayesx.construct.ps.smooth.construct</code> may be provided to translate <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> specific syntax into 
<span class="pkg">BayesX</span> readable commands. During processing with <code>write.bayesx.input</code> each model
term is constructed with <code>bayesx.construct</code> after another, wrapped into a full formula, which 
may then be send to the <span class="pkg">BayesX</span> binary with function <code>run.bayesx</code>.
</p>
<p>At the moment the following model terms are implemented:
</p>

<ul>
<li> <p><code>"rw1"</code>, <code>"rw2"</code>: Zero degree P-splines: Defines a zero degree P-spline with first or
second order difference penalty. A zero degree P-spline typically
estimates for every distinct covariate value in the dataset a separate
parameter. Usually there is no reason to prefer zero degree P-splines
over higher order P-splines. An exception are ordinal covariates or
continuous covariates with only a small number of different values.
For ordinal covariates higher order P-splines are not meaningful while
zero degree P-splines might be an alternative to modeling nonlinear
relationships via a dummy approach with completely unrestricted
regression parameters.
</p>
</li>
<li> <p><code>"season"</code>: Seasonal effect of a time scale. 
</p>
</li>
<li> <p><code>"ps"</code>, <code>"psplinerw1"</code>, <code>"psplinerw2"</code>: P-spline with first or second order 
difference penalty. 
</p>
</li>
<li> <p><code>"te"</code>, <code>"pspline2dimrw1"</code>: Defines a two-dimensional P-spline based on the tensor
product of one-dimensional P-splines with a two-dimensional first order random walk
penalty for the parameters of the spline. 
</p>
</li>
<li> <p><code>"kr"</code>, <code>"kriging"</code>: Kriging with stationary Gaussian random fields.  
</p>
</li>
<li> <p><code>"gk"</code>, <code>"geokriging"</code>: Geokriging with stationary Gaussian random fields: Estimation
is based on the centroids of a map object provided in
boundary format (see function <code>read.bnd</code> and <code>shp2bnd</code>) as an additional
argument named <code>map</code> within function <code>sx</code>, or supplied within argument
<code>xt</code> when using function <code>s</code>, e.g., <code>xt = list(map = MapBnd)</code>. 
</p>
</li>
<li> <p><code>"gs"</code>, <code>"geospline"</code>: Geosplines based on two-dimensional P-splines with a
two-dimensional first order random walk penalty for the parameters of the spline.	
Estimation is based on the coordinates of the centroids of the regions
of a map object provided in boundary format (see function <code>read.bnd</code> and
<code>shp2bnd</code>) as an additional argument named <code>map</code> (see above). 
</p>
</li>
<li> <p><code>"mrf"</code>, <code>"spatial"</code>: Markov random fields: Defines a Markov random field prior for a
spatial covariate, where geographical information is provided by a map object in
boundary or graph file format (see function <code>read.bnd</code>, <code>read.gra</code> and
<code>shp2bnd</code>), as an additional argument named <code>map</code> (see above).
</p>
</li>
<li> <p><code>"bl"</code>, <code>"baseline"</code>: Nonlinear baseline effect in hazard regression or multi-state
models: Defines a P-spline with second order random walk penalty for the parameters of
the spline for the log-baseline effect <code class="reqn">log(\lambda(time))</code>. 
</p>
</li>
<li> <p><code>"factor"</code>: Special <span class="pkg">BayesX</span> specifier for factors, especially meaningful if
<code>method = "STEP"</code>, since the factor term is then treated as a full term,
which is either included or removed from the model. 
</p>
</li>
<li> <p><code>"ridge"</code>, <code>"lasso"</code>, <code>"nigmix"</code>: Shrinkage of fixed effects: defines a
shrinkage-prior for the corresponding parameters
<code class="reqn">\gamma_j</code>, <code class="reqn">j = 1, \ldots, q</code>, <code class="reqn">q \geq 1</code> of the
linear effects <code class="reqn">x_1, \ldots, x_q</code>. There are three
priors possible: ridge-, lasso- and Normal Mixture
of inverse Gamma prior.
</p>
</li>
<li> <p><code>"re"</code>: Gaussian i.i.d.\ Random effects of a unit or cluster identification covariate.
</p>
</li>
</ul>
<p>See function <code>sx</code> for a description of the main
<code>R2BayesX</code> model term constructor functions.
</p>


<h3>Value</h3>

<p>The model term syntax used within <span class="pkg">BayesX</span> as a character string.
</p>


<h3>WARNINGS</h3>

<p>If new <code>bayesx.construct</code> functions are implemented in future work, there may occur problems 
with reading the corresponding <span class="pkg">BayesX</span> output files with <code>read.bayesx.output</code>,
e.g., if the new objects do not have the structure as implemented with <code>bs = "ps"</code> etc.,
i.e. function <code>read.bayesx.output</code> must also be adapted in such cases.
</p>


<h3>Note</h3>

<p>Using <code>sx</code> additional controlling arguments may be supplied within the dot dot dot 
“<code>...</code>” argument. Please see the help site for function <code>bayesx.term.options</code>
for a detailed description of possible optional parameters.
</p>
<p>Within the <code>xt</code> argument in function <code>s</code>, additional
<span class="pkg">BayesX</span> specific parameters may be also supplied, see the examples below.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code>sx</code>, <code>bayesx.term.options</code>, <code>s</code>,
<code>formula.gam</code>, <code>read.bnd</code>,
<code>read.gra</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">bayesx.construct(sx(x1, bs = "ps"))
bayesx.construct(sx(x1, x2, bs = "te"))

## now create BayesX syntax for smooth terms
## using mgcv constructor functions
bayesx.construct(s(x1, bs = "ps"))

## for tensor product P-splines,
bayesx.construct(s(x1, x2, bs = "te"))

## increase number of knots
## for a P-spline
bayesx.construct(sx(x1, bs = "ps", nrknots = 40))

## now with degree 2 and
## penalty order 1
bayesx.construct(sx(x1, bs = "ps", knots = 40, degree = 2, order = 1))
bayesx.construct(s(x1, bs = "ps", k = 41, m = c(0, 1)))

## random walks
bayesx.construct(sx(x1, bs = "rw1"))
bayesx.construct(sx(x1, bs = "rw2"))

## shrinkage priors
bayesx.construct(sx(x1, bs = "lasso"))
bayesx.construct(sx(x1, bs = "ridge"))
bayesx.construct(sx(x1, bs = "nigmix"))

## for cox models, baseline
bayesx.construct(sx(time, bs = "bl"))

## kriging
bayesx.construct(sx(x, z, bs = "kr"))

## seasonal
bayesx.construct(sx(x, bs = "season"))

## factors
bayesx.construct(sx(id, bs = "factor"))

## now with some geographical information
## note: maps must be either supplied in
## 'bnd' or 'gra' format, also see function
## read.bnd() or read.gra()
data("MunichBnd")
bayesx.construct(sx(id, bs = "mrf", map = MunichBnd))

## same with
bayesx.construct(s(id, bs = "mrf", xt = list(map = MunichBnd)))

bayesx.construct(sx(id, bs = "gk", map = MunichBnd))
bayesx.construct(sx(id, bs = "gs", map = MunichBnd))

## also vary number of knots
bayesx.construct(sx(id, bs = "gs", knots = 10, map = MunichBnd))
bayesx.construct(s(id, bs = "gs", k = 12, m = c(1, 1), xt = list(map = MunichBnd)))

## random effects
bayesx.construct(sx(id, bs = "re"))
bayesx.construct(sx(id, bs = "re", by = x1))
bayesx.construct(sx(id, bs = "re", by = x1, xt = list(nofixed=TRUE)))

## generic
## specifies some model term
## and sets all additional arguments 
## within argument xt
## only for experimental use
bayesx.construct(sx(x, bs = "generic", dosomething = TRUE, a = 1, b = 2))
</code></pre>


</div>