<div class="container">

<table style="width: 100%;"><tr>
<td>scores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Relation Scores</h2>

<h3>Description</h3>

<p>Compute scores for the tuples of (ensembles of) endorelations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'relation'
relation_scores(x,
                method = c("ranks", "Barthelemy/Monjardet",
                           "Borda", "Kendall", "Wei",
                           "differential", "Copeland"),
                normalize = FALSE, ...)
## S3 method for class 'relation_ensemble'
relation_scores(x,
                method = c("Borda", "Kendall", "differential",
                           "Copeland"),
                normalize = FALSE,
                weights = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an object inheriting from class <code>relation</code>,
representing an endorelation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string indicating the method (see
<b>Details</b>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>logical indicating whether the score vector should be
normalized to sum up to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Numeric vector of weights used in incidence
aggregation, recycled as needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In the following, consider an endorelation <code class="reqn">R</code> on <code class="reqn">n</code> objects.
Let the <em>in-degree</em> <code class="reqn">I(x)</code> and <em>out-degree</em> <code class="reqn">O(x)</code>
of an object <code class="reqn">x</code> be defined as the numbers of objects <code class="reqn">y</code> such
that <code class="reqn">y R x</code> and, respectively, <code class="reqn">x R y</code>, and let <code class="reqn">D(x) =
    I(x) - O(x)</code> be the <em>differential</em> of <code class="reqn">x</code> (see Regenwetter
and Rykhlevskaia (2004)).  Note that <code class="reqn">I</code> and <code class="reqn">O</code> are given by
the column sums and row sums of the incidence matrix of <code class="reqn">R</code>.  If
<code class="reqn">R</code> is a preference relation with a <code class="reqn">\le</code> interpretation,
<code class="reqn">D(x)</code> is the difference between the numbers of objects dominated
by <code class="reqn">x</code> (i.e., <code class="reqn">&lt; x</code>) and dominating <code class="reqn">x</code> (i.e., <code class="reqn">&gt; x</code>),
as “ties” cancel out.
</p>
<p><code>relation_score()</code> is generic with methods for relations and
relation ensembles. Available built-in score methods for the
relation method are as follows:
</p>

<dl>
<dt><code>"ranks"</code></dt>
<dd>
<p>generalized ranks.  A linear transformation of
the differential <code class="reqn">D</code> to the range from 1 to <code class="reqn">n</code>.  An
additional argument <code>decreasing</code> can be used to specify the
order of the ranks.  By default, or if <code>decreasing</code> is true,
objects are ranked according to decreasing differential
(“from the largest to the smallest” in the <code class="reqn">\le</code>
preference context) using <code class="reqn">(n + 1 - D(x)) / 2</code>.
Otherwise, if <code>decreasing</code> is false, objects are ranked via
<code class="reqn">(n + 1 + D(x)) / 2</code> (“from the smallest to the largest”).
See Regenwetter and Rykhlevskaia (2004) for more details on
generalized ranks.
</p>
</dd>
<dt><code>"Barthelemy/Monjardet"</code></dt>
<dd>
<p><code class="reqn">(M(x) + N(x) - 1) / 2</code>,
where <code class="reqn">M(x)</code> and <code class="reqn">N(x)</code> are the numbers of objects <code class="reqn">y</code>
such that <code class="reqn">y R x</code>, and <code class="reqn">y R x</code> and not <code class="reqn">x R y</code>,
respectively.  If <code class="reqn">R</code> is a <code class="reqn">\le</code> preference relation, we
get the number of dominated objects plus half the number of the
equivalent objects minus 1 (the “usual” average ranks minus
one if the relation is complete).  See Barthélemy and Monjardet
(1981).
</p>
</dd>
<dt>
<code>"Borda"</code>, <code>"Kendall"</code>
</dt>
<dd>
<p>the out-degrees.
See Borda (1770) and Kendall (1955).
</p>
</dd>
<dt><code>"Wei"</code></dt>
<dd>
<p>the eigenvector corresponding to the greatest
eigenvalue of the incidence matrix of the complement of <code class="reqn">R</code>.
See Wei (1952).
</p>
</dd>
<dt>
<code>"differential"</code>, <code>"Copeland"</code>
</dt>
<dd>
<p>the differentials,
equivalent to the negative <em>net flow</em> of Bouyssou (1992), and
also to the Copeland scores.</p>
</dd>
</dl>
<p>For relation ensembles, currently only
<code>"differential"</code>/<code>"Copeland"</code> and
<code>"Borda"</code>/<code>"Kendall"</code> are implemented. They are computed on
the aggregated incidences of the ensembles' relations.
</p>
<p>Definitions of scores for “preference relations” <code class="reqn">R</code> are
somewhat ambiguous because <code class="reqn">R</code> can encode <code class="reqn">\le</code> or <code class="reqn">\ge</code>
(or strict variants thereof) relationships (and all such variants are
used in the literature).  Package <span class="pkg">relations</span> generally assumes a
<code class="reqn">\le</code> encoding, and that scores in the strict sense should
increase with preference (the most preferred get the highest scores)
whereas ranks decrease with preference (the most preferred get the
lowest ranks).
</p>


<h3>Value</h3>

<p>A vector of scores, with names taken from the relation domain labels.
</p>


<h3>References</h3>

<p>J.-P. Barthélemy and B. Monjardet (1981),
The median procedure in cluster analysis and social choice theory.
<em>Mathematical Social Sciences</em>, <b>1</b>, 235–267.
<a href="https://doi.org/10.1016/0165-4896%2881%2990041-X">doi:10.1016/0165-4896(81)90041-X</a>.
</p>
<p>J. C. Borda (1781),
Mémoire sur les élections au scrutin.
Histoire de l'Académie Royale des Sciences.
</p>
<p>D. Bouyssou (1992),
Ranking methods based on valued preference relations: A
characterization of the net flow network.
<em>European Journal of Operational Research</em>, <b>60</b>, 61–67.
<a href="https://doi.org/10.1016/0377-2217%2892%2990333-5">doi:10.1016/0377-2217(92)90333-5</a>.
</p>
<p>M. Kendall (1955),
Further contributions to the theory of paired comparisons.
<em>Biometrics</em>, <b>11</b>, 43–62.
<a href="https://doi.org/10.2307/3001479">doi:10.2307/3001479</a>.
</p>
<p>M. Regenwetter and E. Rykhlevskaia (2004),
On the (numerical) ranking associated with any finite binary relation.
<em>Journal of Mathematical Psychology</em>, <b>48</b>, 239–246.
<a href="https://doi.org/10.1016/j.jmp.2004.03.003">doi:10.1016/j.jmp.2004.03.003</a>.
</p>
<p>T. H. Wei (1952).
<em>The algebraic foundation of ranking theory</em>.
Unpublished thesis, Cambridge University.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example taken from Cook and Cress (1992, p.74)
I &lt;- matrix(c(0, 0, 1, 1, 1,
              1, 0, 0, 0, 1,
              0, 1, 0, 0, 1,
              0, 1, 1, 0, 0,
              0, 0, 0, 1, 0),
            ncol = 5,
            byrow = TRUE)
R &lt;- relation(domain = letters[1:5], incidence = I)

## Note that this is a "preference matrix", so take complement:
R &lt;- !R

## Compare Kendall and Wei scores
cbind(
      Kendall = relation_scores(R, method = "Kendall", normalize = TRUE),
      Wei = relation_scores(R, method = "Wei", normalize = TRUE)
     )

## Example taken from Cook and Cress (1992, p.136)
## Note that the results indicated for the Copeland scores have
## (erroneously?) been computed from the *unweighted* votes.
## Also, they report the votes as strict preferences, so we
## create the dual relations.

D &lt;- letters[1:5]
X &lt;- as.relation(ordered(D, levels = c("b", "c", "a", "d", "e")))
Y &lt;- as.relation(ordered(D, levels = c("d", "a", "e", "c", "b")))
Z &lt;- as.relation(ordered(D, levels = c("e", "c", "b", "a", "d")))
E &lt;- relation_ensemble(X, Y, Z)
relation_scores(E, "Copeland")
relation_scores(E, "Borda", weights = c(4, 3, 2))
</code></pre>


</div>