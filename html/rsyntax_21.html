<div class="container">

<table style="width: 100%;"><tr>
<td>get_nodes</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transform the nodes to long format and match with token data</h2>

<h3>Description</h3>

<p>Transform the nodes to long format and match with token data
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_nodes(tokens, nodes, use = NULL, token_cols = c("token"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tokens</code></td>
<td>
<p>A tokenIndex data.table, or any data.frame coercible with as_tokenindex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodes</code></td>
<td>
<p>A data.table, as created with apply_queries. Can be a list of multiple data.tables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use</code></td>
<td>
<p>Optionally, specify which columns from nodes to add. Other than convenient, this is slighly different 
from subsetting the columns in 'nodes' beforehand if fill is TRUE. When the children are collected,
the ids from the not-used columns are still blocked (see 'block')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token_cols</code></td>
<td>
<p>A character vector, specifying which columns from tokens to include in the output</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A data.table with the nodes in long format, and the specified token_cols attached
</p>


<h3>Examples</h3>

<pre><code class="language-R">## spacy tokens for: Mary loves John, and Mary was loved by John
tokens = tokens_spacy[tokens_spacy$doc_id == 'text3',]

## two simple example tqueries
passive = tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("agent"), label = "subject"))
active =  tquery(pos = "VERB*", label = "predicate",
                 children(relation = c("nsubj", "nsubjpass"), label = "subject"))

nodes = apply_queries(tokens, pas=passive, act=active)
get_nodes(tokens, nodes)
</code></pre>


</div>