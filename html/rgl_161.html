<div class="container">

<table style="width: 100%;"><tr>
<td>primitives</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add primitive shape</h2>

<h3>Description</h3>

<p>Adds a shape node to the current scene.
</p>


<h3>Usage</h3>

<pre><code class="language-R">points3d(x, y = NULL, z = NULL,  ...)
lines3d(x, y = NULL, z = NULL,  ...)
segments3d(x, y = NULL, z = NULL, ...)
triangles3d(x, y = NULL, z = NULL, ...)
quads3d(x, y = NULL, z = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y, z</code></td>
<td>
<p>coordinates. Any reasonable way of defining the
coordinates is acceptable.  See the function <code>xyz.coords</code>
for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code> ... </code></td>
<td>
<p>Material properties (see <code>material3d</code>), <code>normals</code>,
<code>texcoords</code> or <code>indices</code>; see details below.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The functions <code>points3d</code>, <code>lines3d</code>, <code>segments3d</code>,
<code>triangles3d</code> and <code>quads3d</code> add points, joined lines, line segments,
filled triangles or quadrilaterals to the plots.  They correspond to the OpenGL types
<code>GL_POINTS, GL_LINE_STRIP, GL_LINES, GL_TRIANGLES</code> and <code>GL_QUADS</code> respectively.  
</p>
<p>Points are taken in pairs by <code>segments3d</code>, triplets as the vertices
of the triangles, and quadruplets for the quadrilaterals.  Colors are applied vertex by vertex; 
if different at each end of a line segment, or each vertex of a polygon, the colors
are blended over the extent of the object.  Polygons
must be non-degenerate and quadrilaterals must be entirely 
in one plane and convex, or the results are undefined.
</p>
<p>The appearance of the new objects are defined by the material properties.
See <code>material3d</code> for details.
</p>
<p>For triangles and quads, the normals at each vertex may be specified
using <code>normals</code>.  These may be given in any way that would be
acceptable as a single argument to <code>xyz.coords</code>.  
These need not match the actual normals to the polygon:
curved surfaces can be simulated by using other choices of normals.
</p>
<p>Texture coordinates may also be specified.  These may be given in
any way that would be acceptable as a single argument to 
<code>xy.coords</code>, and are interpreted in terms
of the bitmap specified as the material texture, with <code>(0, 0)</code> 
at the lower left, <code>(1, 1)</code> at the upper right.  The texture
is used to modulate the color of the polygon.
</p>
<p>All of these functions support an argument called
<code>indices</code>, which allows vertices (and other attributes)
to be re-used, as they are in objects created by <code>mesh3d</code> and related functions.  This is
intended to be used on smooth surfaces, where each shared
vertex has just one value for normals, colors and texture
coordinates.  
</p>
<p>For shapes with flat-looking faces (e.g. polyhedra like <code>cube3d</code>),
the vertices <b>must</b> be duplicated
to be rendered properly.
</p>


<h3>Value</h3>

<p>Each function returns the integer object ID of the shape that
was added to the scene.  These can be passed to <code>pop3d</code>
to remove the object from the scene.
</p>


<h3>Author(s)</h3>

<p>Ming Chen and Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Show 12 random vertices in various ways. 

M &lt;- matrix(rnorm(36), 3, 12, dimnames = list(c('x', 'y', 'z'), 
                                       rep(LETTERS[1:4], 3)))

# Force 4-tuples to be convex in planes so that quads3d works.

for (i in c(1, 5, 9)) {
    quad &lt;- as.data.frame(M[, i + 0:3])
    coeffs &lt;- runif(2, 0, 3)
    if (mean(coeffs) &lt; 1) coeffs &lt;- coeffs + 1 - mean(coeffs)
    quad$C &lt;- with(quad, coeffs[1]*(B - A) + coeffs[2]*(D - A) + A)
    M[, i + 0:3] &lt;- as.matrix(quad)
}

open3d()

# Rows of M are x, y, z coords; transpose to plot

M &lt;- t(M)
shift &lt;- matrix(c(-3, 3, 0), 12, 3, byrow = TRUE)

points3d(M)
lines3d(M + shift)
segments3d(M + 2*shift)
triangles3d(M + 3*shift, col = 'red')
quads3d(M + 4*shift, col = 'green')  
text3d(M + 5*shift, texts = 1:12)

# Add labels

shift &lt;- outer(0:5, shift[1, ])
shift[, 1] &lt;- shift[, 1] + 3
text3d(shift, 
       texts = c('points3d', 'lines3d', 'segments3d',
         'triangles3d', 'quads3d', 'text3d'),
       adj = 0)
 rgl.bringtotop()
</code></pre>


</div>