<div class="container">

<table style="width: 100%;"><tr>
<td>create_node_edge_df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create dataframe of node and aggregated edge embeddings</h2>

<h3>Description</h3>

<p>Aggregates edge strain and tension to node level
</p>


<h3>Usage</h3>

<pre><code class="language-R">create_node_edge_df(embeddings_data, function_names = c("mean", "median"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>embeddings_data</code></td>
<td>
<p>A list. The output of any of the setse embedding functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>function_names</code></td>
<td>
<p>A string vector. the names of the aggregation methods to be used</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Often if can be useful to have edge data at node level, an example of this would be plotting
the node and tension or strain. To do this requires that the edge embeddings are aggregated somehow to node level
and joined to the appropriate node. This function takes as an argument the output of the setse embedding functions
and any number of aggregation functions to produce a dataframe that is convenient to use.
</p>


<h3>Value</h3>

<p>A dataframe with node names, node force, node elevation and strain and tension aggregated using the named functions.
The strain and tension columns are returned with names in the form "strain_x" where "x" is the name of the function used 
to aggregate. The total number of columns is dependent on the number of aggregation functions.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
embeddings_data &lt;- biconnected_network %&gt;%
 prepare_edges(.) %&gt;%
 prepare_continuous_force(., node_names = "name", force_var = "force") %&gt;%
 setse_auto(., k = "weight")

out &lt;- create_node_edge_df(embeddings_data, function_names = c("mean", "mode", "sum"))

</code></pre>


</div>