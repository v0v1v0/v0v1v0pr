<div class="container">

<table style="width: 100%;"><tr>
<td>coded.data</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions for coded data</h2>

<h3>Description</h3>

<p>These functions facilitate the use of coded data in response-surface analysis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coded.data(data, ..., formulas = list(...), block = "block")
as.coded.data(data, ..., formulas = list(...), block = "block")
decode.data(data)
recode.data(data, ..., formulas = list(...))

val2code(X, codings)
code2val(X, codings)

## S3 method for class 'coded.data'
print(x, ..., decode = TRUE)

### --- Methods for managing coded data ---
is.coded.data(x)

## S3 method for class 'coded.data'
x[...]

codings(object)
## S3 method for class 'coded.data'
codings(object)
codings(object) &lt;- value

## S3 replacement method for class 'coded.data'
names(x) &lt;- value

## Generic method for true variable names (i.e. decoded names)
truenames(x)
## S3 method for class 'coded.data'
truenames(x)
## Generic replacement method for truenames
truenames(x) &lt;- value
## S3 replacement method for class 'coded.data'
truenames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formulas</code></td>
<td>
<p>List of coding formulas; see details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p>Name(s) of blocking variable(s). It is <code>pmatch</code>ed (case insensitively) with names in <code>data</code> to identify blocking factorss</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A vector, matrix, or data.frame to be coded or decoded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codings</code></td>
<td>
<p>A list of formulas; see Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decode</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the decoded values are displayed; if <code>FALSE</code>, the codings are displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>coded.data</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>coded.data</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>Replacement value for <code>&lt;-</code> methods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>In <code>coded.data</code>, <code>as.coded.data</code>, and <code>recode.data</code>, <code>...</code> allows specifying formulas as arguments rather than as a list. In other functions, <code>...</code> is passed to the parent methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Typically, coding formulas are of the form <code>x ~ (var - center) / halfwd</code> 
where <code>x</code> and <code>var</code> are variable names, and <code>center</code> and 
<code>halfwd</code> are numbers.  
The left-hand side gives the name of the coded variable, and the right-hand side 
should be a linear expression in the uncoded variable (linearity is <em>not</em> explicitly 
checked, but nonlinear expressions will not decode correctly.) If <code>coded.data</code> is called without formulas, automatic codings are created (along with a warning message). Automatic codings are based on transforming all non-block variables having five or fewer unique values to the interval [-1,1]. If no formulas are provided in <code>as.coded.data</code>, default coding formulas like those for <code>cube</code> are created all numeric variables with mean zero – again with a warning message.
</p>
<p>An S3 <code>print</code> method is provided for the <code>coded.data</code> class; 
it displays the data.frame in either coded or 
decoded form, along with the coding formulas. Some users may prefer <code>print.data.frame</code> 
or <code>as.data.frame</code> in lieu of <code>print</code> with ‘<span class="samp">⁠decode=FALSE⁠</span>’; they produce the 
same output without displaying the coding formulas.
</p>
<p>Use <code>coded.data</code> to convert a <code>data.frame</code> in which the variables
are on their original scales.  The variables named in the formulas are 
coded and replaced with their coded versions (and also renamed).
</p>
<p>In contrast, <code>as.coded.data</code> does not modify any of the data; it assumes the variables
are already coded, and the coding information is simply added. In addition, if <code>data</code> is 
already a <code>coded.data</code> object from a pre-1.41 version of <span class="pkg">rsm</span>, 
it is converted to 
be compatible with new capabilities such as <code>djoin</code> (no <code>formulas</code> argument 
is needed in this case). Any blocking factors should be specified in the <code>blocks</code> 
argument.
</p>
<p><code>decode.data</code> converts a dataset of class <code>coded.data</code> and 
returns a <code>data.frame</code> containing the original variables.
</p>
<p><code>recode.data</code> is used to convert a <code>coded.data</code> object to new codings. 
Important: this <em>changes</em> the coded values to match the new coding formulas. If you want to keep the coded values the same, but change the levels they represent, use ‘<span class="samp">⁠codings(object) &lt;- \dots⁠</span>’ or <code>dupe</code>.
</p>
<p><code>code2val</code> converts coded values to the original scale using the codings provided, 
and returns an object of the same class as <code>X</code>.  
<code>val2code</code> converts the other direction.  When using these functions, it is 
essential that the names (or column names in the case of matrices) match those of the 
corresponding coded or uncoded variables.
</p>
<p><code>codings</code> is a generic function for accessing codings.  It
returns the list of coding formulas from a <code>coded.data</code> object.  One may use an 
expression like ‘<span class="samp">⁠codings(object) &lt;- list(\dots)⁠</span>’ to change the codings (without changing 
the coded values themselves).   See also <code>codings.rsm</code>.
</p>
<p><code>is.coded.data(x)</code> returns <code>TRUE</code> if <code>x</code> inherits from <code>coded.data</code>, and <code>FALSE otherwise.</code>
</p>
<p>The extraction function <code>x[...]</code> and the naming functions <code>names&lt;-</code>, 
<code>truenames</code>, and <code>truenames&lt;-</code> are provided to preserve the integrity of 
codings. For example, if <code>x[, 1:3]</code> excludes any coded columns, their coding formulas 
are also excluded. If all coded columns are excluded, the return value is unclassed 
from <code>coded.data</code>. When variable names are changed using <code>names(x) &lt;- ...</code>, the coding 
formulas are updated accordingly. The <code>truenames</code> function returns the names of the 
variables in the decoded dataset. We can change the decoded names using 
<code>truenames(x) &lt;- ...</code>, and the coding formulas are updated. Note that <code>truenames</code>
and <code>truenames&lt;-</code> work the same as <code>names</code> and <code>names&lt;-</code> for 
unencoded variables in the object.
</p>
<p>Another convenient way to copy and change the coding formulas a coded dataset (and optionally re-randomize it) is to use the <code>dupe</code> function with a <code>coding</code> argument.
</p>
<p>When a design is created in another package, some of the variables may be <code>factor</code>s, in which case they are converted using <code>as.numeric</code> (values of 1, 2, ...). These levels may be regarded as a yet different coding of the variables, and so it may take two steps to get it in the desired form: one to convert the supplied levels to the desired range (often -1 to 1), and the other to replace the coding formulas to correspond to the real values of the variables to be used. See the examples.
</p>


<h3>Value</h3>

<p><code>coded.data</code>, <code>as.coded.data</code>, and <code>recode.data</code> return an object of class  
<code>coded.data</code>,  which inherits from <code>data.frame</code>. A <code>coded.data</code> 
object is stored in coded form, and its <code>names</code> attribute contains the coded names, 
where they apply. Thus, when fitting models in <code>rsm</code> or <code>lm</code> with 
coded data as the <code>data</code> argument, the model formula should be given in terms of the 
coded variables.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">rsm</span> version 2.00, the <code>coded.data</code> class involves additional attributes to serve broader needs in design-generation. Because of this, old <code>coded.data</code> objects may need to be updated using <code>as.coded.data</code> if they are to be used with the newer functions such as <code>djoin</code>.</p>


<h3>Author(s)</h3>

<p>Russell V. Lenth</p>


<h3>References</h3>

<p>Lenth RV (2009). “Response-Surface Methods in R, Using rsm”, 
<em>Journal of Statistical Software</em>, 32(7), 1–17. 
<a href="https://doi.org/10.18637/jss.v032.i07">doi:10.18637/jss.v032.i07</a>
</p>


<h3>See Also</h3>

<p><code>data.frame</code>, <code>djoin</code>, <code>dupe</code>, <code>rsm</code></p>


<h3>Examples</h3>

<pre><code class="language-R">library(rsm)

### Existing dataset with variables on actual scale
CR &lt;- coded.data (ChemReact, x1 ~ (Time - 85)/5, x2 ~ (Temp - 175)/5)
CR                            # same as print(CR, decode = TRUE)
print(CR, decode = FALSE)     # similar to as.data.frame(CR)
code2val (c(x1=.5, x2=-1), codings = codings(CR))

### Existing dataset, already in coded form
CO &lt;- as.coded.data(codata, x1 ~ (Ethanol - 0.2)/0.1, x2 ~ A.F.ratio - 15)
truenames(CO)
names(CO)

# revert x2 to an uncoded variable
codings(CO)[2] &lt;- NULL
truenames(CO)

### Import a design that is coded in a different way

if (require(conf.design)) { # ----- This example requires conf.design -----

# First, generate a 3^3 in blocks and import it via coded.data
    des3 &lt;- coded.data(conf.design(p=3, G=c(1,1,2)))
    # NOTE: This returns a warning message but does the right thing --
    # It generates these names and coding formulas automatically:
    #   x1 ~ (T1 - 2)/1
    #   x2 ~ (T2 - 2)/1
    #   x3 ~ (T3 - 2)/1
# Now randomize and change the codings and variable names for the real situation:
    mydes &lt;- dupe(des3, coding = c(x1 ~ (Dose - 20)/5,  x2 ~ (Conc - 40)/10,  
                                x3 ~ (Time - 60)/15))
                                
} # ----- end of example requiring package conf.design -----

</code></pre>


</div>