<div class="container">

<table style="width: 100%;"><tr>
<td>find_lambda</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Selecting the Box-Cox parameter for general d</h2>

<h3>Description</h3>

<p>Finds a value of the Box-Cox transformation parameter lambda for which
the (positive) random variable with log-density <code class="reqn">\log f</code> has a
density  closer to that of a Gaussian random variable.
In the following we use <code>theta</code> (<code class="reqn">\theta</code>) to denote the argument
of <code class="reqn">\log f</code> on the original scale and <code>phi</code> (<code class="reqn">\phi</code>) on
the Box-Cox transformed scale.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find_lambda(
  logf,
  ...,
  d = 1,
  n_grid = NULL,
  ep_bc = 1e-04,
  min_phi = rep(ep_bc, d),
  max_phi = rep(10, d),
  which_lam = 1:d,
  lambda_range = c(-3, 3),
  init_lambda = NULL,
  phi_to_theta = NULL,
  log_j = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>logf</code></td>
<td>
<p>A function returning the log of the target density <code class="reqn">f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to <code>logf</code> and related
functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>A numeric scalar. Dimension of <code class="reqn">f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_grid</code></td>
<td>
<p>A numeric scalar.  Number of ordinates for each variable in
<code>phi</code>.  If this is not supplied a default value of
<code>ceiling(2501 ^ (1 / d))</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ep_bc</code></td>
<td>
<p>A (positive) numeric scalar. Smallest possible value of
<code>phi</code> to consider.  Used to avoid negative values of <code>phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_phi, max_phi</code></td>
<td>
<p>Numeric vectors.  Smallest and largest values
of <code>phi</code> at which to evaluate <code>logf</code>, i.e. the range of values
of phi over which to evaluate <code>logf</code>. Any components in
<code>min_phi</code> that are not positive are set to <code>ep_bc</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which_lam</code></td>
<td>
<p>A numeric vector.  Contains the indices of the components
of <code>phi</code> that ARE to be Box-Cox transformed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_range</code></td>
<td>
<p>A numeric vector of length 2.  Range of lambda over
which to optimise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_lambda</code></td>
<td>
<p>A numeric vector of length 1 or <code>d</code>.  Initial value
of lambda used in the search for the best lambda.  If <code>init_lambda</code>
is a scalar then <code>rep(init_lambda, d)</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_to_theta</code></td>
<td>
<p>A function returning (inverse) of the transformation
from <code>theta</code> to <code>phi</code> used to ensure positivity of <code>phi</code>
prior to Box-Cox transformation.  The argument is <code>phi</code> and the
returned value is <code>theta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_j</code></td>
<td>
<p>A function returning the log of the Jacobian of the
transformation from <code>theta</code> to <code>phi</code>, i.e. based on derivatives
of <code>phi</code> with respect to <code>theta</code>. Takes <code>theta</code> as its
argument.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The general idea is to evaluate the density <code class="reqn">f</code> on a
<code>d</code>-dimensional grid, with <code>n_grid</code> ordinates for each of the
<code>d</code> variables.
We treat each combination of the variables in the grid as a data point
and perform an estimation of the Box-Cox transformation parameter
lambda, in which each data point is weighted by the density
at that point.  The vectors <code>min_phi</code> and <code>max_phi</code> define the
limits of the grid and <code>which_lam</code> can be used to specify that only
certain components of <code>phi</code> are to be transformed.
</p>


<h3>Value</h3>

<p>A list containing the following components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A numeric vector.  The value of lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gm</code></td>
<td>
<p>A numeric vector.  Box-Cox scaling parameter, estimated by the
geometric mean of the values of <code>phi</code> used in the optimisation to
find the value of lambda, weighted by the values of <code class="reqn">f</code> evaluated at
<code>phi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init_psi</code></td>
<td>
<p>A numeric vector.  An initial estimate of the mode of the
Box-Cox transformed density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_psi</code></td>
<td>
<p>A numeric vector.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_to_theta</code></td>
<td>
<p>as detailed above (only if <code>phi_to_theta</code> is
supplied)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log_j</code></td>
<td>
<p>as detailed above (only if <code>log_j</code> is supplied)</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Box, G. and Cox, D. R. (1964) An Analysis of Transformations.
Journal of the Royal Statistical Society. Series B (Methodological), 26(2),
211-252.
</p>
<p>Andrews, D. F. and Gnanadesikan, R. and Warner, J. L. (1971)
Transformations of Multivariate Data, Biometrics, 27(4).
</p>


<h3>See Also</h3>

<p><code>ru</code> and <code>ru_rcpp</code> to perform
ratio-of-uniforms sampling.
</p>
<p><code>find_lambda_one_d</code> and
<code>find_lambda_one_d_rcpp</code> to produce (somewhat) automatically
a list for the argument lambda of <code>ru</code>/<code>ru_rcpp</code> for the
<code>d</code> = 1 case.
</p>
<p><code>find_lambda_rcpp</code> for a version of
<code>find_lambda</code> that uses the Rcpp package to improve
efficiency.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Log-normal density ===================
# Note: the default value max_phi = 10 is OK here but this will not always
# be the case
lambda &lt;- find_lambda(logf = dlnorm, log = TRUE)
lambda
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, trans = "BC",
        lambda = lambda)

# Gamma density ===================
alpha &lt;- 1
#  Choose a sensible value of max_phi
max_phi &lt;- qgamma(0.999, shape = alpha)
# [Of course, typically the quantile function won't be available.  However,
# In practice the value of lambda chosen is quite insensitive to the choice
# of max_phi, provided that max_phi is not far too large or far too small.]

lambda &lt;- find_lambda(logf = dgamma, shape = alpha, log = TRUE,
                      max_phi = max_phi)
lambda
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = lambda)


# Generalized Pareto posterior distribution ===================

# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = -0.5, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate an initial estimate
init &lt;- c(mean(gpd_data), 0)

n &lt;- 1000
# Sample on original scale, with no rotation ----------------
x1 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
  lower = c(0, -Inf), rotate = FALSE)
plot(x1, xlab = "sigma", ylab = "xi")
# Parameter constraint line xi &gt; -sigma/max(data)
# [This may not appear if the sample is far from the constraint.]
abline(a = 0, b = -1 / ss$xm)
summary(x1)

# Sample on original scale, with rotation ----------------
x2 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
  lower = c(0, -Inf))
plot(x2, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x2)

# Sample on Box-Cox transformed scale ----------------

# Find initial estimates for phi = (phi1, phi2),
# where phi1 = sigma
#   and phi2 = xi + sigma / max(x),
# and ranges of phi1 and phi2 over over which to evaluate
# the posterior to find a suitable value of lambda.
temp &lt;- do.call(gpd_init, ss)
min_phi &lt;- pmax(0, temp$init_phi - 2 * temp$se_phi)
max_phi &lt;- pmax(0, temp$init_phi + 2 * temp$se_phi)

# Set phi_to_theta() that ensures positivity of phi
# We use phi1 = sigma and phi2 = xi + sigma / max(data)
phi_to_theta &lt;- function(phi) c(phi[1], phi[2] - phi[1] / ss$xm)
log_j &lt;- function(x) 0

lambda &lt;- find_lambda(logf = gpd_logpost, ss = ss, d = 2, min_phi = min_phi,
  max_phi = max_phi, phi_to_theta = phi_to_theta, log_j = log_j)
lambda

# Sample on Box-Cox transformed, without rotation
x3 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = "BC",
  lambda = lambda, rotate = FALSE)
plot(x3, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x3)

# Sample on Box-Cox transformed, with rotation
x4 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = "BC",
  lambda = lambda)
plot(x4, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x4)

def_par &lt;- graphics::par(no.readonly = TRUE)
par(mfrow = c(2,2), mar = c(4, 4, 1.5, 1))
plot(x1, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "mode relocation")
plot(x2, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "mode relocation and rotation")
plot(x3, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "Box-Cox and mode relocation")
plot(x4, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "Box-Cox, mode relocation and rotation")
graphics::par(def_par)

</code></pre>


</div>