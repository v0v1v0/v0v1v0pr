<div class="container">

<table style="width: 100%;"><tr>
<td>sort_at_path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sorting a table at a specific path</h2>

<h3>Description</h3>

<p>Main sorting function to order the sub-structure of a <code>TableTree</code> at a particular path in the table tree.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sort_at_path(
  tt,
  path,
  scorefun,
  decreasing = NA,
  na.pos = c("omit", "last", "first"),
  .prev_path = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tt</code></td>
<td>
<p>(<code>TableTree</code> or related class)<br> a <code>TableTree</code> object representing a populated table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>(<code>character</code>)<br> a vector path for a position within the structure of a <code>TableTree</code>. Each element
represents a subsequent choice amongst the children of the previous choice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scorefun</code></td>
<td>
<p>(<code>function</code>)<br> scoring function. Should accept the type of children directly under the position
at <code>path</code> (either <code>VTableTree</code>, <code>VTableRow</code>, or <code>VTableNodeInfo</code>, which covers both) and return a numeric value
to be sorted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>
<p>(<code>flag</code>)<br> whether the scores generated by <code>scorefun</code> should be sorted in decreasing order. If
unset (the default of <code>NA</code>), it is set to <code>TRUE</code> if the generated scores are numeric and <code>FALSE</code> if they are
characters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.pos</code></td>
<td>
<p>(<code>string</code>)<br> what should be done with children (sub-trees/rows) with <code>NA</code> scores. Defaults to
<code>"omit"</code>, which removes them. Other allowed values are <code>"last"</code>  and <code>"first"</code>, which indicate where <code>NA</code> scores
should be placed in the order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.prev_path</code></td>
<td>
<p>(<code>character</code>)<br> internal detail, do not set manually.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>sort_at_path</code>, given a path, locates the (sub)table(s) described by the path (see below for handling of the <code>"*"</code>
wildcard). For each such subtable, it then calls <code>scorefun</code> on each direct child of the table, using the resulting
scores to determine their sorted order. <code>tt</code> is then modified to reflect each of these one or more sorting
operations.
</p>
<p>In <code>path</code>, a leading <code>"root"</code> element will be ignored, regardless of whether this matches the object name (and thus
actual root path name) of <code>tt</code>. Including <code>"root"</code> in paths where it does not match the name of <code>tt</code> may mask deeper
misunderstandings of how valid paths within a <code>TableTree</code> object correspond to the layout used to originally declare
it, which we encourage users to avoid.
</p>
<p><code>path</code> can include the "wildcard" <code>"*"</code> as a step, which translates roughly to <em>any</em> node/branching element and means
that each child at that step will be <em>separately</em> sorted based on <code>scorefun</code> and the remaining <code>path</code> entries. This
can occur multiple times in a path.
</p>
<p>A list of valid (non-wildcard) paths can be seen in the <code>path</code> column of the <code>data.frame</code> created by
<code>formatters::make_row_df()</code> with the <code>visible_only</code> argument set to <code>FALSE</code>. It can also be inferred from the
summary given by <code>table_structure()</code>.
</p>
<p>Note that sorting needs a deeper understanding of table structure in <code>rtables</code>. Please consider reading the related
vignette
(<a href="https://insightsengineering.github.io/rtables/latest-tag/articles/sorting_pruning.html">Sorting and Pruning</a>)
and explore table structure with useful functions like <code>table_structure()</code> and <code>row_paths_summary()</code>. It is also
very important to understand the difference between "content" rows and "data" rows. The first one analyzes and
describes the split variable generally and is generated with <code>summarize_row_groups()</code>, while the second one is
commonly produced by calling one of the various <code>analyze()</code> instances.
</p>
<p>Built-in score functions are <code>cont_n_allcols()</code> and <code>cont_n_onecol()</code>. They are both working with content rows
(coming from <code>summarize_row_groups()</code>) while a custom score function needs to be used on <code>DataRow</code>s. Here, some
useful descriptor and accessor functions (coming from related vignette):
</p>

<ul>
<li> <p><code>cell_values()</code> - Retrieves a named list of a <code>TableRow</code> or <code>TableTree</code> object's values.
</p>
</li>
<li> <p><code>formatters::obj_name()</code> - Retrieves the name of an object. Note this can differ from the label that is
displayed (if any is)  when printing.
</p>
</li>
<li> <p><code>formatters::obj_label()</code> - Retrieves the display label of an object. Note this can differ from the name that
appears in the path.
</p>
</li>
<li> <p><code>content_table()</code> - Retrieves a <code>TableTree</code> object's content table (which contains its summary rows).
</p>
</li>
<li> <p><code>tree_children()</code> - Retrieves a <code>TableTree</code> object's direct children (either subtables, rows or possibly a mix
thereof, though that should not happen in practice).
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>TableTree</code> with the same structure as <code>tt</code> with the exception that the requested sorting has been done
at <code>path</code>.
</p>


<h3>See Also</h3>


<ul>
<li>
<p> Score functions <code>cont_n_allcols()</code> and <code>cont_n_onecol()</code>.
</p>
</li>
<li> <p><code>formatters::make_row_df()</code> and <code>table_structure()</code> for pathing information.
</p>
</li>
<li> <p><code>tt_at_path()</code> to select a table's (sub)structure at a given path.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Creating a table to sort

# Function that gives two statistics per table-tree "leaf"
more_analysis_fnc &lt;- function(x) {
  in_rows(
    "median" = median(x),
    "mean" = mean(x),
    .formats = "xx.x"
  )
}

# Main layout of the table
raw_lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by(
    "RACE",
    split_fun = drop_and_remove_levels("WHITE") # dropping WHITE levels
  ) %&gt;%
  summarize_row_groups() %&gt;%
  split_rows_by("STRATA1") %&gt;%
  summarize_row_groups() %&gt;%
  analyze("AGE", afun = more_analysis_fnc)

# Creating the table and pruning empty and NAs
tbl &lt;- build_table(raw_lyt, DM) %&gt;%
  prune_table()

# Peek at the table structure to understand how it is built
table_structure(tbl)

#  Sorting only ASIAN sub-table, or, in other words, sorting STRATA elements for
# the ASIAN group/row-split. This uses content_table() accessor function as it
# is a "ContentRow". In this case, we also base our sorting only on the second column.
sort_at_path(tbl, c("ASIAN", "STRATA1"), cont_n_onecol(2))

# Custom scoring function that is working on "DataRow"s
scorefun &lt;- function(tt) {
  # Here we could use browser()
  sum(unlist(row_values(tt))) # Different accessor function
}
# Sorting mean and median for all the AGE leaves!
sort_at_path(tbl, c("RACE", "*", "STRATA1", "*", "AGE"), scorefun)

</code></pre>


</div>