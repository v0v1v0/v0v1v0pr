<div class="container">

<table style="width: 100%;"><tr>
<td>capturePlot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Captures a plot such that it can be redrawn later/elsewhere</h2>

<h3>Description</h3>

<p>Captures a plot such that it can be redrawn later/elsewhere.
</p>
<p><em>This feature is only supported in R (&gt;= 3.3.0).</em>
</p>


<h3>Usage</h3>

<pre><code class="language-R">capturePlot(expr, envir=parent.frame(), type=nulldev, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>The <code>expression</code> of graphing commands to be evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>The <code>environment</code> where <code>expr</code> should be evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of graphics device used in the background.
The choice should not matter since the result should be identical
regardless.  All graphics is captured but any output is also voided
by sending the output to a "null" file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the graphics device.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that plot dimensions/aspect ratios are not recorded.  This
means that one does not have to worry about those when recording
the plot.  Instead, they are specified when setting up the graphics
device(s) in which the recorded plot is replayed (see example).
</p>


<h3>Value</h3>

<p>Returns a <code>recordedplot</code> object, which can be
<code>replayPlot()</code>:ed.  If replayed in an
interactive session, the plot is displayed in a new window.
For conveniency, the object is also replayed when <code>print()</code>:ed.
</p>


<h3>Replaying / replotting on a different architecture</h3>

<p>In order to replay a <code>recordedplot</code> object, it has to be replayed
on an architecture that is compatible with the one who created the
object.
If this is not the case, then <code>replayPlot()</code>
will generate an <em>Incompatible graphics state</em> error.
The <code>as.architecture()</code> function of this package tries
to coerce between different architectures, such that one can replay
across architectures using <code>replayPlot(as.architectures(g))</code>.
For convenience, the recorded plot returned by <code>capturePlot()</code>
is automatically coerced when <code>print()</code>:ed.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson</p>


<h3>References</h3>

<p>[1] Paul Murrell et al.,
<em>Recording and Replaying the Graphics Engine Display List</em>,
December 2015.
<a href="https://www.stat.auckland.ac.nz/~paul/Reports/DisplayList/dl-record.html">https://www.stat.auckland.ac.nz/~paul/Reports/DisplayList/dl-record.html</a><br></p>


<h3>See Also</h3>

<p>Internally <code>recordPlot()</code> is used.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (getRversion() &gt;= "3.3.0") {
oopts &lt;- R.devices::devOptions("*", path=file.path(tempdir(), "figures"))

g &lt;- capturePlot({
  plot(1:10)
})

## Display
print(g)

## Display with a 2/3 height-to-width aspect ratio
toDefault(aspectRatio=2/3, { print(g) })

## Redraw to many output formats using whatever PNG, EPS, and PDF
## device outputs available
devEval(c("{png}", "{eps}", "{pdf}"), aspectRatio=2/3, print(g))

R.devices::devOptions("*", path=oopts$path)
} ## if (getRversion() &gt;= "3.3.0")
</code></pre>


</div>