<div class="container">

<table style="width: 100%;"><tr>
<td>Expression-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Expressions and Translation</h2>

<h3>Description</h3>

<p>Underlying rsolr is a simple, general framework for representing,
manipulating and translating between expressions in arbitrary
languages. The two foundational classes are <code>Expression</code> and
<code>Symbol</code>, which are partially implemented by
<code>SimpleExpression</code> and <code>SimpleSymbol</code>, respectively.
</p>


<h3>Translation</h3>

<p>The <code>Expression</code> framework defines a translation strategy based
on evaluating source language expressions, using promises to represent
the objects, such that the result is a promise with its deferred
computation expressed in the target language.
</p>
<p>The primary entry point is the <code>translate</code> generic, which has a
default method that abstractly implements this strategy.  The first
step is to obtain a <code>SymbolFactory</code> instance for the target
expression type via a method on the <code>SymbolFactory</code> generic. The
<code>SymbolFactory</code> (a simple R function) is set on the
<code>Context</code>, which should define (perhaps through inheritance) all
symbols referenced in the source expression. The translation happens
when the source expression is <code>eval</code>uated in the context.  The
context calls the factory to construct <code>Symbol</code> objects which are
passed, along with the context, to the <code>Promise</code> generic, which
wraps them in the appropriate type of promise. Typically, R is the
source language, and the <code>eval</code> method evaluates the R expression
on the promises. Each method for the specific type of promise will
construct a new promise with an expression that encodes the
computation, building on the existing expression. When evaluation is
finished, we simply extract the expression from the returned promise.
</p>

<ul>
<li>
<p><code>translate(x, target, context, ...)</code>: Translates the source
expression <code>x</code> to the <code>target</code> <code>Expression</code>, where
the symbols in the source expression are resolved in
<code>context</code>, which is usually an R environment or some sort of
database. The ... are passed to <code>symbolFactory</code>.

</p>
</li>
<li>
<p><code>symbolFactory(x)</code>: Gets the <code>SymbolFactory</code> object
that will construct the appropriate type of symbol for the target
expression <code>x</code>.

</p>
</li>
</ul>
<h3>Note on Laziness</h3>

<p>In general, translation requires access to the referenced data.  There
may be certain operations that cannot be deferred, so evaluation is
allowed to be eager, in the hope that the result can be embedded
directly into the larger expression. Or, at the very least, the
translation machinery needs to know whether the data actually exist,
and whether the data are typed or have other constraints.  Since the
data and schema are not always available when translation is
requested, such as when building a database query that will be sent to
by another module to an as-yet-unspecified endpoint, translation
itself must be deferred. The <code>TranslationRequest</code> class provides
a foundation for capturing translations and evaluating them later.
</p>


<h3>Author(s)</h3>

<p> Michael Lawrence </p>


</div>