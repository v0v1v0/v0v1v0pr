<div class="container">

<table style="width: 100%;"><tr>
<td>fossa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nested Filter-adjusted O-SSA decomposition</h2>

<h3>Description</h3>

<p>Perform nested decomposition by Filter-adjusted O-SSA (FOSSA).
</p>


<h3>Usage</h3>

<pre><code class="language-R">  ## S3 method for class 'ssa'
fossa(x, nested.groups, filter = c(-1, 1), gamma = Inf, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>SSA object holding SSA decomposition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested.groups</code></td>
<td>
<p>vector of numbers of eigentriples from full decomposition
for nested decomposition. The argument is coerced to a vector, if
necessary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>numeric vector or array of reversed impulse response (IR)
coefficients for filter adjustment or list of such vectors or arrays</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>weight of filter adjustment. See ‘Details’ and ‘References’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>logical, whether to normalize left decomposition vectors before filtering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>decompose</code>
routines</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See Golyandina N. and Shlemov A. (2015) and Section 2.5 in Golyanina et al (2018) 
for full details in the 1D case and 
p.250-252 from the same book for an example in the 2D case.
</p>
<p>Briefly, FOSSA serves for decomposition of series components that are
mixed due to equal contributions of their elementary components, e.g. of
sinusoids with equal amplitudes or of complex-form trend and
periodics. FOSSA performs a new decomposition of a part of the
ssa-object, which is given by a set of eigentriples. Note that
eigentriples that do not belong to the chosen set are not changed.
</p>
<p>In particular, Filter-adjusted O-SSA performs a nested decomposition
specified by a number of eigentriples via Oblique SSA with a specific
inner product in the row space:
</p>
<p style="text-align: center;"><code class="reqn">%
    \langle x, y \rangle = (x, y) + \gamma^2(\Phi(x), \Phi(y)),
  </code>
</p>

<p>where <code class="reqn">(\cdot, \cdot)</code> denotes conventional inner product and
'<code class="reqn">\Phi</code>' is linear filtration which is specified by <code>filter</code> argument.
</p>
<p>The default value of <code class="reqn">\Phi</code> corresponds to sequential
differences, that is, to derivation. Such version of Filter-adjusted
O-SSA is called ‘DerivSSA’. See ‘References’ for more details.
</p>


<h4>
<code>filter</code> argument</h4>

<p>For 1D-SSA, Toeplitz-SSA and MSSA:
Filter can be given by a vector or a list of vectors. Each vector corresponds to reversed IR
for a filter, these filters are applied independently and their results are stacked such that the matrix
<code class="reqn">[X:\Phi_1(X):\Phi_2(X)]</code> is decomposed.
</p>
<p>For 2D-SSA: the following variants are possible: (1) a list of vectors.
Each vector corresponds to reversed IR for a filter. Each filter is
applied to different dimensions, the first to columns, the second to rows, and the results are stacked.
(2) single vector. Given vector corresponds to one-dimensional filter applied to both dimensions, the same as list of two equal vectors.
(3) a list of matrices, where each matrix provides 2d filter coefficients and the results are stacked.
(4) single matrix. Given matrix corresponds to two-dimensional filter applied once, the same as list of one matrix.
</p>
<p>For nD-SSA: the same as for 2D-SSA, a list of vectors for filters by directions, single vector,
a list of arrays (matroids) for nD filters or single array.
</p>



<h4>Normalization</h4>

<p>Let us explain for the 1D case.
Let <code class="reqn">X</code> be the reconstructed matrix, corresponding to the selected eigentriples
<code class="reqn">\{(\sigma_i,U_i,V_i)\}</code>, <code class="reqn">\Psi(X)</code> is the matrix, where the filter is applied to
each row of <code class="reqn">X</code>.
</p>
<p>Then <code>normalize = FALSE</code> (Algorithm 2.9 or 2.10 in Golyandina et al (2018)) corresponds 
to finding the basis in the column space of
<code class="reqn">X</code> by means of the SVD of <code class="reqn">[X, \Psi(X)]</code>, while
<code>normalize = TRUE</code> (by default, see Algorithm 2.11 in Golyandina et al (2018))
corresponds to finding the basis by the SVD of <code class="reqn">[V, \Phi(V)]</code>,
where the rows of
matrix <code class="reqn">V</code> are <code class="reqn">V_i</code>.
The value by default <code>TRUE</code> guaranties that the contributions
of sine waves will be ordered by decreasing of frequencies, although can
slightly worsen the weak separability</p>



<h3>Value</h3>

<p>Object of class ‘ossa’. The field ‘ossa.set’ contains the vector of indices
of elementary components used in Filter-adjusted O-SSA (that is, used in <code>nested.groups</code>).
</p>


<h3>References</h3>

<p>Golyandina N., Korobeynikov A., Zhigljavsky A. (2018):
<em>Singular Spectrum Analysis with R.</em>  Use R!.
Springer, Berlin, Heidelberg.
</p>
<p>Golyandina N. and Shlemov A. (2015): <em>Variations of Singular Spectrum Analysis
for separability improvement: non-orthogonal decompositions of time series</em>, 
Statistics and Its Interface. Vol.8, No 3, P.277-294.
<a href="https://arxiv.org/abs/1308.4022">https://arxiv.org/abs/1308.4022</a>
</p>


<h3>See Also</h3>

<p><code>Rssa</code> for an overview of the package, as well as,
<code>iossa</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Separation of two mixed sine-waves with equal amplitudes
N &lt;- 150
L &lt;- 70
omega1 &lt;- 1/15
omega2 &lt;- 1/10

v &lt;- sin(2*pi*omega1 * (1:N)) + sin(2*pi*omega2 * (1:N))
s &lt;- ssa(v, L)
fs &lt;- fossa(s, nested.groups = 1:4, gamma = 100)

# Rssa does most of the plots via lattice
ws &lt;- plot(wcor(s, groups = 1:4))
wfs &lt;- plot(wcor(fs, groups = 1:4))
plot(ws, split = c(1, 1, 2, 1), more = TRUE)
plot(wfs, split = c(2, 1, 2, 1), more = FALSE)

opar &lt;- par(mfrow = c(2, 1))
plot(reconstruct(s, groups = list(1:2, 3:4)))
plot(reconstruct(fs, groups = list(1:2, 3:4)))
par(opar)

# Real-life example: Australian Wine Sales

data(AustralianWine)
s &lt;- ssa(AustralianWine[1:120, "Fortified"], L = 60)
fs &lt;- fossa(s, nested.groups = list(6:7, 8:9, 10:11), gamma = 10)

plot(reconstruct(fs, groups = list(6:7, 8:9, 10:11)))
plot(wcor(s, groups = 6:11))
plot(wcor(fs, groups = 6:11))

# Real life example: improving of strong separability
data(USUnemployment)
unempl.male &lt;- USUnemployment[, "MALE"]
s &lt;- ssa(unempl.male)
fs &lt;- fossa(s, nested.groups = 1:13, gamma = 1000)

# Comparison of reconstructions
rec &lt;- reconstruct(s, groups = list(c(1:4, 7:11), c(5:6, 12:13)))
frec &lt;- reconstruct(fs, groups &lt;- list(5:13, 1:4))
# Trends
matplot(data.frame(frec$F1, rec$F1, unempl.male), type= 'l',
        col=c("red","blue","black"), lty=c(1,1,2))
# Seasonalities
matplot(data.frame(frec$F2, rec$F2), type = 'l', col=c("red","blue"), lty=c(1,1))

# W-cor matrices before and after FOSSA
ws &lt;- plot(wcor(s, groups = 1:30), grid = 14)
wfs &lt;- plot(wcor(fs, groups = 1:30), grid = 14)
plot(ws, split = c(1, 1, 2, 1), more = TRUE)
plot(wfs, split = c(2, 1, 2, 1), more = FALSE)

# Eigenvectors before and after FOSSA
plot(s, type = "vectors", idx = 1:13)
plot(fs, type = "vectors", idx = 1:13)

# 2D plots of periodic eigenvectors before and after FOSSA
plot(s, type = "paired", idx = c(5, 12))
plot(fs, type = "paired", idx = c(1, 3))

# Compare FOSSA with and without normalize
N &lt;- 150
L &lt;- 70
omega1 &lt;- 1/15
omega2 &lt;- 1/10

v &lt;- 3*sin(2*pi*omega1 * (1:N)) + 2*sin(2*pi*omega2 * (1:N))
s &lt;- ssa(v, L)
fs &lt;- fossa(s, nested.groups = 1:4, gamma = 100)
fs.norm &lt;- fossa(s, nested.groups = 1:4, gamma = 100, normalize = TRUE)
opar &lt;- par(mfrow = c(2, 1))
plot(reconstruct(fs, groups = list(1:2, 3:4)))
plot(reconstruct(fs.norm, groups = list(1:2, 3:4)))
par(opar)

# 2D example
data(Mars)
s &lt;- ssa(Mars)
plot(s, "vectors", idx = 1:50)
plot(s, "series", idx = 1:50)
fs &lt;- fossa(s, nested.groups = 1:50, gamma = Inf)
plot(fs, "vectors", idx = 1:14)
plot(fs, "series", groups = 1:13)

# Filters example, extracting horizontal and vertical stripes
data(Mars)
s &lt;- ssa(Mars)
fs.hor &lt;- fossa(s, nested.groups = 1:50, gamma = Inf,
                filter = list(c(-1, 1), c(1)))
plot(fs.hor, "vectors", idx = 1:14)
plot(fs.hor, "series", groups = 1:13)
fs.ver &lt;- fossa(s, nested.groups = 1:50, gamma = Inf,
                filter = list(c(1), c(-1, 1)))
plot(fs.ver, "vectors", idx = 1:14)
plot(fs.ver, "series", groups = 1:13)

</code></pre>


</div>