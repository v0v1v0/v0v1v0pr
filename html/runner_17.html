<div class="container">

<table style="width: 100%;"><tr>
<td>runner</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply running function</h2>

<h3>Description</h3>

<p>Applies custom function on running windows.
</p>


<h3>Usage</h3>

<pre><code class="language-R">runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## Default S3 method:
runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'data.frame'
runner(
  x,
  f = function(x) x,
  k = attr(x, "k"),
  lag = if (!is.null(attr(x, "lag"))) attr(x, "lag") else integer(1),
  idx = attr(x, "idx"),
  at = attr(x, "at"),
  na_pad = if (!is.null(attr(x, "na_pad"))) attr(x, "na_pad") else FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'grouped_df'
runner(
  x,
  f = function(x) x,
  k = attr(x, "k"),
  lag = if (!is.null(attr(x, "lag"))) attr(x, "lag") else integer(1),
  idx = attr(x, "idx"),
  at = attr(x, "at"),
  na_pad = if (!is.null(attr(x, "na_pad"))) attr(x, "na_pad") else FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'matrix'
runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'xts'
runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br>
Input in runner custom function <code>f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>(<code>function</code>)<br>
Applied on windows created from <code>x</code>. This function is meant to summarize
windows and create single element for each window, but one can also specify
function which return multiple elements (runner output will be a list).
By default runner returns windows as is (<code style="white-space: pre;">⁠f = function(x)⁠</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br>
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code>base::seq.POSIXt()</code>.
See 'Specifying time-intervals' in details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br>
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code>base::seq.POSIXt()</code>. See 'Specifying time-intervals' in details
section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br>
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br>
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code>base::seq.POSIXt()</code>.
See 'Specifying time-intervals' in details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br>
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>(<code>logical</code> or <code>character</code> value)<br>
should the result be simplified to a vector, matrix or higher dimensional
array if possible. The default value, <code>simplify = TRUE</code>, returns a vector or
matrix if appropriate, whereas if <code>simplify = "array"</code> the result may be an
array of "rank" <code style="white-space: pre;">⁠(=length(dim(.)))⁠</code> one higher than the result of output
from the function <code>f</code> for each window. Consequences of <code>simplify</code> in <code>runner</code>
are identical to <code>sapply</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>(<code>cluster</code>) <em>experimental</em><br>
Create and pass the cluster to the <code>runner</code> function to run each window
calculation in parallel. See <code>parallel::makeCluster()</code> in details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional)<br>
other arguments passed to the function <code>f</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function can apply any R function on running windows defined by <code>x</code>,
<code>k</code>, <code>lag</code>, <code>idx</code> and <code>at</code>. Running window can be calculated
on several ways:
</p>

<ul>
<li> <p><strong>Cumulative windows</strong><br>
applied when user doesn't specify <code>k</code> argument or specify <code>k = length(x)</code>,
this would mean that <code>k</code> is equal to number of available elements <br><img src="../help/figures/cumulativewindows.png" width="75%" alt="Figure: cumulativewindows.png"></p>
</li>
<li> <p><strong>Constant sliding windows</strong>
applied when user specify <code>k</code> as constant value keeping <code>idx</code> and
<code>at</code> unspecified. <code>lag</code> argument shifts windows left (<code>lag &gt; 0</code>)
or right (<code>lag &lt; 0</code>). <br><img src="../help/figures/incrementalindex.png" width="75%" alt="Figure: incrementalindex.png"></p>
</li>
<li> <p><strong>Windows depending on date</strong><br>
If one specifies <code>idx</code> this would mean that output windows size might
change in size because of unequally spaced indexes. Fox example 5-period
window is different than 5-element window, because 5-period window might
contain any number of observation (7-day mean is not the same as 7-element
mean)
<br><img src="../help/figures/runningdatewindows.png" width="75%" alt="Figure: runningdatewindows.png"></p>
</li>
<li> <p><strong>Window at specific indices</strong><br><code>runner</code> by default returns vector of the same size as <code>x</code> unless one
specifies <code>at</code> argument. Each element of <code>at</code> is an index on which runner
calculates function - which means that output of the runner is now of
length equal to <code>at</code>. Note that one can change index of <code>x</code> by specifying
<code>idx</code>. Illustration below shows output of <code>runner</code> for
<code>at = c(18, 27, 45, 31)</code> which gives windows in ranges enclosed in square
brackets. Range for <code>at = 27</code> is <code style="white-space: pre;">⁠[22, 26]⁠</code> which is not available in
current indices. <br><img src="../help/figures/runnerat.png" width="75%" alt="Figure: runnerat.png"></p>
</li>
</ul>
<h4>Specifying time-intervals</h4>

<p><code>at</code> can also be specified as interval of the output defined by
<code>at = "&lt;increment&gt;"</code> which results in indices sequence defined by
<code>seq.POSIXt(min(idx), max(idx), by = "&lt;increment&gt;")</code>. Increment of sequence
is the same as in <code>base::seq.POSIXt()</code> function.
It's worth noting that increment interval can't be more frequent than
interval of <code>idx</code> - for <code>Date</code> the most frequent time-unit is a <code>"day"</code>,
for <code>POSIXt</code> a <code>sec</code>.
</p>
<p><code>k</code> and <code>lag</code> can also be specified as using time sequence increment.
Available time units are
<code style="white-space: pre;">⁠"sec", "min", "hour", "day", "DSTday", "week", "month", "quarter" or "year"⁠</code>.
To increment by number of units one can also specify <code style="white-space: pre;">⁠&lt;number&gt; &lt;unit&gt;s⁠</code>
for example <code>lag = "-2 days"</code>, <code>k = "5 weeks"</code>.
</p>
<p>Setting <code>k</code> and <code>lag</code> as a sequence increment can be also a vector can be a
vector which allows to stretch and lag/lead each window freely on in time
(on indices).
<br></p>



<h4>Parallel computing</h4>

<p>Beware that executing R call in parallel not always
have the edge over single-thread even if the
<code>cl &lt;- registerCluster(detectCores())</code> was specified before.
<br>
Parallel windows are executed in the independent environment, which means
that objects other than function arguments needs to be copied to the
parallel environment using <code>parallel::clusterExport()</code>. For
example using <code>f = function(x) x + y + z</code> will result in error as
<code>clusterExport(cl, varlist = c("y", "z"))</code> needs to be called before.
</p>



<h3>Value</h3>

<p>vector with aggregated values for each window. Length of output is
the same as <code>length(x)</code> or <code>length(at)</code> if specified. Type of the output
depends on the output from a function <code>f</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# runner returns windows as is by default
runner(1:10)

# mean on k = 3 elements windows
runner(1:10, f = mean, k = 3)

# mean on k = 3 elements windows with different specification
runner(1:10, k = 3, f = function(x) mean(x, na.rm = TRUE))

# concatenate two columns
runner(
  data.frame(
    a = letters[1:10],
    b = 1:10
  ),
  f = function(x) paste(paste0(x$a, x$b), collapse = "+")
)

# concatenate two columns with additional argument
runner(
  data.frame(
    a = letters[1:10],
    b = 1:10
  ),
  f = function(x, xxx) {
    paste(paste0(x$a, xxx, x$b), collapse = " + ")
  },
  xxx = "..."
)

# number of unique values in each window (varying window size)
runner(letters[1:10],
  k = c(1, 2, 2, 4, 5, 5, 5, 5, 5, 5),
  f = function(x) length(unique(x))
)

# concatenate only on selected windows index
runner(letters[1:10],
  f = function(x) paste(x, collapse = "-"),
  at = c(1, 5, 8)
)

# 5 days mean
idx &lt;- c(4, 6, 7, 13, 17, 18, 18, 21, 27, 31, 37, 42, 44, 47, 48)
runner::runner(
  x = idx,
  k = "5 days",
  lag = 1,
  idx = Sys.Date() + idx,
  f = function(x) mean(x)
)

# 5 days mean at 4-indices
runner::runner(
  x = 1:15,
  k = 5,
  lag = 1,
  idx = idx,
  at = c(18, 27, 48, 31),
  f = mean
)

# runner with data.frame
df &lt;- data.frame(
  a = 1:13,
  b = 1:13 + rnorm(13, sd = 5),
  idx = seq(as.Date("2022-02-22"), as.Date("2023-02-22"), by = "1 month")
)
runner(
  x = df,
  idx = "idx",
  at = "6 months",
  f = function(x) {
    cor(x$a, x$b)
  }
)

# parallel computing
library(parallel)
data &lt;- data.frame(
  a = runif(100),
  b = runif(100),
  idx = cumsum(sample(rpois(100, 5)))
)
const &lt;- 0
cl &lt;- makeCluster(1)
clusterExport(cl, "const", envir = environment())

runner(
  x = data,
  k = 10,
  f = function(x) {
    cor(x$a, x$b) + const
  },
  idx = "idx",
  cl = cl
)
stopCluster(cl)

# runner with matrix
data &lt;- matrix(data = runif(100, 0, 1), nrow = 20, ncol = 5)
runner(
  x = data,
  f = function(x) {
    tryCatch(
      cor(x),
      error = function(e) NA
    )
  }
)
</code></pre>


</div>