<div class="container">

<table style="width: 100%;"><tr>
<td>comboIter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Combination and Permutation Iterator
</h2>

<h3>Description</h3>


<ul>
<li>
<p> Returns an iterator for iterating over combinations or permutations of a vector with or without constraints.
</p>
</li>
<li>
<p> Supports random access via the <code>[[</code> method.
</p>
</li>
<li>
<p> GMP support allows for exploration of combinations/permutations of vectors with many elements.
</p>
</li>
<li>
<p> The output is in lexicographical order for the <code>next</code> methods and reverse lexicographical order for the <code>prev</code> methods.
</p>
</li>
<li>
<p> Learn more in <code>vignette("iterators")</code>.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">comboIter(v, m = NULL, ...)
permuteIter(v, m = NULL, ...)

## S3 method for class 'numeric'
comboIter(v, m = NULL, repetition = FALSE, freqs = NULL,
          constraintFun = NULL, comparisonFun = NULL,
          limitConstraints = NULL, keepResults = NULL,
          FUN = NULL, Parallel = FALSE, nThreads = NULL,
          tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'numeric'
permuteIter(v, m = NULL, repetition = FALSE, freqs = NULL,
            constraintFun = NULL, comparisonFun = NULL,
            limitConstraints = NULL, keepResults = NULL,
            FUN = NULL, Parallel = FALSE, nThreads = NULL,
            tolerance = NULL, FUN.VALUE = NULL, ...)

## S3 method for class 'factor'
comboIter(
    v, m = NULL, repetition = FALSE, freqs = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)
## S3 method for class 'factor'
permuteIter(
    v, m = NULL, repetition = FALSE, freqs = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, FUN.VALUE = NULL, ...
)

## Default S3 method:
comboIter(
    v, m = NULL, repetition = FALSE, freqs = NULL,
    FUN = NULL, FUN.VALUE = NULL, ...
)
## Default S3 method:
permuteIter(
    v, m = NULL, repetition = FALSE, freqs = NULL,
    FUN = NULL, FUN.VALUE = NULL, ...
)

## S3 method for class 'table'
comboIter(
    v, m = NULL, constraintFun = NULL, comparisonFun = NULL,
    limitConstraints = NULL, keepResults = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...
)
## S3 method for class 'table'
permuteIter(
    v, m = NULL, constraintFun = NULL, comparisonFun = NULL,
    limitConstraints = NULL, keepResults = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, tolerance = NULL, FUN.VALUE = NULL, ...
)

## S3 method for class 'list'
comboIter(v, m = NULL, repetition = FALSE, freqs = NULL, ...)
## S3 method for class 'list'
permuteIter(v, m = NULL, repetition = FALSE, freqs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code>is.atomic</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of elements to choose.  If <code>repetition = TRUE</code> or <code>freqs</code> is utilized, <code>m</code> can exceed the length of <code>v</code>. If <code>m = NULL</code>, the length will default to <code>length(v)</code> or <code>sum(freqs)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code>rep</code>. The default value is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraintFun</code></td>
<td>
<p>Function to be applied to the elements of <code>v</code> that should be passed as a string (<em>e.g.</em> <code>constraintFun = "sum"</code>). The possible constraint functions are: <code>"sum"</code>, <code>"prod"</code>, <code>"mean"</code>, <code>"max"</code>, &amp; <code>"min"</code>. The default is <code>NULL</code>, meaning no function is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comparisonFun</code></td>
<td>
<p>Comparison operator that will be used to compare <code>limitConstraints</code> with the result of <code>constraintFun</code> applied to <code>v</code>. It should be passed as a string or a vector of two strings (<em>e.g.</em> <code>comparisonFun = "&lt;="</code> or  <code>comparisonFun = c("&gt;","&lt;")</code>). The possible comparison operators are: <code>"&lt;"</code>, <code>"&gt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"=="</code>. The default is <code>NULL</code>.
</p>
<p>When <code>comparisonFun</code> is a vector of two comparison strings, <em>e.g</em> <code>comparisonFun = c(comp1, comp2)</code>, and <code>limitConstraints</code> is a vector of two numerical values, <em>e.g</em> <code>limitConstraints = c(x1, x2)</code>, the combinations/permutations will be filtered in one of the following two ways:
</p>

<ol>
<li>
<p>When <code>comp1</code> is one of the 'greater-than' operators (<em>i.e.</em> "&gt;=" or "&gt;"), <code>comp2</code> is one of the 'less-than' operators (<em>i.e.</em> "&lt;=" or "&lt;"), and <code>x1 &lt; x2</code>, the combinations/permutations that are returned will have a value (after <code>constraintFun</code> has been applied) between <code>x1</code> and <code>x2</code>.
</p>
</li>
<li>
<p>When <code>comp1</code> and <code>comp2</code> are defined as in #1 and <code>x1 &gt; x2</code>, the combinations/permutations that are returned will have a value outside the range of <code>x1</code> and <code>x2</code>. See the examples below.
</p>
</li>
</ol>
<p>In other words, the first comparison operator is applied to the first limit and the second operator is applied to the second limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limitConstraints</code></td>
<td>
<p>This is the value(s) that will be used for comparison. Can be passed as a single value or a vector of two numerical values. The default is <code>NULL</code>. See the definition of <code>comparisonFun</code> as well as the examples below for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepResults</code></td>
<td>
<p>A logical flag indicating if the result of <code>constraintFun</code> applied to <code>v</code> should be displayed; if <code>TRUE</code>, an additional column of results will be added to the resulting matrix. The default is <code>FALSE</code>. If user is only applying <code>constraintFun</code>, <code>keepResults</code> will default to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>Function to be applied to each combination/permutation. The default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Parallel</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be generated in parallel using <code class="reqn">n - 1</code> threads, where <code class="reqn">n</code> is the maximum number of threads. The default is <code>FALSE</code>. If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>A numeric value greater than or equal to zero. This parameter is utilized when a constraint is applied on a numeric vector. The default value is 0 when it can be determined that whole values are being utilized, otherwise it is <code>sqrt(.Machine$double.eps)</code> which is approximately <code class="reqn">1.5e-8</code>. N.B. If the input vector is of type integer, this parameter will be ignored and strict equality will be enforced.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN.VALUE</code></td>
<td>
<p>A template for the return value from <code>FUN</code>. See 'Details' of <code>vapply</code> for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Once you initialize a new iterator, the following methods are available via <code>@</code> (<em>e.g.</em> <code>a@nextIter()</code>) or <code>$</code> (<em>e.g.</em> <code>a$nextIter()</code>). The preferred practice is to use <code>@</code> as it is much more efficient (See examples below). Also note that not all of the methods below are available in all cases. See <code>Combo-class</code>, <code>Constraints-class</code>, and <code>Partitions-class</code>:
</p>

<dl>
<dt><code>nextIter</code></dt>
<dd>
<p>Retrieve the <b>next</b> lexicographical result</p>
</dd>
<dt><code>nextNIter</code></dt>
<dd>
<p>Pass an integer <em>n</em> to retrieve the <b>next</b> <em>n</em> lexicographical results</p>
</dd>
<dt><code>nextRemaining</code></dt>
<dd>
<p>Retrieve all remaining lexicographical results</p>
</dd>
<dt><code>currIter</code></dt>
<dd>
<p>Returns the current iteration</p>
</dd>
<dt><code>prevIter</code></dt>
<dd>
<p>Retrieve the <b>previous</b> lexicographical result (the <b>next</b> <em>reverse</em> lexicographical result)</p>
</dd>
<dt><code>prevNIter</code></dt>
<dd>
<p>Pass an integer <em>n</em> to retrieve the <b>previous</b> <em>n</em> lexicographical results (the <b>next</b> <em>n</em> <em>reverse</em> lexicographical results)</p>
</dd>
<dt><code>prevRemaining</code></dt>
<dd>
<p>Retrieve all remaining <em>reverse</em> lexicographical results</p>
</dd>
<dt><code>startOver</code></dt>
<dd>
<p>Resets the iterator</p>
</dd>
<dt><code>sourceVector</code></dt>
<dd>
<p>View the source vector</p>
</dd>
<dt><code>summary</code></dt>
<dd>
<p>Returns a list of summary information about the iterator</p>
</dd>
<dt><code>front</code></dt>
<dd>
<p>Retrieve the <b>first</b> lexicographical result</p>
</dd>
<dt><code>back</code></dt>
<dd>
<p>Retrieve the <b>last</b> lexicographical result</p>
</dd>
<dt><code>[[</code></dt>
<dd>
<p>Random access method. Pass a single value or a vector of valid indices. If a single value is passed, the internal index of the iterator will be updated, however if a vector is passed the internal state will not change. GMP support allows for flexible indexing.</p>
</dd>
</dl>
<h3>Value</h3>


<ul>
<li>
<p> If <code>nextIter</code> or <code>prevIter</code> is called, a vector is returned
</p>
</li>
<li>
<p> Otherwise, a matrix with <code class="reqn">m</code> or <code class="reqn">m + 1</code> columns, depending on the value of <code>keepResults</code>
</p>
</li>
<li>
<p> If <code>FUN</code> is utilized, <code>FUN.VALUE = NULL</code>, and either <code>nextIter</code> or <code>prevIter</code> is called, the result will be determined by <code>FUN</code>, otherwise a list is returned.
</p>
</li>
<li>
<p> When both <code>FUN</code> and <code>FUN.VALUE</code> are not <code>NULL</code>, the return is modeled after the return of <code>vapply</code>. See the 'Value' section of <code>vapply</code>.
</p>
</li>
</ul>
<h3>Note</h3>


<ul>
<li> <p><code>Parallel</code> and <code>nThreads</code> will be ignored in the following cases:
</p>

<ul>
<li>
<p> When the output is constrained (except for most partitions cases)
</p>
</li>
<li>
<p> If the class of the vector passed is <code>character</code>, <code>raw</code>, and <code>complex</code> (N.B. <code>Rcpp::CharacterMatrix</code> is not thread safe). Alternatively, you can generate an indexing matrix in parallel.
</p>
</li>
<li>
<p> If <code>FUN</code> is utilized.
</p>
</li>
</ul>
</li>
<li>
<p> If either <code>constraintFun</code>, <code>comparisonFun</code> or <code>limitConstraints</code> is <code>NULL</code> –or– if the class of the vector passed is <code>logical</code>, <code>character</code>, <code>raw</code>, <code>factor</code>, or <code>complex</code>, the constraint check will not be carried out. This is equivalent to simply finding all combinations/permutations of <code class="reqn">v</code> choose <code class="reqn">m</code>.
</p>
</li>
<li>
<p> The maximum number of combinations/permutations that can be generated at one time is <code class="reqn">2^{31} - 1</code>.
</p>
</li>
<li>
<p> Factor vectors are accepted. Class and level attributes are preserved except when <code>FUN</code> is used.
</p>
</li>
<li>
<p> Lexicographical ordering isn't guaranteed for permutations if the output is constrained.
</p>
</li>
<li> <p><code>FUN</code> will be ignored if the constraint check is satisfied.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical Order</a>
</p>
</li>
<li>
<p><a href="https://oeis.org/wiki/Orderings#Reverse_lexicographic_order">Reverse Lexicographical Order</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>comboGeneral</code>, <code>permuteGeneral</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Typical usage
a = permuteIter(unique(state.region))
a@nextIter()
a@nextNIter(3)
a@front()
a@nextRemaining()
a@prevIter()
a@prevNIter(15)
a@summary()
a@back()
a@prevRemaining()
a[[5]]
a@summary()
a[[c(1, 17, 3)]]
a@summary()

## See examples for comboGeneral where lower and upper are used
set.seed(1009)
mySamp = sort(rnorm(75, 997, 23))

b = comboIter(mySamp, 7,
              constraintFun = "sum",
              comparisonFun = "&gt;",
              limitConstraints = 7200)
b@nextIter()
b@nextNIter(3)
b@summary()
b@currIter()

## Not run: 
## We don't have random access or previous methods
b@back()
#&gt; Error: no slot of name "back" for this object of class "Constraints"
b@prevIter()
#&gt; Error: no slot of name "prevIter" for this object of class "Constraints"

## End(Not run)
</code></pre>


</div>