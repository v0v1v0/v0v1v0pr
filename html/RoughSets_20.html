<div class="container">

<table style="width: 100%;"><tr>
<td>D.global.discernibility.heuristic.RST</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Supervised discretization based on the maximum discernibility heuristic</h2>

<h3>Description</h3>

<p>It is a function used for computing globally semi-optimal cuts using the maximum discernibility heuristic.
</p>


<h3>Usage</h3>

<pre><code class="language-R">D.global.discernibility.heuristic.RST(
  decision.table,
  maxNOfCuts = 2 * ncol(decision.table),
  attrSampleSize = ncol(decision.table) - 1,
  cutCandidatesList = NULL,
  discFunction = global.discernibility,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decision.table</code></td>
<td>
<p>an object inheriting from the <code>"DecisionTable"</code> class, which represents a decision system.
See <code>SF.asDecisionTable</code>.
It should be noted that for this particular method all conditional attributes
must be numeric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxNOfCuts</code></td>
<td>
<p>a positive integer indicating the maximum number of allowed cuts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attrSampleSize</code></td>
<td>
<p>an integer between 1 and the number of conditional attributes (the default). It indicates
the attribute sample size for the Monte Carlo selection of candidating cuts.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutCandidatesList</code></td>
<td>
<p>an optional list containing candidates for optimal cut values.
By default the candidating cuts are determined automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discFunction</code></td>
<td>
<p>a function used for computation of cuts. Currently only one implementation of maximu discernibility heuristic
is available (the default). However, this parameter can be used to integrate custom implementations of
discretization functions with the <code>RoughSets</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional parameters to the <code>discFunction</code> (currently unsupported).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A complete description of the implemented algorithm can be found in (Nguyen, 2001).
</p>
<p>It should be noted that the output of this function is an object of a class <code>"Discretization"</code>
which contains the cut values.
The function <code>SF.applyDecTable</code> has to be used in order to generate the new (discretized) decision table.
</p>


<h3>Value</h3>

<p>An object of a class <code>"Discretization"</code> which stores cuts for each conditional attribute.
See <code>D.discretization.RST</code>.
</p>


<h3>Author(s)</h3>

<p>Andrzej Janusz
</p>


<h3>References</h3>

<p>S. H. Nguyen, "On Efficient Handling of Continuous Attributes in Large Data Bases",
Fundamenta Informaticae, vol. 48, p. 61 - 81 (2001).
</p>
<p>Jan G. Bazan, Hung Son Nguyen, Sinh Hoa Nguyen, Piotr Synak, and Jakub Wroblewski,
"Rough Set Algorithms in Classification Problem", Chapter 2
In: L. Polkowski, S. Tsumoto and T.Y. Lin (eds.): Rough Set Methods and Applications
Physica-Verlag, Heidelberg, New York, p. 49 - 88 ( 2000).
</p>


<h3>See Also</h3>

<p><code>D.discretize.quantiles.RST</code>, <code>D.discretize.equal.intervals.RST</code>,
<code>D.local.discernibility.heuristic.RST</code> and <code>SF.applyDecTable</code>.
A wrapper function for all available discretization methods: <code>D.discretization.RST</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#################################################################
## Example: Determine cut values and generate new decision table
#################################################################
data(RoughSetData)
wine.data &lt;- RoughSetData$wine.dt
cut.values &lt;- D.global.discernibility.heuristic.RST(wine.data)

## generate a new decision table:
wine.discretized &lt;- SF.applyDecTable(wine.data, cut.values)
dim(wine.discretized)
lapply(wine.discretized, unique)

## remove attributes with only one possible value:
to.rm.idx &lt;- which(sapply(lapply(wine.discretized, unique), function(x) length(x) == 1))
to.rm.idx
wine.discretized.reduced &lt;- wine.discretized[-to.rm.idx]
dim(wine.discretized.reduced)

## check whether the attributes in the reduced data are a super-reduct of the original data:
colnames(wine.discretized.reduced)
class.idx &lt;- which(colnames(wine.discretized.reduced) == "class")
sum(duplicated(wine.discretized.reduced)) == sum(duplicated(wine.discretized.reduced[-class.idx]))
## yes it is

</code></pre>


</div>