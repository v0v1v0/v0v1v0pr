<div class="container">

<table style="width: 100%;"><tr>
<td>goGARCHroll-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>class: GO-GARCH Roll Class</h2>

<h3>Description</h3>

<p>Class for the GO-GARCH Roll.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code>gogarchroll</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>forecast</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code> which contains the
rolling forecasts of the distributional parameters for each factor.</p>
</dd>
<dt>
<code>model</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code> containing details of the
GOGARCH model specification.</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"mGARCHroll"</code>, directly.
Class <code>"GARCHroll"</code>, by class "mGARCHroll", distance 2.
Class <code>"rGARCH"</code>, by class "mGARCHroll", distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:
Extraction of independent factor GARCH model coefficients saved from the
goGARCHfit objects(returns a list).</p>
</dd>
<dt>fitted</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:
Extracts the conditional fitted forecast values (returns an xts object with
index the actual forecast T+1 times).</p>
</dd>
<dt>sigma</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:
Extracts the conditional sigma forecast values (returns an xts object with
index the actual forecast T+1 times). Takes optional argument “factors”
(default TRUE) denoting whether to return the factor conditional sigma or
the transformed sigma for the assets.</p>
</dd>
<dt>rcov</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset x (n.roll+1) covariance matrix in
array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). A further argument ‘output’ allows
to switch between “array” and “matrix” returned object.</p>
</dd>
<dt>rcor</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset x (n.roll+1) correlation matrix
in array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). A further argument ‘output’
allows to switch between “array” and “matrix” returned object.</p>
</dd>
<dt>rcoskew</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset^2 x (n.roll+1) coskewness matrix
in array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). There is a “standardize”
option which indicates whether the coskewness should be standardized by the
conditional sigma (see equations in vignette).</p>
</dd>
<dt>rcokurt</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset^3 x (n.roll+1) cokurtosis matrix
in array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). There is a “standardize”
option which indicates whether the cokurtosis should be standardized by the
conditional sigma (see equations in vignette).</p>
</dd>
<dt>gportmoments</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:<br>
function:<br><b>gportmoments(object, weights)</b><br>
Calculates the first 4 standardized portfolio moments using the geometric
properties of the model, given a matrix of asset weights with row dimension
equal to the total rolling forecast horizon. Returns an xts object of
dimensions (total rolling forecast) x 4 (moments), with the index denoting
the T+1 actual forecast time. If the number of assets &gt; 100, then the
kurtosis is not returned (see cokurtosis restrictions below).</p>
</dd>
<dt>convolution</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>:<br>
function:<br><b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c("user", "adaptive"),
use.ff = TRUE, cluster = NULL, trace = 0,...)</b><br>
The convolution method takes a goGARCHroll object and a weights vector or
matrix and calculates the weighted density. If a vector is given, it must be
the same length as the number of assets, otherwise a matrix with
row dimension equal to the row dimension of total forecast horizon.
In the case of the multivariate normal distribution, this simply returns the
linear and quadratic transformation of the mean and covariance matrix, while
in the multivariate affine NIG distribution this is based on the numerical
inversion by FFT of the characteristic function. In that case, the
“fft.step” option determines the stepsize for tuning the
characteristic function inversion, “fft.by” determines the resolution
for the equally spaced support given by “fft.support”, while the use
of the “ff” package is recommended to avoid memory problems on some
systems and is turned on via the “use.ff” option.
The “support.method” option allows either a fixed support range to be
given (option ‘user’), else an adaptive method is used based on the
min and max of the assets at each point in time at the 0.00001 and 1-0.00001
quantiles. The range is equally spaced subject to the “fft.by” value
but the returned object no longer makes of the “ff” package returning
instead a list. The option for parallel computation is available
via the use of a cluster object as elsewhere in this package. Passing this
object to the distribution methods (e.g. qfft) follows the same rules as
the goGARCHforecast object, namely that the index is zero based.</p>
</dd>
<dt>show</dt>
<dd>
<p><code>signature(object = "goGARCHroll")</code>: Summary. </p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Alexios Galanos</p>


</div>