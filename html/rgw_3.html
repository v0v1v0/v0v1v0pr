<div class="container">

<table style="width: 100%;"><tr>
<td>GoodmanWeare.rem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Goodman-Weare Affine-Invariant Sampling
</h2>

<h3>Description</h3>

<p>Produces a Monte-Carlo Markov ensemble using the affine-invariant method of Goodman &amp; Weare, saving progress periodically.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GoodmanWeare.rem(post, lnpost, thin=1, mention.every=NA,
 save.every=NA, save.file=NA, show.every=NA,
 show.params=1:dim(post)[1], show.walkers=min(dim(post)[2],8),
 show.pch1=1, show.pch2='.', show.pch.switch=500,
 return.lnpost=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>post</code></td>
<td>

<p>an Nparam*Nwalkers*Nsteps array. post[,,1] should hold the initial state of the sampler (see help for GoodmanWeare). Checkpoints and the return value will have the same shape, with subsequent layers post[,,i] holding the ensemble state at later iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lnpost</code></td>
<td>

<p>function taking a vector of parameter values as input, and returning the log-posterior density.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>

<p>thinning factor for saving the results.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mention.every</code></td>
<td>

<p>print a message to the console every time this many iterations are completed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.every</code></td>
<td>

<p>save the accumulated Markov ensemble to disk every time this many iterations are completed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.file</code></td>
<td>

<p>filename for saving progress.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.every</code></td>
<td>

<p>plot parameter traces so far to the active graphics device periodically.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.params</code></td>
<td>

<p>(sub)set of parameter traces to plot (default is to show all).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.walkers</code></td>
<td>

<p>which walkers to plot traces of (default is first 8).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.pch1</code></td>
<td>

<p>plot symbol to use for short chains.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.pch2</code></td>
<td>

<p>plot symbol to use for long chains.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.pch.switch</code></td>
<td>

<p>chain length that distinguishes "short" and "long" chains for plotting purposes.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.lnpost</code></td>
<td>

<p>whether to return log-posterior values for each sample; see Value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional named arguments to pass to GoodmanWeare or lnpost.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>If return.lnpost==FALSE, an array of the same dimensionality as post, storing the position of the walkers in post[,,i] every thin iterations. Otherwise, a list containing that array as $post, as well as an Nwalkers*Nsteps array storing the corresponding log-posterior values as $lnP. The log-posterior values $lnP[,1], corresponding with the starting ensemble positions $post[,,1], will always be NA.
</p>


<h3>Note</h3>

<p>By default, the code will attempt to run in parallel (see the ‘parallel’
package). To prevent this, pass mc.cores=1.
</p>
<p>If traces are being plotted (show.every not NA),
par(mfrow=c(length(show.params), 1)) is called on the current graphics
device.
</p>


<h3>Author(s)</h3>

<p>Adam Mantz
</p>


<h3>References</h3>

<p>See also help for rgw::GoodmanWeare.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># In this example, we'll sample from a simple 2D Gaussian.
# (This is the same example as used in GoodmanWeare.)

# Define the log-posterior function
lnP = function(x) sum( dnorm(x, c(0,1), c(pi, exp(0.5)), log=TRUE) )

# Initialize an ensemble of 100 walkers. We'll take 100 steps, saving the
# ensemble after each.
nwalk = 100
post = array(NA, dim=c(2, nwalk, 101))
post[1,,1] = rnorm(nwalk, 0, 0.1)
post[2,,1] = rnorm(nwalk, 1, 0.1)

# Run
post = GoodmanWeare.rem(post, lnP, mc.cores=1)

# Plot the final ensemble
plot(post[1,,101], post[2,,101])
# Look at the trace of each parameter for one of the walkers.
plot(post[1,1,])
plot(post[2,1,])
</code></pre>


</div>