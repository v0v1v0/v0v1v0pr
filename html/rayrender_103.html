<div class="container">

<table style="width: 100%;"><tr>
<td>segment</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Segment Object</h2>

<h3>Description</h3>

<p>Similar to the cylinder object, but specified by start and end points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">segment(
  start = c(0, -1, 0),
  end = c(0, 1, 0),
  radius = 0.1,
  phi_min = 0,
  phi_max = 360,
  from_center = TRUE,
  direction = NA,
  material = diffuse(),
  capped = TRUE,
  flipped = FALSE,
  scale = c(1, 1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Default 'c(0, -1, 0)'. Start point of the cylinder segment, specifing 'x', 'y', 'z'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>
<p>Default 'c(0, 1, 0)'. End point of the cylinder segment, specifing 'x', 'y', 'z'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Default '1'. Radius of the segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_min</code></td>
<td>
<p>Default '0'. Minimum angle around the segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phi_max</code></td>
<td>
<p>Default '360'. Maximum angle around the segment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from_center</code></td>
<td>
<p>Default 'TRUE'. If orientation specified via 'direction', setting this argument
to 'FALSE' will make 'start' specify the bottom of the segment, instead of the middle.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>Default 'NA'. Alternative to 'start' and 'end', specify the direction (via 
a length-3 vector) of the segment. Segment will be centered at 'start', and the length will be
determined by the magnitude of the direction vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>material</code></td>
<td>
<p>Default  <code>diffuse</code>.The material, called from one of the material 
functions <code>diffuse</code>, <code>metal</code>, or <code>dielectric</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capped</code></td>
<td>
<p>Default 'TRUE'. Whether to add caps to the segment. Turned off when using the 'light()' material.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly. Notes: this will change the stated start/end position of the segment. 
Emissive objects may not currently function correctly when scaled.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Single row of a tibble describing the segment in the scene.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate a segment in the cornell box. 
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(segment(start = c(100, 100, 100), end = c(455, 455, 455), radius = 50)) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

# Draw a line graph representing a normal distribution, but with metal:
xvals = seq(-3, 3, length.out = 30)
yvals = dnorm(xvals)

scene_list = list()
for(i in 1:(length(xvals) - 1)) {
  scene_list[[i]] = segment(start = c(555/2 + xvals[i] * 80, yvals[i] * 800, 555/2),
                            end = c(555/2 + xvals[i + 1] * 80, yvals[i + 1] * 800, 555/2),
                            radius = 10,
                            material = metal())
}
scene_segments = do.call(rbind,scene_list)
if(run_documentation()) {
generate_cornell() %&gt;% 
  add_object(scene_segments) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Draw the outline of a cube:

cube_outline = segment(start = c(100, 100, 100), end = c(100, 100, 455), radius = 10) %&gt;%
  add_object(segment(start = c(100, 100, 100), end = c(100, 455, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 100, 100), end = c(455, 100, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 100, 455), end = c(100, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 100, 455), end = c(455, 100, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 455, 455), end = c(100, 455, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 455, 455), end = c(455, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 455, 100), end = c(455, 100, 100), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 455, 100), end = c(455, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 100, 100), end = c(455, 100, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(455, 100, 455), end = c(455, 455, 455), radius = 10)) %&gt;%
  add_object(segment(start = c(100, 455, 100), end = c(455, 455, 100), radius = 10))

if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(cube_outline) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}

#Shrink and rotate the cube
if(run_documentation()) {
generate_cornell() %&gt;%
  add_object(group_objects(cube_outline, pivot_point = c(555/2, 555/2, 555/2),
                           angle = c(45,45,45), scale = c(0.5,0.5,0.5))) %&gt;%
  render_scene(lookfrom = c(278, 278, -800) ,lookat = c(278, 278, 0), fov = 40, 
               ambient_light = FALSE, samples = 128, parallel = TRUE, clamp_value = 5)
}
</code></pre>


</div>