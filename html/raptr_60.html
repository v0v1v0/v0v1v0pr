<div class="container">

<table style="width: 100%;"><tr>
<td>make.DemandPoints</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate demand points for RAP</h2>

<h3>Description</h3>

<p>This function generates demand points to characterize a distribution of
points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">make.DemandPoints(
  points,
  n = 100L,
  quantile = 0.5,
  kernel.method = c("ks", "hypervolume")[1],
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>points</code></td>
<td>
<p><code>base::matrix()</code> object containing points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p><code>integer</code> number of demand points to use for each attribute
space for each species. Defaults to <code>100L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantile</code></td>
<td>
<p><code>numeric</code> quantile to generate demand points within. If
0 then demand points are generated across the full range of values the
<code>points</code> intersect. Defaults to <code>0.5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel.method</code></td>
<td>
<p><code>character</code> name of kernel method to use to
generate demand points. Defaults to <code>'ks'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed to kernel density estimating functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Broadly speaking, demand points are generated by fitting a kernal
to the input <code>points</code>. A shape is then fit to the extent of
the kernal, and then points are randomly generated inside the shape. The
demand points are generated as random points inside the shape. The weights
for each demand point are calculated the estimated density of input points
at the demand point. By supplying 'ks' as an argument to <code>method</code> in
<code>kernel.method</code>, the shape is defined using a minimum convex polygon
<code>adehabitatHR::mcp()</code> and <code>ks::kde()</code> is used to fit
the kernel. Note this can only be used when the data is low-dimensional (d
&lt; 3). By supplying <code>"hypervolume"</code> as an argument to <code>method</code>,
the <code>hypervolume::hypervolume()</code> function is used to create the
demand points. This method can be used for hyper-dimensional data
(<code class="reqn">d &lt;&lt; 3</code>).
</p>


<h3>Value</h3>

<p>A new <code>DemandPoints()</code> object.
</p>


<h3>See Also</h3>

<p><code>hypervolume::hypervolume()</code>, <code>ks::kde()</code>,
<code>adehabitatHR::mcp()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# set random number generator seed
set.seed(500)

# load data
cs_spp &lt;- terra::rast(
  system.file("extdata", "cs_spp.tif", package = "raptr")
)
cs_space &lt;- terra::rast(
  system.file("extdata", "cs_space.tif", package = "raptr")
)

# generate species points
species.points &lt;- randomPoints(cs_spp[[1]], n = 100, prob = TRUE)
env.points &lt;- as.matrix(terra::extract(cs_space, species.points))

# generate demand points for a 1d space using ks
dps1 &lt;- make.DemandPoints(points = env.points[, 1], kernel.method = "ks")

# print object
print(dps1)

# generate demand points for a 2d space using hypervolume
dps2 &lt;- make.DemandPoints(
  points = env.points,
  kernel.method = "hypervolume",
  samples.per.point = 50,
  verbose = FALSE
)

# print object
print(dps2)

## End(Not run)
</code></pre>


</div>