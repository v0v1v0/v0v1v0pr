<div class="container">

<table style="width: 100%;"><tr>
<td>predict_MS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>

Prediction for the robust calibration model for multiple sources
</h2>

<h3>Description</h3>


<p>Function to make prediction on Robust Calibration models after the rcalibration class has been constructed for multiple sources.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'rcalibration_MS'
predict_MS(object, testing_input,
                                       X_testing=as.list(rep(0,object@num_sources)),
                                       testing_output_weights=NULL, 
                                       n_thinning=10,
                                       interval_est=NULL,
                                       interval_data=rep(F,length(testing_input)),
                                       math_model=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of  class <code>rcalibration_MS</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testing_input</code></td>
<td>
<p>a list of matrices containing the inputs where the <code>predict_MS</code> is to perform prediction. Each element of the list is a matrix of testing inputs for the corresponding source of data. The number of rows of the matrix is equal to the number of predictive outputs for the corresponding source. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X_testing</code></td>
<td>
<p>a list of matrices of mean/trend for prediction if specified.  The number of rows of the matrix is equal to the number of predictive outputs for the corresponding source.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testing_output_weights</code></td>
<td>
<p>a list of vecots for the weight of testing outputs for multiple sources.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_thinning</code></td>
<td>
<p>number of points further thinning the MCMC posterior samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval_est</code></td>
<td>
<p>a list of vectors for the posterior predctive credible interval for multiple sources. If interval_est is NULL, we do  not compute the posterior credible interval.  It can be specified as a vector of values ranging from zero to one. E.g.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval_data</code></td>
<td>
<p>a vector of bool values to decide whether the experimental noise is included for computing the posterior credible interval.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>math_model</code></td>
<td>

<p>a list of functions  for the math model to be calibrated for multiple sources.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra arguments to be passed to the function (not implemented yet).</p>
</td>
</tr>
</table>
<h3>Value</h3>






<p>The returned value is a S4 CLass <code>predictobj.rcalibration</code>. 
</p>


<h3>Author(s)</h3>


<p>Mengyang Gu [aut, cre]
</p>
<p>Maintainer: Mengyang Gu &lt;mengyang@pstat.ucsb.edu&gt;
</p>


<h3>References</h3>

<p>A. O'Hagan and M. C. Kennedy (2001), <em>Bayesian calibration of computer models</em>, <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology</em>, <b>63</b>, 425-464.
</p>
<p>K. R. Anderson and M. P. Poland (2016), <em>Bayesian estimation of magma supply, storage, and eroption rates using a multiphysical volcano model: Kilauea volcano, 2000-2012.</em>. <em>Eath and Planetary Science Letters</em>, <b>447</b>, 161-171.
</p>
<p>K. R. Anderson and M. P. Poland (2017), <em>Abundant carbon in the mantle beneath Hawaii</em>. <em>Nature Geoscience</em>, <b>10</b>, 704-708.
</p>
<p>Bayarri, Maria J and Berger, James O and Paulo, Rui and Sacks, Jerry and Cafeo, John A and Cavendish, James and Lin, Chin-Hsu and Tu, Jian (2007) <em>A framework for validation of computer models</em>. <em>Technometrics</em>. <b>49</b>, 138â€“154.
</p>
<p>M. Gu (2016), <em>Robust Uncertainty Quantification and Scalable Computation for Computer Models with Massive Output</em>, Ph.D. thesis., Duke University.
</p>
<p>M. Gu and L. Wang (2017) <em>Scaled Gaussian Stochastic Process for Computer Model Calibration and Prediction</em>. arXiv preprint arXiv:1707.08215.
</p>
<p>M. Gu (2018) <em>Jointly Robust Prior for Gaussian Stochastic Process in Emulation, Calibration and Variable Selection
</em>. arXiv preprint arXiv:1804.09329.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#---------------------------------------------------------------------------------------------
# An example for calibrating and predicting mathematical models for data from multiple sources
#---------------------------------------------------------------------------------------------
    


library(RobustCalibration)


##reality
test_funct&lt;-function(x){
  sin(pi*x/2)+2*cos(pi*x/2)
}


##math model from two sources
math_model_source_1&lt;-function(x,theta){
  sin(theta*x) 
}

math_model_source_2&lt;-function(x,theta){
  cos(theta*x) 
}

input1=seq(0,2,2/(10-1))
input2=seq(0,3,3/(10-1))
##
output1=test_funct(input1)+rnorm(length(input1), sd=0.01)
output2=test_funct(input2)+rnorm(length(input2), sd=0.02)

plot(input1, output1)
plot(input2, output2)



design=list()
design[[1]]=as.matrix(input1)
design[[2]]=as.matrix(input2)

observations=list()
observations[[1]]=output1
observations[[2]]=output2


p_theta=1


theta_range=matrix(0,p_theta,2)
theta_range[1,]=c(0, 8)  
simul_type=c(1,1)

math_model=list()

math_model[[1]]=math_model_source_1
math_model[[2]]=math_model_source_2


## calibrating two mathematical models for these two sources
model_sgasp=rcalibration_MS(design=design, observations=observations, p_theta=1,
                            simul_type=simul_type,math_model=math_model,
                            theta_range=theta_range, 
                            S=10000,S_0=2000,
                            discrepancy_type=rep('S-GaSP',length(design)))

#plot(model_sgasp@post_theta[,1],type='l')
mean(model_sgasp@post_theta[,1])

testing_input1=seq(0,2,2/(25-1))

testing_input2=seq(0,3,3/(25-1))

testing_input=list()
testing_input[[1]]=as.matrix(testing_input1)
testing_input[[2]]=as.matrix(testing_input2)


predict_sgasp=predict_MS(model_sgasp, testing_input, math_model=math_model)
  

testing_output1=test_funct(testing_input1)
testing_output2=test_funct(testing_input2)


plot(predict_sgasp@mean[[1]])
lines(testing_output1)

plot(predict_sgasp@mean[[2]])
lines(testing_output2)



</code></pre>


</div>