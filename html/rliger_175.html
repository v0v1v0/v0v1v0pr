<div class="container">

<table style="width: 100%;"><tr>
<td>optimizeSubset</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform factorization for subset of data</h2>

<h3>Description</h3>

<p>Uses an efficient strategy for updating that takes advantage of
the information in the existing factorization.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optimizeSubset(
  object,
  clusterVar = NULL,
  useClusters = NULL,
  lambda = NULL,
  nIteration = 30,
  cellIdx = NULL,
  scaleDatasets = NULL,
  seed = 1,
  verbose = getOption("ligerVerbose"),
  cell.subset = cellIdx,
  cluster.subset = useClusters,
  max.iters = nIteration,
  datasets.scale = scaleDatasets,
  thresh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>liger object. Should have integrative
factorization (e.g. <code>runINMF</code>) performed in advance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterVar, useClusters</code></td>
<td>
<p>Together select the clusters to subset the
object conveniently. <code>clusterVar</code> is the name of variable in
<code>cellMeta(object)</code> and <code>useClusters</code> should be vector of names of
clusters in the variable. <code>clusterVar</code> is by default the default
cluster (See <code>runCluster</code>, or <code>defaultCluster</code> at
"Cell metadata access"). Users can otherwise select cells explicitly with
<code>cellIdx</code> for complex conditions. <code>useClusters</code> overrides
<code>cellIdx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Numeric regularization parameter. By default <code>NULL</code>, this
will use the lambda value used in the latest factorization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIteration</code></td>
<td>
<p>Maximum number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cellIdx</code></td>
<td>
<p>Valid index vector that applies to the whole object. See
<code>subsetLiger</code> for requirement. Default <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleDatasets</code></td>
<td>
<p>Names of datasets to re-scale after subsetting.
Default <code>NULL</code> does not re-scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>. Used
by <code>runINMF</code> factorization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> which is <code>TRUE</code> if users have not set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell.subset, cluster.subset, max.iters, datasets.scale</code></td>
<td>
<p>These arguments
are now replaced by others and will be removed in the future. Please see
usage for replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p><b>Deprecated</b>. New implementation of iNMF does not require
a threshold for convergence detection. Setting a large enough
<code>nIteration</code> will bring it to convergence.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Subset <code>object</code> with factorization matrices optimized, including
the <code>W</code> matrix in liger object, and <code>W</code> and <code>V</code>
matrices in each ligerDataset object in the <code>datasets</code>
slot. <code>scaleData</code> in the ligerDataset objects of
datasets specified by <code>scaleDatasets</code> will also be updated to reflect
the subset.
</p>


<h3>Examples</h3>

<pre><code class="language-R">pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    # Only running a few iterations for fast examples
    pbmc &lt;- runINMF(pbmc, k = 20, nIteration = 2)
    pbmc &lt;- optimizeSubset(pbmc, cellIdx = sort(sample(ncol(pbmc), 200)),
                           nIteration = 2)
}
</code></pre>


</div>