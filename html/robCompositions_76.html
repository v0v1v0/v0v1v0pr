<div class="container">

<table style="width: 100%;"><tr>
<td>imputeBDLs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>EM-based replacement of rounded zeros in compositional data</h2>

<h3>Description</h3>

<p>Parametric replacement of rounded zeros for compositional data using
classical and robust methods based on ilr coordinates with a special
choice of balances.
</p>


<h3>Usage</h3>

<pre><code class="language-R">imputeBDLs(
  x,
  maxit = 10,
  eps = 0.1,
  method = "subPLS",
  dl = rep(0.05, ncol(x)),
  variation = TRUE,
  nPred = NULL,
  nComp = "boot",
  bruteforce = FALSE,
  noisemethod = "residuals",
  noise = FALSE,
  R = 10,
  correction = "normal",
  verbose = FALSE,
  test = FALSE
)

adjustImputed(xImp, xOrig, wind)

checkData(x, dl)

## S3 method for class 'replaced'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data.frame or matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>convergency criteria</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>either "lm", "lmrob" or "pls"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dl</code></td>
<td>
<p>Detection limit for each variable. zero for variables with
variables that have no detection limit problems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variation, </code></td>
<td>
<p>if TRUE those predictors are chosen in each step, who's variation is lowest to the predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nPred, </code></td>
<td>
<p>if determined and variation equals TRUE, it fixes the number of predictors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nComp</code></td>
<td>
<p>if determined, it fixes the number of pls components. If
“boot”, the number of pls components are estimated using a
bootstraped cross validation approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bruteforce</code></td>
<td>
<p>sets imputed values above the detection limit to the
detection limit. Replacement above the detection limit are only exeptionally
occur due to numerical instabilities. The default is FALSE!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noisemethod</code></td>
<td>
<p>adding noise to imputed values. Experimental</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise</code></td>
<td>
<p>TRUE to activate noise (experimental)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>number of bootstrap samples for the determination of pls
components. Only important for method “pls”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>
<p>normal or density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>additional print output during calculations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>an internal test situation (this parameter will be deleted soon)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xImp</code></td>
<td>
<p>imputed data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xOrig</code></td>
<td>
<p>original data set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wind</code></td>
<td>
<p>index matrix of rounded zeros</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed through the print function</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Statistical analysis of compositional data including zeros runs into
problems, because log-ratios cannot be applied.  Usually, rounded zeros are
considerer as missing not at random missing values.
</p>
<p>The algorithm iteratively imputes parts with rounded zeros whereas in each
step (1) compositional data are expressed in pivot coordinates (2) tobit regression is
applied (3) the rounded zeros are replaced by the expected values (4) the
corresponding inverse ilr mapping is applied. After all parts are
imputed, the algorithm starts again until the imputations do not change.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x </code></td>
<td>
<p>imputed data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteria </code></td>
<td>
<p>change between last and
second last iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter </code></td>
<td>
<p>number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit
</code></td>
<td>
<p>maximum number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wind</code></td>
<td>
<p>index of zeros</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nComp</code></td>
<td>
<p>number of components for method pls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>chosen
method</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matthias Templ, method subPLS from Jiajia Chen
</p>


<h3>References</h3>

<p>Templ, M., Hron, K., Filzmoser, P., Gardlo, A. (2016). 
Imputation of rounded zeros for high-dimensional compositional data. 
<em>Chemometrics and Intelligent Laboratory Systems</em>, 155, 183-190.
</p>
<p>Chen, J., Zhang, X., Hron, K., Templ, M., Li, S. (2018). 
Regression imputation with Q-mode clustering for rounded zero replacement in high-dimensional compositional data. 
<em>Journal of Applied Statistics</em>, 45 (11), 2067-2080.
</p>


<h3>See Also</h3>

<p><code>imputeBDLs</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
p &lt;- 10
n &lt;- 50
k &lt;- 2
T &lt;- matrix(rnorm(n*k), ncol=k)
B &lt;- matrix(runif(p*k,-1,1),ncol=k)
X &lt;- T %*% t(B)
E &lt;-  matrix(rnorm(n*p, 0,0.1), ncol=p)
XE &lt;- X + E
data &lt;- data.frame(pivotCoordInv(XE))
col &lt;- ncol(data)
row &lt;- nrow(data)
DL &lt;- matrix(rep(0),ncol=col,nrow=1)
for(j in seq(1,col,2))
{DL[j] &lt;- quantile(data[,j],probs=0.06,na.rm=FALSE)}

for(j in 1:col){        
  data[data[,j]&lt;DL[j],j] &lt;- 0
}
## Not run: 
# under dontrun because of long exectution time
imp &lt;- imputeBDLs(data,dl=DL,maxit=10,eps=0.1,R=10,method="subPLS")
imp
imp &lt;- imputeBDLs(data,dl=DL,maxit=10,eps=0.1,R=10,method="pls", variation = FALSE)
imp
imp &lt;- imputeBDLs(data,dl=DL,maxit=10,eps=0.1,R=10,method="lm")
imp
imp &lt;- imputeBDLs(data,dl=DL,maxit=10,eps=0.1,R=10,method="lmrob")
imp

data(mcad)
## generate rounded zeros artificially:
x &lt;- mcad
x &lt;- x[1:25, 2:ncol(x)]
dl &lt;- apply(x, 2, quantile, 0.1)
for(i in seq(1, ncol(x), 2)){
  x[x[,i] &lt; dl[i], i] &lt;- 0
} 
ni &lt;- sum(x==0, na.rm=TRUE) 
ni/(ncol(x)*nrow(x)) * 100
dl[seq(2, ncol(x), 2)] &lt;- 0
replaced_lm &lt;- imputeBDLs(x, dl=dl, eps=1, method="lm",  
  verbose=FALSE, R=50, variation=TRUE)$x
replaced_lmrob &lt;- imputeBDLs(x, dl=dl, eps=1, method="lmrob",  
  verbose=FALSE, R=50, variation=TRUE)$x
replaced_plsfull &lt;- imputeBDLs(x, dl=dl, eps=1, 
  method="pls", verbose=FALSE, R=50, 
  variation=FALSE)$x 

## End(Not run)



</code></pre>


</div>