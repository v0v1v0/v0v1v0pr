<div class="container">

<table style="width: 100%;"><tr>
<td>ensemble</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Relation Ensembles</h2>

<h3>Description</h3>

<p>Creation and manipulation of relation ensembles.</p>


<h3>Usage</h3>

<pre><code class="language-R">relation_ensemble(..., list = NULL)
as.relation_ensemble(x)
is.relation_ensemble(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> objects representing relations, or coercible to such.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list</code></td>
<td>
<p>a list of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> objects as in <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>for coercion with <code>as.relation_ensemble()</code>, an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object
as in <code>...</code>; for testing with <code>is.relation_ensemble()</code>,
an arbitrary <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>relation_ensemble()</code> creates non-empty “relation
ensembles”, i.e., collections of relations <code class="reqn">R_i = (D, G_i)</code> with
the same domain <code class="reqn">D</code> and possibly different graphs <code class="reqn">G_i</code>.
</p>
<p>Such ensembles are implemented as suitably classed lists of relation
objects, making it possible to use <code>lapply()</code> for computations on
the individual relations in the ensemble.  Available methods for
relation ensembles include those for subscripting, <code>c()</code>,
<code>t()</code>, <code>rep()</code>, and <code>print()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data("Cetacea")
## Consider each variable an equivalence relation on the objects.
## Note that 2 variables (LACHRYMAL_AND_JUGAL_BONES and HEAD_BONES) have
## missing values, and hence are excluded.
ind &lt;- sapply(Cetacea, function(s) all(!is.na(s)))
relations &lt;- as.relation_ensemble(Cetacea[, ind])
## This gives a relation ensemble of length 14 (number of complete
## variables in the data set).
print(relations)
## Are there any duplicated relations?
any(duplicated(relations))
## Replicate and combine ...
thrice &lt;- c(rep(relations, 2), relations)
## Extract unique elements again:
all.equal(unique(thrice), relations)
## Note that unique() does not preserve attributes, and hence names.
## In case we want otherwise:
all.equal(thrice[!duplicated(thrice)], relations)
## Subscripting:
relation_dissimilarity(relations[1 : 2], relations["CLASS"])
## Which relation is "closest" to the classification?
d &lt;- relation_dissimilarity(relations)
sort(as.matrix(d)[, "CLASS"])[-1]
</code></pre>


</div>