<div class="container">

<table style="width: 100%;"><tr>
<td>numDivisorSieve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Apply Divisor Function to Every Element in a Range
</h2>

<h3>Description</h3>

<p>Sieve that generates the number of divisors for every number between <code>bound1</code> and <code>bound2</code> (if supplied) or all numbers up to <code>bound1</code>. This is equivalent to applying the divisor function (often written as <code class="reqn">\sigma(x)</code>) to every number in a given range.
</p>


<h3>Usage</h3>

<pre><code class="language-R">numDivisorSieve(bound1, bound2 = NULL, namedVector = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namedVector</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named vector is returned. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Simple and efficient sieve that calculates the number of divisors for every number in a given range. This function is very useful when you need to calculate the number of divisors for many numbers.
</p>
<p>This algorithm benefits greatly from the fast integer division library 'libdivide'. The following is from <a href="https://libdivide.com/">https://libdivide.com/</a>:
</p>
<ul><li>
<p>“<em>libdivide allows you to replace expensive integer divides with comparatively cheap multiplication and bitshifts. Compilers usually do this, but only when the divisor is known at compile time. libdivide allows you to take advantage of it at runtime. The result is that integer division can become faster - a lot faster.</em>”</p>
</li></ul>
<h3>Value</h3>

<p>Returns a named/unnamed integer vector
</p>


<h3>Note</h3>

<p>The maximum allowed value is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Divisor_function">Divisor function</a>
</p>
</li>
<li>
<p><a href="https://ridiculousfish.com/">ridiculousfish (author of libdivide)</a>
</p>
</li>
<li>
<p><a href="https://github.com/ridiculousfish/libdivide">github.com/ridiculousfish/libdivide</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a></p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Generate some random data
set.seed(8128)
mySamp &lt;- sample(10^6, 5*10^5)

## Generate number of divisors for
## every number less than a million
system.time(mySigmas &lt;- numDivisorSieve(10^6))

## Now use result in algorithm
for (s in mySamp) {
    sSig &lt;- mySigmas[s]
    ## Continue algorithm
}

## Generating number of divisors for every
## number in a range is no problem
system.time(sigmaRange &lt;- numDivisorSieve(10^13, 10^13 + 10^6))

## Returning a named vector
numDivisorSieve(10, 20, namedVector = TRUE)
numDivisorSieve(10, namedVector = TRUE)

## Using nThreads
system.time(numDivisorSieve(1e5, 2e5, nThreads = 2))
</code></pre>


</div>