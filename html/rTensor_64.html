<div class="container">

<table style="width: 100%;"><tr>
<td>Tensor-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>S4 Class for a Tensor</h2>

<h3>Description</h3>

<p>An S4 class for a tensor with arbitrary number of modes. The Tensor class extends the base 'array' class to include additional tensor manipulation (folding, unfolding, reshaping, subsetting) as well as a formal class definition that enables more explicit tensor algebra.
</p>


<h3>Details</h3>

<p>This can be seen as a wrapper class to the base <code>array</code> class. While it is possible to create an instance using <code>new</code>, it is also possible to do so by passing the data into <code>as.tensor</code>.
</p>
<p>Each slot of a Tensor instance can be obtained using <code>@</code>.
</p>
<p>The following methods are overloaded for the Tensor class: <code>dim-methods</code>, <code>head-methods</code>, <code>tail-methods</code>, <code>print-methods</code>, <code>show-methods</code>,  element-wise array operations, array subsetting (extract via ‘[’), array subset replacing (replace via ‘[&lt;-’), and <code>tperm-methods</code>, which is a wrapper around the base <code>aperm</code> method.
</p>
<p>To sum across any one mode of a tenor, use the function <code>modeSum-methods</code>. To compute the mean across any one mode, use <code>modeMean-methods</code>.
</p>
<p>You can always unfold any Tensor into a matrix, and the <code>unfold-methods</code>, <code>k_unfold-methods</code>, and <code>matvec-methods</code> methods are for that purpose. The output can be kept as a Tensor with 2 modes or a <code>matrix</code> object. The vectorization function is also provided as <code>vec</code>. See the attached vignette for a visualization of the different unfoldings.
</p>
<p>Conversion from <code>array</code>/<code>matrix</code> to Tensor is facilitated via <code>as.tensor</code>. To convert from a Tensor instance, simply invoke <code>@data</code>.
</p>
<p>The Frobenius norm of the Tensor is given by <code>fnorm-methods</code>, while the inner product between two Tensors (of equal modes) is given by <code>innerProd-methods</code>. You can also sum through any one mode to obtain the K-1 Tensor sum using <code>modeSum-methods</code>. <code>modeMean-methods</code> provides similar functionality to obtain the K-1 Tensor mean. These are primarily meant to be used internally but may be useful in doing statistics with Tensors.
</p>
<p>For Tensors with 3 modes, we also overloaded <code>t</code> (transpose) defined by Kilmer et.al (2013). See <code>t-methods</code>.
</p>
<p>To create a Tensor with i.i.d. random normal(0, 1) entries, see <code>rand_tensor</code>.

</p>


<h3>Slots</h3>


<dl>
<dt>num_modes</dt>
<dd>
<p>number of modes (integer)</p>
</dd>
<dt>modes</dt>
<dd>
<p>vector of modes (integer), aka sizes/extents/dimensions</p>
</dd>
<dt>data</dt>
<dd>
<p>actual data of the tensor, which can be 'array' or 'vector'</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>[</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>[&lt;-</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>matvec</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>dim</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>fnorm</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>head</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>initialize</dt>
<dd>
<p><code>signature(.Object = "Tensor")</code>: ... </p>
</dd>
<dt>innerProd</dt>
<dd>
<p><code>signature(tnsr1 = "Tensor", tnsr2 = "Tensor")</code>: ... </p>
</dd>
<dt>modeMean</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>modeSum</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "array", e2 = "Tensor")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "Tensor")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "Tensor", e2 = "array")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "Tensor", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Ops</dt>
<dd>
<p><code>signature(e1 = "Tensor", e2 = "Tensor")</code>: ... </p>
</dd>
<dt>print</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>k_unfold</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>show</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>t</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>tail</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>unfold</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ... </p>
</dd>
<dt>tperm</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ...</p>
</dd>
<dt>image</dt>
<dd>
<p><code>signature(tnsr = "Tensor")</code>: ...</p>
</dd>
</dl>
<h3>Note</h3>

<p>All of the decompositions and regression models in this package require a Tensor input.
</p>


<h3>Author(s)</h3>

<p>James Li <a href="mailto:jamesyili@gmail.com">jamesyili@gmail.com</a>
</p>


<h3>References</h3>

<p>James Li, Jacob Bien, Martin T. Wells (2018). rTensor: An R Package for Multidimensional Array (Tensor) Unfolding, Multiplication, and Decomposition. Journal of Statistical Software, 87(10), 1-31. URL http://www.jstatsoft.org/v087/i10/.
</p>


<h3>See Also</h3>

<p><code>as.tensor</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">tnsr &lt;- rand_tensor()
class(tnsr)
tnsr
print(tnsr)
dim(tnsr)
tnsr@num_modes
tnsr@data
</code></pre>


</div>