<div class="container">

<table style="width: 100%;"><tr>
<td>secondDeriv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Numeric second derivatives</h2>

<h3>Description</h3>

<p>Computes numeric second derivatives (hessian) of an 
arbitrary multidimensional function at a particular location.
</p>


<h3>Usage</h3>

<pre><code class="language-R">secondDeriv(x, FUN, eps = 1e-08, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The location (a vector) where the second derivatives 
of <code>FUN</code> are desired.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>An R function for which the second derivatives are 
sought.  
This must be a function of the form FUN &lt;- function(x, ...)...
where x is a vector of variable parameters to FUN at which 
to evaluate the 2nd derivative, 
and ... are additional parameters needed to evaluate the function.
FUN must return a single value (scalar), the height of the 
surface above <code>x</code>, i.e., FUN evaluated at x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>A vector of small relative 
distances to add to <code>x</code> 
when evaluating derivatives.   This determines the '<code class="reqn">dx</code>' of 
the numerical derivatives.  That is, the function 
is evaluated at <code>x</code>, <code>x+dx</code>, and <code>x+2*dx</code>, where 
<code class="reqn">dx</code> = <code>x*eps^0.25</code>, in order to compute the second 
derivative. 
<code>eps</code> defaults to 1e-8 for all 
dimensions which equates to setting <code class="reqn">dx</code> to one percent
of each <code>x</code> (i.e., by default the function is 
evaluate at <code>x</code>, <code>1.01*x</code> and <code>1.02*x</code> 
to compute the second derivative).  
</p>
<p>One might want to change <code>eps</code> if the scale 
of dimensions in <code>x</code> varies wildly (e.g., kilometers and millimeters), 
or if changes between 
<code>FUN(x)</code> and <code>FUN(x*1.01)</code> are below machine precision.
If length of <code>eps</code> is less than length of <code>x</code>,
<code>eps</code> is replicated to the length of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Any arguments passed to <code>FUN</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses the "5-point" numeric second derivative 
method advocated in numerous numerical recipe texts.  During computation
of the 2nd derivative, FUN must be 
capable of being evaluated at numerous locations within a hyper-ellipsoid 
with cardinal radii 2*<code>x</code>*(<code>eps</code>)^0.25 = 0.02*<code>x</code> at the 
default value of <code>eps</code>.   
</p>
<p>A handy way to use this function is to call an optimization routine 
like <code>nlminb</code> with FUN, then call this function with the 
optimized values (solution) and FUN.  This will yield the hessian 
at the solution and this is can produce a better 
estimate of the variance-covariance
matrix than using the hessian returned by some optimization routines. 
Some optimization routines return the hessian evaluated 
at the next-to-last step of optimization. 
</p>
<p>An estimate of the variance-covariance matrix, which is used in 
<code>Rdistance</code>, is <code>solve(hessian)</code> where <code>hessian</code> is
<code>secondDeriv(&lt;parameter estimates&gt;, &lt;likelihood&gt;)</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
func &lt;- function(x){-x*x} # second derivative should be -2
secondDeriv(0,func)
secondDeriv(3,func)

func &lt;- function(x){3 + 5*x^2 + 2*x^3} # second derivative should be 10+12x
secondDeriv(0,func)
secondDeriv(2,func)

func &lt;- function(x){x[1]^2 + 5*x[2]^2} # should be rbind(c(2,0),c(0,10))
secondDeriv(c(1,1),func)

</code></pre>


</div>