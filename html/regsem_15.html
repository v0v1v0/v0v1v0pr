<div class="container">

<table style="width: 100%;"><tr>
<td>regsem</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Regularized Structural Equation Modeling. Tests a single penalty. For
testing multiple penalties, see cv_regsem().</h2>

<h3>Description</h3>

<p>Regularized Structural Equation Modeling. Tests a single penalty. For
testing multiple penalties, see cv_regsem().
</p>


<h3>Usage</h3>

<pre><code class="language-R">regsem(
  model,
  lambda = 0,
  alpha = 0.5,
  gamma = 3.7,
  type = "lasso",
  dual_pen = NULL,
  random.alpha = 0.5,
  data = NULL,
  optMethod = "rsolnp",
  estimator = "ML",
  gradFun = "none",
  hessFun = "none",
  prerun = FALSE,
  parallel = "no",
  Start = "lavaan",
  subOpt = "nlminb",
  longMod = FALSE,
  pars_pen = "regressions",
  diff_par = NULL,
  LB = -Inf,
  UB = Inf,
  par.lim = c(-Inf, Inf),
  block = TRUE,
  full = TRUE,
  calc = "normal",
  max.iter = 500,
  tol = 1e-05,
  round = 3,
  solver = FALSE,
  quasi = FALSE,
  solver.maxit = 5,
  alpha.inc = FALSE,
  line.search = FALSE,
  step = 0.1,
  momentum = FALSE,
  step.ratio = FALSE,
  nlminb.control = list(),
  missing = "listwise"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Lavaan output object. This is a model that was previously
run with any of the lavaan main functions: cfa(), lavaan(), sem(),
or growth(). It also can be from the efaUnrotate() function from
the semTools package. Currently, the parts of the model which cannot
be handled in regsem is the use of multiple group models, missing
other than listwise, thresholds from categorical variable models,
the use of additional estimators other than
ML, most notably WLSMV for categorical variables. Note: the model
does not have to actually run (use do.fit=FALSE), converge etc...
regsem() uses the lavaan object as more of a parser and to get
sample covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Penalty value. Note: higher values will result in additional
convergence issues. If using values &gt; 0.1, it is recommended to use
mutli_optim() instead. See <code>multi_optim</code> for more detail.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Mixture for elastic net. 1 = ridge, 0 = lasso</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Additional penalty for MCP and SCAD</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Penalty type. Options include "none", "lasso",
"enet" for the elastic net,
"alasso" for the adaptive lasso
and "diff_lasso". If ridge penalties are desired, use type="enet" and
alpha=1. diff_lasso penalizes the discrepency between
parameter estimates and some pre-specified values. The values
to take the deviation from are specified in diff_par. Two methods for
sparser results than lasso are the smooth clipped absolute deviation,
"scad", and the minimum concave penalty, "mcp". Last option is "rlasso"
which is the randomised lasso to be used for stability selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dual_pen</code></td>
<td>
<p>Two penalties to be used for type="dual", first is lasso, second ridge</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.alpha</code></td>
<td>
<p>Alpha parameter for randomised lasso. Has to be between
0 and 1, with a default of 0.5. Note this is only used for
"rlasso", which pairs with stability selection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional dataframe. Only required for missing="fiml" which
is not currently working.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optMethod</code></td>
<td>
<p>Solver to use. Two main options for use: rsoolnp and coord_desc.
Although slightly slower, rsolnp works much better for complex models.
coord_desc uses gradient descent with soft thresholding for the type of
of penalty. Rsolnp is a nonlinear solver that doesn't rely on gradient
information. There is a similar type of solver also available for use,
slsqp from the nloptr package. coord_desc can also be used with hessian
information, either through the use of quasi=TRUE, or specifying a hess_fun.
However, this option is not recommended at this time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>Whether to use maximum likelihood (ML) or unweighted least squares
(ULS) as a base estimator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradFun</code></td>
<td>
<p>Gradient function to use. Recommended to use "ram",
which refers to the method specified in von Oertzen &amp; Brick (2014).
Only for use with optMethod="coord_desc".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessFun</code></td>
<td>
<p>Hessian function to use. Recommended to use "ram",
which refers to the method specified in von Oertzen &amp; Brick (2014).
This is currently not recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prerun</code></td>
<td>
<p>Logical. Use rsolnp to first optimize before passing to
gradient descent? Only for use with coord_desc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Logical. Whether to parallelize the processes?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Start</code></td>
<td>
<p>type of starting values to use. Only recommended to use
"default". This sets factor loadings and variances to 0.5.
Start = "lavaan" uses the parameter estimates from the lavaan
model object. This is not recommended as it can increase the
chances in getting stuck at the previous parameter estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subOpt</code></td>
<td>
<p>Type of optimization to use in the optimx package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>longMod</code></td>
<td>
<p>If TRUE, the model is using longitudinal data? This changes
the sample covariance used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pars_pen</code></td>
<td>
<p>Parameter indicators to penalize. There are multiple ways to specify.
The default is to penalize all regression parameters ("regressions"). Additionally,
one can specify all loadings ("loadings"), or both c("regressions","loadings").
Next, parameter labels can be assigned in the lavaan syntax and passed to pars_pen.
See the example.Finally, one can take the parameter numbers from the A or S matrices and pass these
directly. See extractMatrices(lav.object)$A.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diff_par</code></td>
<td>
<p>Parameter values to deviate from. Only used when
type="diff_lasso".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>LB</code></td>
<td>
<p>lower bound vector. Note: This is very important to specify
when using regularization. It greatly increases the chances of
converging.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>UB</code></td>
<td>
<p>Upper bound vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.lim</code></td>
<td>
<p>Vector of minimum and maximum parameter estimates. Used to
stop optimization and move to new starting values if violated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block</code></td>
<td>
<p>Whether to use block coordinate descent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>Whether to do full gradient descent or block</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calc</code></td>
<td>
<p>Type of calc function to use with means or not. Not recommended
for use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>Number of iterations for coordinate descent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance for coordinate descent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round</code></td>
<td>
<p>Number of digits to round results to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>Whether to use solver for coord_desc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quasi</code></td>
<td>
<p>Whether to use quasi-Newton</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.maxit</code></td>
<td>
<p>Max iterations for solver in coord_desc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.inc</code></td>
<td>
<p>Whether alpha should increase for coord_desc</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line.search</code></td>
<td>
<p>Use line search for optimization. Default is no, use fixed step size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>Step size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momentum</code></td>
<td>
<p>Momentum for step sizes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.ratio</code></td>
<td>
<p>Ratio of step size between A and S. Logical</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.control</code></td>
<td>
<p>list of control values to pass to nlminb</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>
<p>How to handle missing data. Current options are "listwise"
and "fiml". "fiml" is not currently working well.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>out List of return values from optimization program
</p>
<p>convergence Convergence status. 0 = converged, 1 or 99 means the model did not converge.
</p>
<p>par.ret Final parameter estimates
</p>
<p>Imp_Cov Final implied covariance matrix
</p>
<p>grad Final gradient.
</p>
<p>KKT1 Were final gradient values close enough to 0.
</p>
<p>KKT2 Was the final Hessian positive definite.
</p>
<p>df Final degrees of freedom. Note that df changes with lasso
penalties.
</p>
<p>npar Final number of free parameters. Note that this can change
with lasso penalties.
</p>
<p>SampCov Sample covariance matrix.
</p>
<p>fit Final F_ml fit. Note this is the final parameter estimates
evaluated with the F_ml fit function.
</p>
<p>coefficients Final parameter estimates
</p>
<p>nvar Number of variables.
</p>
<p>N sample size.
</p>
<p>nfac Number of factors
</p>
<p>baseline.chisq Baseline chi-square.
</p>
<p>baseline.df Baseline degrees of freedom.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Note that this is not currently recommended. Use cv_regsem() instead
library(lavaan)
# put variables on same scale for regsem
HS &lt;- data.frame(scale(HolzingerSwineford1939[,7:15]))
mod &lt;- '
f =~ 1*x1 + l1*x2 + l2*x3 + l3*x4 + l4*x5 + l5*x6 + l6*x7 + l7*x8 + l8*x9
'
# Recommended to specify meanstructure in lavaan
outt = cfa(mod, HS, meanstructure=TRUE)

fit1 &lt;- regsem(outt, lambda=0.05, type="lasso",
  pars_pen=c("l1", "l2", "l6", "l7", "l8"))
#equivalent to pars_pen=c(1:2, 6:8)
#summary(fit1)
</code></pre>


</div>