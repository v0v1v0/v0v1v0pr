<div class="container">

<table style="width: 100%;"><tr>
<td>ata</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Automated Test Assembly (ATA)</h2>

<h3>Description</h3>

<p><code>ata</code> creates a basic ATA model
</p>
<p><code>ata_relative_objective</code> adds a relative objective to the model
</p>
<p><code>ata_absolute_objective</code> adds an absolute objective to the model
</p>
<p><code>ata_constraint</code> adds a constraint to the model
</p>
<p><code>ata_item_use</code> limits the minimum and maximum usage for items
</p>
<p><code>ata_item_enemy</code> adds an enemy-item constraint to the model
</p>
<p><code>ata_item_fix</code> forces an item to be selected or not selected
</p>
<p><code>ata_solve</code> solves the MIP model
</p>


<h3>Usage</h3>

<pre><code class="language-R">ata(pool, n_forms = 1, test_len = NULL, max_use = NULL, ...)

ata_relative_objective(x, coef, mode = c("max", "min"), tol = NULL,
  negative = FALSE, forms = NULL, collapse = FALSE,
  internal_index = FALSE)

ata_absolute_objective(x, coef, target, equal_tol = FALSE,
  tol_up = NULL, tol_down = NULL, forms = NULL, collapse = FALSE,
  internal_index = FALSE)

ata_constraint(x, coef, min = NA, max = NA, level = NULL,
  forms = NULL, collapse = FALSE, internal_index = FALSE)

ata_item_use(x, min = NA, max = NA, items = NULL)

ata_item_enemy(x, items)

ata_item_fix(x, items, min = NA, max = NA, forms)

ata_solve(x, solver = c("lpsolve", "glpk"), return_format = c("model",
  "form", "simple"), silent = FALSE, time_limit = 10,
  message = FALSE, ...)

## S3 method for class 'ata'
print(x, ...)

## S3 method for class 'ata'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pool</code></td>
<td>
<p>the item pool(s), a list of '3pl', 'gpcm', and 'grm' items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_forms</code></td>
<td>
<p>the number of forms to be assembled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test_len</code></td>
<td>
<p>test length of each form</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_use</code></td>
<td>
<p>maximum use of each item</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>options, e.g. group, common_items, overlap_items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an ATA object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>the coefficients of the objective function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>optimization direction: 'max' for maximization and 'min' for minimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>the tolerance paraemter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negative</code></td>
<td>
<p><code>TRUE</code> when the objective function is expected to be negative</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forms</code></td>
<td>
<p>forms where objectives are added. <code>NULL</code> for all forms</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>
<p><code>TRUE</code> to collapse into one objective function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>internal_index</code></td>
<td>
<p><code>TRUE</code> to use internal form indices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>target</code></td>
<td>
<p>the target values of the objective function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>equal_tol</code></td>
<td>
<p><code>TRUE</code> to force upward and downward tolerance to be equal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_up</code></td>
<td>
<p>the range of upward tolerance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_down</code></td>
<td>
<p>the range of downward tolerance</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min</code></td>
<td>
<p>the lower bound of the constraint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max</code></td>
<td>
<p>the upper bound of the constraint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>the level of a categorical variable to be constrained</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>items</code></td>
<td>
<p>a vector of item indices, <code>NULL</code> for all items</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>use 'lpsolve' for lp_solve 5.5 or 'glpk' for GLPK</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_format</code></td>
<td>
<p>the format of the results: use <code>'form'</code> to organize results in a list of forms,
<code>'model'</code> to organize results in a list of models, use <code>'simple'</code> to organize results in
data.frame after removing item paraemters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p><code>TRUE</code> to mute solution information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_limit</code></td>
<td>
<p>the time limit in seconds passed along to solvers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p><code>TRUE</code> to print messages from solvers</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The ATA model stores the definitions of a MIP model. When <code>ata_solve</code>
is called, a real MIP object is created from the definitions.
</p>
<p><code>ata_obj_relative</code>:
when mode='max', maximize (y-tol), subject to y &lt;= sum(x) &lt;= y+tol;
when mode='min', minimize (y+tol), subject to y-tol &lt;= sum(x) &lt;= y.
When <code>negative</code> is <code>TRUE</code>, y &lt; 0, tol &gt; 0.
<code>coef</code> can be a numeric vector that has the same length with the pool,
or a variable name in the pool, or a numeric vector of theta points.
When <code>tol</code> is <code>NULL</code>, it is optimized; when it's <code>FALSE</code>, ignored;
when it's a number, fixed; when it's a range, constrained with lower and upper bounds.
</p>
<p><code>ata_obj_absolute</code> minimizes y0+y1 subject to t-y0 &lt;= sum(x) &lt;= t+y1.
</p>
<p>When <code>level</code> is <code>NA</code>, it is assumed that the constraint is on
a quantitative item property; otherwise, a categorical item property.
<code>coef</code> can be a variable name, a constant, or a numeric vector that has
the same size as the pool.
</p>
<p><code>ata_solve</code> takes control options in <code>...</code>.
For lpsolve, see <code>lpSolveAPI::lp.control.options</code>.
For glpk, see <code>glpkAPI::glpkConstants</code><br>
Once the model is solved, additional data are added to the model.
<code>status</code> shows the status of the solution, <code>optimum</code>
the optimal value of the objective fucntion found in the solution,
<code>obj_vars</code> the values of two critical variables in the objective
function, <code>result</code> the assembly results in a binary matrix, and
<code>items</code> the assembled items
</p>


<h3>Value</h3>

<p><code>ata</code> returns a <code>ata</code> object
</p>
<p><code>ata_solve</code> returns a solved <code>ata</code> object
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate a pool of 100 items
library(Rirt)
n_items &lt;- 100
pool &lt;- with(model_3pl_gendata(1, n_items), data.frame(id=1:n_items, a=a, b=b, c=c))
pool$content &lt;- sample(1:3, n_items, replace=TRUE)
pool$time &lt;- round(rlnorm(n_items, log(60), .2))
pool$group &lt;- sort(sample(1:round(n_items/3), n_items, replace=TRUE))
pool &lt;- list('3pl'=pool)

## ex. 1: four 10-item forms, maximize b parameter
x &lt;- ata(pool, 4, test_len=10, max_use=1)
x &lt;- ata_relative_objective(x, "b", "max")
x &lt;- ata_solve(x, time_limit=2)
with(x$items$'3pl', aggregate(b, by=list(form=form), mean))
with(x$items$'3pl', table(form))


## ex. 2: four 10-item forms, minimize b parameter
x &lt;- ata(pool, 4, test_len=10, max_use=1)
x &lt;- ata_relative_objective(x, "b", "min", negative=TRUE)
x &lt;- ata_solve(x, time_limit=5)
with(x$items$'3pl', aggregate(b, by=list(form=form), mean))
with(x$items$'3pl', table(form))

## ex. 3: two 10-item forms, mean(b)=0, sd(b)=1
## content = (3, 3, 4), avg. time = 55--65 seconds
constr &lt;- data.frame(name='content',level=1:3, min=c(3,3,4), max=c(3,3,4), stringsAsFactors=FALSE)
constr &lt;- rbind(constr, c('time', NA, 55*10, 65*10))
x &lt;- ata(pool, 2, test_len=10, max_use=1)
x &lt;- ata_absolute_objective(x, pool$'3pl'$b, target=0*10)
x &lt;- ata_absolute_objective(x, (pool$'3pl'$b-0)^2, target=1*10)
for(i in 1:nrow(constr))
  x &lt;- with(constr, ata_constraint(x, name[i], min[i], max[i], level=level[i]))
x &lt;- ata_solve(x)
with(x$items$'3pl', aggregate(b, by=list(form=form), mean))
with(x$items$'3pl', aggregate(b, by=list(form=form), sd))
with(x$items$'3pl', aggregate(time, by=list(form=form), mean))
with(x$items$'3pl', aggregate(content, by=list(form=form), function(x) freq(x, 1:3)$freq))

## ex. 4: two 10-item forms, max TIF over (-1, 1), consider item sets
x &lt;- ata(pool, 2, test_len=10, max_use=1, group="group")
x &lt;- ata_relative_objective(x, seq(-1, 1, .5), 'max')
x &lt;- ata_solve(x, time_limit=5)
plot(x)

</code></pre>


</div>