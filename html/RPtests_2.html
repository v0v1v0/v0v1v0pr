<div class="container">

<table style="width: 100%;"><tr>
<td>RPtest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Goodness of fit tests for potentially high-dimensional linear models</h2>

<h3>Description</h3>

<p>Can test for the significance of (potentially large) groups of predictors and
the presence of nonlinearity or heteroscedasticity in the context of both low
and high-dimensional linear models. Outputs a p-value. Also allows for the
calibration of arbitrary goodness of fit tests via specification of
<code>RPfunction</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RPtest(
  x,
  y,
  resid_type = c("Lasso", "OLS"),
  test = c("nonlin", "group", "hetero"),
  x_alt,
  RPfunction = NULL,
  B = 49L,
  rand_gen = rnorm,
  noise_matrix = NULL,
  mc.cores = 1L,
  nfolds = 5L,
  nperms = 2L,
  beta_est = NULL,
  resid_only = FALSE,
  output_all = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input matrix with <code>nobs</code> rows, each an observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Response vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid_type</code></td>
<td>
<p>Type of residuals used for the test (see details below).
Use <code>Lasso</code> when the null model is high-dimensional; otherwise use
<code>OLS</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>Type of departure from the linear model to test for (see details
below). Ignored if <code>RPfunction</code> is given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_alt</code></td>
<td>
<p>If <code>test</code> is <code>group</code>, this gives the set of variables
whose significance we wish to ascertain, after controlling for those in
<code>x</code>. If <code>RPfunction</code> is given, it is the input matrix passed to
the function <code>RPfunction</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>RPfunction</code></td>
<td>
<p>A residual prediction (RP) function that must permit
calling as <code>RPfunction(x_alt, resid)</code> where <code>resid</code> is a numeric
vector with <code>nobs</code> components. The output must be either a single
number or a numeric vector (in the latter case <code>RPfunction</code> would
encode a number of RP functions).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>The number of bootstrap samples to use - note the p-value produced
will always be at least 1/B.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rand_gen</code></td>
<td>
<p>A function to generate the simulated errors up to an unknown
scale factor. It must permit calling as <code>rand_gen(nobs*B)</code>. Determines
the form of errors in the null model. The default <code>rnorm</code> equates to a
null of a (sparse) Gaussian linear model. Setting <code>rand_gen=NULL</code>
resamples residuals to generate simulated errors and approximates a null of
i.i.d. errors with unknown distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_matrix</code></td>
<td>
<p>An optional matrix whose columns are the simulated errors to use.
Note that <code>B</code> and <code>rand_gen</code> will be ignored if this is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>
<p>The number of cores to use. Will always be 1 in Windows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>Number of folds to use when performing cross-validation to
obtain <code>beta_est</code>, the initial estimate of the vector of regression
coefficients, via Lasso estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nperms</code></td>
<td>
<p>Number of permutations of the data for which <code>nfolds</code>
cross-validation is to be performed. Thus in total prediction errors on
<code>nfolds*nperms</code> folds are averaged over.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_est</code></td>
<td>
<p>An optional user-supplied estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid_only</code></td>
<td>
<p>If <code>TRUE</code> only outputs the residuals without applying
an RP function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_all</code></td>
<td>
<p>In addition to the p-value, gives further output (see Value
below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether to print addition information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function works by first computing residuals from a regression of
y on x. Next <code>B</code> sets of errors generated through <code>rand_gen</code> are
added to a signal derived from <code>beta_est</code> and aritificial residuals
are computed. The option <code>resid_only=TRUE</code> then outputs these
residuals along with the original residuals, scaled to have l_2-norm
squared equal to <code>nobs</code>. The residuals in question are OLS residuals
when <code>resid_type=OLS</code> (case a - for use when the null hypothesis is
low-dimensional so the number of columns of <code>x</code> is smaller than
<code>nobs-1</code>), and square-root / scaled Lasso residuals otherwise (case
b). The options for <code>test</code> then apply different functions to the
residuals as described below.
</p>

<dl>
<dt><code>nonlin</code></dt>
<dd>
<p>In case (a), the test statistic is the RSS (residual
sum of squares) of a <code>randomForest</code> fit from
regressing the residuals on to <code>x</code>; case (b) is similar but the OOB
error is used and the regression is carried out on the equicorrelation set
rather than all of <code>x</code>.</p>
</dd>
<dt><code>group</code></dt>
<dd>
<p><code>x_alt</code> is first residualised with
respect to <code>x</code> by (a) OLS or (b) <code>sparse_proj</code>. Then the
RSS from Lasso fits from regressions of the residuals on to <code>x_alt</code>
are used.</p>
</dd>
<dt><code>hetero</code></dt>
<dd>
<p>Uses the RSS from Lasso fits from
regressions of the squared residuals to the equicorrelation set (b) or all
of <code>x</code> (a).</p>
</dd>
</dl>
<h3>Value</h3>

<p>When <code>resid_only=FALSE</code> and <code>output_all=FALSE</code>, the output
is a single p-value. Otherwise, a list with some of the following
components is returned (<code>resid_only=FALSE</code> causes the last two
components to be omitted):
</p>

<dl>
<dt><code>p-value</code></dt>
<dd>
<p>p-value</p>
</dd>
<dt><code>beta_est</code></dt>
<dd>
<p>estimated vector of regression coefficients
<code>beta_est</code></p>
</dd>
<dt><code>sigma_est</code></dt>
<dd>
<p>set to 1 when <code>resid_type=OLS</code>;
otherwise the normalised root-RSS derived from
<code>beta_est</code> used in generated the simulated errors</p>
</dd>
<dt><code>resid</code></dt>
<dd>
<p>scaled residuals</p>
</dd>
<dt><code>resid_sim</code></dt>
<dd>
<p>simulated scaled residuals</p>
</dd>
<dt><code>test</code></dt>
<dd>
<p>the test statistic(s) - may be a vector if multiple RP
functions are being used such as when <code>test=group</code></p>
</dd>
<dt><code>test_sim</code></dt>
<dd>
<p>a list of simulated test statistics</p>
</dd>
</dl>
<h3>References</h3>

<p>Shah, R. D., Buhlmann, P. (2017) <em>Goodness-of-fit tests for
high dimensional linear models</em> <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12234">https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12234</a>
</p>


<h3>See Also</h3>

<p><code>RPtest_single</code> and <code>sqrt_lasso</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Testing for nonlinearity
set.seed(1)
x &lt;- scale(matrix(runif(100*200), 100, 200))
y &lt;- x[, 1] + x[, 1]^4 + rnorm(nrow(x))
out &lt;- RPtest(x, y, test="nonlin", B=9L, nperms=2, resid_type = "Lasso")

# Testing significance of a group
y &lt;- x[, 1:5] %*% rep(1, 5) + x[, 151] + rnorm(nrow(x))
(out &lt;- RPtest(x[, 1:150], y, test="group", x_alt = x[, 151:200], B=9L, nperms=1))

# Testing for heteroscedasticity
x &lt;- scale(matrix(runif(250*100), 250, 100))
hetero_sig &lt;- x[, 1] + x[, 2]
var_vec &lt;- hetero_sig - min(hetero_sig) + 0.01
var_vec &lt;- var_vec / mean(var_vec)
sd_vec &lt;- sqrt(var_vec)
y &lt;- x[, 1:5] %*% rep(1, 5) + sd_vec*rnorm(nrow(x))
(out &lt;- RPtest(x, y, test="hetero", B=9L, nperms=1))
</code></pre>


</div>