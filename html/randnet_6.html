<div class="container">

<table style="width: 100%;"><tr>
<td>ECV.block</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
selecting block models by ECV
</h2>

<h3>Description</h3>

<p>Model selection by ECV for SBM and DCSBM. It can be used to select
between the two models or given on model (either SBM or DCSBM) and
select K.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ECV.block(A, max.K, cv = NULL, B = 3, holdout.p = 0.1, tau = 0, dc.est = 2, kappa = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>

<p>adjacency matrix
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.K</code></td>
<td>

<p>largest possible K for number of communities
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>

<p>cross validation fold. The default value is NULL. We recommend to use
the argument B instead, doing indpendent sampling.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>

<p>number of replications
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>holdout.p</code></td>
<td>

<p>testing set proportion
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>

<p>constant for numerical stability only. Not useful for current version.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dc.est</code></td>
<td>

<p>estimation method for DCSBM. By defaulty (dc.est=2), the maximum
likelihood is used. If dc.est=1, the method used by Chen and Lei (2016)
is used, which is less stable according to our observation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>

<p>constant for numerical stability only. Not useful for current version.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current version is based on a simple matrix completion procedure,
as described in the paper. The performance can be improved by better
matrix completion method that will be implemented in next
version. Moreover, the current implementation is better in
computational time but less efficient in memory. Another memory
efficient implementation will be added in next version.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>impute.err </code></td>
<td>
<p>average validaiton imputation error</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l2 </code></td>
<td>
<p>average validation L_2 loss under SBM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev </code></td>
<td>
<p>average validation binomial deviance loss under SBM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auc </code></td>
<td>
<p>average validation AUC</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dc.l2</code></td>
<td>
<p>average validation L_2 loss under DCSBM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dc.dev</code></td>
<td>
<p>average validation binomial deviance loss under DCSBM</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sse</code></td>
<td>
<p>average validation SSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l2.model </code></td>
<td>
<p>selected model by L_2 loss</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dev.model </code></td>
<td>
<p>selected model by binomial deviance loss</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l2.mat, dc.l2.mat,... </code></td>
<td>
<p>cross-validation loss matrix for B replications</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Tianxi Li, Elizaveta Levina, Ji Zhu<br>
Maintainer: Tianxi Li  <a href="mailto:tianxili@virginia.edu">tianxili@virginia.edu</a>
</p>


<h3>References</h3>

<p>T. Li, E. Levina, and J. Zhu. Network cross-validation by edge sampling. Biometrika, 107(2), pp.257-276, 2020.
</p>


<h3>See Also</h3>

<p><code>NCV.select</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
dt &lt;- BlockModel.Gen(30,300,K=3,beta=0.2,rho=0.9,simple=FALSE,power=TRUE)


A &lt;- dt$A

ecv &lt;- ECV.block(A,6,B=3)

ecv$l2.model
ecv$dev.model


which.min(ecv$l2)
which.min(ecv$dev)

which.min(ecv$dc.l2)
which.min(ecv$dc.dev)

which.max(ecv$auc)
which.min(ecv$sse)

</code></pre>


</div>