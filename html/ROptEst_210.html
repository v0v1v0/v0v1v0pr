<div class="container">

<table style="width: 100%;"><tr>
<td>leastFavorableRadius</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Function for the Computation of Least Favorable Radii</h2>

<h3>Description</h3>

<p>Generic function for the computation of least favorable radii.
</p>


<h3>Usage</h3>

<pre><code class="language-R">leastFavorableRadius(L2Fam, neighbor, risk, ...)

## S4 method for signature 'L2ParamFamily,UncondNeighborhood,asGRisk'
leastFavorableRadius(
          L2Fam, neighbor, risk, rho, upRad = 1, 
            z.start = NULL, A.start = NULL, upper = 100,
            OptOrIter = "iterate", maxiter = 100,
            tol = .Machine$double.eps^0.4, warn = FALSE, verbose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L2Fam</code></td>
<td>
<p> L2-differentiable family of probability measures. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upRad</code></td>
<td>
<p> the upper end point of the radius interval to be searched. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p> The considered radius interval is: <code class="reqn">[r \rho, r/\rho]</code>
with <code class="reqn">\rho\in(0,1)</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> the maximum number of iterations </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p> logical: print warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to be passed to <code>E</code> </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The least favorable radius and the corresponding inefficiency 
are computed.
</p>


<h3>Methods</h3>


<dl>
<dt>L2Fam = "L2ParamFamily", neighbor = "UncondNeighborhood", 
risk = "asGRisk"</dt>
<dd>
<p> computation of the least favorable radius. </p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of not Knowing
the Radius. Statistical Methods and Applications, <em>17</em>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2001). The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>.
</p>
<p>P. Ruckdeschel (2005). Optimally One-Sided Bounded Influence Curves.
Mathematical Methods of Statistics <em>14</em>(1), 105-131.
</p>
<p>P. Ruckdeschel and H. Rieder (2004). Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <em>22</em>, 201-223.
<a href="https://doi.org/10.1524/stnd.22.3.201.57067">doi:10.1524/stnd.22.3.201.57067</a>
</p>


<h3>See Also</h3>

<p><code>radiusMinimaxIC</code></p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- NormLocationFamily(mean=0, sd=1) 
leastFavorableRadius(L2Fam=N, neighbor=ContNeighborhood(),
                     risk=asMSE(), rho=0.5)
</code></pre>


</div>