<div class="container">

<table style="width: 100%;"><tr>
<td>dccfit-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>function: DCC-GARCH Fit</h2>

<h3>Description</h3>

<p>Method for creating a DCC-GARCH fit object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dccfit(spec, data, out.sample = 0, solver = "solnp", solver.control = list(), 
fit.control = list(eval.se = TRUE, stationarity = TRUE, scale = FALSE), 
cluster = NULL, fit = NULL, VAR.fit = NULL, realizedVol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p> A <code>DCCspec</code> object created by calling 
<code>dccspec</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p> A multivariate data object of class xts or one which can be 
coerced to such.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.sample</code></td>
<td>
<p> A positive integer indicating the number of periods 
before the last to keep for out of sample forecasting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p> Either “nlminb”, “solnp”, “gosolnp” or
“lbfgs”. It can also optionally be a vector of length 2 with the first
solver being used for the first stage univariate GARCH estimation (in which 
case the option of “hybrid” is also available).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine. 
The ‘eval.se’ option determines whether standard errors are calculated 
(see details below). The ‘stationarity’ option is for the univariate 
stage GARCH fitting routine, whilst for the second stage DCC this is 
imposed by design. The ‘scale’ option is also for the first stage 
univariate GARCH fitting routine.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p> (optional) A previously estimated univariate 
<code>uGARCHmultifit</code> object (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VAR.fit</code></td>
<td>
<p> (optional) A previously estimated VAR object returned from 
calling the <code>varxfit</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>realizedVol</code></td>
<td>
<p> Required xts matrix for the realGARCH model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> . </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The 2-step DCC estimation fits a GARCH-Normal model to the univariate data and 
then proceeds to estimate the second step based on the chosen multivariate 
distribution. Because of this 2-step approach, standard errors are expensive to 
calculate and therefore the use of parallel functionality, built into both the 
fitting and standard error calculation routines is key. The switch to turn off 
the calculation of standard errors through the ‘fit.control’ option could 
be quite useful in rolling estimation such as in the <code>dccroll</code> 
routine.<br>
The optional ‘fit’ argument allows to pass your own <code>uGARCHmultifit</code> 
object instead of having the routine estimate it. This is very useful in cases 
of multiple use of the same fit and problems in convergence which might require 
a more hands on approach to the univariate fitting stage. However, it is up to 
the user to ensure consistency between the ‘fit’ and supplied ‘spec’.
</p>


<h3>Value</h3>

<p>A <code>DCCfit</code> object containing details of the DCC-GARCH fit.
</p>


<h3>Note</h3>

<p>There is no check on the VAR.fit list passed to the method so particular care 
should be exercised so that the same data used in the fitting routine is also 
used in the VAR fit routine. This this must have been called with the option 
<code>postpad</code> ‘constant’. The ability to pass this list of the 
pre-calculated VAR model is particularly useful when comparing different models 
(such as copula-GARCH, GO-GARCH etc) using the same dataset and VAR method (i.e. 
the same first stage conditional mean filtration). Though the classical VAR 
estimation is very fast and may not require this extra step, the robust method 
is slow and therefore benefits from calculating this only once.<br>
For extensive examples look in the ‘rmgarch.tests’ folder.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


</div>