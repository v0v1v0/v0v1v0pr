<div class="container">

<table style="width: 100%;"><tr>
<td>cROC.kernel</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Nonparametric kernel-based estimation of the covariate-specific ROC curve (cROC).
</h2>

<h3>Description</h3>

<p>This function estimates the covariate-specific ROC curve (cROC) using the nonparametric kernel-based method proposed by Rodriguez-Alvarez et al. (2011). The method, as it stands now, can only deal with one continuous covariate. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cROC.kernel(marker, covariate, group, tag.h, 
  bw = c("LS", "AIC"), regtype = c("LC", "LL"), 
  data, newdata, pauc = pauccontrol(),  
  p = seq(0, 1, l = 101), B = 1000, ci.level = 0.95,
    parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>
<p>A character string with the name of the continuous covariate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>A character string specifying which method to use to select the bandwidths. AIC specifies expected Kullback-Leibler cross-validation, and LS specifies least-squares cross-validation. Defaults to LS. For details see <code>R</code>-package <code>np</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regtype</code></td>
<td>
<p>A character string specifying which type of kernel estimator to use for the regression function (see Details). LC specifies a local-constant estimator (Nadaraya-Watson) and LL specifies a local-linear estimator. Defaults to LC. For details see <code>R</code>-package <code>np</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if computed) will be computed. If not supplied, the function <code>cROCData</code> is used to build a default dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>pauccontrol</code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve should be computed, and in case it is computed, , whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-specific ROC curve. This set is also used to compute the area under the covariate-specific ROC curve using Simpson's rule. Thus, the length of the set should be an odd number, and it should be rich enough for an accurate estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. The default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either "no" (default), "multicore" (not available on Windows) or "snow".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = "snow". If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates the covariate-specific ROC curve (cROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|x) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p|x)|x\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y|x) = Pr(Y_{D} \leq y | X_{D} = x ),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|x) = Pr(Y_{\bar{D}} \leq y | X_{\bar{D}} = x).</code>
</p>

<p>Note that, for the sake of clarity, we assume that the covariate of interest is the same in both healthy and diseased populations. In particular, the method implemented in this function estimates <code class="reqn">F_{D}(\cdot|x)</code> and <code class="reqn">F_{\bar{D}}(\cdot|x)</code> assuming a nonparametric location-scale regression model for <code class="reqn">Y</code> in each population separately, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">Y_{D} = \mu_{D}(X_{D}) + \sigma_{D}(X_{D})\varepsilon_{D},</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{\bar{D}} = \mu_{\bar{D}}(X_{\bar{D}}) + \sigma_{\bar{D}}(X_{\bar{D}})\varepsilon_{\bar{D}},</code>
</p>

<p>where <code class="reqn">\mu_{D}(x) = E(Y_D | X_D = x)</code>,  <code class="reqn">\mu_{\bar{D}}(x) = E(Y_{\bar{D}} | X_{\bar{D}} = x)</code> (regression function), <code class="reqn">\sigma^2_{D}(x) = Var(Y_D | X_D = x)</code>, <code class="reqn">\sigma^2_{\bar{D}}(x) = Var(Y_{\bar{D}} | X_{\bar{D}} = x)</code> (variance functions), and <code class="reqn">\varepsilon_{D}</code> and <code class="reqn">\varepsilon_{\bar{D}}</code> have zero mean, variance one, and distribution functions <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code>, respectively. In this case, the covariate-specific ROC curve can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|x) = 1 - G_{D}\{a(\mathbf{x}) + b(\mathbf{x})G_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where <code class="reqn">a(x) = \frac{\mu_{\bar{D}}(x) - \mu_{D}(x)}{\sigma_{D}(x)}</code>, <code class="reqn">b(x) = \frac{\sigma_{\bar{D}}(x)}{\sigma_{D}(x)}</code>, and <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code> are the distribution functions of <code class="reqn">\varepsilon_{D}</code> and <code class="reqn">\varepsilon_{\bar{D}}</code>, respectively.
By default, for both the healthy and diseased population, both the regression and variance functions are estimated using the Nadaraya-Watson estimator (LC), and the bandwidth are selected using least-squares cross-validation (LS). Implementation relies on the <code>R</code>-package <code>np</code>. No assumptions are made about <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code>, which are empirically estimated on the basis of standardised residuals. 
</p>
<p>The covariate-specific area under the curve is
</p>
<p style="text-align: center;"><code class="reqn">AUC(\mathbf{x})=\int_{0}^{1}ROC(p|\mathbf{x})dp,</code>
</p>

<p>and is computed numerically (using Simpson's rule). With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})=\int_0^{u_1} ROC(p|\mathbf{x})dp,</code>
</p>

<p>where again the integral is approximated numerically (Simpson's rule). The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})=\int_{u_2}^{1}ROC_{TNF}(p|\mathbf{x})dp,</code>
</p>

<p>where <code class="reqn">ROC_{TNF}(p|\mathbf{x})</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p|\mathbf{x}) = F_{\bar{D}}\{F_{D}^{-1}(1-p|\mathbf{x})|\mathbf{x}\}=G_{\bar{D}}\{\frac{\mu_{D}(x)-\mu_{\bar{D}}(x)}{\sigma_{\bar{D}}(x)}+G_{D}^{-1}(1-p)\frac{\sigma_{D}(x)}{\sigma_{\bar{D}}(x)}\}.</code> Again, the computation of the integral is done via Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>A data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if required) was computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate</code></td>
<td>
<p>The value of the argument <code>covariate</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-specific ROC curve has been estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ROC</code></td>
<td>
<p>Estimated covariate-specific ROC curve (AROC), and <code>ci.level</code>*100% pointwise confidence band (if computed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-specific ROC curve, and <code>ci.level</code>*100% confidence interval (if computed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve and <code>ci.level</code>*100%  confidence interval (if computed). Note that the returned values are normalised, so that the maximum value is one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component of the list contains the following information: (1) <code>bw.mean</code>: An object of class <code>npregbw</code> with the selected bandwidth for the nonparametric regression function. For further details, see <code>R</code>-package <code>np</code>. (2) <code>bw.var</code>: An object of class <code>npregbw</code> with the selected bandwidth for the nonparametric variance function. For further details, see  <code>R</code>-package <code>np</code>. (3) <code>fit.mean</code>: An object of class <code>npreg</code> with the nonparametric regression function estimate. For further details, see <code>R</code>-package <code>np</code>. (4) <code>fit.var</code>: An object of class <code>npreg</code> with the nonparametric variance function estimate. For further details, see <code>R</code>-package <code>np</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Hayfield, T., and Racine, J. S.(2008). Nonparametric Econometrics: The np Package. Journal of Statistical Software 27(5). URL http://www.jstatsoft.org/v27/i05/.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, <b>21</b>, 483–499.
</p>


<h3>See Also</h3>

<p><code>AROC.bnp</code>, <code>AROC.sp</code>, <code>AROC.kernel</code>, <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code>, <code>pooledROC.dpm</code>, <code>cROC.kernel</code> or <code>cROC.sp</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_kernel &lt;- cROC.kernel(marker = "l_marker1",
               covariate = "age",
               group = "status", 
               tag.h = 0,
               data = newpsa, 
               bw = "LS",
               regtype = "LC",
               p = seq(0, 1, len = 101),
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               B = 500)

plot(cROC_kernel)

summary(cROC_kernel )


</code></pre>


</div>