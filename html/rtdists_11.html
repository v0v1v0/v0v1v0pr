<div class="container">

<table style="width: 100%;"><tr>
<td>LBA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Linear Ballistic Accumulator (LBA)</h2>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation for
the LBA model with the following parameters: <code>A</code> (upper value of
starting point), <code>b</code> (response threshold), <code>t0</code> (non-decision
time), and driftrate (<code>v</code>). All functions are available with different
distributions underlying the drift rate: Normal (<code>norm</code>), Gamma
(<code>gamma</code>), Frechet (<code>frechet</code>), and log normal (<code>lnorm</code>). The
functions return their values conditional on the accumulator given in the
response argument winning.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dLBA(rt, response, A, b, t0, ..., st0 = 0, distribution = c("norm",
  "gamma", "frechet", "lnorm"), args.dist = list(), silent = FALSE)

pLBA(rt, response, A, b, t0, ..., st0 = 0, distribution = c("norm",
  "gamma", "frechet", "lnorm"), args.dist = list(), silent = FALSE)

qLBA(p, response, A, b, t0, ..., st0 = 0, distribution = c("norm",
  "gamma", "frechet", "lnorm"), args.dist = list(), silent = FALSE,
  interval = c(0, 10), scale_p = FALSE, scale_max = Inf)

rLBA(n, A, b, t0, ..., st0 = 0, distribution = c("norm", "gamma",
  "frechet", "lnorm"), args.dist = list(), silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rt</code></td>
<td>
<p>vector of RTs. Or for convenience also a <code>data.frame</code> with
columns <code>rt</code> and <code>response</code> (such as returned from <code>rLBA</code> or
<code>rdiffusion</code>). See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>response</code></td>
<td>
<p>integer vector of winning accumulators/responses
corresponding to the vector of RTs/p (i.e., used for specifying the
response for a given RT/probability). Will be recycled if necessary. Cannot
contain values larger than the number of accumulators. First
response/accumulator must receive value 1, second 2, and so forth. For
conmvenience, <code>response</code> is converted via <code>as.numeric</code> thereby
allowing factors to be passed as well (such as returned from
<code>rdiffusion</code>). Ignored if <code>rt</code> or <code>p</code> is a
<code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>start point interval or evidence in accumulator before beginning of
decision process. Start point varies from trial to trial in the interval
[0, <code>A</code>] (uniform distribution). Average amount of evidence before
evidence accumulation across trials is <code>A</code>/2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>response threshold. (<code>b</code> - <code>A</code>/2) is a measure of
"response caution".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t0</code></td>
<td>
<p>non-decision time or response time constant (in seconds). Lower
bound for the duration of all non-decisional processes (encoding and
response execution).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>two <em>named</em> drift rate parameters depending on
<code>distribution</code> (e.g., <code>mean_v</code> and <code>sd_v</code> for
<code>distribution=="norm"</code>). The parameters can either be given as a
numeric vector or a list. If a numeric vector is passed each element of the
vector corresponds to one accumulator. If a list is passed each list
element corresponds to one accumulator allowing again trialwise driftrates.
The shorter parameter will be recycled as necessary (and also the elements
of the list to match the length of <code>rt</code>). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>st0</code></td>
<td>
<p>variability of non-decision time, such that <code>t0</code> is uniformly
distributed between <code>t0</code> and <code>t0</code> + <code>st0</code>. Default is 0. Can
be trialwise, and will be recycled to length of <code>rt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>character specifying the distribution of the drift rate.
Possible values are <code>c("norm", "gamma", "frechet", "lnorm")</code>, default
is <code>"norm"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args.dist</code></td>
<td>
<p>list of optional further arguments to the distribution
functions (i.e., <code>posdrift</code> or <code>robust</code> for
<code>distribution=="norm"</code>, see <code>single-LBA</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>logical. Should the number of accumulators used be suppressed?
Default is <code>FALSE</code> which prints the number of accumulators.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of probabilities. Or for convenience also a <code>data.frame</code>
with columns <code>p</code> and <code>response</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be
searched for the desired quantiles (i.e., RTs) in <code>qLBA</code>. Default is
<code>c(0, 10)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_p</code></td>
<td>
<p>logical. Should entered probabilities automatically be scaled
by maximally predicted probability? Default is <code>FALSE</code>. Convenience
argument for obtaining predicted quantiles. Can be slow as the maximally
predicted probability is calculated individually for each <code>p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_max</code></td>
<td>
<p>numerical scalar. Value at which maximally predicted RT
should be calculated if <code>scale_p</code> is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>desired number of observations (scalar integer).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For convenience, all functions (with the exception of <code>rdiffusion</code>)
allow that the first argument is a <code>data.frame</code> containing the
information of the first and second argument in two columns (i.e.,
<code>rt</code>/<code>p</code> and <code>response</code>). Other columns will be ignored. This
allows, for example, to pass the <code>data.frame</code> generated by <code>rLBA</code>
directly to <code>pLBA</code>. See examples.
</p>


<h4>Parameters</h4>

<p> The following arguments are allowed as <code>...</code>
drift rate parameters: </p>
 <ul>
<li> <p><code>mean_v,sd_v</code> mean and standard
deviation of normal distribution for drift rate (<code>norm</code>). See
<code>Normal</code> </p>
</li>
<li> <p><code>shape_v,rate_v,scale_v</code> shape, rate, and
scale of gamma (<code>gamma</code>) and scale and shape of Frechet (<code>frechet</code>)
distributions for drift rate. See <code>GammaDist</code> or
<code>frechet</code>. For Gamma, scale = 1/shape and shape = 1/scale. 
</p>
</li>
<li> <p><code>meanlog_v,sdlog_v</code> mean and standard deviation of lognormal
distribution on the log scale for drift rate (<code>lnorm</code>). See
<code>Lognormal</code>. </p>
</li>
</ul>
<p>As described above, the accumulator parameters can either be given as a
numeric vector or a list. If a numeric vector is passed each element of the
vector corresponds to one accumulator. If a list is passed each list element
corresponds to one accumulator allowing trialwise driftrates. The shorter
parameter will be recycled as necessary (and also the elements of the list to
match the length of <code>rt</code>).
</p>
<p>The other LBA parameters (i.e., <code>A</code>, <code>b</code>, and <code>t0</code>, with the
exception of <code>st0</code>) can either be a single numeric vector (which will be
recycled to reach <code>length(rt)</code> or <code>length(n)</code> for trialwise
parameters) <em>or</em> a <code>list</code> of such vectors in which each list
element corresponds to the parameters for this accumulator (i.e., the list
needs to be of the same length as there are accumulators). Each list will
also be recycled to reach <code>length(rt)</code> for trialwise parameters per
accumulator.
</p>
<p>To make the difference between both paragraphs clear: Whereas for the
accumulators both a single vector or a list corresponds to different
accumulators, only the latter is true for the other parameters. For those
(i.e., <code>A</code>, <code>b</code>, and <code>t0</code>) a single vector always corresponds
to trialwise values and a list must be used for accumulator wise values.
</p>
<p><code>st0</code> can only vary trialwise (via a vector). And it should be noted
that <code>st0</code> not equal to zero will considerably slow done everything. </p>



<h4>Quantile Function</h4>

<p> Due to the bivariate nature of the LBA,
single accumulators only return defective CDFs that do not reach 1. Only the
sum of all accumulators reaches 1. Therefore, <code>qLBA</code> can only return
quantiles/RTs for any accumulator up to the maximal probability of that
accumulator's CDF. This can be obtained by evaluating the CDF at <code>Inf</code>.
</p>
<p>As a conveniece for the user, if <code>scale_p = TRUE</code> in the call to
<code>qLBA</code> the desired probabilities are automatically scaled by the maximal
probability for the corresponding response. Note that this can be slow as the
maximal probability is calculated separately for each desired probability.
See examples.
</p>
<p>Also note that quantiles (i.e., predicted RTs) are obtained by numerically
minimizing the absolute difference between desired probability and the value
returned from <code>pLBA</code> using <code>optimize</code>. If the difference
between the desired probability and probability corresponding to the returned
quantile is above a certain threshold (currently 0.0001) no quantile is
returned but <code>NA</code>. This can be either because the desired quantile is
above the maximal probability for this accumulator or because the limits for
the numerical integration are too small (default is <code>c(0, 10)</code>). </p>



<h4>RNG</h4>

<p> For random number generation at least one of the
distribution parameters (i.e., <code>mean_v</code>, <code>sd_v</code>, <code>shape_v</code>,
<code>scale_v</code>, <code>rate_v</code>, <code>meanlog_v</code>, and <code>sdlog_v</code>) should
be of length &gt; 1 to receive RTs from multiple responses. Shorter vectors are
recycled as necessary.<br> Note that for random number generation from a
normal distribution for the driftrate the number of returned samples may be
less than the number of requested samples if <code>posdrifts==FALSE</code>. </p>



<h3>Value</h3>

<p><code>dLBA</code> returns the density (PDF), <code>pLBA</code> returns the
distribution function (CDF), <code>qLBA</code> returns the quantile/RT,
<code>rLBA</code> return random response times and responses (in a
<code>data.frame</code>).
</p>
<p>The length of the result is determined by <code>n</code> for <code>rLBA</code>, equal
to the length of <code>rt</code> for <code>dLBA</code> and <code>pLBA</code>, and equal to
the length of <code>p</code> for <code>qLBA</code>.
</p>
<p>The distribution parameters (as well as <code>response</code>) are recycled to
the length of the result. In other words, the functions are completely
vectorized for all parameters and even the response.
</p>


<h3>Note</h3>

<p>These are the top-level functions intended for end-users. To obtain the
density and cumulative density the race functions are called for each
response time with the corresponding winning accumulator as first
accumulator (see <code>LBA-race</code>).
</p>


<h3>References</h3>

<p>Brown, S. D., &amp; Heathcote, A. (2008). The simplest complete model of choice
response time: Linear ballistic accumulation. <em>Cognitive Psychology</em>,
57(3), 153-178. doi:10.1016/j.cogpsych.2007.12.002
</p>
<p>Donkin, C., Averell, L., Brown, S., &amp; Heathcote, A. (2009). Getting more from
accuracy and response time data: Methods for fitting the linear ballistic
accumulator. <em>Behavior Research Methods</em>, 41(4), 1095-1110.
doi:10.3758/BRM.41.4.1095
</p>
<p>Heathcote, A., &amp; Love, J. (2012). Linear deterministic accumulator models of
simple choice. <em>Frontiers in Psychology</em>, 3, 292.
doi:10.3389/fpsyg.2012.00292
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## generate random LBA data:
rt1 &lt;- rLBA(500, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
head(rt1)
prop.table(table(rt1$response))

# original parameters have 'high' log-likelihood:
sum(log(dLBA(rt1$rt, rt1$response, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))

# data can also be passed as data.frame (same is true for pLBA):
sum(log(dLBA(rt1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))

objective_fun &lt;- function(par, rt, response, distribution = "norm") {
  # simple parameters
  spar &lt;- par[!grepl("[12]$", names(par))]  
  
  # distribution parameters:
  dist_par_names &lt;- unique(sub("[12]$", "", grep("[12]$" ,names(par), value = TRUE)))
  dist_par &lt;- vector("list", length = length(dist_par_names))
  names(dist_par) &lt;- dist_par_names
  for (i in dist_par_names) dist_par[[i]] &lt;- as.list(unname(par[grep(i, names(par))]))
  dist_par$sd_v &lt;- c(1, dist_par$sd_v) # fix first sd to 1

  # get summed log-likelihood:
  d &lt;- do.call(dLBA, args = c(rt=list(rt), response=list(response), spar, dist_par, 
                               distribution=distribution, silent=TRUE))
  if (any(d &lt; 0e-10)) return(1e6) 
  else return(-sum(log(d)))
}

# gives same value as manual calculation above:
objective_fun(c(A=0.5, b=1, t0=0.5, mean_v1=2.4, mean_v2=1.6, sd_v2=1.2), 
              rt=rt1$rt, response=rt1$response)

## Not run: 
# can we recover the parameters? 
# should be run several times with different random values of init_par
init_par &lt;- runif(6)
init_par[2] &lt;- sum(init_par[1:2]) # ensures b is larger than A
init_par[3] &lt;- runif(1, 0, min(rt1$rt)) #ensures t0 is mot too large
names(init_par) &lt;- c("A", "b", "t0", "mean_v1", "mean_v2",  "sd_v2")
nlminb(objective_fun, start = init_par, rt=rt1$rt, response=rt1$response, lower = 0)

## End(Not run)


# plot cdf (2 accumulators):
curve(pLBA(x, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2)), 
     xlim = c(0, 2), ylim = c(0,1), 
     ylab = "cumulative probability", xlab = "response time",
     main = "Defective CDFs of LBA")
curve(pLBA(x, response = 2, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2)), 
     add=TRUE, lty = 2)
legend("topleft", legend=c("1", "2"), title="Response", lty=1:2)


# plot cdf (3 accumulators):
curve(pLBA(x, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6, 1.0), sd_v=c(1,1.2, 2.0)), 
     xlim = c(0, 2), ylim = c(0,1), 
     ylab = "cumulative probability", xlab = "response time",
     main = "Defective CDFs of LBA")
curve(pLBA(x, response = 2, A=0.5, b=1, t0 = 0.5,  mean_v=c(2.4, 1.6, 1.0), sd_v=c(1,1.2, 2.0)), 
     add=TRUE, lty = 2)
curve(pLBA(x, response = 3, A=0.5, b=1, t0 = 0.5,  mean_v=c(2.4, 1.6, 1.0), sd_v=c(1,1.2, 2.0)), 
     add=TRUE, lty = 3)
legend("topleft", legend=c("1", "2", "3"), title="Response", lty=1:2)


## qLBA can only return values up to maximal predicted probability:
(max_p &lt;- pLBA(Inf, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2)))
# [1] 0.6604696

qLBA(0.66, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
# 2.559532

qLBA(0.67, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
# NA

# to get predicted quantiles, scale required quantiles by maximally predicted response rate:
qs &lt;- c(.1, .3, .5, .7, .9)
qLBA(qs*max_p, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))

# or set scale_p to TRUE which scales automatically by maximum p
# (but can be slow as it calculates max_p for each probability separately) 
qLBA(qs, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2), scale_p=TRUE)

# qLBA also accepts a data.frame as first argument:
t &lt;- data.frame(p = rep(c(0.05, 0.1, 0.66), 2), response = rep(1:2, each = 3))
#      p response
# 1 0.05        1
# 2 0.10        1
# 3 0.66        1
# 4 0.05        2
# 5 0.10        2
# 6 0.66        2
qLBA(t, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))


## LBA and diffusion can be used interchangeably:
rt1 &lt;- rLBA(500, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
rt2 &lt;- rdiffusion(500, a=1, v=2, t0=0.5)

# data can also be passed as data.frame (same is true for pLBA):
sum(log(dLBA(rt1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))
sum(log(dLBA(rt2, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))

sum(log(ddiffusion(rt1, a=1, v=2, t0=0.5)))
sum(log(ddiffusion(rt2, a=1, v=2, t0=0.5)))

### trial wise parameters work as expected (only since package version 0.9):
x1 &lt;- dLBA(rt=c(1,1), response=c(1,2), A=1,b=list(c(1,3),c(2,4)),
           t0=0.1, mean_v=c(3,3), sd_v=c(1,1),distribution="norm")
x2a &lt;- dLBA(rt=c(1), response=c(1), A=1,b=list(c(1),c(2)),
            t0=0.1,mean_v=c(3,3),sd_v=c(1,1),distribution="norm")
x2b &lt;- dLBA(rt=c(1), response=c(2), A=1,b=list(c(3),c(4)),
            t0=0.1,mean_v=c(3,3),sd_v=c(1,1),distribution="norm")
all(x1 == c(x2a, x2b)) ## should be TRUE
</code></pre>


</div>