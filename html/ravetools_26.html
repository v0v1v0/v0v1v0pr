<div class="container">

<table style="width: 100%;"><tr>
<td>convolve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convolution of <code>1D</code>, <code>2D</code>, <code>3D</code> data via <code>FFT</code>
</h2>

<h3>Description</h3>

<p>Use the 'Fast-Fourier' transform to compute the convolutions of two data
with zero padding. This function is mainly designed for image convolution.
For forward and backward convolution/filter, see <code>filtfilt</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">convolve_signal(x, filter)

convolve_image(x, filter)

convolve_volume(x, filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>one-dimensional signal vector, two-dimensional image, or
three-dimensional volume; numeric or complex</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>kernel with the same number of dimensions as <code>x</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This implementation uses 'Fast-Fourier' transform to perform
<code>1D</code>, <code>2D</code>, or <code>3D</code> convolution. Compared to implementations
using original mathematical definition of convolution, this approach is
much faster, especially for image and volume convolutions.
</p>
<p>The input <code>x</code> is zero-padded beyond edges. This is most common in image
or volume convolution, but less optimal for periodic one-dimensional signals.
Please use other implementations if non-zero padding is needed.
</p>
<p>The convolution results might be different to the ground truth by a precision
error, usually at <code>1e-13</code> level, depending on the <code>'FFTW3'</code>
library precision and implementation.
</p>


<h3>Value</h3>

<p>Convolution results with the same length and dimensions as <code>x</code>.
If <code>x</code> is complex, results will be complex, otherwise results will
be real numbers.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# ---- 1D convolution ------------------------------------
x &lt;- cumsum(rnorm(100))
filter &lt;- dnorm(-2:2)
# normalize
filter &lt;- filter / sum(filter)
smoothed &lt;- convolve_signal(x, filter)

plot(x, pch = 20)
lines(smoothed, col = 'red')

# ---- 2D convolution ------------------------------------
x &lt;- array(0, c(100, 100))
x[
  floor(runif(10, min = 1, max = 100)),
  floor(runif(10, min = 1, max = 100))
] &lt;- 1

# smooth
kernel &lt;- outer(dnorm(-2:2), dnorm(-2:2), FUN = "*")
kernel &lt;- kernel / sum(kernel)

y &lt;- convolve_image(x, kernel)

oldpar &lt;- par(mfrow = c(1,2))
image(x, asp = 1, axes = FALSE, main = "Origin")
image(y, asp = 1, axes = FALSE, main = "Smoothed")
par(oldpar)


</code></pre>


</div>