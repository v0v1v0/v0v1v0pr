<div class="container">

<table style="width: 100%;"><tr>
<td>export_codes_to_txt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Export codes to a plain text file</h2>

<h3>Description</h3>

<p>These function can be used to convert one or more parsed sources to HTML,
or to convert all sources to tabbed sections in Markdown.
</p>


<h3>Usage</h3>

<pre><code class="language-R">export_codes_to_txt(
  input,
  output = NULL,
  codeTree = "fullyMergedCodeTrees",
  codingScheme = "codes",
  regex = ".*",
  onlyChildrenOf = NULL,
  leavesOnly = TRUE,
  includePath = TRUE,
  preventOverwriting = rock::opts$get(preventOverwriting),
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>An object of class <code>rock_parsedSource</code> (as resulting from a call
to <code>parse_source</code>) or of class <code>rock_parsedSources</code> (as resulting from a call
to <code>parse_sources</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>THe filename to write to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codeTree</code></td>
<td>
<p>Codes from which code tree to export the codes. Valid options
are <code>fullyMergedCodeTrees</code>, <code>extendedDeductiveCodeTrees</code>, <code>deductiveCodeTrees</code>,
and <code>inductiveCodeTrees</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>codingScheme</code></td>
<td>
<p>With the ROCK, it's possible to use multiple coding scheme's
in parallel. The ROCK default is called <code>codes</code> (using the double square brackets
as code delimiters), but other delimiters can be used as well, and give a different
name. Use <code>codingScheme</code> to specify which code tree you want to export, if you
have multiple.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>An optional regular expression: only codes matching this regular
expression will be selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlyChildrenOf</code></td>
<td>
<p>A character vector of one or more regular expressions that
specify codes within which to search. For example, if the code tree contains codes
<code>parent1</code> and <code>parent2</code>, and each have a number of child codes, and <code>parent</code> is
passed as <code>onlyChildrenOf</code>, only the codes within <code>parent</code> are selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leavesOnly</code></td>
<td>
<p>Whether to only write the leaves (i.e. codes that don't have
children) or all codes in the code tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>includePath</code></td>
<td>
<p>Whether to only return the code itself (e.g. <code>code</code>) or also
include the path to the root (e.g. <code style="white-space: pre;">⁠code1&gt;code2&gt;code⁠</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting of output files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>The encoding to use when writing the exported source(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Whether to suppress messages.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Parse a selection of example sources in that directory
parsedExamples &lt;-
  rock::parse_sources(
    examplePath,
    regex = "(test|example)(.txt|.rock)"
  );

### Show results of exporting the codes
rock::export_codes_to_txt(parsedExamples);

### Only show select a narrow set of codes
rock::export_codes_to_txt(
  parsedExamples,
  leavesOnly=TRUE,
  includePath=FALSE,
  onlyChildrenOf = "inductFather",
  regex="3|5"
);

</code></pre>


</div>