<div class="container">

<table style="width: 100%;"><tr>
<td>ALC_RNAmf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>find the next point by ALC criterion</h2>

<h3>Description</h3>

<p>The function acquires the new point by the Active learning Cohn (ALC) criterion.
It calculates the ALC criterion
<code class="reqn">\frac{\Delta \sigma_L^{2}(l,\bm{x})}{\sum^l_{j=1}C_j} =
\frac{\int_{\Omega} \sigma_L^{*2}(\bm{\xi})-\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x}){\rm{d}}\bm{\xi}}{\sum^l_{j=1}C_j}</code>,
where <code class="reqn">f_L</code> is the highest-fidelity simulation code,
<code class="reqn">\sigma_L^{*2}(\bm{\xi})</code> is the posterior variance of <code class="reqn">f_L(\bm{\xi})</code>,
<code class="reqn">C_j</code> is the simulation cost at fidelity level <code class="reqn">j</code>,
and <code class="reqn">\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})</code> is the posterior variance
based on the augmented design combining the current design and a new input location <code class="reqn">\bm{x}</code>
at each fidelity level lower than or equal to <code class="reqn">l</code>.
The integration is approximated by MC integration using uniform reference samples.
</p>
<p>A new point is acquired on <code>Xcand</code>. If <code>Xcand=NULL</code> and <code>Xref=NULL</code>, a new point is acquired on unit hypercube <code class="reqn">[0,1]^d</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ALC_RNAmf(Xref = NULL, Xcand = NULL, fit, mc.sample = 100,
cost = NULL, optim = TRUE, parallel = FALSE, ncore = 1, trace=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xref</code></td>
<td>
<p>vector or matrix of reference location to approximate the integral of ALC. If <code>Xref=NULL</code>, <code class="reqn">100 \times d</code> points from 0 to 1 are generated by Latin hypercube design. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xcand</code></td>
<td>
<p>vector or matrix of candidate set which could be added into the current design only when <code>optim=FALSE</code>. <code>Xcand</code> is the set of the points where ALC criterion is evaluated. If <code>Xcand=NULL</code>, <code>Xref</code> is used. Default is <code>NULL</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>object of class <code>RNAmf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.sample</code></td>
<td>
<p>a number of mc samples generated for the imputation through MC approximation. Default is <code>100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>vector of the costs for each level of fidelity. If <code>cost=NULL</code>, total costs at all levels would be 1. <code>cost</code> is encouraged to have a ascending order of positive value. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>logical indicating whether to optimize AL criterion by <code>optim</code>'s gradient-based <code>L-BFGS-B</code> method. If <code>optim=TRUE</code>, <code class="reqn">5 \times d</code> starting points are generated by Latin hypercube design for optimization. If <code>optim=FALSE</code>, AL criterion is optimized on the <code>Xcand</code>. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>logical indicating whether to compute the AL criterion in parallel or not. If <code>parallel=TRUE</code>, parallel computation is utilized. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncore</code></td>
<td>
<p>a number of core for parallel. It is only used if <code>parallel=TRUE</code>. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical indicating whether to print the computational time for each step. If <code>trace=TRUE</code>, the computation time for each step is printed. Default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>Xref</code> plays a role of <code class="reqn">\bm{\xi}</code> to approximate the integration.
To impute the posterior variance based on the augmented design <code class="reqn">\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})</code>,
MC approximation is used.
Due to the nested assumption, imputing <code class="reqn">y^{[s]}_{n_s+1}</code> for each <code class="reqn">1\leq s\leq l</code> by drawing samples
from the posterior distribution of <code class="reqn">f_s(\bm{x}^{[s]}_{n_s+1})</code>
based on the current design allows to compute <code class="reqn">\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})</code>.
Inverse of covariance matrix is computed by the Sherman-Morrison formula.
For details, see Heo and Sung (2024, &lt;<a href="https://doi.org/10.1080/00401706.2024.2376173">doi:10.1080/00401706.2024.2376173</a>&gt;).
</p>
<p>To search for the next acquisition <code class="reqn">\bm{x^*}</code> by maximizing AL criterion,
the gradient-based optimization can be used by <code>optim=TRUE</code>.
Firstly, <code class="reqn">\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})</code> is computed on the
<code class="reqn">5 \times d</code> number of points.
After that, the point minimizing <code class="reqn">\tilde{\sigma}_L^{*2}(\bm{\xi};l,\bm{x})</code>
serves as a starting point of optimization by <code>L-BFGS-B</code> method.
Otherwise, when <code>optim=FALSE</code>, AL criterion is optimized only on <code>Xcand</code>.
</p>
<p>The point is selected by maximizing the ALC criterion:
<code class="reqn">\text{argmax}_{l\in\{1,\ldots,L\}; \bm{x} \in \Omega}
\frac{\Delta \sigma_L^{2}(l,\bm{x})}{\sum^l_{j=1}C_j}</code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ALC</code>: list of ALC criterion integrated on <code>Xref</code> when each data point on <code>Xcand</code> is added at each level <code class="reqn">l</code> if <code>optim=FALSE</code>. If <code>optim=TRUE</code>, <code>ALC</code> returns <code>NULL</code>.
</p>
</li>
<li> <p><code>cost</code>: a copy of <code>cost</code>.
</p>
</li>
<li> <p><code>Xcand</code>: a copy of <code>Xcand</code>.
</p>
</li>
<li> <p><code>chosen</code>: list of chosen level and point.
</p>
</li>
<li> <p><code>time</code>: a scalar of the time for the computation.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
library(lhs)
library(doParallel)
library(foreach)

### simulation costs ###
cost &lt;- c(1, 3)

### 1-d Perdikaris function in Perdikaris, et al. (2017) ###
# low-fidelity function
f1 &lt;- function(x) {
  sin(8 * pi * x)
}

# high-fidelity function
f2 &lt;- function(x) {
  (x - sqrt(2)) * (sin(8 * pi * x))^2
}

### training data ###
n1 &lt;- 13
n2 &lt;- 8

### fix seed to reproduce the result ###
set.seed(1)

### generate initial nested design ###
X &lt;- NestedX(c(n1, n2), 1)
X1 &lt;- X[[1]]
X2 &lt;- X[[2]]

### n1 and n2 might be changed from NestedX ###
### assign n1 and n2 again ###
n1 &lt;- nrow(X1)
n2 &lt;- nrow(X2)

y1 &lt;- f1(X1)
y2 &lt;- f2(X2)

### n=100 uniform test data ###
x &lt;- seq(0, 1, length.out = 100)

### fit an RNAmf ###
fit.RNAmf &lt;- RNAmf_two_level(X1, y1, X2, y2, kernel = "sqex")

### predict ###
predy &lt;- predict(fit.RNAmf, x)$mu
predsig2 &lt;- predict(fit.RNAmf, x)$sig2

### active learning with optim=TRUE ###
alc.RNAmf.optim &lt;- ALC_RNAmf(
  Xref = x, Xcand = x, fit.RNAmf, cost = cost,
  optim = TRUE, parallel = TRUE, ncore = 2
)
print(alc.RNAmf.optim$time) # computation time of optim=TRUE

### active learning with optim=FALSE ###
alc.RNAmf &lt;- ALC_RNAmf(
  Xref = x, Xcand = x, fit.RNAmf, cost = cost,
  optim = FALSE, parallel = TRUE, ncore = 2
)
print(alc.RNAmf$time) # computation time of optim=FALSE

### visualize ALC ###
oldpar &lt;- par(mfrow = c(1, 2))
plot(x, alc.RNAmf$ALC$ALC1,
  type = "l", lty = 2,
  xlab = "x", ylab = "ALC criterion augmented at the low-fidelity level",
  ylim = c(min(c(alc.RNAmf$ALC$ALC1, alc.RNAmf$ALC$ALC2)),
           max(c(alc.RNAmf$ALC$ALC1, alc.RNAmf$ALC$ALC2)))
)
plot(x, alc.RNAmf$ALC$ALC2,
  type = "l", lty = 2,
  xlab = "x", ylab = "ALC criterion augmented at the high-fidelity level",
  ylim = c(min(c(alc.RNAmf$ALC$ALC1, alc.RNAmf$ALC$ALC2)),
           max(c(alc.RNAmf$ALC$ALC1, alc.RNAmf$ALC$ALC2)))
)
points(alc.RNAmf$chosen$Xnext,
  alc.RNAmf$ALC$ALC2[which(x == drop(alc.RNAmf$chosen$Xnext))],
  pch = 16, cex = 1, col = "red"
)
par(oldpar)

</code></pre>


</div>