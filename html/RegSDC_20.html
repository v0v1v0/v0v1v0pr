<div class="container">

<table style="width: 100%;"><tr>
<td>SuppressDec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Suppressed tabular data: Inner cell frequencies as decimal numbers</h2>

<h3>Description</h3>

<p>Assume that frequencies to be published, <code>z</code>, can be computed from inner 
frequencies, <code>y</code>, via <code> z = t(x) %*% y</code>, 
where <code>x</code> is a dummy matrix. 
Assuming correct suppression, this function will generate safe inner cell frequencies as decimal numbers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SuppressDec(
  x,
  z = NULL,
  y = NULL,
  suppressed = NULL,
  digits = 9,
  nRep = 1,
  yDeduct = NULL,
  resScale = NULL,
  rmse = NULL,
  sparseLimit = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Dummy matrix where the dimensions matches z and/or y input. Sparse matrix (Matrix package) is possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Frequencies to be published. All, only the safe ones or with suppressed as NA.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Inner cell frequencies (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suppressed</code></td>
<td>
<p>Logical vector defining the suppressed elements of z.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Output close to whole numbers will be rounded using <code>digits</code> as input to <code>RoundWhole</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nRep</code></td>
<td>
<p>Integer, when &gt;1, several y's will be generated. Extra columns in output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yDeduct</code></td>
<td>
<p>Values to be subtracted from y and added back after the calculations. 
Can be used to perform the modulo method described in the paper (see examples).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resScale</code></td>
<td>
<p>Residuals will be scaled by resScale</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmse</code></td>
<td>
<p>Desired root mean square error (residual standard error). Will be used when resScale is NULL or cannot be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparseLimit</code></td>
<td>
<p>Limit for the number of rows of a reduced x-matrix within the algorithm. When exceeded, a sparse algorithm is used 
(see <code>IpsoExtra</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function makes use of <code>ReduceX</code> and <code>RegSDCipso</code>.
It is not required that <code>y</code> consists of cell frequencies. A multivariate <code>y</code> or <code>z</code> is also possible. 
Then several values are possible as <code>digits</code>, <code>resScale</code> and <code>rmse</code> input.
</p>


<h3>Value</h3>

<p>The inner cell frequencies as decimal numbers
</p>


<h3>Note</h3>

<p>Capital letters, X, Y and Z, are used in the paper.
</p>


<h3>Author(s)</h3>

<p>Ã˜yvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Same data as in the paper
z &lt;- RegSDCdata("sec7z")
x &lt;- RegSDCdata("sec7x")
y &lt;- RegSDCdata("sec7y")  # Now z is t(x) %*% y 
zAll &lt;- RegSDCdata("sec7zAll")
zAllSupp &lt;- RegSDCdata("sec7zAllSupp")
xAll &lt;- RegSDCdata("sec7xAll")

# When no suppression, output is identical to y
SuppressDec(xAll, zAll, y)
SuppressDec(xAll, zAll)  # y can be seen in z

# Similar to Y* in paper (but other random values)
SuppressDec(x, z, y)

# Residual standard error forced to be 1
SuppressDec(x, z, y, rmse = 1)

# Seven ways of obtaining the same output
SuppressDec(x, z, rmse = 1)  # slower, y must be estimated
SuppressDec(x, y = y, rmse = 1)
SuppressDec(xAll, zAllSupp, y, rmse = 1)
SuppressDec(xAll, zAllSupp, rmse = 1)  # slower, y must be estimated
SuppressDec(xAll, zAll, y, is.na(zAllSupp), rmse = 1)
SuppressDec(xAll, zAll, suppressed = is.na(zAllSupp), rmse = 1)  # y seen in z
SuppressDec(xAll, y = y, suppressed = is.na(zAllSupp), rmse = 1)

# YhatMod4 and YhatMod10 in Table 2 in paper
SuppressDec(xAll, zAllSupp, y, yDeduct = 4 * (y%/%4), resScale = 0)
SuppressDec(xAll, zAllSupp, y, yDeduct = 10 * (y%/%10), rmse = 0)

# As data in Table 3 in paper (but other random values)
SuppressDec(xAll, zAllSupp, y, yDeduct = 10 * (y%/%10), resScale = 0.1)

# rmse instead of resScale and 5 draws
SuppressDec(xAll, zAllSupp, y, yDeduct = 10 * (y%/%10), rmse = 1, nRep = 5)
</code></pre>


</div>