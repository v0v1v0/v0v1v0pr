<div class="container">

<table style="width: 100%;"><tr>
<td>Singleton</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Singleton Pattern</h2>

<h3>Description</h3>

<p>Ensure a class only has one instance, and provide a global point
of access to it.
</p>


<h3>Details</h3>

<p>&lt;!– One line about what the function does –&gt;
</p>
<p><em><strong>Singleton</strong></em> ensures a class only has one instance, and provide a global
point of access to it.
</p>


<h4>How It Works</h4>


<ol>
<li>
<p> Create only one instance of the <strong>Singleton</strong> class; and
</p>
</li>
<li>
<p> If an instance exists, then serve the same object again.
</p>
</li>
</ol>
<p>The main features of <strong>Singleton</strong> are:
</p>

<ul>
<li>
<p> Ensuring that one and only one object of the class gets created;
</p>
</li>
<li>
<p> Providing an access point for an object that is global to the program; and
</p>
</li>
<li>
<p> Controlling concurrent access to resources that are shared.
</p>
</li>
</ul>
<h4>When to Use It</h4>


<ul><li>
<p> In situations that require exactly one instance of a class, that must be
accessible to clients from a well-known access point. See the <a href="#example-1"><code>Counter</code> example</a>.
</p>
</li></ul>
<p>&lt;div class="alert alert-danger"&gt;
**Caution:** Singletons can be a problem in multi-threaded applications, especially when they manipulate mutable data.
&lt;/div&gt;
&lt;div class="alert alert-info"&gt;
**Tip:** 
Singletons work well for immutable data, such as reading from some data source, since anything that can’t change isn’t going to run into thread clash problems.
&lt;/div&gt;
</p>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul><li> <p><a href="#method-Singleton-new"><code>Singleton$new()</code></a>
</p>
</li></ul>
<hr>
<a id="method-Singleton-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create or retrieve an object
</p>


<h5>Usage</h5>

<div class="r"><pre>Singleton$new()</pre></div>




<h3>See Also</h3>

<p>Other base design patterns: 
<code>NullObject()</code>,
<code>ValueObject()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># See more examples at &lt;https://tidylab.github.io/R6P/articles&gt;
address &lt;- function(x) sub('&lt;environment: (.*)&gt;', '\\1', capture.output(x))

# In this example we implement a `Counter` that inherits the qualities of
# Singleton
Counter &lt;- R6::R6Class("Counter", inherit = R6P::Singleton, public = list(
    count = 0,
    add_1 = function(){self$count = self$count + 1; invisible(self)}
))

# Whenever we call the constructor on `Counter`, we always get the exact same
# instance:
counter_A &lt;- Counter$new()
counter_B &lt;- Counter$new()

identical(counter_A, counter_B, ignore.environment = FALSE)

# The two objects are equal and located at the same address; thus, they are
# the same object.

# When we make a change in any of the class instances, the rest of the
# instances are changed as well.

# How many times has the counter been increased?
counter_A$count

# Increase the counter by 1
counter_A$add_1()

# How many times have the counters been increased?
counter_A$count
counter_B$count
</code></pre>


</div>