<div class="container">

<table style="width: 100%;"><tr>
<td>pinv.new</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>UNU.RAN generator based on Polynomial interpolation of INVerse CDF (PINV)</h2>

<h3>Description</h3>

<p>UNU.RAN random variate generator for continuous distributions with
given probability density function (PDF) or cumulative distribution
function (CDF).
It is based on the Polynomial interpolation of INVerse CDF (‘PINV’).
</p>
<p>[Universal] – Inversion Method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pinv.new(pdf, cdf, lb, ub, islog=FALSE, center=0,
         uresolution=1.e-10, smooth=FALSE, ...)
pinvd.new(distr, uresolution=1.e-10, smooth=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pdf</code></td>
<td>
<p>probability density function. (<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cdf</code></td>
<td>
<p>cumulative distribution function. (<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lb</code></td>
<td>
<p>lower bound of domain;
use <code>-Inf</code> if unbounded from left. (numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ub</code></td>
<td>
<p>upper bound of domain;
use <code>Inf</code> if unbounded from right. (numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>islog</code></td>
<td>
<p>whether <code>pdf</code> and <code>cdf</code> are given by their
corresponding logarithms. (boolean)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center</code></td>
<td>
<p>“typical” point of distribution. (numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional) arguments for <code>pdf</code> and <code>cdf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distr</code></td>
<td>
<p>distribution object. (S4 object of class <code>"unuran.cont"</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uresolution</code></td>
<td>
<p>maximal acceptable u-error. (numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>whether the inverse CDF is differentiable. (boolean)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function creates an <code>unuran</code> object based on ‘PINV’
(Polynomial interpolation of INVerse CDF). It can be used to draw
samples of a continuous random variate with given probability density
function <code>pdf</code> or cumulative distribution function <code>cdf</code>
by means of <code>ur</code>.
It also allows to compute quantiles by means of <code>uq</code>.
</p>
<p>Function <code>pdf</code> must be positive but need not be normalized
(i.e., it can be any multiple of a density function).
The set of points where the <code>pdf</code> is strictly positive
must be connected.
The <code>center</code> is a point where the <code>pdf</code> is not too
small, e.g., (a point near) the mode of the distribution.
</p>
<p>If the density <code>pdf</code> is given, then the algorithm automatically
computes the CDF using Gauss-Lobatto integration.
If the <code>cdf</code> is given but not the <code>pdf</code> then the CDF is used
instead of the PDF. However, we found in our experiments that using
the PDF is numerically more stable.
</p>
<p>Alternatively, one can use function <code>pinvd.new</code> where the object
<code>distr</code> of class <code>"unuran.cont"</code> must contain all required
information about the distribution.
</p>
<p>The algorithm approximates the inverse of the CDF of the
distribution by means of Newton interpolation between carefully
selected nodes. The approxiating functing is thus continuous.
Argument <code>smooth</code> controls whether this function is also
differentiable(“smooth”) at the nodes.
Using <code>smooth=TRUE</code> requires the <code>pdf</code> of the
distribution. It results in a higher setup time and memory
consumption. Thus using <code>smooth=TRUE</code> is not
<em>not recommended</em>, unless differentiability is important.
</p>
<p>The approximation error is estimated by means of the the
u-error, i.e., <code class="reqn">|CDF(G(U)) - U|</code>,
where <code class="reqn">G</code> denotes the approximation of the inverse CDF.
The error can be controlled by means of argument <code>uresolution</code>.
</p>
<p>When sampling from truncated distributions with extreme
truncation points, it is recommended to provide the log-density
by setting <code>islog=TRUE</code>. Then the algorithm is numerically more
stable.
</p>
<p>The setup time of this method depends on the given PDF, whereas its
marginal generation times are independent of the target
distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>"unuran"</code>.
</p>


<h3>Remark</h3>

<p>Using function <code>up</code> generator objects that implement
method ‘PINV’ may also be used to approximate the cumulative
distribution function of the given distribution when only the density
is given. The approximation error is about one tenth of the requested
<code>uresolution</code>.
</p>


<h3>Author(s)</h3>

<p>Josef Leydold and Wolfgang H\"ormann
<a href="mailto:unuran@statmath.wu.ac.at">unuran@statmath.wu.ac.at</a>.
</p>


<h3>References</h3>

<p>G. Derflinger, W. H\"ormann, and J. Leydold (2010):
Random variate generation by numerical inversion when only the density
is known. 
ACM Trans. Model. Comput. Simul., 20:4, #18
</p>


<h3>See Also</h3>

<p><code>ur</code>, <code>uq</code>, <code>up</code>,
<code>unuran.cont</code>,
<code>unuran.new</code>, 
<code>unuran</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Create a sample of size 100 for a Gaussian distribution
pdf &lt;- function (x) { exp(-0.5*x^2) }
gen &lt;- pinv.new(pdf=pdf, lb=-Inf, ub=Inf)
x &lt;- ur(gen,100)

## Create a sample of size 100 for a 
## Gaussian distribution (use logPDF)
logpdf &lt;- function (x) { -0.5*x^2 }
gen &lt;- pinv.new(pdf=logpdf, islog=TRUE, lb=-Inf, ub=Inf)
x &lt;- ur(gen,100)

## Draw sample from Gaussian distribution with mean 1 and
## standard deviation 2. Use 'dnorm'.
gen &lt;- pinv.new(pdf=dnorm, lb=-Inf, ub=Inf, mean=1, sd=2)
x &lt;- ur(gen,100)

## Draw a sample from a truncated Gaussian distribution
## on domain [2,Inf)
gen &lt;- pinv.new(pdf=dnorm, lb=2, ub=Inf)
x &lt;- ur(gen,100)

## Improve the accuracy of the approximation
gen &lt;- pinv.new(pdf=dnorm, lb=-Inf, ub=Inf, uresolution=1e-15)
x &lt;- ur(gen,100)

## We have to provide a 'center' when PDF (almost) vanishes at 0.
gen &lt;- pinv.new(pdf=dgamma, lb=0, ub=Inf, center=4, shape=5)
x &lt;- ur(gen,100)

## We also can force a smoother approximation
gen &lt;- pinv.new(pdf=dnorm, lb=-Inf, ub=Inf, smooth=TRUE)
x &lt;- ur(gen,100)

## Alternative approach
distr &lt;- udnorm()
gen &lt;- pinvd.new(distr)
x &lt;- ur(gen,100)

</code></pre>


</div>