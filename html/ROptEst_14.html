<div class="container">

<table style="width: 100%;"><tr>
<td>internals_for_ROptEst</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal / Helper functions of package ROptEst</h2>

<h3>Description</h3>

<p>These functions are used internally by package <span class="pkg">ROptEst</span>.</p>


<h3>Usage</h3>

<pre><code class="language-R">### helper function to check whether given b is in (bmin, bmax)
###        if not returns corresponding upper / lower case solution

.checkUpLow(L2deriv, b, risk, neighbor, biastype, normtype,
                        Distr, Finfo, DistrSymm, L2derivSymm,
                        L2derivDistrSymm, z.start, A.start, trafo, maxiter,
                        tol, QuadForm, verbose, nrvalpts, warn, ...)
                        
### helper function to return the upper case solution if r=0
.getUpperSol(L2deriv, radius, risk, neighbor, biastype,
                       normtype, Distr, Finfo, trafo,
                       QuadForm, verbose, warn, ...)

### helper function to return the lower case solution if b-search was not successful
.getLowerSol(L2deriv, risk, neighbor, Distr, DistrSymm,
                         L2derivSymm, L2derivDistrSymm,
                         z.start, A.start, trafo,
                         maxiter, tol, warn, Finfo, QuadForm, verbose, ...)


### helper function to return upper &amp; lower bounds for b for b-search
.getLowUpB(L2deriv, Finfo, Distr, normtype, z, A, radius, iter)

### helper function to check whether (TotalVariation) weight w has already been modified
.isVirginW(w)

### helper function to check whether (intermediate) results give a pIC
.checkPIC(L2deriv, neighbor, Distr, trafo, z, A, w, z.comp, A.comp, ...)

.LowerCaseMultivariate(L2deriv, neighbor, biastype,
             normtype, Distr, Finfo, trafo, z.start = NULL,
             A.start = NULL, z.comp = NULL, A.comp = NULL,
             maxiter, tol, verbose = NULL, ...)

.LowerCaseMultivariateTV(L2deriv, neighbor, biastype,
             normtype, Distr, Finfo, trafo,
             A.start,  maxiter, tol,
             verbose = NULL, ...)

.getSB(IC,neighbor, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family
of probability measures. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>numeric; clipping bound under consideration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>biastype</code></td>
<td>
<p>object of class <code>"BiasType"</code> — the bias type with we work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normtype</code></td>
<td>
<p>object of class <code>"NormType"</code> — the norm type with we work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Finfo</code></td>
<td>
<p> Fisher information matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DistrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>QuadForm</code></td>
<td>
<p> matrix of (or which may coerced to) class
<code>PosSemDefSymmMatrix</code> for use of different
(standardizing) norm </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrvalpts</code></td>
<td>
<p>integer: number of evaluation points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p> logical: print warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>radius of the neighborhood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>centering constant (in <code>k</code>-space)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>standardizing matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>a weight of class <code>"BdStWeight"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.comp</code></td>
<td>
<p>logical vector: indicator which components of <code>z</code> need
to be computed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.comp</code></td>
<td>
<p>logical matrix: indicator which components of <code>A</code> need
to be computed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>the number of iterations computed so far; used for specifying
a different value of the clipping component of the weight in
total variation case in the very first iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC</code></td>
<td>
<p>some IC of class <code>"IC"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed on <code>E()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>.checkUpLow</code> checks whether the given clipping height <code>b</code> lies in
<code class="reqn">(b_{\rm\scriptstyle min},b_{\rm\scriptstyle min})</code>;
<code>.getUpperSol</code> determines the upper case/classical solution and computes
corresponding risks
<code>.getLowerSol</code> determines the lower case (minimax bias) solution and computes
corresponding risks
<code>.getLowUpB</code> determines a search interval for <code>b</code> to given radius
<code>r</code>, i.e., lower and upper bounds for
<code class="reqn">(b_{\rm\scriptstyle min},b_{\rm\scriptstyle min})</code>
<code>.isVirginW</code> checks whether the (total variation) weight <code>w</code> in
the argument has already been modified since creation (<code>TRUE</code> if not)
<code>.checkPIC</code> checks whether (intermediate) results give a pIC
<code>.LowerCaseMultivariatefunction</code> determines the Lagrange multipliers for
the multivariate lower case solution for convex contamination
by solving a corresponding dual problem (Rieder[94],p.199 eq.(18)).
<code>.LowerCaseMultivariatefunctionTV</code> determines the Lagrange multipliers for
the multivariate lower case solution for total variation in dimension <code class="reqn">p=1</code>
and <code class="reqn">k&gt;1</code> by solving a corresponding dual problem (Rieder[94],p.205 eq.(58)).
<code>.getSB</code> computes the bias and (the square root of the trace of) the variance
of the IC.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.checkUpLow</code></td>
<td>
<p>a list with items <code>up</code> (logical)
<code>low</code> (logical) and <code>res</code> a return list for
<code>getInfRobIC</code> or <code>NULL</code>: if <code>up</code> is <code>TRUE</code>,
<code>res</code> contains the upper case solution,
if <code>low</code> is <code>TRUE</code> the lower case solution
and if both <code>low</code> and <code>up</code> are <code>FALSE</code>
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.getUpperSol</code></td>
<td>
<p>a return list for <code>getInfRobIC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.getLowerSol</code></td>
<td>
<p>a return list for <code>getInfRobIC</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.checkUpLow</code></td>
<td>
<p>a list with items <code>lower</code> and <code>upper</code> (both numeric).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.isVirginW</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.checkPIC</code></td>
<td>
<p>nothing is returned; precision values are issued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.LowerCaseMultivariatefunction</code></td>
<td>
<p>a list with elements
<code>erg</code> the return value of the corresponding call to <code>optim</code>,
<code>w</code> the corresponding weight (of class <code>HampelWeight</code>),
<code>normtype</code> the norm —possibly modified,
<code>z.comp</code> the indices of non-null entries in <code>z</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.LowerCaseMultivariatefunctionTV</code></td>
<td>
<p>a list with elements
<code>A</code> the standardization matrix,
<code>b</code> the minimax bias,
<code>w</code> the corresponding weight (of class <code>BdStWeight</code>),
<code>a</code> the corresponding infimum of the [p]IC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.getSB</code></td>
<td>
<p>a list with elements <code>s</code>, (the square root of the trace of) 
the variance and <code>b</code>, the bias.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>References</h3>

<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


</div>