<div class="container">

<table style="width: 100%;"><tr>
<td>predict.RNAmf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>prediction of the RNAmf emulator with 2 or 3 fidelity levels.</h2>

<h3>Description</h3>

<p>The function computes the posterior mean and variance of RNA models with two or three fidelity levels
by fitted model using <code>RNAmf_two_level</code> or <code>RNAmf_three_level</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'RNAmf'
predict(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a class <code>RNAmf</code> object fitted by <code>RNAmf_two_level</code> or <code>RNAmf_three_level</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector or matrix of new input locations to predict.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>for compatibility with generic method <code>predict</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>From the model fitted by <code>RNAmf_two_level</code> or <code>RNAmf_three_level</code>,
the posterior mean and variance are calculated based on the closed form expression derived by a recursive fashion.
The formulas depend on its kernel choices.
For details, see Heo and Sung (2024, &lt;<a href="https://doi.org/10.1080/00401706.2024.2376173">doi:10.1080/00401706.2024.2376173</a>&gt;).
</p>


<h3>Value</h3>


<ul>
<li> <p><code>mu</code>: vector of predictive posterior mean.
</p>
</li>
<li> <p><code>sig2</code>: vector of predictive posterior variance.
</p>
</li>
<li> <p><code>time</code>: a scalar of the time for the computation.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>RNAmf_two_level</code> or <code>RNAmf_three_level</code> for the model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### two levels example ###
library(lhs)

### Perdikaris function ###
f1 &lt;- function(x) {
  sin(8 * pi * x)
}

f2 &lt;- function(x) {
  (x - sqrt(2)) * (sin(8 * pi * x))^2
}

### training data ###
n1 &lt;- 13
n2 &lt;- 8

### fix seed to reproduce the result ###
set.seed(1)

### generate initial nested design ###
X &lt;- NestedX(c(n1, n2), 1)
X1 &lt;- X[[1]]
X2 &lt;- X[[2]]

### n1 and n2 might be changed from NestedX ###
### assign n1 and n2 again ###
n1 &lt;- nrow(X1)
n2 &lt;- nrow(X2)

y1 &lt;- f1(X1)
y2 &lt;- f2(X2)

### n=100 uniform test data ###
x &lt;- seq(0, 1, length.out = 100)

### fit an RNAmf ###
fit.RNAmf &lt;- RNAmf_two_level(X1, y1, X2, y2, kernel = "sqex")

### predict ###
predy &lt;- predict(fit.RNAmf, x)$mu
predsig2 &lt;- predict(fit.RNAmf, x)$sig2

### RMSE ###
print(sqrt(mean((predy - f2(x))^2)))

### visualize the emulation performance ###
plot(x, predy,
  type = "l", lwd = 2, col = 3, # emulator and confidence interval
  ylim = c(-2, 1)
)
lines(x, predy + 1.96 * sqrt(predsig2 * length(y2) / (length(y2) - 2)), col = 3, lty = 2)
lines(x, predy - 1.96 * sqrt(predsig2 * length(y2) / (length(y2) - 2)), col = 3, lty = 2)

curve(f2(x), add = TRUE, col = 1, lwd = 2, lty = 2) # high fidelity function

points(X1, y1, pch = 1, col = "red") # low-fidelity design
points(X2, y2, pch = 4, col = "blue") # high-fidelity design

### three levels example ###
### Branin function ###
branin &lt;- function(xx, l){
  x1 &lt;- xx[1]
  x2 &lt;- xx[2]
  if(l == 1){
    10*sqrt((-1.275*(1.2*x1+0.4)^2/pi^2+5*(1.2*x1+0.4)/pi+(1.2*x2+0.4)-6)^2 +
    (10-5/(4*pi))*cos((1.2*x1+0.4))+ 10) + 2*(1.2*x1+1.9) - 3*(3*(1.2*x2+2.4)-1) - 1 - 3*x2 + 1
  }else if(l == 2){
    10*sqrt((-1.275*(x1+2)^2/pi^2+5*(x1+2)/pi+(x2+2)-6)^2 +
    (10-5/(4*pi))*cos((x1+2))+ 10) + 2*(x1-0.5) - 3*(3*x2-1) - 1
  }else if(l == 3){
    (-1.275*x1^2/pi^2+5*x1/pi+x2-6)^2 + (10-5/(4*pi))*cos(x1)+ 10
  }
}

output.branin &lt;- function(x, l){
  factor_range &lt;- list("x1" = c(-5, 10), "x2" = c(0, 15))

  for(i in 1:length(factor_range)) x[i] &lt;- factor_range[[i]][1] + x[i] * diff(factor_range[[i]])
  branin(x[1:2], l)
}

### training data ###
n1 &lt;- 20; n2 &lt;- 15; n3 &lt;- 10

### fix seed to reproduce the result ###
set.seed(1)

### generate initial nested design ###
X &lt;- NestedX(c(n1, n2, n3), 2)
X1 &lt;- X[[1]]
X2 &lt;- X[[2]]
X3 &lt;- X[[3]]

### n1, n2 and n3 might be changed from NestedX ###
### assign n1, n2 and n3 again ###
n1 &lt;- nrow(X1)
n2 &lt;- nrow(X2)
n3 &lt;- nrow(X3)

y1 &lt;- apply(X1,1,output.branin, l=1)
y2 &lt;- apply(X2,1,output.branin, l=2)
y3 &lt;- apply(X3,1,output.branin, l=3)

### n=10000 grid test data ###
x &lt;- as.matrix(expand.grid(seq(0, 1, length.out = 100),seq(0, 1, length.out = 100)))

### fit an RNAmf ###
fit.RNAmf &lt;- RNAmf_three_level(X1, y1, X2, y2, X3, y3, kernel = "sqex")

### predict ###
pred.RNAmf &lt;- predict(fit.RNAmf, x)
predy &lt;- pred.RNAmf$mu
predsig2 &lt;- pred.RNAmf$sig2

### RMSE ###
print(sqrt(mean((predy - apply(x,1,output.branin, l=3))^2)))

### visualize the emulation performance ###
x1 &lt;- x2 &lt;- seq(0, 1, length.out = 100)
oldpar &lt;- par(mfrow=c(1,2))
image(x1, x2, matrix(apply(x,1,output.branin, l=3), ncol=100),
zlim=c(0,310), main="Branin function")
image(x1, x2, matrix(predy, ncol=100),
zlim=c(0,310), main="RNAmf prediction")
par(oldpar)

### predictive variance ###
print(predsig2)

</code></pre>


</div>