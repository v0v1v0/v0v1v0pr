<div class="container">

<table style="width: 100%;"><tr>
<td>parse_source_by_coderId</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parsing sources separately for each coder</h2>

<h3>Description</h3>

<p>Parsing sources separately for each coder
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_source_by_coderId(
  input,
  ignoreOddDelimiters = FALSE,
  postponeDeductiveTreeBuilding = TRUE,
  rlWarn = rock::opts$get(rlWarn),
  encoding = "UTF-8",
  silent = TRUE
)

parse_sources_by_coderId(
  input,
  recursive = TRUE,
  filenameRegex = ".*",
  ignoreOddDelimiters = FALSE,
  postponeDeductiveTreeBuilding = TRUE,
  encoding = rock::opts$get(encoding),
  silent = rock::opts$get(silent)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>For <code>parse_source_by_coderId</code>, either a character vector
containing the text of the relevant source <em>or</em> a path to a file that
contains the source text; for <code>parse_sources_by_coderId</code>, a path to a
directory that contains the sources to parse.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignoreOddDelimiters</code></td>
<td>
<p>If an odd number of YAML delimiters is encountered, whether this
should result in an error (<code>FALSE</code>) or just be silently ignored (<code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>postponeDeductiveTreeBuilding</code></td>
<td>
<p>Whether to imediately try to build the deductive
tree(s) based on the information in this file (<code>FALSE</code>) or whether to skip that. Skipping
this is useful if the full tree information is distributed over multiple files (in which case
you should probably call <code>parse_sources</code> instead of <code>parse_source</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rlWarn</code></td>
<td>
<p>Whether to let <code>readLines()</code> warn, e.g. if files do not end
with a newline character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>encoding</code></td>
<td>
<p>The encoding of the file to read (in <code>file</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>Whether to provide (<code>FALSE</code>) or suppress (<code>TRUE</code>) more detailed progress updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>Whether to search all subdirectories (<code>TRUE</code>) as well or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filenameRegex</code></td>
<td>
<p>A regular expression to match against located files; only
files matching this regular expression are processed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>For <code>rock::parse_source_by_coderId()</code>, an object of
class <code>rock_parsedSource</code>; for <code>rock::parse_sources_by_coderId()</code>, an
object of class <code>rock_parsedSources</code>. These objects contain the original
source(s) as well as the final data frame with utterances and codes, as
well as the code structures.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### Get path to example source
examplePath &lt;-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile &lt;-
  file.path(examplePath, "example-1.rock");

### Parse single example source
parsedExample &lt;- rock::parse_source_by_coderId(exampleFile);

</code></pre>


</div>