<div class="container">

<table style="width: 100%;"><tr>
<td>sReplace</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Helper function for value replacement</h2>

<h3>Description</h3>

<p>The function is not intended for direct use. Once called by replaceVals
it firstly checks for index presence in lookup. Upon the result of this check, the
function moves along the branches of a decision tree (see Details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">sReplace(x, y0, uv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y0</code></td>
<td>
<p>Data.tables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uv</code></td>
<td>
<p>Character vector or list of same length as x, containing unique names of
involved columns in data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function starts by checking the presence of a User-made index in lookup.
</p>


<h4>If the index is found absent</h4>

<p>The function calls the helper whichDups to find the duplicated values in data. Also, looks for missing
values set for <em>multiple</em> replacements and for eventual splits on missing data. In case of mixed <em>simple/multiple</em>
requests the function splits lookup into maximum 3 subsets: one for <em>simple</em> replacements, for which it creates an
internal index, one for <em>multiple replacements</em> of duplicated values for which it creates an internal index, and one
for <em>multiple replacements</em> of missing values for which an internal index is not necessary.
</p>


<h5>Index for multiple replacements of duplicated values</h5>

<p>The internal index contains row numbers corresponding to all the elements of distinct subsets of duplicated values
found within each involved data column and loops the function <code>data.table::set()</code> to perform replacements on these
columns.
</p>



<h5>No Index for multiple replacements of missing values</h5>

<p>As mentioned above, no index is created for multiple replacements of missing values as there is only one generic value
per data column. The missing values data subset is then <em>reshaped</em>, and the columns are <em>coalesced</em> (see <code>data.table</code>
Manual) with corresponding data columns, for each generic value entered in lookup.
</p>



<h5>Index For Unique Values</h5>

<p>As stated above, simple replacements of unique values without User-made index are possible. Once the internal index
created, the subset is <em>reshaped</em>, <em>joined</em> with the data on index and the corresponding columns are <em>coalesced</em>.
</p>




<h4>If the index is found present</h4>

<p>The function subsets the lookup using the special index values <strong>0</strong> and/or <strong>NA</strong> (or empty). At maximum, 3 subsets
of lookup are formed as above. The replacement process is similar with the process used for absent index with the
difference that simple replacements already have User-made index.
</p>



<h4>Value replacement</h4>

<p>Following the decision tree described above, the function calls utility's helpers and functions imported from the
<strong>data.table</strong> package to process all lookup requests, in one single run.
</p>



<h3>Value</h3>

<p>A named list containing updated involved columns in x, count of multiple replacements
of duplicated values (if requested), count of multiple replacements of missing values
(if requested).
</p>


<h3>See Also</h3>

<p>dcast, fcoalesce,
merge, set
</p>


</div>