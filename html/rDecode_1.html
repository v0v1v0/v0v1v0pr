<div class="container">

<table style="width: 100%;"><tr>
<td>decode</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Descent-based Calibrated Optimal Direct Estimation</h2>

<h3>Description</h3>

<p>Implement <code>DECODE</code> for <code>sigma</code> and <code>beta</code> to estimate <code class="reqn">\Sigma^{-1}\beta</code> where <code>sigma</code> is an estimator of <code class="reqn">\Sigma</code> and <code>beta</code> is an estimator of <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">decode(sigma, beta, lambda0, decode.tol = 1e-06, decode.maxit = 100,
  trace = FALSE, solver = c("apg", "homotopy"), solver.tol = 1e-08,
  solver.maxit = 10000, return.sigma = FALSE, return.beta = FALSE,
  return.param = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p><code class="reqn">p \times p</code> positive semidefinite symmetric matrix. <code>sigma</code> will be perturbed if needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p><code class="reqn">p</code>-length vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p>number between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decode.tol</code></td>
<td>
<p>error tolerance for <code>DECODE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decode.maxit</code></td>
<td>
<p>maximum iterations for <code>DECODE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical. If <code>TRUE</code>, will return <code class="reqn">\eta</code>, <code class="reqn">\theta</code>, and <code class="reqn">\lambda</code> found during each iteration of <code>DECODE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver</code></td>
<td>
<p>solver for <code class="reqn">\ell_1</code>-RQP problem inside <code>DECODE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.tol</code></td>
<td>
<p>tolerance for solver.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.maxit</code></td>
<td>
<p>maximum iterations for solver (only for APG).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.sigma</code></td>
<td>
<p>logical. If <code>TRUE</code> the <code>sigma</code> entered is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.beta</code></td>
<td>
<p>logical. If <code>TRUE</code> the <code>beta</code> entered is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.param</code></td>
<td>
<p>logical. If <code>TRUE</code> the parameters used are returned.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>decode</code> containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p><code>DECODE</code> of <code class="reqn">\Sigma^{-1}\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>final <code class="reqn">\theta</code> of the <code>DECODE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>final <code class="reqn">\lambda</code> of the <code>DECODE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.mult</code></td>
<td>
<p>multiplier applied on <code>sigma</code> to ensure convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total.iter</code></td>
<td>
<p>number of iterations until convergence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>the solver used, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda0</code></td>
<td>
<p>the <code>lambda0</code> entered, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decode.tol</code></td>
<td>
<p>the <code>decode.tol</code> used, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decode.maxit</code></td>
<td>
<p>the <code>decode.maxit</code> used, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>the <code>trace</code> used, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.tol</code></td>
<td>
<p>the <code>solver.tol</code> used, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solver.maxit</code></td>
<td>
<p>the <code>solver.maxit</code> used, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta.trace</code></td>
<td>
<p>matrix of <code class="reqn">\eta</code> used in each iteration, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.trace</code></td>
<td>
<p>vector of <code class="reqn">\theta</code> used in each iteration, if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.trace</code></td>
<td>
<p>vector of <code class="reqn">\lambda</code> used in each iteration, if requested.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Pun, C. S. (2018). A Sparse Learning Approach to Relative-Volatility-Managed Portfolio Selection.
Hadimaja, M. Z., &amp; Pun, C. S. (2018). A Self-Calibrated Regularized Direct Estimation for Graphical Selection and Discriminant Analysis.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># estimate A^(-1) b with a certain lambda0
X &lt;- matrix(rnorm(100), 10, 10)
A &lt;- t(X) %*% X
b &lt;- rnorm(10)
object &lt;- decode(A, b, lambda0 = 0.8)

object
summary(object)

coef(object)

</code></pre>


</div>