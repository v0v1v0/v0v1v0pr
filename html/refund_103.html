<div class="container">

<table style="width: 100%;"><tr>
<td>sff</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct a smooth function-on-function regression term</h2>

<h3>Description</h3>

<p>Defines a term <code class="reqn">\int^{s_{hi, i}}_{s_{lo, i}} f(X_i(s), s, t) ds</code> for
inclusion in an <code>mgcv::gam</code>-formula (or <code>bam</code> or <code>gamm</code> or
<code>gamm4:::gamm</code>) as constructed by <code>pffr</code>. Defaults to a
cubic tensor product B-spline with marginal second differences penalties for
<code class="reqn">f(X_i(s), s, t)</code> and integration over the entire range <code class="reqn">[s_{lo, i},
s_{hi, i}] = [\min(s_i), \max(s_i)]</code>. Can't deal with any missing <code class="reqn">X(s)</code>,
unequal lengths of <code class="reqn">X_i(s)</code> not (yet?) possible. Unequal ranges for
different <code class="reqn">X_i(s)</code> should work. <code class="reqn">X_i(s)</code> is assumed to be numeric.<br><code>sff()</code> IS AN EXPERIMENTAL FEATURE AND NOT WELL TESTED YET â€“ USE AT
YOUR OWN RISK.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sff(
  X,
  yind,
  xind = seq(0, 1, l = ncol(X)),
  basistype = c("te", "t2", "s"),
  integration = c("simpson", "trapezoidal"),
  L = NULL,
  limits = NULL,
  splinepars = list(bs = "ps", m = c(2, 2, 2))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an n by <code>ncol(xind)</code> matrix of function evaluations
<code class="reqn">X_i(s_{i1}),\dots, X_i(s_{iS})</code>; <code class="reqn">i=1,\dots,n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yind</code></td>
<td>
<p><em>DEPRECATED</em> matrix (or vector) of indices of evaluations of
<code class="reqn">Y_i(t)</code>; i.e. matrix with rows <code class="reqn">(t_{i1},\dots,t_{iT})</code>; no longer
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xind</code></td>
<td>
<p>vector of indices of evaluations of <code class="reqn">X_i(s)</code>,
i.e, <code class="reqn">(s_{1},\dots,s_{S})</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basistype</code></td>
<td>
<p>defaults to "<code>te</code>", i.e. a tensor product
spline to represent <code class="reqn">f(X_i(s), t)</code>. Alternatively, use <code>"s"</code> for
bivariate basis functions (see <code>s</code>) or <code>"t2"</code> for an
alternative parameterization of tensor product splines (see
<code>t2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integration</code></td>
<td>
<p>method used for numerical integration. Defaults to
<code>"simpson"</code>'s rule. Alternatively and for non-equidistant grids,
<code>"trapezoidal"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>optional: an n by <code>ncol(xind)</code> giving the weights for the
numerical integration over <code class="reqn">s</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>
<p>defaults to NULL for integration across the entire range of
<code class="reqn">X(s)</code>, otherwise specifies the integration limits <code class="reqn">s_{hi, i},
s_{lo, i}</code>: either one of <code>"s&lt;t"</code> or <code>"s&lt;=t"</code> for <code class="reqn">(s_{hi,
i}, s_{lo, i}) = (0, t)</code> or a function that takes <code>s</code> as the first and
<code>t</code> as the second argument and returns TRUE for combinations of values
<code>(s,t)</code> if <code>s</code> falls into the integration range for the given
<code>t</code>. This is an experimental feature and not well tested yet; use at
your own risk.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splinepars</code></td>
<td>
<p>optional arguments supplied to the <code>basistype</code>-term.
Defaults to a cubic tensor product B-spline with marginal second
differences, i.e. <code>list(bs="ps", m=c(2,2,2))</code>. See
<code>te</code> or <code>s</code> for details</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list containing </p>
 <ul>
<li> <p><code>call</code> a "call" to
<code>te</code> (or <code>s</code>, <code>t2</code>)
using the appropriately constructed covariate and weight matrices (see
<code>linear.functional.terms</code>) </p>
</li>
<li> <p><code>data</code> a list
containing the necessary covariate and weight matrices </p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Fabian Scheipl, based on Sonja Greven's trick for fitting functional
responses.
</p>


</div>