<div class="container">

<table style="width: 100%;"><tr>
<td>reprompt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Update the documentation of a topic</h2>

<h3>Description</h3>

<p>Examine the documentation of functions, methods or classes and
update it with additional arguments, aliases, methods or slots, as
appropriate. This is an extention of the promptXXX() family of functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">reprompt(object, infile = NULL, Rdtext = NULL, final = TRUE, 
         type = NULL, package = NULL, methods = NULL, verbose = TRUE, 
         filename = NULL, sec_copy = TRUE, edit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>the object whose documentation is to be updated, such as
a string, a function, a help topic, a parsed Rd object, see
‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>infile</code></td>
<td>
<p>a file name containing Rd documentation, see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rdtext</code></td>
<td>
<p>a character string with Rd formatted text, see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>final</code></td>
<td>
<p>logical, if <code>TRUE</code> modifies the output of
<code>prompt</code> so that the package can be built.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of topic, such as <code>"methods"</code> or
<code>"class"</code>, see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>package</code></td>
<td>
<p>package name; document only objects defined in this
package, especially useful for methods, see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods</code></td>
<td>

<p>used for documentation of S4 methods only, rarely needed even for
them.  This argument is passed on to
<code>promptMethods</code>, see its documentation for
details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code> print messages on the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>name of the file for the generated Rd content; if
<code>NULL</code>, a suitable file name is generated, if <code>TRUE</code> it
will be set to <code>infile</code>,   
if <code>FALSE</code> the Rd text is returned, see ‘Details’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>currently not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sec_copy</code></td>
<td>
<p>if <code>TRUE</code> copy Rd contents of unchanged sections
in the result, see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edit</code></td>
<td>
<p>if <code>TRUE</code> call <code>file.edit</code> just before
returning. This argument is ignored if <code>filename</code> is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The typical use of <code>reprompt</code> is with one argument, as in
</p>
<pre>
    reprompt(infile = "./Rdpack/man/reprompt.Rd")
    reprompt(reprompt)
    reprompt("reprompt")
  </pre>
<p><code>reprompt</code> updates the requested documentation and writes the new
Rd file in the current working directory. When argument <code>infile</code>
is used, the descriptions of all objects described in the input file
are updated. When an object or its name is given, <code>reprompt</code>
looks first for installed documentation and processes it in the same
way as in the case of <code>infile</code>. If there is no documentation for
the object, <code>reprompt</code> creates a skeleton Rd file similar to the
one produced by the base R functions from the <code>prompt</code> family (if
<code>final = TRUE</code>, the default, it modifies the output of
<code>prompt()</code>, so that the package can be built).
</p>
<p>To document a function, say <code>myfun</code>, in an existing Rd file, just
add <code>myfun()</code> to the usage section in the file and call
<code>reprompt()</code> on that file. Put quotes around the function name if
it is non-syntactic.  For replacement functions (functions with names
ending in <code>&lt;-</code>) <code>reprompt()</code> will insert the proper usage
statement. For example, if the signature of <code>xxx&lt;-</code> is <code>(x,
  ..., value)</code> then both, <code>"xxx&lt;-"()</code> and <code>xxx() &lt;- value</code>
will be replaced by <code>xxx(x, ...) &lt;- value</code>.
</p>
<p>For S4 methods and classes the argument "package" is often needed to
restrict the output to methods defined in the package of interest.
</p>
<pre>
    reprompt("myfun-methods")

    reprompt("[&lt;--methods", package = "mypackage")             
    reprompt("[&lt;-", type = "methods", package = "mypackage") # same

    reprompt("myclass", type = "class", package = "mypackage") 
    reprompt("myclass-class", package = "mypackage")         # same
  </pre>
<p>Without the "package" argument the reprompt for <code>"[&lt;-"</code> would give
all methods defined by loaded packages at the time of the call. 
</p>
<p>Currently <code>reprompt</code> functionality is not implemented for topic
"package" but if <code>object</code> has the form "name-package" (or the
equivalent with argument <code>topic</code>) and there is no documentation
for <code>package?name</code>, <code>reprompt</code> calls
<code>promptPackageSexpr</code> to create the required shell.
Note that the shell produced by <code>promptPackageSexpr</code> does not
need ‘reprompting’ since the automatically generated information is
included by <code style="white-space: pre;">⁠\Sexpr⁠</code>'s, not literal strings.
</p>
<p>Below are the details.
</p>
<p>Typically, only one of <code>object</code>, <code>infile</code>, and <code>Rdtext</code>
is supplied. Warning messages are issued if this is not the case.
</p>
<p>The object must have been made available by the time when
<code>reprompt()</code> is issued. If the object is in a package this is
typically achieved by a <code>library()</code> command.
</p>
<p><code>object</code> may be a function or a name, as accepted by the <code>?</code>
operator. If it has the form "name-class" and "name-methods" a
documentation shell for class "name" or the methods for generic function
"name" will be examined/created. Alternatively, argument <code>type</code>
may be set to "class" or "methods" to achieve the same effect.
</p>
<p><code>infile</code> specifies a documentation file to be updated. If it
contains the documentation for one or more functions, <code>reprompt</code>
examines their usage statements and updates them if they have
changed. It also adds arguments to the "arguments" section if not all
arguments in the usage statements have entries there. If <code>infile</code>
describes the methods of a function or a class, the checks made are as
appropriate for them. For example, new methods and/or slots are added
to the corresponding sections.
</p>
<p>It is all too easy in interactive use to forget to name the
<code>infile</code> argument, compare<br><code>reprompt("./man/reprompt.Rd")</code> vs.
<code>reprompt(infile = "./man/reprompt.Rd")</code>).<br>
A convenience feature is that if <code>infile</code> is missing
and <code>object</code> is a character string ending in ".Rd" and containing
a forward slash (i.e. it looks like Rd file in a directory), then it
is taken to be <code>infile</code>. 
</p>
<p><code>Rdtext</code> is similar to <code>infile</code> but the Rd content is taken
from a character vector.
</p>
<p>If Rd content is supplied by <code>infile</code> or <code>Rdtext</code>,
<code>reprompt</code> uses it as a basis for comparison. Otherwise it tries
to find installed documentation for the object or topic requested.
If that fails, it resorts to one of the <code>promptXXX</code> functions to
generate a documentation shell. If that also fails, the requested
object or topic does not exist.
</p>
<p>If the above succeeds, the function examines the current definition of
the requested object(s), methods, or class and amends the
documentation with any additional items it finds.
</p>
<p>For Rd objects describing one or more functions, the usage expressions
are checked and replaced, if they have changed. Arguments appearing in
one or more usage expressions and missing from section "Arguments" are
amended to it with content "Describe ..."  and a message is
printed. Arguments no longer in the usage statements are NOT removed
but a message is issued to alert the user. Alias sections are inserted
for any functions with "usage" but without "alias" section.
</p>
<p>If <code>filename</code> is a character string, it is used as is, so any
path should be included in the string.  Argument <code>filename</code>
usuallly is omitted since the automatically generated file name is
suitable in most cases. Exceptions are functions with non-standard
names (such as replacement functions whose names end in <code>"&lt;-"</code>)
for which the generated file names may not be acceptable on some
operating systems.
</p>
<p>If <code>filename</code> is missing or <code>NULL</code>, a suitable name is
generated as follows. If <code>infile</code> is supplied, <code>filename</code> is
set to a file with the same name in the current working directory
(i.e. any path information in <code>infile</code> is dropped). Otherwise,
<code>filename</code> is obtained by appending the name tag of the Rd object
with <code>".Rd"</code>. 
</p>
<p>If <code>filename</code> is <code>TRUE</code>, it is set to <code>infile</code> or, if
<code>infile</code> is missing or <code>NULL</code>, a suitable name is generated
as above. This can be used to change <code>infile</code> in place.
</p>
<p>If <code>filename</code> is <code>FALSE</code>, the Rd text is returned as a
character vector and not written to a file. 
</p>
<p>If <code>edit</code> is <code>TRUE</code>, the reprompted file is opened in an
editor, see also <code>ereprompt</code> (‘e’ for ‘edit’) which is
like <code>reprompt</code> but has as default <code>edit = TRUE</code> and some
other related settings.
</p>
<p><code>file.edit()</code> is used to call the editor.  Which editor is opened
depends on the OS and on the user configuration. RStudio users will
probably prefer the 'Reprompt' add-in or the underlying function
<code>RStudio_reprompt</code>.  Emacs users would normally have set
up <code>emacsclient</code> as their editor and this is automatically done
by EMACS/ESS (even on Windows).
</p>
<p>If argument <code>sec_copy</code> is <code>TRUE</code> (the default),
<code>reprompt</code> will, effectively, copy the contents of (some)
unchanged sections, thus ensuring that they are exactly the same as in
the original.  This needs additional work, since parsing an Rd file
and then exporting the created Rd object to an Rd file does not
necessarilly produce an identical Rd file (some escape sequences may
be changed in the process, for example).  Even though the new version
should be functionally equivalent to the original, such changes are
usually not desirable. For example, if such changes creep into the
Details section (which <code>reprompt</code> never changes) the user may be
annoyed or worried.
</p>


<h3>Value</h3>

<p>if <code>filename</code> is a character string or <code>NULL</code>, the name of
the file to which the updated shell was written.
</p>
<p>Otherwise, the Rd text is returned as a character vector.
</p>


<h3>Note</h3>

<p>The arguments of <code>reprompt</code> are similar to prompt, with some
additions. As in <code>prompt</code>, <code>filename</code> specifies the output
file. In <code>reprompt</code> a new argument, <code>infile</code>, specifies the
input file containing the Rd source.
</p>
<p>When <code>reprompt</code> is used to update sources of Rd documentation for
a package, it is best to supply the original Rd file in argument
<code>infile</code>. Otherwise, if the original Rd file contains
<code style="white-space: pre;">⁠\Sexpr⁠</code> commands, <code>reprompt</code> may not be able to recover the
original Rd content from the installed documentation. Also, the fields
(e.g. the keywords) in the installed documentation may not be were you
expect them to be. (This may be addressed in a future revision.)
</p>
<p>While <code>reprompt</code> adds new items to the documentation, it never
removes existing content. It only issues a suggestion to remove an
item, if it does not seem necessary any more (e.g. a removed argument
from a function definition).
</p>
<p><code>reprompt</code> handles usage statements for S3 and S4 methods
introduced with any of the macros <code style="white-space: pre;">⁠\method⁠</code>, <code style="white-space: pre;">⁠\S3method⁠</code> and
<code style="white-space: pre;">⁠\S4method⁠</code>, as in
<code style="white-space: pre;">⁠\method{fun}{class}(args...)⁠</code>. <code>reprompt</code> understands also
subsetting ans subassignment operators.  For example, suppose that the
<code>\arguments</code> section of file "bracket.Rd" contains these
directives (or any other wrong signatures):
</p>
<pre>
    \method{[}{ts}()
    \method{[[}{Date}()
</pre>
<p>Then <code>reprompt("./bracket.Rd")</code> will change them to
</p>
<pre>
    \method{[}{ts}(x, i, j, drop = TRUE)
    \method{[[}{Date}(x, \dots, drop = TRUE)
</pre>
<p>This works for the assignment operators and functions, as well. For
example, any of these
</p>
<pre>
    \method{`[&lt;-`}{POSIXlt}()
    \method{[}{POSIXlt}(x, j) &lt;- value
</pre>
<p>will be converted by <code>reprompt</code> to the standard form
</p>
<pre>
    \method{[}{POSIXlt}(x, i, j) &lt;- value
</pre>    
<p>Note that the quotes in <code>`[&lt;-`</code> above. 
</p>
<p>Usage statements for functions are split over two or more lines if
necessary. The user may edit them afterwards if the automatic
splitting is not appropriate, see below.
</p>
<p>The usage section of Rd objects describing functions is left intact if
the usage has not changed. To force <code>reprompt</code> to recreate the
usage section (e.g. to reformat long lines), invalidate the usage of
one of the described functions by removing an argument from its usage
expression.  Currently the usage section is recreated completely if
the usage of any of the described functions has changed. Manual
formatting may be lost in such cases.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code>ereprompt</code> which by default calls the editor on the
original file
</p>


<h3>Examples</h3>

<pre><code class="language-R">## note: usage of reprompt() is simple.  the examples below are bulky
##       because they simulate various usage scenarios with commands,
##       while in normal usage they would be due to editing.

## change to a temporary directory to avoid clogging up user's
cur_wd &lt;- getwd()
tmpdir &lt;- tempdir()
setwd(tmpdir)

## as for prompt() the default is to save in current dir as "seq.Rd".
## the argument here is a function, reprompt finds its doc and
## updates all objects described along with `seq'.
## (In this case there is nothing to update, we have not changed `seq'.)

fnseq &lt;- reprompt(seq)

## let's parse the saved Rd file (the filename is returned by reprompt)
rdoseq &lt;- tools::parse_Rd(fnseq)   # parse fnseq to see the result.
Rdo_show(rdoseq)

## we replace usage statements with wrong ones for illustration.
## (note there is an S3 method along with the functions)
dummy_usage &lt;- char2Rdpiece(paste("seq()", "\\method{seq}{default}()",
                   "seq.int()", "seq_along()", "seq_len()", sep="\n"),
                   "usage")
rdoseq_dummy &lt;- Rdo_replace_section(rdoseq, dummy_usage)
Rdo_show(rdoseq_dummy)  # usage statements are wrong

reprompt(rdoseq_dummy, file = "seqA.Rd")
Rdo_show(tools::parse_Rd("seqA.Rd"))  # usage ok after reprompt

## define function myseq() 
myseq &lt;- function(from, to, x){
    if(to &lt; 0) {
        seq(from = from, to = length(x) + to)
    } else seq(from, to)
}

## we wish to describe  myseq() along with seq();
##    it is sufficient to put myseq() in the usage section
##    and let reprompt() do the rest
rdo2 &lt;- Rdo_modify_simple(rdoseq, "myseq()", "usage")
reprompt(rdo2, file = "seqB.Rd")  # updates usage of myseq

## show the rendered result:
Rdo_show(tools::parse_Rd("seqB.Rd"))

## Run this if you wish to see the Rd file:
##   file.show("seqB.Rd")

reprompt(infile = "seq.Rd", filename = "seq2.Rd")
reprompt(infile = "seq2.Rd", filename = "seq3.Rd")

## Rd objects for installed help may need some tidying for human editing.
#hseq_inst &lt;- help("seq")
#rdo &lt;- utils:::.getHelpFile(hseq_inst)
rdo &lt;- Rdo_fetch("seq", "base")
rdo
rdo &lt;- Rdpack:::.Rd_tidy(rdo)          # tidy up (e.g. insert new lines
                                       #          for human readers)
reprompt(rdo) # rdo and rdoseq are equivalent
all.equal(reprompt(rdo), reprompt(rdoseq)) # TRUE

## clean up 
unlink("seq.Rd")         # remove temporary files
unlink("seq2.Rd")
unlink("seq3.Rd")
unlink("seqA.Rd")
unlink("seqB.Rd")

setwd(cur_wd)            # restore user's working directory
unlink(tmpdir)
</code></pre>


</div>