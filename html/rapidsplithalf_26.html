<div class="container">

<table style="width: 100%;"><tr>
<td>rapidsplit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>rapidsplit</h2>

<h3>Description</h3>

<p>A very fast algorithm for computing stratified permutated split-half reliability.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rapidsplit(
  data,
  subjvar,
  diffvars = NULL,
  stratvars = NULL,
  subscorevar = NULL,
  aggvar,
  splits = 6000,
  aggfunc = c("means", "medians"),
  errorhandling = list(type = c("none", "fixedpenalty"), errorvar = NULL, fixedpenalty =
    600, blockvar = NULL),
  standardize = FALSE,
  include.scores = TRUE,
  verbose = TRUE,
  check = TRUE
)

## S3 method for class 'rapidsplit'
print(x, ...)

## S3 method for class 'rapidsplit'
plot(
  x,
  type = c("average", "minimum", "maximum", "random", "all"),
  show.labels = TRUE,
  ...
)

rapidsplit.chunks(
  data,
  subjvar,
  diffvars = NULL,
  stratvars = NULL,
  subscorevar = NULL,
  aggvar,
  splits = 6000,
  aggfunc = c("means", "medians"),
  errorhandling = list(type = c("none", "fixedpenalty"), errorvar = NULL, fixedpenalty =
    600, blockvar = NULL),
  standardize = FALSE,
  include.scores = TRUE,
  verbose = TRUE,
  check = TRUE,
  chunks = 4,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Dataset, a <code>data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subjvar</code></td>
<td>
<p>Subject ID variable name, a <code>character</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diffvars</code></td>
<td>
<p>Names of variables that determine which conditions
need to be subtracted from each other, <code>character</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stratvars</code></td>
<td>
<p>Additional variables that the splits should
be stratified by; a <code>character</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subscorevar</code></td>
<td>
<p>A <code>character</code> variable identifying subgroups within
a participant's data from which separate scores should be computed.
To compute a participant's final score, these subscores will be averaged together.
A typical use case is the D-score of the implicit association task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggvar</code></td>
<td>
<p>Name of variable whose values to aggregate, a <code>character</code>.
Examples include reaction times and error rates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splits</code></td>
<td>
<p>Number of split-halves to average, an <code>integer</code>.
It is recommended to use around 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggfunc</code></td>
<td>
<p>The function by which to aggregate the variable
defined in <code>aggvar</code>; can be <code>"means"</code>, <code>"medians"</code>,
or a custom function (not a function name).
This custom function must take a numeric vector and output a single value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>errorhandling</code></td>
<td>
<p>A list with 4 named items, to be used to replace error trials
with the block mean of correct responses plus a fixed penalty, as in the IAT D-score.
The 4 items are <code>type</code> which can be set to <code>"none"</code> for no error replacement,
or <code>"fixedpenalty"</code> to replace error trials as described;
<code>errorvar</code> requires name of the <code>logical</code> variable indicating an incorrect response
(as <code>TRUE</code>); <code>fixedpenalty</code> indicates how much of a penalty should be added
to said block mean; and <code>blockvar</code> indicates the name of the block variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Whether to divide by scores by the subject's SD; a <code>logical</code>.
Regardless of whether error penalization is utilized, this standardization
will be based on the unpenalized SD of correct and incorrect trials, as in the IAT D-score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.scores</code></td>
<td>
<p>Include all individual split-half scores?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Display progress bars? Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>Check input for possible problems?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>rapidsplit</code> object to print or plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character argument indicating what should be plotted. 
By default, this plots the random split whose correlation is closest to the average.
However, this can also plot the random split with 
the <code>"minimum"</code> or <code>"maximum"</code> split-half correlation, or any <code>"random"</code> split. 
<code>"all"</code> splits can also be plotted together in one figure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.labels</code></td>
<td>
<p>Should participant IDs be shown above their points in the scatterplot?
Defaults to <code>TRUE</code> and is ignored when <code>type</code> is <code>"all"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunks</code></td>
<td>
<p>Number of chunks to divide the splits in, for more memory-efficient computation,
and to divide over multiple cores if requested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Chunks will be run on separate cores if a cluster is provided, 
or an <code>integer</code> specifying the number of cores. Otherwise, if the value is <code>NULL</code>,
the chunks are run sequentially.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The order of operations (with optional steps between brackets) is:
</p>

<ul>
<li>
<p> Splitting
</p>
</li>
<li>
<p> (Replacing error trials within block within split)
</p>
</li>
<li>
<p> Computing aggregates per condition (per subscore) per person
</p>
</li>
<li>
<p> Subtracting conditions from each other
</p>
</li>
<li>
<p> (Dividing the resulting (sub)score by the SD of the data used to compute that (sub)score)
</p>
</li>
<li>
<p> (Averaging subscores together into a single score per person)
</p>
</li>
<li>
<p> Correlating scores from one half with scores from the other half
</p>
</li>
<li>
<p> Computing the average split-half reliability using <code>cormean()</code>
</p>
</li>
<li>
<p> Applying the Spearman-Brown formula to the absolute correlation
using <code>spearmanBrown()</code>, and restoring the original sign after
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>list</code> containing
</p>

<ul>
<li> <p><code>r</code>: the averaged reliability.
</p>
</li>
<li> <p><code>allcors</code>: a vector with the reliability of each iteration.
</p>
</li>
<li> <p><code>nobs</code>: the number of participants.
</p>
</li>
<li> <p><code>scores</code>: the individual participants scores in each split-half,
contained in a list with two matrices (Only included if requested with <code>include.scores</code>).
</p>
</li>
</ul>
<h3>Note</h3>


<ul>
<li>
<p> This function can use a lot of memory in one go.
If you are computing the reliability of a large dataset or you have little RAM,
it may pay off to use the sequential version of this function instead:
<code>rapidsplit.chunks()</code>
</p>
</li>
<li>
<p> It is currently unclear it is better to pre-process your data before or after splitting it.
If you are computing the IAT D-score,
you can therefore use <code>errorhandling</code> and <code>standardize</code> to perform these two actions
after splitting, or you can process your data before splitting and forgo these two options.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
data(foodAAT)
# Reliability of the double difference score:
# [RT(push food)-RT(pull food)] - [RT(push object)-RT(pull object)]

frel&lt;-rapidsplit(data=foodAAT,
                 subjvar="subjectid",
                 diffvars=c("is_pull","is_target"),
                 stratvars="stimid",
                 aggvar="RT",
                 splits=100)
                 
print(frel)

plot(frel,type="all")

           
# Compute a single random split-half reliability of the error rate
rapidsplit(data=foodAAT,
           subjvar="subjectid",
           aggvar="error",
           splits=1,
           aggfunc="means")

# Compute the reliability of an IAT D-score
data(raceIAT)
rapidsplit(data=raceIAT,
           subjvar="session_id",
           diffvars="congruent",
           subscorevar="blocktype",
           aggvar="latency",
           errorhandling=list(type="fixedpenalty",errorvar="error",
                              fixedpenalty=600,blockvar="block_number"),
           splits=100,
           standardize=TRUE)


# Unstratified reliability of the median RT
rapidsplit.chunks(data=foodAAT,
                  subjvar="subjectid",
                  aggvar="RT",
                  splits=100,
                  aggfunc="medians",
                  chunks=8)

# Compute the reliability of Tukey's trimean of the RT
# on 2 CPU cores
trimean&lt;-function(x){ 
  sum(quantile(x,c(.25,.5,.75))*c(1,2,1))/4
}
rapidsplit.chunks(data=foodAAT,
                  subjvar="subjectid",
                  aggvar="RT",
                  splits=200,
                  aggfunc=trimean,
                  cluster=2)

</code></pre>


</div>