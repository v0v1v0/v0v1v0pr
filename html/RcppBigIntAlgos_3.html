<div class="container">

<table style="width: 100%;"><tr>
<td>quadraticSieve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Prime Factorization with the Parallel Quadratic Sieve
</h2>

<h3>Description</h3>

<p>Get the prime factorization of a number, <code class="reqn">n</code>, using the <a href="https://en.wikipedia.org/wiki/Quadratic_sieve">Quadratic Sieve</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">quadraticSieve(n, showStats = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>An integer, numeric, string value, or an element of class bigz.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showStats</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, summary statistics will be displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>First, <a href="https://en.wikipedia.org/wiki/Trial_division">trial division</a> is carried out to remove small prime numbers, then a constrained version of <a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm">Pollard's rho algorithm</a> is called to quickly remove further prime numbers. Next, we check to make sure that we are not passing a perfect power to the main quadratic sieve algorithm. After removing any perfect powers, we finally call the quadratic sieve with multiple polynomials in a recursive fashion until we have completely factored our number.
</p>
<p>When <code>showStats = TRUE</code>, summary statistics will be shown. The frequency of updates is dynamic as writing to stdout can be expensive. It is determined by how fast smooth numbers (including partially smooth numbers) are found along with the total number of smooth numbers required in order to find a non-trivial factorization. The statistics are:
</p>

<dl>
<dt><code>MPQS Time</code></dt>
<dd>
<p>The time measured for the multiple polynomial quadratic sieve section in hours <code>h</code>, minutes <code>m</code>, seconds <code>s</code>, and milliseconds <code>ms</code>.</p>
</dd>
<dt><code>Complete</code></dt>
<dd>
<p>The percent of smooth numbers plus partially smooth numbers required to guarantee a non-trivial solution when <a href="https://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian Elimination</a> is performed on the matrix of powers of primes.</p>
</dd>
<dt><code>Polynomials</code></dt>
<dd>
<p>The number of polynomials sieved</p>
</dd>
<dt><code>Smooths</code></dt>
<dd>
<p>The number of <a href="https://en.wikipedia.org/wiki/Smooth_number">Smooth numbers</a> found</p>
</dd>
<dt><code>Partials</code></dt>
<dd>
<p>The number of partially smooth numbers found. These numbers have one large factor, <em>F</em>, that is not reduced by the prime factor base determined in the algorithm. When we encounter another number that is almost smooth with the same large factor, <em>F</em>, we can combine them into one partially smooth number.</p>
</dd>
</dl>
<h3>Value</h3>

<p>Vector of class bigz
</p>


<h3>Note</h3>


<ul>
<li>
<p><code>primeFactorizeBig</code> is preferred for general prime factorization.
</p>
</li>
<li>
<p>Both the extended Pollard's rho algorithm and the elliptic curve method are skipped. For general prime factorization, see <code>primeFactorizeBig</code>.
</p>
</li>
<li>
<p>Safely interrupt long executing commands by pressing <code>Ctrl + c</code>, <code>Esc</code>, or whatever interruption command offered by the user's GUI. If you are using multiple threads, you can still interrupt execution, however there will be a delay up to 30 seconds if the number is very large.
</p>
</li>
<li>
<p>Note, the function <code>primeFactorizeBig(n, skipECM = T, skipPolRho = T)</code> is the same as <code>quadraticSieve(n)</code>
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="http://library.msri.org/books/Book44/files/03carl.pdf">Pomerance, C. (2008). Smooth numbers and the quadratic sieve. In Algorithmic
Number Theory Lattices, Number Fields, Curves and Cryptography (pp. 69-81).
Cambridge: Cambridge University Press.</a>
</p>
</li>
<li>
<p><a href="http://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866119-8/S0025-5718-1987-0866119-8.pdf">Silverman, R. D. (1987). The Multiple Polynomial Quadratic Sieve.
Mathematics of Computation, 48(177), 329-339. doi:10.2307/2007894</a>
</p>
</li>
<li>
<p><a href="https://micsymposium.org/mics_2011_proceedings/mics2011_submission_28.pdf">Integer Factorization using the Quadratic Sieve</a>
</p>
</li>
<li>
<p><a href="https://codegolf.stackexchange.com/questions/8629/fastest-semiprime-factorization/9088#9088">From https://codegolf.stackexchange.com/ (Credit to user primo for answer)
P., &amp; Chowdhury, S. (2012, October 7). Fastest semiprime factorization. Retrieved October 06, 2017</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>primeFactorizeBig</code>, <code>factorize</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">mySemiPrime &lt;- gmp::prod.bigz(gmp::nextprime(gmp::urand.bigz(2, 50, 17)))
quadraticSieve(mySemiPrime)
</code></pre>


</div>