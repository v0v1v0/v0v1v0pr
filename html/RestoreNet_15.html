<div class="container">

<table style="width: 100%;"><tr>
<td>get.scatterpie</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clonal pie-chart</h2>

<h3>Description</h3>

<p>Draw a clonal pie-chart of a random-effects reaction network.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get.scatterpie(re.res, txt = FALSE, legend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>re.res</code></td>
<td>
<p>output list returned by fit.re().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>txt</code></td>
<td>
<p>logical (defaults to FALSE). If TRUE, barcode names will be printed on the pies.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend</code></td>
<td>
<p>logical (defaults to FALSE). If TRUE, the legend of the pie-chart will be printed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates a clonal pie-chart given a previously fitted random-effects model.
In this representation each clone <code class="reqn">k</code> is identified with a pie whose slices are
lineage-specific and weighted with <code class="reqn">w_k</code>, defined as the difference between the
conditional expectations of the random-effects on duplication and death parameters, that is
</p>
<p style="text-align: center;"><code class="reqn">w_k = E_{u\vert \Delta Y; \hat{\psi}}[u^k_{\alpha_{lin}}] - E_{u\vert \Delta Y; \hat{\psi}}[u^k_{\delta_{lin}}]</code>
</p>
<p>,
where <code class="reqn">\texttt{lin}</code> is a cell lineage.
The diameter of the <code class="reqn">k</code>-th pie is proportional to the euclidean 2-norm of <code class="reqn">w_k</code>.
Therefore, the larger the diameter, the more the corresponding clone is expanding
into the lineage associated to the largest slice.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class="language-R">rcts &lt;- c("A-&gt;1", "B-&gt;1", "C-&gt;1", "D-&gt;1",
          "A-&gt;0", "B-&gt;0", "C-&gt;0", "D-&gt;0",
          "A-&gt;B", "A-&gt;C", "C-&gt;D") ## set of reactions
ctps &lt;- head(LETTERS,4)
nC &lt;- 3 ## number of clones
S &lt;- 10 ## trajectory length
tau &lt;- 1 ## for tau-leaping algorithm
u_1 &lt;- c(.2, .15, .17, .09*5,
         .001, .007, .004, .002,
         .13, .15, .08)
u_2 &lt;- c(.2, .15, .17, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
u_3 &lt;- c(.2, .15, .17*3, .09,
         .001, .007, .004, .002,
         .13, .15, .08)
theta_allcls &lt;- cbind(u_1, u_2, u_3) ## clone-specific parameters
rownames(theta_allcls) &lt;- rcts
s20 &lt;- 1 ## additional noise
Y &lt;- array(data = NA,
           dim = c(S + 1, length(ctps), nC),
           dimnames = list(seq(from = 0, to = S*tau, by = tau),
                           ctps,
                           1:nC)) ## empty array to store simulations
Y0 &lt;- c(100,0,0,0) ## initial state
names(Y0) &lt;- ctps
for (cl in 1:nC) { ## loop over clones
  Y[,,cl] &lt;- get.sim.tl(Yt = Y0,
                        theta = theta_allcls[,cl],
                        S = S,
                        s2 = s20,
                        tau = tau,
                        rct.lst = rcts,
                        verbose = TRUE)
}
null.res &lt;- fit.null(Y = Y,
                     rct.lst = rcts,
                     maxit = 0, ## needs to be increased (&gt;=100) for real applications
                     lmm = 0, ## needs to be increased (&gt;=5) for real applications
) ## null model fitting

re.res &lt;- fit.re(theta_0 = null.res$fit$par,
                 Y = Y,
                 rct.lst = rcts,
                 maxit = 0, ## needs to be increased (&gt;=100) for real applications
                 lmm = 0, ## needs to be increased (&gt;=5) for real applications
                 maxemit = 1 ## needs to be increased (&gt;= 100) for real applications
) ## random-effects model fitting

get.scatterpie(re.res, txt = TRUE)
</code></pre>


</div>