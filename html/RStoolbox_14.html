<div class="container">

<table style="width: 100%;"><tr>
<td>ggRGB</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create ggplot2 Raster Plots with RGB from 3 RasterLayers</h2>

<h3>Description</h3>

<p>Calculates RGB color composite raster for plotting with ggplot2. Optional values for clipping and and stretching can be used to enhance the imagery.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ggRGB(
  img,
  r = 3,
  g = 2,
  b = 1,
  scale,
  maxpixels = 5e+05,
  stretch = "none",
  ext = NULL,
  limits = NULL,
  clipValues = "limits",
  quantiles = c(0.02, 0.98),
  ggObj = TRUE,
  ggLayer = FALSE,
  alpha = 1,
  coord_equal = TRUE,
  geom_raster = FALSE,
  nullValue = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>img</code></td>
<td>
<p>SpatRaster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Integer or character. Red layer in x. Can be set to <code>NULL</code>, in which case the red channel will be set to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>Integer or character. Green layer in x. Can be set to <code>NULL</code>, in which case the green channel will be set to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>Integer or character. Blue layer in x. Can be set to <code>NULL</code>, in which case the blue channel will be set to zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Numeric. Maximum possible pixel value (optional). Defaults to 255 or to the maximum value of x if that is larger than 255</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxpixels</code></td>
<td>
<p>Integer. Maximal number of pixels used for plotting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stretch</code></td>
<td>
<p>Character. Either 'none', 'lin', 'hist', 'sqrt' or 'log' for no stretch, linear, histogram, square-root or logarithmic stretch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ext</code></td>
<td>
<p>Extent or SpatExtent object to crop the image</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>
<p>Vector or matrix. Can be used to reduce the range of values. Either a vector of two values for all bands (c(min, max))
or a 3x2 matrix with min and max values (columns) for each layer (rows).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clipValues</code></td>
<td>
<p>Matrix, numeric vector, string or NA. Values to reset out of range (out of <code>limits</code>) values to. 
By default ('limits') values are reset to <code>limits</code>. A single value (e.g. NA) will be recycled to all lower/higher clippings,
A vector of length two (c(min,max)) can be used to specify lower and higher replace values, applied to all bands. 
A two column matrix (typically with three rows) can be used to fully control lower and upper clipping values differently for each band.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>Numeric vector with two elements. Min and max quantiles to stretch. Defaults to 2% stretch, i.e. c(0.02,0.98).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ggObj</code></td>
<td>
<p>Logical. If <code>TRUE</code> a ggplot2 object is returned. If <code>FALSE</code> a data.frame with coordinates and color will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ggLayer</code></td>
<td>
<p>Logical. If <code>TRUE</code> a ggplot2 layer is returned. This is useful if you want to add it to an existing ggplot2 object.
Note that if <code>TRUE</code> &amp; <code>annotate = FALSE</code> you have to add a scale_fill_identity() manually in your call to ggplot().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Numeric. Transparency (0-1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coord_equal</code></td>
<td>
<p>Logical. Force addition of coord_equal, i.e. aspect ratio of 1:1. Typically useful for remote sensing data (depending on your projection), hence it defaults to TRUE.
Note howver, that this does not apply if (<code>ggLayer=FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geom_raster</code></td>
<td>
<p>Logical. If <code>FALSE</code> annotation_raster is used, otherwise geom_raster()+scale_fill_identity is used.
Note that you can't use scale_fill* in addition to the latter, because it already requires scale_fill_identity().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nullValue</code></td>
<td>
<p>Numeric. Intensity value used for NULL layers in color compositing. E.g. set g=NULL and fix green value at 0.5 (defaults to 0).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functionality is based on <code>plotRGB</code> from the raster package.
</p>


<h3>Value</h3>


<table>
<tr>
<td style="text-align: left;">
 <code>ggObj = TRUE</code>:   </td>
<td style="text-align: left;"> ggplot2 plot </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>ggLayer = TRUE</code>: </td>
<td style="text-align: left;"> ggplot2 layer to be combined with an existing ggplot2 </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>ggObj = FALSE</code>:  </td>
<td style="text-align: left;"> data.frame in long format suitable for plotting with ggplot2, includes the pixel values and the calculated colors </td>
</tr>
<tr>
<td style="text-align: left;">  
</td>
</tr>
</table>
<h3>See Also</h3>

<p>ggR, fortifySpatRaster
</p>


<h3>Examples</h3>

<pre><code class="language-R">  
library(ggplot2)

ggRGB(rlogo, r=1, g=2, b=3)

## Define minMax ranges
ggRGB(rlogo, r=1,g=2, b=3, limits = matrix(c(100,150,10,200,50,255),  ncol = 2, by = TRUE))

## Perform stong linear contrast stretch
ggRGB(rlogo, r = 1, g = 2, b = 3,stretch = "lin", quantiles = c(0.2, 0.8))

## Use only two layers for color calculation
ggRGB(rlogo, r = 1, g = 2, b = NULL)

## Return only data.frame
df &lt;- ggRGB(rlogo, ggObj = FALSE)
head(df)

## Use in layer-mode, e.g. to add to another plot
wave &lt;- data.frame(x = c(0, 0:100,100), y = c(0,sin(seq(0,2*pi,pi/50))*10+20, 0))
p &lt;- ggplot(wave, aes(x, y)) 
p + ggRGB(rlogo, ggLayer = TRUE) +
       geom_polygon(aes(x, y), fill = "blue", alpha = 0.4) +
       coord_equal(ylim=c(0,75))
</code></pre>


</div>