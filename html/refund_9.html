<div class="container">

<table style="width: 100%;"><tr>
<td>coef.pffr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get estimated coefficients from a pffr fit</h2>

<h3>Description</h3>

<p>Returns estimated coefficient functions/surfaces <code class="reqn">\beta(t), \beta(s,t)</code>
and estimated smooth effects <code class="reqn">f(z), f(x,z)</code> or <code class="reqn">f(x, z, t)</code> and their point-wise estimated standard errors.
Not implemented for smooths in more than 3 dimensions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'pffr'
coef(
  object,
  raw = FALSE,
  se = TRUE,
  freq = FALSE,
  sandwich = FALSE,
  seWithMean = TRUE,
  n1 = 100,
  n2 = 40,
  n3 = 20,
  Ktt = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted <code>pffr</code>-object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, the function simply returns <code>object$coefficients</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>logical, defaults to TRUE. Return estimated standard error of the estimates?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>logical, defaults to FALSE. If FALSE, use posterior variance <code>object$Vp</code> for variability estimates,
else use <code>object$Ve</code>. See <code>gamObject</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sandwich</code></td>
<td>
<p>logical, defaults to FALSE. Use a Sandwich-estimator for approximate variances? See Details.
THIS IS AN EXPERIMENTAL FEATURE, USE A YOUR OWN RISK.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seWithMean</code></td>
<td>
<p>logical, defaults to TRUE. Include uncertainty about the intercept/overall mean in  standard errors returned for smooth components?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n1</code></td>
<td>
<p>see below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n2</code></td>
<td>
<p>see below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n3</code></td>
<td>
<p><code>n1, n2, n3</code> give the number of gridpoints for 1-/2-/3-dimensional smooth terms
used in the marginal equidistant grids over the range of the covariates at which the estimated effects are evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ktt</code></td>
<td>
<p>(optional) an estimate of the covariance operator of the residual process <code class="reqn">\epsilon_i(t) \sim N(0, K(t,t'))</code>,
evaluated on <code>yind</code> of <code>object</code>. If not supplied, this is estimated from the crossproduct matrices of the
observed residual vectors. Only relevant for sandwich CIs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments, not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>seWithMean</code>-option corresponds to the <code>"iterms"</code>-option in <code>predict.gam</code>.
The <code>sandwich</code>-options works as follows: Assuming that the residual vectors <code class="reqn">\epsilon_i(t), i=1,\dots,n</code> are i.i.d.
realizations of a mean zero Gaussian process with covariance <code class="reqn">K(t,t')</code>, we can construct an estimator for
<code class="reqn">K(t,t')</code> from the <code class="reqn">n</code> replicates of the observed residual vectors. The covariance matrix of the stacked observations
vec<code class="reqn">(Y_i(t))</code> is then given by a block-diagonal matrix with <code class="reqn">n</code> copies of the estimated <code class="reqn">K(t,t')</code> on the diagonal.
This block-diagonal matrix is used to construct the "meat" of a sandwich covariance estimator, similar to Chen et al. (2012),
see reference below.
</p>


<h3>Value</h3>

<p>If <code>raw==FALSE</code>, a list containing </p>

<ul>
<li> <p><code>pterms</code> a matrix containing the parametric / non-functional coefficients (and, optionally, their se's)
</p>
</li>
<li> <p><code>smterms</code> a named list with one entry for each smooth term in the model. Each entry contains
</p>

<ul>
<li> <p><code>coef</code> a matrix giving the grid values over the covariates, the estimated effect (and, optionally, the se's).
The first covariate varies the fastest.
</p>
</li>
<li> <p><code>x, y, z</code> the unique gridpoints used to evaluate the smooth/coefficient function/coefficient surface
</p>
</li>
<li> <p><code>xlim, ylim, zlim</code> the extent of the x/y/z-axes
</p>
</li>
<li> <p><code>xlab, ylab, zlab</code> the names of the covariates for the x/y/z-axes
</p>
</li>
<li> <p><code>dim</code> the dimensionality of the effect
</p>
</li>
<li> <p><code>main</code> the label of the smooth term (a short label, same as the one used in <code>summary.pffr</code>)
</p>
</li>
</ul>
</li>
</ul>
<h3>Author(s)</h3>

<p>Fabian Scheipl
</p>


<h3>References</h3>

<p>Chen, H., Wang, Y., Paik, M.C., and Choi, A. (2013).
A marginal approach to reduced-rank penalized spline smoothing with application to multilevel functional data.
<em>Journal of the American Statistical Association</em>, 101, 1216â€“1229.
</p>


<h3>See Also</h3>

<p><code>plot.gam</code>, <code>predict.gam</code> which this routine is
based on.
</p>


</div>