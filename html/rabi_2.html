<div class="container">

<table style="width: 100%;"><tr>
<td>brute_IDs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Brute force color coding scheme generator</h2>

<h3>Description</h3>

<p>Generates "color" coding schemes used to mark and identify individual animals. The codes are robust to an arbitrary number of partial erasures. This method uses a sloppy, very slow, stochastic brute force method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">brute_IDs(
  total.length,
  redundancy,
  alphabet,
  num.tries = 10,
  available.colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>total.length</code></td>
<td>
<p>the number of unique positions to be marked on the animal. (This can be thought of as the total number of positions on which color bands or paint marks will be applied.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redundancy</code></td>
<td>
<p>the number of erasures that can occur without disrupting surety of unique identification. This value determines how robust the scheme is to erasures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alphabet</code></td>
<td>
<p>an integer representing the 'alphabet size.' This is the number of unique markings (think different paint colors, symbols, or varieties of bands) at your disposal.Note: unlike the Reed-Solomon inspired function, <code>rs_IDs</code>, this function can take non-prime values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.tries</code></td>
<td>
<p>the number of iterations that will be run before choosing the best option. Increasing this number increases the running time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>available.colors</code></td>
<td>
<p>an optional list of strings that contains the names of the unique markings which compose the given 'alphabet' (e.g. "blue", "red", "yellow", etc.). If left blank, the mapping can be done at any later time using <code>codes_to_colors</code>. Additionally, the length of this list must match the 'alphabet size' given above.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function generates the list of all possible unique ID codes given the 'alphabet size' (<code>alphabet</code>) and the number of unique positions available for marking (<code>total.length</code>). The list of combinations is then iteratively pruned down until the required robustness has been reached; the <a href="https://en.wikipedia.org/wiki/Hamming_distance">distance</a> between any two ID codes must greater than the value specified in <code>redundancy</code>.
</p>
<p>However, the iterative pruning is done randomly, so it is likely that resulting list of codes does not contain the maximum possible number of robust codes. Thus, the process is repeated multiple times (<code>num.tries</code>) and the list that contains the largest number of robust codes is kept and returned.
</p>


<h3>Value</h3>

<p>a list of unique ID codes that fit the provided parameters.
</p>
<p>If an appropriate argument for <code>available.colors</code> is provided, each code will be a sequence of strings, otherwise, each code will be a sequence of numeric values.
</p>


<h3>Note</h3>

<p>the <code>rs_IDs</code> function always generates the maximum number of unique codes per scheme. However, <code>rs_IDs</code> suffers from certain limitations that <code>brute_IDs</code> does not: it requires <code>alphabet</code> to be a prime number, <code>total.length</code> to be less than or equal to <code>alphabet</code>, etc.
</p>


<h3>Author(s)</h3>

<p>Andrew Burchill, <a href="mailto:andrew.burchill@asu.edu">andrew.burchill@asu.edu</a>
</p>


<h3>References</h3>

<p>Burchill, A. T., &amp; Pavlic, T. P. (2019). Dude, where's my mark? Creating robust animal identification schemes informed by communication theory. <em>Animal Behaviour</em>, 154, 203-208. <a href="https://doi.org/10.1016/j.anbehav.2019.05.013">doi:10.1016/j.anbehav.2019.05.013</a>
</p>


<h3>See Also</h3>

<p><code>rs_IDs</code>, <code>tweaked_IDs</code>, <code>simple_IDs</code>. Also see the vignette <a href="../doc/loosebirdtag.html"><code>loosebirdtag</code></a> for demonstrations and additional uses.
</p>


<h3>Examples</h3>

<pre><code class="language-R">total.length &lt;- 6  #we have six positions to mark,
redundancy &lt;- 2    #we want surety even with two erasures,
alphabet &lt;- 4      #and we currently have five types of paint in stock

 #This gives a warning because rs_IDs() only accepts
 #a pretty constrained set of parameters
codes &lt;- rs_IDs(total.length, redundancy, alphabet)
length(codes)

 #However, we can do it with brute_IDs() to get more unique IDs
codes &lt;- brute_IDs(total.length, redundancy, alphabet, num.tries = 1)
length(codes)

 #Let's make those into human-readable color sequences
color.names &lt;- c("blue","red","green","pink","yellow-with-a-stripe")
color.codes &lt;- codes_to_colors(codes, color.names)



</code></pre>


</div>