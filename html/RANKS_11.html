<div class="container">

<table style="width: 100%;"><tr>
<td>Utilities</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Utility functions
</h2>

<h3>Description</h3>

<p>Mixed utility functions to compute accuracy, norms, labels from scores and to perform stratified cross-validation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compute.acc(pred, labels)
compute.F(pred, labels)
norm1(x)
Unit.sphere.norm(K)
do.stratified.cv.data(examples, positives, k = 5, seed = NULL)
do.cv.data(examples, positives, k = 5, seed = NULL)
labelsfromscores(scores, thresh)
Multiple.labels.from.scores(S, thresh.vect)
selection.test(pos.scores, av.scores, ind.positives, alpha = 0.05, thresh.pos = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>vector of the predicted labels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>vector of the true labels.
Note that 0  stands for negative and 1 for positive.
In general the first level is negative and the second positive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>a kernel matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>examples</code></td>
<td>
<p>indices of the examples (a vector of integer)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>positives</code></td>
<td>
<p>vector of integer. Indices of the positive examples. The indices refer to the indices of examples</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>number of folds (def = 5)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>seed of the random generator (def=NULL). If is set to NULL no initiazitation is performed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>numeric. Vector of scores: each element correspond to the score of an example</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>real value. Threshold for the classification</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>numeric matrix. Matrix of scores: rows represent examples, columns classes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh.vect</code></td>
<td>
<p>numeric vector. Vector of the thresholds for multiple classes (one threshold for each class)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.scores</code></td>
<td>
<p>vector with scores of positive examples. It is returned from multiple.ker.score.cv.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>av.scores</code></td>
<td>
<p>a vector with the average scores computed by multiple.ker.score.cv. It may be a named vector. 
If not, the names attributes corresponding to the indices of the vector are added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind.positives</code></td>
<td>
<p>indices of the positive examples. They are the indices of av.scores corresponding to positive examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>quantile level (def. 0.05)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh.pos</code></td>
<td>
<p>only values larger than thresh.pos are retained in pos.scores (def.: 0)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>compute.acc</code> computes  the accuracy for a single class
</p>
<p><code>compute.F</code> computes  the F-score for a single class
</p>
<p><code>norm1</code> computes the L1-norm of a numeric vector
</p>
<p><code>Unit.sphere.norm</code> normalize a kernel according to the unit sphere
</p>
<p><code>do.stratified.cv.data</code> generates data for the stratified cross-validation. In particular subdivides the indices that refer to the rows of the data matrix in different folds (separated for positive and negative examples)
</p>
<p><code>do.cv.data</code> generates data for the vanilla not stratified cross-validation.
</p>
<p><code>labelsfromscores</code> computes the labels of a single class from the corresponding scores
</p>
<p><code>Multiple.labels.from.scores</code> computes the labels of multiple classes from the corresponding scores
</p>
<p><code>selection.test</code> is a non parametric test to select the most significant unlabeled examples 
</p>


<h3>Value</h3>

<p><code>compute.acc</code> returns the accuracy
</p>
<p><code>compute.F</code> returns the F-score
</p>
<p><code>norm1</code> returns the L1-norm value
</p>
<p><code>Unit.sphere.norm</code> returns  the kernel normalized according to the unit sphere
</p>
<p><code>do.stratified.cv.data</code> returns a list with 2 two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fold.non.positives</code></td>
<td>
<p>a list with k components. Each component is a vector with the indices of the non positive elements of the fold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fold.positives</code></td>
<td>
<p>a list with k components. Each component is a vector with the indices of the positive elements of the fold</p>
</td>
</tr>
</table>
<p>Indices refer to row numbers of the data matrix
</p>
<p><code>do.cv.data</code> returns a list with 2 two components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fold.non.positives</code></td>
<td>
<p>a list with k components. Each component is a vector with the indices of the non positive elements of the fold</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fold.positives</code></td>
<td>
<p>a list with k components. Each component is a vector with the indices of the positive elements of the fold</p>
</td>
</tr>
</table>
<p>Indices refer to row numbers of the data matrix
</p>
<p><code>labelsfromscores</code> returns a numeric vector res with 0 or 1 values. The label res[i]=1 if scores[i]&gt;thresh, otherwise res[i]=0
</p>
<p><code>Multiple.labels.from.scores</code> returns a binary matrix with the labels of the predictions. Rows represent examples, columns classes. Element L[i,j] is the label of example i w.r.t. class j.  L[i,j]=1 if i belongs to j, 0 otherwise.
</p>
<p><code>selection.test</code> returns a list with 5 components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>selected</code></td>
<td>
<p>a named vector with the components of av.scores selected by the test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected.labeled</code></td>
<td>
<p>a named vector with the labeled components of av.scores selected by the test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected.unlabeled</code></td>
<td>
<p>a named vector with the unlabeled components of av.scores selected by the test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>the score threshold selected by the test</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level (the same value of the input)</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R"># L1-norm of a vector
norm1(rnorm(10));
# generation of 5 stratified folds;
do.stratified.cv.data(1:100, 1:10, k = 5, seed = NULL);
# generation of labels form scores.
labelsfromscores(runif(20), thresh=0.3);
</code></pre>


</div>