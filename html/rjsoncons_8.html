<div class="container">

<table style="width: 100%;"><tr>
<td>j_flatten</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Flatten and find keys or values in JSON or NDJSON documents</h2>

<h3>Description</h3>

<p><code>j_flatten()</code> transforms a JSON document into a list
where names are JSONpointer 'paths' and elements are the
corresponding 'values' from the JSON document.
</p>
<p><code>j_find_values()</code> finds paths to exactly matching
values.
</p>
<p><code>j_find_values_grep()</code> finds paths to values matching
a regular expression.
</p>
<p><code>j_find_keys()</code> finds paths to exactly matching keys.
</p>
<p><code>j_find_keys_grep()</code> finds paths to keys matching a
regular expression.
</p>
<p>For NDJSON documents, the result is either a character
vector (for <code>as = "string"</code>) or list of <em>R</em> objects, one
element for each NDJSON record.
</p>


<h3>Usage</h3>

<pre><code class="language-R">j_flatten(
  data,
  object_names = "asis",
  as = "string",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_values(
  data,
  values,
  object_names = "asis",
  as = "R",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_values_grep(
  data,
  pattern,
  object_names = "asis",
  as = "R",
  ...,
  grep_args = list(),
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_keys(
  data,
  keys,
  object_names = "asis",
  as = "R",
  ...,
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)

j_find_keys_grep(
  data,
  pattern,
  object_names = "asis",
  as = "R",
  ...,
  grep_args = list(),
  n_records = Inf,
  verbose = FALSE,
  data_type = j_data_type(data),
  path_type = "JSONpointer"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a character() JSON string or NDJSON records, or the
name of a file or URL containing JSON or NDJSON, or an <em>R</em>
object parsed to a JSON string using <code>jsonlite::toJSON()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object_names</code></td>
<td>
<p>character(1) order <code>data</code> object elements
<code>"asis"</code> (default) or <code>"sort"</code> before filtering on <code>path</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as</code></td>
<td>
<p>character(1) describing the return type.  For
<code>j_flatten()</code>, either "string" or "R". For other functions on
this page, one of "R", "data.frame", or "tibble".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed to <code>jsonlite::toJSON</code> when <code>data</code> is an <em>R</em> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_records</code></td>
<td>
<p>numeric(1) maximum number of NDJSON records parsed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical(1) report progress when parsing large NDJSON
files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_type</code></td>
<td>
<p>character(1) type of <code>data</code>; one of <code>"json"</code>,
<code>"ndjson"</code>, or a value returned by <code>j_data_type()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path_type</code></td>
<td>
<p>character(1) type of 'path' to be returned; one of
'"JSONpointer"', '"JSONpath"'; '"JMESpath"' is not supported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>vector of one or more values to be matched exactly to
values in the JSON document.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>character(1) regular expression to match values or
paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grep_args</code></td>
<td>
<p>list() additional arguments passed to <code>grepl()</code>
when searching on values or paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keys</code></td>
<td>
<p>character() vector of one or more keys to be matched
exactly to path elements.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions documented on this page expand <code>data</code> into all
path / value pairs. This is not suitable for very large JSON
documents.
</p>
<p>For <code>j_find_keys()</code>, the <code>key</code> must exactly match one or
more consecutive keys in the JSONpointer path returned by
<code>j_flatten()</code>.
</p>
<p>For <code>j_find_keys_grep()</code>, the <code>key</code> can define a pattern
that spans across JSONpointer or JSONpath elements.
</p>


<h3>Value</h3>

<p><code>j_flatten(as = "string")</code> (default) returns a JSON string
representation of the flattened document, i.e., an object with keys
the JSONpointer paths and values the value at the corresponding
path in the original document.
</p>
<p><code>j_flatten(as = "R")</code> returns a named list, where <code>names()</code> are the
JSONpointer paths to each element in the JSON document and list
elements are the corresponding values.
</p>
<p><code>j_find_values()</code> and <code>j_find_values_grep()</code> return a list
with names as JSONpointer paths and list elements the matching
values, or a <code>data.frame</code> or <code>tibble</code> with columns <code>path</code> and
<code>value</code>. Values are coerced to a common type when <code>as</code> is
<code>data.frame</code> or <code>tibble</code>.
</p>
<p><code>j_find_keys()</code> and <code>j_find_keys_grep()</code> returns a list,
data.frame, or tibble similar to <code>j_find_values()</code> and
<code>j_find_values_grep()</code>.
</p>
<p>For NDJSON documents, the result is a vector paralleling
the NDJSON document, with <code>j_flatten()</code> applied to each element
of the NDJSON document.
</p>


<h3>Examples</h3>

<pre><code class="language-R">json &lt;- '{
    "discards": {
        "1000": "Record does not exist",
        "1004": "Queue limit exceeded",
        "1010": "Discarding timed-out partial msg"
    },
    "warnings": {
        "0": "Phone number missing country code",
        "1": "State code missing",
        "2": "Zip code missing"
    }
}'

## JSONpointer
j_flatten(json) |&gt;
    cat("\n")

## JSONpath
j_flatten(json, as = "R", path_type = "JSONpath") |&gt;
    str()

j_find_values(json, "Zip code missing", as = "tibble")
j_find_values(
    json,
    c("Queue limit exceeded", "Zip code missing"),
    as = "tibble"
)

j_find_values_grep(json, "missing", as = "tibble")

## JSONpath
j_find_values_grep(json, "missing", as = "tibble", path_type = "JSONpath")

j_find_keys(json, "discards", as = "tibble")
j_find_keys(json, "1", as = "tibble")
j_find_keys(json, c("discards", "warnings"), as = "tibble")

## JSONpath
j_find_keys(json, "discards", as = "tibble", path_type = "JSONpath")

j_find_keys_grep(json, "discard", as = "tibble")
j_find_keys_grep(json, "1", as = "tibble")
j_find_keys_grep(json, "car.*/101", as = "tibble")

## JSONpath
j_find_keys_grep(json, "car.*\\['101", as = "tibble", path_type = "JSONpath")

## NDJSON

ndjson_file &lt;-
    system.file(package = "rjsoncons", "extdata", "example.ndjson")
j_flatten(ndjson_file) |&gt;
    noquote()
j_find_values_grep(ndjson_file, "e") |&gt;
    str()
</code></pre>


</div>