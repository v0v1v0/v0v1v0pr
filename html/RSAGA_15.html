<div class="container">

<table style="width: 100%;"><tr>
<td>multi.focal.function</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local and Focal Grid Function with Multiple Grids as Inputs</h2>

<h3>Description</h3>

<p><code>multi.focal.function</code> cuts out square or circular moving windows from a stack of grids (matrices) and applies a user-defined matrix function that takes multiple arguments to this data. <code>multi.local.function</code> is a more efficiently coded special case of moving windows of size 0, i.e. functions applied to individual grid cells of a stack of grids. This is especially useful for applying <code>predict</code> methods of statistical models to a stack of grids containing the explanatory variables (see Examples and <code>grid.predict()</code>). The function is suitable for large grid files as it can process them row by row; but it may be slow because one call to the focal function is generated for each grid cell.
</p>


<h3>Usage</h3>

<pre><code class="language-R">multi.focal.function(
  in.grids,
  in.grid.prefix,
  in.factor.grid,
  out.grid.prefix,
  path = NULL,
  in.path = path,
  out.path = path,
  fun,
  in.varnames,
  out.varnames,
  radius = 0,
  is.pixel.radius = TRUE,
  na.strings = "NA",
  valid.ranges,
  nodata.values = c(),
  out.nodata.value,
  search.mode = c("circle", "square"),
  digits = 4,
  hdr.digits = 10,
  dec = ".",
  quiet = TRUE,
  nlines = Inf,
  mw.to.vector = FALSE,
  mw.na.rm = FALSE,
  pass.location = FALSE,
  ...
)

multi.local.function(
  in.grids,
  in.grid.prefix,
  out.grid.prefix,
  path = NULL,
  in.path = path,
  out.path = path,
  fun,
  in.varnames,
  out.varnames,
  na.strings = "NA",
  valid.ranges,
  nodata.values = c(),
  out.nodata.value,
  digits = 4,
  hdr.digits = 10,
  dec = ".",
  quiet = TRUE,
  nlines = Inf,
  na.action = stats::na.exclude,
  pass.location = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>in.grids</code></td>
<td>
<p>character vector: file names of input ASCII grids, relative to <code>in.path</code>; <code>in.grid.prefix</code> will be used as a prefix to the file name if specified; default file extension: <code>.asc</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.grid.prefix</code></td>
<td>
<p>character string (optional), defining a file name prefix to be used for the input file names; a dash (<code>-</code>) will separate the prefix and the <code>in.varnames</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.factor.grid</code></td>
<td>
<p>optional file name giving a gridded categorical variables defining zones; zone boundaries are used as breaklines for the moving window (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.grid.prefix</code></td>
<td>
<p>character string (optional), defining a file name prefix to be used for the output file names; a dash (<code>-</code>) will separate the prefix and the <code>out.varnames</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>path</code></td>
<td>
<p>path in which to look for <code>in.grids</code> and write output grid files; see also <code>in.path</code> and <code>out.path</code>, which overwrite <code>path</code> if they are specified</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.path</code></td>
<td>
<p>path in which to look for <code>in.grids</code> (defaults to <code>path</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.path</code></td>
<td>
<p>path in which to write output grid files; defaults to <code>path</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>a function, or name of a function, to be applied on the moving window; see Details; <code>fun</code> is expected to accept named arguments with the names given by <code>in.varnames</code>; <code>grid.predict()</code> is a wrapper function that can be used for applying a model's <code>predict</code> method to a stack of grids; see Details. In <code>multi.local.function</code>, <code>fun</code> must be able to process  arguments that are vectors of equal length (e.g., a vector of 50 slope angles, another vector of 50 elevation values, etc.).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in.varnames</code></td>
<td>
<p>character vector: names of the variables corresponding to the <code>in.grids</code>; if missing, same as <code>in.grids</code>; if specified, must have the same length and order as <code>in.grids</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.varnames</code></td>
<td>
<p>character vector specifying the name(s) of the variable(s) returned by <code>fun</code>; if missing, <code>multi.focal.function</code> will try to determine the varnames from <code>fun</code> itself, or or from a call to <code>fun</code> if this is a function (see Details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>numeric value specifying the (circular or square) radius  of the moving window; see <code>is.pixel.radius</code> and <code>search.mode</code>; note that all data within distance <code style="white-space: pre;">⁠&lt;=radius⁠</code> will be included in the moving window, not <code style="white-space: pre;">⁠&lt;radius⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.pixel.radius</code></td>
<td>
<p>logical: if <code>TRUE</code> (default), the <code>radius</code> will be interpreted as a (possibly non-integer) number of pixels; if <code>FALSE</code>, it is interpreted as a radius measured in the grid (map) units.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.strings</code></td>
<td>
<p>passed on to <code>scan()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>valid.ranges</code></td>
<td>
<p>optional list of length <code>length(in.grids)</code> with numeric vector of length 2, specifying minimum and maximum valid values read from input file; all values <code style="white-space: pre;">⁠&lt;valid.ranges[[i]][1]⁠</code> or <code style="white-space: pre;">⁠&gt;valid.ranges[[i]][1]⁠</code> will be converted to <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodata.values</code></td>
<td>
<p>numeric vector: any values from the input grid file that should be converted to <code>NA</code>, in addition to the nodata value specified in the grid header</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out.nodata.value</code></td>
<td>
<p>numeric: value used for storing <code>NA</code>s in the output file(s); if missing, use the same nodata value as specified in the header of the input grid file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>search.mode</code></td>
<td>
<p>character, either <code>"circle"</code> (default) for a circular search window, or <code>"square"</code> for a squared one.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for output grid file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hdr.digits</code></td>
<td>
<p>numeric, specifying the number of digits to be used for the header of the output grid file (default: 10; see <code>write.ascii.grid.header()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dec</code></td>
<td>
<p>character, specifying the decimal mark to be used for input and output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>If <code>FALSE</code>, gives some output (<code>"*"</code>) after every 10th line of the grid file and when the job is done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlines</code></td>
<td>
<p>Number of lines to be processed; useful for testing purposes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mw.to.vector</code></td>
<td>
<p>logical: Should the content of the moving window be coerced (from a matrix) to a vector?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mw.na.rm</code></td>
<td>
<p>logical: Should <code>NA</code>s be removed from moving window prior to passing the data to <code>fun</code>? Only applicable when <code>mw.to.vector=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pass.location</code></td>
<td>
<p>logical: Should the x,y coordinates of grid points (center of grid cells) be passed to <code>fun</code>? If <code>TRUE</code>, two additional arguments named arguments <code>x</code> and <code>y</code> are passed to <code>fun</code>; NOTE: This currently only works for <code>radius=0</code>, otherwise a warning is produced and <code>pass.location</code> is reset to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed to <code>fun</code>; <code>local.function</code>: arguments to be passed to  <code>focal.function</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>function: determines if/how <code>NA</code> values are omitted from the stack of input variables; use <code>na.exclude()</code> (default) or <code>na.pass()</code> if <code>fun</code> can handle <code>NA</code> values correctly</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>multi.local.function</code> is probably most useful for applying the <code>predict</code> method of a fitted model to a grids representing the predictor variables. An example is given below and in more detail in Brenning (2008) (who used <code>multi.focal.function</code> for the same purpose); see also <code>grid.predict()</code>.
</p>
<p><code>multi.local.function</code> is essentially the same as <code>multi.focal.function</code> for <code>radius=0</code>, but coded MUCH more efficiently. (The relevant code will eventually migrate into <code>multi.focal.function</code> as well, but requires further testing.) Applying a GAM to the data set of Brenning (2008) takes about 1/100th the time with <code>multi.local.function</code> compared to <code>multi.focal.function</code>.
</p>
<p><code>multi.focal.function</code> extends <code>focal.function()</code> by allowing multiple input grids to be passed to the focal function <code>fun</code> operating on moving windows. It passes square matrices of size <code>2*radius+1</code> to the function <code>fun</code> if <code>mw.to.vector=FALSE</code> (default), or a vector of length <code style="white-space: pre;">⁠&lt;=(2*radius+1)^2⁠</code> if <code>mw.to.vector=TRUE</code>; one such matrix or vector per input grid will be passed to <code>fun</code> as an argument whose name is specified by <code>in.varnames</code>.
</p>
<p>These matrices or vectors will contain the content of the moving window, which may possibly contain <code>NA</code>s even if the <code>in.grid</code> has no nodata values, e.g. due to edge effects. If <code>search.mode="circle"</code>, values more than <code>radius</code> units (pixels or grid units, depending on <code>is.pixel.radius</code>) away from the center pixel / matrix entry will be set to <code>NA</code>. In addition, <code>valid.range</code>, <code>nodata.values</code>, and the nodata values specified in the <code>in.grid</code> are checked to assign further <code>NA</code>s to pixels in the moving window. Finally, if <code>in.factor.grid</code> specifies zones, all pixels in the moving window that belong to a different zone than the center pixel are set to <code>NA</code>, or, in other words, zone boundaries are used as breaklines.
</p>
<p>The function <code>fun</code> should return a single numeric value or a numeric vector, such as a regression result or a vector of class probabilities returned by a soft classifier. In addition to the named arguments receiving the moving window data, <code>fun</code> may have additional arguments; the <code>...</code> argument of <code>focal.function</code> is passed on to <code>fun</code>. <code>grid.predict()</code> uses this feature.
</p>
<p>Optionally, <code>fun</code> should support the following feature: If no argument is passed to it, then it should return a character vector giving variable names to be used for naming the output grids.
</p>
<p>For the input files, <code>.asc</code> is used as the default file extension, if it is not specified by the user.
</p>
<p>See <code>focal.function()</code> for details.
</p>


<h3>Value</h3>

<p><code>multi.focal.function</code> returns the character vector of output file names.
</p>


<h3>Note</h3>

<p><code>multi.focal.function</code> can do all the things <code>focal.function()</code> can do.
</p>


<h3>Author(s)</h3>

<p>Alexander Brenning
</p>


<h3>References</h3>

<p>Brenning, A. (2008): Statistical geocomputing combining R and SAGA: The example of landslide susceptibility analysis with generalized additive models. In: J. Boehner, T. Blaschke, L. Montanarella (eds.), SAGA - Seconds Out (= Hamburger Beitraege zur Physischen Geographie und Landschaftsoekologie, 19), 23-32.
</p>


<h3>See Also</h3>

<p><code>focal.function()</code>, <code>grid.predict()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Assume that d is a data.frame with point observations
# of a numerical response variable y and predictor variables
# a, b, and c.
# Fit a generalized additive model to y,a,b,c.
# We want to model b and c as nonlinear terms:
require(gam)
fit &lt;- gam(y ~ a + s(b) + s(c), data = d)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit )
    # Note that the 'grid.predict' uses by default the
    # predict method of 'fit'.
# Model predictions are written to a file named pred.asc

## End(Not run)

## Not run: 
# A fake example of a logistic additive model:
require(gam)
fit &lt;- gam(cl ~ a + s(b) + s(c), data = d, family = binomial)
multi.local.function(in.grids = c("a", "b", "c"),
    out.varnames = "pred",
    fun = grid.predict, fit = fit,
    control.predict = list(type = "response") )
    # 'control.predict' is passed on to 'grid.predict', which
    # dumps its contents into the arguments for 'fit''s
    # 'predict' method.
# Model predictions are written to a file named pred.asc

## End(Not run)
</code></pre>


</div>