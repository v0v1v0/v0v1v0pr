<div class="container">

<table style="width: 100%;"><tr>
<td>update_b</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Update class means</h2>

<h3>Description</h3>

<p>This function updates the class means (independent from the other classes).
</p>


<h3>Usage</h3>

<pre><code class="language-R">update_b(beta, Omega, z, m, xi, Dinv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The matrix of the decision-maker specific coefficient vectors of dimension
<code>P_r</code> x <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega</code></td>
<td>
<p>The matrix of class covariance matrices as columns of dimension
<code>P_r*P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>The vector of the allocation variables of length <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The vector of class sizes of length <code>C</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xi</code></td>
<td>
<p>The mean vector of length <code>P_r</code> of the normal prior for each <code>b_c</code>.
Per default, <code>xi = numeric(P_r)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dinv</code></td>
<td>
<p>The precision matrix (i.e. the inverse of the covariance matrix) of dimension <code>P_r</code> x <code>P_r</code>
of the normal prior for each <code>b_c</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following holds independently for each class <code class="reqn">c</code>.
Let <code class="reqn">b_c</code> be the mean of class number <code class="reqn">c</code>. A priori, we assume that <code class="reqn">b_c</code> is normally distributed
with mean vector <code class="reqn">\xi</code> and covariance matrix <code class="reqn">D</code>.
Let <code class="reqn">(\beta_n)_{z_n=c}</code> be the collection of <code class="reqn">\beta_n</code> that are currently allocated to class <code class="reqn">c</code>,
<code class="reqn">m_c</code> the class size, and <code class="reqn">\bar{b}_c</code> their arithmetic mean.
Assuming independence across draws, <code class="reqn">(\beta_n)_{z_n=c}</code> has
a normal likelihood of </p>
<p style="text-align: center;"><code class="reqn">\prod_n \phi(\beta_n \mid b_c,\Omega_c),</code>
</p>
<p> where the product is over the values <code class="reqn">n</code>
for which <code class="reqn">z_n=c</code> holds.
Due to the conjugacy of the prior, the posterior <code class="reqn">\Pr(b_c \mid (\beta_n)_{z_n=c})</code> follows a normal distribution
with mean </p>
<p style="text-align: center;"><code class="reqn">(D^{-1} + m_c\Omega_c^{-1})^{-1}(D^{-1}\xi + m_c\Omega_c^{-1}\bar{b}_c)</code>
</p>
<p> and covariance matrix
</p>
<p style="text-align: center;"><code class="reqn">(D^{-1} + m_c \Omega_c^{-1})^{-1}.</code>
</p>



<h3>Value</h3>

<p>A matrix of updated means for each class in columns.
</p>


<h3>Examples</h3>

<pre><code class="language-R">### N = 100 decider, P_r = 2 random coefficients, and C = 2 latent classes
N &lt;- 100
(b_true &lt;- cbind(c(0,0),c(1,1)))
Omega &lt;- matrix(c(1,0.3,0.3,0.5,1,-0.3,-0.3,0.8), ncol=2)
z &lt;- c(rep(1,N/2),rep(2,N/2))
m &lt;- as.numeric(table(z))
beta &lt;- sapply(z, function(z) rmvnorm(b_true[,z], matrix(Omega[,z],2,2)))
### prior mean vector and precision matrix (inverse of covariance matrix)
xi &lt;- c(0,0)
Dinv &lt;- diag(2)
### updated class means (in columns)
update_b(beta = beta, Omega = Omega, z = z, m = m, xi = xi, Dinv = Dinv)
</code></pre>


</div>