<div class="container">

<table style="width: 100%;"><tr>
<td>raymesh_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>'raymesh' model</h2>

<h3>Description</h3>

<p>Load an 'raymesh' object, as specified in the 'rayvertex' package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">raymesh_model(
  mesh,
  x = 0,
  y = 0,
  z = 0,
  flip_transmittance = TRUE,
  verbose = FALSE,
  importance_sample_lights = FALSE,
  calculate_consistent_normals = TRUE,
  subdivision_levels = 1,
  displacement_texture = NA,
  displacement_intensity = 1,
  displacement_vector = FALSE,
  recalculate_normals = FALSE,
  override_material = TRUE,
  material = diffuse(),
  angle = c(0, 0, 0),
  order_rotation = c(1, 2, 3),
  flipped = FALSE,
  scale = c(1, 1, 1),
  validate_mesh = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>A 'raymesh' object. Pulls the vertex, index, texture coordinates, 
normals, and material information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Default '0'. x-coordinate to offset the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Default '0'. y-coordinate to offset the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Default '0'. z-coordinate to offset the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flip_transmittance</code></td>
<td>
<p>Default 'TRUE'. Flips '(1-t)' the transmittance values to match the way the colors
would be interpreted in a rasterizer (where it specifies the transmitted color). Turn off to specify
the attenuation values directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', prints information about the mesh to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>importance_sample_lights</code></td>
<td>
<p>Default 'TRUE'. Whether to importance sample lights specified in the OBJ material
(objects with a non-zero Ke MTL material).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calculate_consistent_normals</code></td>
<td>
<p>Default 'TRUE'. Whether to calculate consistent vertex normals to prevent energy 
loss at edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subdivision_levels</code></td>
<td>
<p>Default '1'. Number of Loop subdivisions to be applied to the mesh.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>displacement_texture</code></td>
<td>
<p>Default 'NA'. File path to the displacement texture. 
This texture is used to displace the vertices of the mesh based on the texture's pixel values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>displacement_intensity</code></td>
<td>
<p>Default '1'. Intensity of the displacement effect. 
Higher values result in greater displacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>displacement_vector</code></td>
<td>
<p>Default 'FALSE'. Whether to use vector displacement. 
If 'TRUE', the displacement texture is interpreted as providing a 3D displacement vector. 
Otherwise, the texture is interpreted as providing a scalar displacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recalculate_normals</code></td>
<td>
<p>Default 'FALSE'. Whether to recalculate vertex normals based on the 
connecting face orientations. This can be used to compute normals for meshes lacking them or
to calculate new normals after a displacement map has been applied to the mesh.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>override_material</code></td>
<td>
<p>Default 'TRUE'. If 'TRUE', overrides the material specified in the 
'raymesh' object with the one specified in 'material'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>material</code></td>
<td>
<p>Default  <code>diffuse</code>, but ignored unless 'override_material = TRUE'. The material, called from one of the material 
functions <code>diffuse</code>, <code>metal</code>, or <code>dielectric</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>angle</code></td>
<td>
<p>Default 'c(0, 0, 0)'. Angle of rotation around the x, y, and z axes, applied in the order specified in 'order_rotation'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_rotation</code></td>
<td>
<p>Default 'c(1, 2, 3)'. The order to apply the rotations, referring to "x", "y", and "z".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flipped</code></td>
<td>
<p>Default 'FALSE'. Whether to flip the normals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Default 'c(1, 1, 1)'. Scale transformation in the x, y, and z directions. If this is a single value,
number, the object will be scaled uniformly.
Note: emissive objects may not currently function correctly when scaled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validate_mesh</code></td>
<td>
<p>Default 'TRUE'. Validates the 'raymesh' object using 'rayvertex::validate_mesh()' 
before parsing to ensure correct parsing. Set to 'FALSE' to speed up scene construction if 'raymesh_model()' 
is taking a long time (Note: this does not affect rendering time).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Single row of a tibble describing the raymesh model in the scene.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Render a simple raymesh object
library(rayvertex)
if(run_documentation()) {
raymesh_model(sphere_mesh(position = c(-1, 0, 0),
              material = material_list(transmittance = "red"))) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# We create a complex rayvertex mesh, using the `rayvertex::add_shape` function which
# creates a new `raymesh` object out of individual `raymesh` objects
rm_scene = sphere_mesh(position = c(-1, 0, 0),
            material = material_list(transmittance = "red")) %&gt;% 
    add_shape(sphere_mesh(position = c(1, 0, 0),
            material = material_list(transmittance = "green", ior = 1.5)))

# Pass the single raymesh object to `raymesh_model()`
# `raymesh_model()`
if(run_documentation()) {
raymesh_model(rm_scene) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# Set `flip_transmittance = FALSE` argument to specify attenuation coefficients directly
# (as specified in the `dielectric()` material). We change the material's numerical attenuation
# constants using `rayvertex::change_material`
rm_scene_new= change_material(rm_scene, transmittance = c(1,2,0.3), id = 1) %&gt;% 
  change_material(transmittance = c(3,1,2), id = 2)
if(run_documentation()) {
raymesh_model(rm_scene_new, flip_transmittance = FALSE) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# Override the material specified in the `raymesh` object and render the scene
if(run_documentation()) {
raymesh_model(rm_scene,
              material = dielectric(attenuation = "dodgerblue2", attenuation_intensity = 4), 
  override_material = TRUE) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30, samples=128, sample_method="sobol_blue")
}

# Adjusting the scale, position, and rotation parameters of the `raymesh` model
if(run_documentation()) {
raymesh_model(rm_scene,
              x = 0, y = 0.5, z = -1, angle = c(0, 0, 20)) %&gt;%
  add_object(generate_ground(material = diffuse(checkercolor="grey20"))) %&gt;%
  render_scene(fov = 30,lookat=c(0,0.5,0), samples=128, sample_method="sobol_blue")
}
</code></pre>


</div>