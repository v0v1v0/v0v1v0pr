<div class="container">

<table style="width: 100%;"><tr>
<td>compute.threshold.cROC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Covariate-specific ROC based threshold values.
</h2>

<h3>Description</h3>

<p>This function implements methods for estimating covariate-specific ROC-based threshold values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">compute.threshold.cROC(object, criterion = c("FPF", "TPF", "YI"), FPF, TPF, newdata,
  ci.level = 0.95, parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class <code>cROC</code> as produced by <code>cROC.bnp()</code>, <code>cROC.sp()</code>, or <code>cROC.kernel()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>A character string indicating whether the covariate-specific threshold values should be computed based on the Youden index (“YI”) or for fixed false positive fractions (“FPF”) or true positive fractions (“TPF”). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FPF</code></td>
<td>
<p>For <code>criterion = "FPF"</code>, a numeric vector with the FPF at which to calculate the covariate-specific threshold values. Atomic values are also valid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TPF</code></td>
<td>
<p>For <code>criterion = "TPF"</code>, a numeric vector with the TPF at which to calculate the covariate-specific threshold values. Atomic values are also valid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the covariate-specific threshold values will be computed. If not supplied, the function <code>cROCData</code> is used to build a default dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either "no" (default), "multicore" (not available on Windows) or "snow".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = "snow". If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates covariate-specific ROC-based threshold values based on three different criteria, namely, the Youden index (YI), one that gives rise to a pre-specified FPF, and one that gives rise to a pre-specified TPF.
</p>
<p>In the conditional case, the Youden index is defined as
</p>
<p style="text-align: center;"><code class="reqn">YI(\mathbf{x}) = \max_{c}|TPF(c|\mathbf{x}) - FPF(c|\mathbf{x})| = \max_{c}|F_{\bar{D}}(c|\mathbf{x}) - F_{D}(c|\mathbf{x})|,</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y|\mathbf{x}) = Pr(Y_{D} \leq y | \mathbf{X}_{D} = \mathbf{x}),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{x}) = Pr(Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>The value <code class="reqn">c^{*}_{\mathbf{x}}</code> that achieves the maximum is called the optimal covariate-specific YI threshold. Regarding the criterion for a fixed FPF, the covariate-specific threshold values are obtained as follows
</p>
<p style="text-align: center;"><code class="reqn">c^{*}_{\mathbf{x}} = F_{\bar{D}}^{-1}(1-FPF|\mathbf{x}),</code>
</p>

<p>and for a fixed TPF we have
</p>
<p style="text-align: center;"><code class="reqn">c^{*}_{\mathbf{x}} = F_{D}^{-1}(1-TPF|\mathbf{x}),</code>
</p>

<p>In all cases, we use the notation <code class="reqn">c^{*}_{\mathbf{x}}</code> to emphasise that this value depends on covariate <code class="reqn">\mathbf{x}</code>.
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Data frame containing the values of the covariates at which the covariate-specific thresholds were computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresholds</code></td>
<td>
<p>If method = "YI", the estimated covariate-specific (optimal) threshold corresponding to the covariate-specific Youden index (the one that maximises TPF/sensitivity + TNF/specificity). If method = "FPF", the covariate-specific threshold corresponding to the specified FPF, and if method = "TPF", the covariate-specific threshold corresponding to the specified TPF. For the Bayesian approach (<code>cROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>YI</code></td>
<td>
<p>If method = "YI", the estimated covariate-specific Youden index. For the Bayesian approach (<code>cROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FPF</code></td>
<td>
<p>If method = "YI" or method = "TPF", the FPF corresponding to the estimated (optimal) covariate-specific thresholds (for the Bayesian approach (<code>cROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.). If method = "FPF", the supplied FPF argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TPF</code></td>
<td>
<p>If method = "YI" or method = "FPF", the covariate-specific TPF/sensitivity corresponding to the estimated covariate-specific (optimal) threshold. For the Bayesian approach (<code>AROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned. If method = "TPF", the supplied TPF argument.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Inacio de Carvalho, V., de Carvalho, M. and Branscum, A. J. (2017). Nonparametric Bayesian Covariate-Adjusted Estimation of the Youden Index. Biometrics, <b>73</b>, 1279-1288.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, <b>21</b>, 483–499.
</p>
<p>Rutter, C.M. and Miglioretti, D. L. (2003). Estimating the Accuracy of Psychological Scales Using Longitudinal Data. Biostatistics, <b>4</b>, 97–107.
</p>
<p>Youden, W. J. (1950). Index for rating diagnostic tests. Cancer, <b>3</b>, 32–35.
</p>


<h3>See Also</h3>

<p><code>cROC.bnp</code>, <code>cROC.kernel</code> or <code>cROC.sp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
			  formula.d = l_marker1 ~ f(age, K = 0),
              group = "status", 
              tag.h = 0, 
              data = newpsa,
              standardise = TRUE,
              p = seq(0,1,l=101),
              mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))

### Threshold values based on the YI
th_cROC_bnp_yi &lt;- compute.threshold.cROC(cROC_bnp, criterion = "YI")

# Plot results
	# Threshold values
	plot(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$thresholds[,"est"], 
		type = "l", xlab = "Age", 
		ylab = "log(PSA)", ylim = c(0,3), 
		main = "Threshold values based on the Youden Index")
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$thresholds[,"qh"], lty = 2)
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$thresholds[,"ql"], lty = 2)

	# Youden Index
	plot(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$YI[,"est"], 
		type = "l", xlab = "Age", 
		ylab = "log(PSA)", ylim = c(0,1), 
		main = "Threshold values based on the Youden Index")
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$YI[,"qh"], lty = 2)
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$YI[,"ql"], lty = 2)

### Threshold values for a fixed FPF
th_cROC_bnp_fpf &lt;- compute.threshold.cROC(cROC_bnp, criterion = "FPF", FPF = 0.1)

# Plot results
	# Threshold values
	plot(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_fpf$thresholds[["0.1"]][,"est"], 
		type = "l", xlab = "Age", 
		ylab = "log(PSA)", ylim = c(0,3), main = "Threshold values for a FPF = 0.1")
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_fpf$thresholds[["0.1"]][,"qh"], lty = 2)
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_fpf$thresholds[["0.1"]][,"ql"], lty = 2)



</code></pre>


</div>