<div class="container">

<table style="width: 100%;"><tr>
<td>levelplot-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Level and contour plots of Raster objects.</h2>

<h3>Description</h3>

<p>Level and contour plots of Raster objects with <code>lattice</code> methods
and marginal plots with <code>grid</code> objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'Raster,missing'
levelplot(x, data = NULL, layers,
            margin = list(), 
            maxpixels = 1e5, 
            par.settings = rasterTheme(),
            between = list(x=0.5, y=0.2),
            as.table = TRUE,
            xlab=if(isLonLat(x)) 'Longitude' else NULL,
            ylab=if(isLonLat(x)) 'Latitude' else NULL,
            main=NULL,
            names.attr,
            scales  =list(),
            xscale.components = xscale.raster,
            yscale.components = yscale.raster,
            zscaleLog = NULL,
            colorkey = list(space='right'),
            panel = panel.levelplot,
            pretty = FALSE, 
            contour = FALSE, region = TRUE, labels = FALSE,
            FUN.margin = NULL, 
            scales.margin = NULL, axis.margin = NULL,
            ..., att=1L)

## S4 method for signature 'SpatRaster,missing'
levelplot(x, data = NULL, layers,
            margin = list(), 
            maxpixels = 1e5, 
            par.settings = rasterTheme(),
            between = list(x=0.5, y=0.2),
            as.table = TRUE,
            xlab=if(is.lonlat(x)) 'Longitude' else NULL,
            ylab=if(is.lonlat(x)) 'Latitude' else NULL,
            main=NULL,
            names.attr,
            scales  =list(),
            xscale.components = xscale.raster,
            yscale.components = yscale.raster,
            zscaleLog = NULL,
            colorkey = list(space='right'),
            panel = panel.levelplot,
            pretty = FALSE, 
            contour = FALSE, region = TRUE, labels = FALSE,
            FUN.margin = NULL, 
            scales.margin = NULL, axis.margin = NULL,
            ..., att=1L)

## S4 method for signature 'Raster,missing'
contourplot(x, data=NULL, layers, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A Raster or SpatRaster object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layers</code></td>
<td>
<p>A numeric or character which should indicate the layers
to be displayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxpixels</code></td>
<td>
<p>A positive integer giving the number of cells to
display, for <code>sampleRegular</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>
<p>A list or a logical. If it is TRUE, two marginal
graphics show the column (x) and row (y) summaries of the
<code>Raster*</code> object. The summary is computed with the function
<code>mean</code>. If it is a list, it contains parameters in <code>name=value</code>
form that define both margins, and may contain two other lists
called <code>x</code> and <code>y</code> whose components affect the respective margins
only: </p>

<ul>
<li>
<p> draw: A logical. If TRUE (default) the marginal graphics are
drawn.
</p>
</li>
<li>
<p> FUN: A function to summarise the <code>Raster*</code> or
<code>SpatRaster</code> by rows and columns (default: <code>mean</code>).
</p>
</li>
<li>
<p> scales: A list with components <code>x</code> (columns) and
<code>y</code> (rows). Each of these components must be a numeric
vector of length 2 defining the range for each marginal plot.
If <code>scales = NULL</code> (default) the range is internally
computed.  If any of the elements of the vectors is <code>NA</code>,
the corresponding limit of the range will be calculated
internally.  If any of the vectors is of length 1, it is assumed
that it defines the lower limit of the range, and the upper
limit is calculated internally. 
</p>
</li>
<li>
<p> axis: Logical or a list. Its default value is
<code>FALSE</code>. If it is <code>TRUE</code> or a list, a simple axis is
drawn with the marginal graphic.  If it is a list, its
components define the graphical parameters of the axis using
<code>grid::gpar</code>.  The default value is <code>gpar(col =
	  'darkgrey', fontsize = 7)</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN.margin, scales.margin, axis.margin</code></td>
<td>
<p>Deprecated
arguments. Use <code>margin</code> as a list instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>att</code></td>
<td>
<p>Integer or character to choose which variable (column) in
the RAT table should be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlab, ylab, main</code></td>
<td>
<p>A character string or expression describing
the axis and title labels. These arguments are used by the
underlying <code>lattice::xyplot</code> function, which
provides this information in its help page:
</p>
<p>“<code>main</code>, <code>xlab</code> and <code>ylab</code> are usually a
character string or an expression that gets used as the label, but
can also be a list that controls further details.  Expressions are
treated as specification of LaTeX-like markup as described in
<code>plotmath</code>.  The label can be a vector, in which case
the components will be spaced out horizontally (or vertically for
<code>ylab</code>).  This feature can be used to provide column or row
labels rather than a single axis label.
</p>
<p>When <code>main</code> (etc.) is a list, the actual label should
be specified as the <code>xlab</code> component (which may be
unnamed if it is the first component).  The label can be
missing, in which case the default will be used.  Further
named arguments are passed on to <code>textGrob</code>; this can
include arguments controlling positioning like <code>just</code> and
<code>rot</code> as well as graphical parameters such as <code>col</code> and
<code>font</code> (see <code>gpar</code> for a full list).
</p>
<p><code>main</code>, <code>xlab</code> and <code>ylab</code> can also be
arbitrary "grobs" (grid graphical objects).”
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.attr</code></td>
<td>
<p>Character or expression, names to use in each
panel. If missing its default value is the result of <code>names(x)</code>
(after subsetting the layers to be displayed).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xscale.components, yscale.components</code></td>
<td>
<p>See
<code>xscale.raster</code> and <code>yscale.raster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colorkey</code></td>
<td>
<p>logical specifying whether a color key is to be drawn
alongside the plot (default is <code>TRUE</code>), or a list describing
the color key (see the <code>colorkey</code> section of the help page of
<code>lattice::levelplot</code> for details).
</p>
<p>It accepts a <code>title</code> argument to include the title of the color
key. It can be a <code>character</code> vector or expression providing the
text, or a list with the text and graphical parameters. In this
case, the text must be the <code>label</code> component of the list (or
unnamed if it is the first component). The other components of the
list are the graphical parameters and are passed to the
<code>grid::gpar</code> function (for example, <code>col</code>,
<code>fontfamily</code>, <code>fontface</code>, etc.). Besides, it may include a
component named <code>title.control</code>: (extracted from
<code>lattice::levelplot</code>): A list providing control
over the placement of a title, if specified. Currently two
components are honoured: <code>side</code> can take values "top",
"bottom", "left", and "right", and specifies the side of the
colorkey on which the title is to be placed. Defaults to the value
of the "space" component; <code>padding</code> is a multiplier for the
default amount of padding between the title and the colorkey.
</p>
<p>The color key will always be drawn at the bottom if the marginal
graphics are also displayed. If you need to change the location of
the color key, disable the marginal graphics with <code>margin =
    FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>between, as.table, par.settings, scales, panel</code></td>
<td>
<p>Graphical
parameters used by <code>lattice::xyplot</code>. Adapted
from the help page of this function: </p>

<ul>
<li>
<p> between: A list with components <code>x</code> and
<code>y</code> (both usually 0 by default), numeric vectors
specifying the space between the panels (units are character
heights). <code>x</code> and <code>y</code> are repeated to account for all
panels in a page and any extra components are ignored.
</p>
</li>
<li>
<p> as.table: A logical flag that controls the order in which
panels should be displayed: if <code>TRUE</code> (the default), left
to right, top to bottom (as in a table).  If <code>FALSE</code>
panels are drawn left to right, bottom to top.
</p>
</li>
<li>
<p> par.settings: A list to choose some display settings
temporarily. This list is supplied to
<code>trellis.par.set</code>. When the resulting object
is plotted, these options are applied temporarily for the
duration of the plotting, after which the settings revert
back to what they were before.  This enables the user to
attach some display settings to the trellis object itself
rather than change the settings globally.
</p>
<p><code>rasterVis</code> includes some functions with predefined
themes that can be directly supplied to <code>par.settings</code>:
<code>rasterTheme</code> (default), <code>RdBuTheme</code> and
<code>BuRdTheme</code>, <code>GrTheme</code>,
<code>BTCTheme</code>, <code>PuOrTheme</code> and
<code>streamTheme</code> (for <code>streamplot</code>).  These
themes are defined using <code>custom.theme</code>. You can use
<code>rasterTheme</code> or <code>custom.theme</code> to
define your own theme (see examples for details).
</p>
</li>
<li>
<p> scales: A list determining how the x- and y-axes (tick
marks and labels) are drawn.  The list contains parameters in
<code>name=value</code> form, and may also contain two other lists
called <code>x</code> and <code>y</code> of the same form. Components of
<code>x</code> and <code>y</code> affect the respective axes only, while
those in <code>scales</code> affect both.  When parameters are
specified in both lists, the values in <code>x</code> or <code>y</code>
are used. For example, use <code>scales=list(draw=FALSE)</code> to
suppress ticks and labels in both axis. Read the help page of
<code>lattice::xyplot</code> to know about the
possible components of <code>scales</code>.
</p>
</li>
<li>
<p> panel: A function object or a character string giving the
name of a predefined function. The default is
<code>panel.levelplot</code>. Another useful option is
<code>panel.levelplot.raster</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pretty, contour, region, labels</code></td>
<td>
<p>Graphical parameters
supplied to <code>lattice::levelplot</code>.  Adapted
from its help page: </p>

<ul>
<li>
<p> pretty: A logical flag, indicating whether to use pretty
cut locations and labels. It is <code>FALSE</code> for
<code>levelplot</code> and <code>TRUE</code> for <code>contourplot</code>.
</p>
</li>
<li>
<p> contour: A logical flag, indicating whether to draw
contour lines. It is <code>TRUE</code> for <code>contourplot</code> and
<code>FALSE</code> for <code>levelplot</code>.
</p>
</li>
<li>
<p> region: A logical flag, indicating whether regions
between contour lines should be filled as in a level plot. It
is <code>FALSE</code> for <code>contourplot</code> and <code>TRUE</code> for
<code>levelplot</code>.
</p>
</li>
<li>
<p> labels: Typically a logical indicating whether the
labels are to be drawn (default is <code>TRUE</code> for
<code>contourplot</code>), a character or expression vector giving
the labels associated with the <code>at</code> values, or a list
whose components define the labels and their graphical
parameters. Read the help page of
<code>panel.levelplot</code> for details.</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zscaleLog</code></td>
<td>
<p>Controls whether the Raster* will be log transformed
before being passed to the panel function.  Defaults to <code>NULL</code>,
in which case the <code>Raster*</code> is not transformed.  Other possible
values are any number that works as a base for taking logarithm,
<code>TRUE</code> (which is equivalent to 10), <code>"e"</code> (for the natural
logarithm), and <code>FALSE</code> (that is equivalent to <code>NULL</code>).
As a side effect, the colorkey is labeled differently.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for
<code>lattice::levelplot</code>,
<code>lattice::xyplot</code>,
<code>panel.levelplot</code> and
<code>panel.levelplot.raster</code>. The most important ones are:
</p>

<ul>
<li>
<p> layout: From the help page of
<code>lattice::xyplot</code>: <code>layout</code> is a
numeric vector of length 2 or 3 giving the number of
columns, rows, and pages (optional) in a multipanel
display.  The number of pages is by default set to as many
as is required to plot all the panels, and so rarely needs
to be specified.
</p>
<p>For example, with <code>layout=c(1, 1)</code> each panel
(corresponding to a layer of a <code>RasterStackBrick</code>)
object will be printed in a separate page (which could be
useful to generate a series of output files to build an
animation.)
</p>
</li>
<li>
<p> xlim, ylim: From the help page of
<code>lattice::xyplot</code>: A numeric vector
of length 2 giving left and right limits for x-axis, and
lower and upper limits for the y-axis.
</p>
</li>
<li>
<p> shrink: From the help page of
<code>panel.levelplot</code>: Either a numeric vector of
length 2 (meant to work as both x and y components), or a list
with components x and y which are numeric vectors of length 2.
This allows the rectangles to be scaled proportional to the
z-value. The specification can be made separately for widths
(x) and heights (y).  The elements of the length 2 numeric
vector gives the minimum and maximum proportion of shrinkage
(corresponding to min and max of z).
</p>
</li>
<li>
<p> border, border.lty, border.lwd: Graphical parameters
(color, type of line, width of line, respectively) of each
rectangle borders. See the help page of
<code>panel.levelplot</code> for details.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The result of the <code>levelplot</code> method is similar to the
<code>spplot</code> method for <code>Raster</code> objects defined in the
<code>raster</code> package. However, this method does not use the
<code>spplot</code> of the <code>sp</code> package and, therefore, no conversion
between classes is needed.
</p>
<p>The <code>contourplot</code> method is a wrapper for <code>levelplot</code> with
the next additional default settings: <code>cuts=7</code>,
<code>labels=TRUE</code>, <code>contour</code>=TRUE, <code>pretty</code>=TRUE,
<code>region=TRUE</code> and <code>colorkey=TRUE</code> (see the help of
<code>contourplot</code> for details.)
</p>
<p><code>levelplot</code> displays categorical data with a convenient
legend. You should use <code>ratify</code> to define a layer as a
categorical variable. It is able to display multilayer categorical
rasters <b>only if</b> they share the same RAT (Raster Attribute
Table). <code>levelplot</code> is not able to display multilayer rasters
with factor <b>and</b> numeric layers. See <code>ratify</code> and the
examples below for details.
</p>


<h3>Author(s)</h3>

<p>Oscar Perpiñán Lamigueiro</p>


<h3>See Also</h3>

<p><code>spplot</code>,
<code>lattice::levelplot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(raster)
library(terra)

f &lt;- system.file("external/test.grd", package="raster")

## raster
r &lt;- raster(f)
levelplot(r)
## terra
rt &lt;- rast(f)
levelplot(rt)

## Change the color theme
levelplot(r, par.settings=GrTheme())

## Not run: 
myPal &lt;- RColorBrewer::brewer.pal('Blues', n=9)
myTheme &lt;- rasterTheme(region = myPal)
levelplot(r, par.settings = myTheme)

## End(Not run)
## Define the legend breaks
my.at &lt;- seq(100, 1850, 500)
levelplot(rt, at=my.at)

myColorkey &lt;- list(at=my.at, ## where the colors change
                   labels=list(
                     at=my.at ## where to print labels
                     ))
levelplot(r, at=my.at, colorkey=myColorkey)

## Define the units of the color key
levelplot(r, margin = FALSE,
             colorkey = list(title = list("[m]",
                                          cex = 1,
                                          fontface = "bold",
                                          col = "red")
                             ))


levelplot(r, margin = FALSE,
          colorkey = list(title = "[m]",
                          space = "left",
                          title.control = list(side = "bottom")))

## shrink and border color
## raster
rCenter &lt;- (maxValue(r) + minValue(r)) / 2
levelplot(r - rCenter, par.settings=RdBuTheme(), shrink=c(.8, 15), border='black')
## Not run: 
## terra
tCenter &lt;- mean(minmax(rt))
levelplot(rt - tCenter, par.settings=RdBuTheme(), shrink=c(.8, 15), border='black')

## End(Not run)

## With subticks
levelplot(r, xscale.components=xscale.raster.subticks,
             yscale.components=yscale.raster.subticks)

## Not run: 
levelplot(rt, xscale.components=xscale.raster.subticks,
             yscale.components=yscale.raster.subticks,
             scales=list(x=list(rot=30, cex=0.8)))

## End(Not run)
## log-scale
levelplot(r^2, zscaleLog=TRUE, contour=TRUE)

## Customizing axis and title labels
levelplot(rt, margin=FALSE,
          main=list('My plot', col='red'),
          xlab=c('This is the', 'X-Axis'),
          ylab=list('Y-Axis', rot=30, fontface='bold')
          )

## xlim and ylim to display a smaller region
levelplot(r, xlim=c(179000, 181000), ylim=c(329500, 334000))

## RasterStacks
s &lt;- stack(r, r+500, r-500)
levelplot(s, contour=TRUE)
contourplot(s, labels=list(cex=0.4), cuts=12)

## Not run: 
## Use of layout
levelplot(s, layout=c(1, 3))

## SpatRaster with several layers
st &lt;- c(rt, rt + 500, rt - 500)

## c() assign the same name for all the layers,
## but each layer needs a unique name for levelplot
set.names(st, c("r0", "rp500", "rm500"))

levelplot(st, contour=TRUE)
contourplot(st, labels=list(cex=0.4), cuts=12)

levelplot(st, layout=c(1, 1)) # useful for animations

## End(Not run)

## names.attr to change the labels of each panel
levelplot(s, names.attr=c('R', 'R + 500', 'R - 500'))

## Defining the scales for the marginal plot
levelplot(r, margin = list(axis = TRUE,
                           scales = list(x=c(100, 600),
                                         y=c(100, 1000))))
## if a component of the list is null, it is internally calculated
levelplot(rt, margin=list(axis = TRUE, scales = list(x=c(100, 1000))))

## Add a layer of sampling points
## and change the theme
pts &lt;- sampleRandom(r, size=20, sp=TRUE)



## Using +.trellis and layer from latticeExtra
library(latticeExtra)

levelplot(r, par.settings = BTCTheme) +
   layer(sp.points(pts, col = 'red'))
contourplot(r, labels = FALSE) +
   layer(sp.points(pts, col = 'red'))

## or with a custom panel function
levelplot(r, par.settings=BTCTheme,
          panel=function(...){
            panel.levelplot(...)
            sp.points(pts, col='red')
            })


## Categorical data
r &lt;- raster(nrow=10, ncol=10)
r[] = 1
r[51:100] = 3
r[3:6, 1:5] = 5
r &lt;- ratify(r)
     
rat &lt;- levels(r)[[1]]
rat$landcover &lt;- c('Pine', 'Oak', 'Meadow')
rat$class &lt;- c('A1', 'B2', 'C3')
levels(r) &lt;- rat
r

levelplot(r, col.regions=c('palegreen', 'midnightblue', 'indianred1'))

## with 'att' you can choose another variable from the RAT
levelplot(r, att=2, col.regions=c('palegreen', 'midnightblue', 'indianred1'))
levelplot(r, att='class', col.regions=c('palegreen', 'midnightblue', 'indianred1'))

r2 &lt;- raster(r)
r2[] = 3
r2[51:100] = 1
r2[3:6, 1:5] = 5

r3 &lt;- raster::init(r, function(n)sample(c(1, 3, 5), n, replace=TRUE))

## Multilayer categorical Raster* are displayed only if their RATs are the same
levels(r2) &lt;- levels(r3) &lt;- levels(r)

s &lt;- stack(r, r2, r3)
names(s) &lt;- c('A', 'B', 'C')

levelplot(s)
levelplot(s, att=2)

## Not run: 
dataURL &lt;- "https://raw.github.com/oscarperpinan/bookvis/master/data/"

##Solar irradiation data from CMSAF http://dx.doi.org/10.5676/EUM_SAF_CM/RAD_MVIRI/V001
old &lt;- setwd(tempdir())
download.file(paste0(dataURL, "SISmm2008_CMSAF.zip"),
   "SISmm2008_CMSAF.zip", method='wget')
unzip("SISmm2008_CMSAF.zip")

listFich &lt;- dir(pattern='\\.nc')
stackSIS &lt;- stack(listFich)
stackSIS &lt;- stackSIS*24 ##from irradiance (W/m2) to irradiation Wh/m2

idx &lt;- seq(as.Date('2008-01-15'), as.Date('2008-12-15'), 'month')

SISmm &lt;- setZ(stackSIS, idx)
names(SISmm) &lt;- month.abb

levelplot(SISmm)

levelplot(SISmm, layers=1, margin = list(FUN = 'median'), contour=TRUE)

setwd(old)

## End(Not run)</code></pre>


</div>