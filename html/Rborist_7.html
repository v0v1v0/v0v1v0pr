<div class="container">

<table style="width: 100%;"><tr>
<td>predict.arbTrain</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>predict method for arbTrain result</h2>

<h3>Description</h3>

<p>Prediction and test using Rborist.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'arbTrain'
predict(object, newdata, sampler, yTest=NULL,
keyedFrame = FALSE, quantVec=NULL, quantiles = !is.null(quantVec),
ctgCensus = "votes", indexing = FALSE, trapUnobserved = FALSE,
bagging = FALSE, nThread = 0, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>arbTrain</code>, created from a
previous invocation of the command <code>rfArb</code>, <code>Rborist</code>
or <code>rfTrain</code> to train.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a design frame or matrix containing new data, with the
same signature of predictors as in the training command.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampler</code></td>
<td>
<p>an object of class <code>Sampler</code> used in the
command.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yTest</code></td>
<td>
<p>a response vector against which to test the new
predictions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keyedFrame</code></td>
<td>
<p>whether the columns of <code>newdata</code> may appear in
arbitrary order or as a superset of the predictors used to train.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantVec</code></td>
<td>
<p>a vector of quantiles to predict.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quantiles</code></td>
<td>
<p>whether to predict quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ctgCensus</code></td>
<td>
<p>whether/how to summarize per-category predictions.
"votes" specifies the number of trees predicting a given class.
"prob" specifies a normalized, probabilistic summary.
"probSample" specifies sample-weighted probabilities, similar to
quantile histogramming.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indexing</code></td>
<td>
<p>whether to record the final node index, typically
terminal, of tree traversal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trapUnobserved</code></td>
<td>
<p>reports score for nonterminal upon encountering
values not observed during training, such as missing data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bagging</code></td>
<td>
<p>whether prediction is restricted to out-of-bag samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThread</code></td>
<td>
<p>suggests ans OpenMP-style thread count.  Zero denotes
default processor setting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>whether to output progress of prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not currently used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of one of two classes:
</p>

<ul>
<li> <p><code>SummaryReg</code> summarizing regression, consisting of:
</p>

<ul>
<li> <p><code>prediction</code> an object of class <code>PredictReg</code> consisting of:
</p>

<ul>
<li> <p><code>yPred</code> the estimated numerical response.
</p>
</li>
<li> <p><code>qPred</code> quantiles of prediction, if requested.
</p>
</li>
<li> <p><code>qEst</code> quantile of the estimate, if quantiles requested.
</p>
</li>
<li> <p><code>indices</code> final index of prediction, if requested.
</p>
</li>
</ul>
</li>
<li> <p><code>validation</code> if validation requested, an object of class <code>ValidReg</code> consisting of:
</p>

<ul>
<li> <p><code>mse</code> the mean-squared error of the estimate.
</p>
</li>
<li> <p><code>rsq</code> the r-squared statistic of the estimate.
</p>
</li>
<li> <p><code>mae</code> the mean absolute error of the estimate.
</p>
</li>
</ul>
</li>
<li> <p><code>importance</code> if permution importance requested, an object of class <code>importanceReg</code>, containing multiple instances of:
</p>

<ul>
<li> <p><code>names</code> the predictor names.
</p>
</li>
<li> <p><code>mse</code> the per-predictor mean-squared error, under permutation.
</p>
</li>
</ul>
</li>
</ul>
</li>
<li> <p><code>SummaryCtg</code> summarizing classification, consisting of:
</p>

<ul>
<li> <p><code>PredictCtg</code> consisting of:
</p>

<ul>
<li> <p><code>yPred</code> estimated categorical response.
</p>
</li>
<li> <p><code>census</code> factor-valued matrix of the estimate, by category, if requested.
</p>
</li>
<li> <p><code>prob</code> matrix of estimate probabilities, by category, if requested.
</p>
</li>
<li> <p><code>indices</code> final index of prediction, if requested.
</p>
</li>
</ul>
</li>
<li> <p><code>validation</code> if validation requested, an object of class <code>ValidCtg</code> consisting of:
</p>

<ul>
<li> <p><code>confusion</code> the confusion matrix.
</p>
</li>
<li> <p><code>misprediction</code> the misprediction rate.
</p>
</li>
<li> <p><code>oobError</code> the out-of-bag error.
</p>
</li>
</ul>
</li>
<li> <p><code>importance</code> if permution importance requested, an object of class <code>importanceCtg</code>, consisting of:
</p>

<ul>
<li> <p><code>mispred</code> the misprediction rate, by predictor.
</p>
</li>
<li> <p><code>oobErr</code> the out-of-bag error, by predictor.
</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>See Also</h3>

<p><code>rfTrain</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  # Regression example:
  nRow &lt;- 5000
  x &lt;- data.frame(replicate(6, rnorm(nRow)))
  y &lt;- with(x, X1^2 + sin(X2) + X3 * X4) # courtesy of S. Welling.

  pf &lt;- preformat(x)
  sp &lt;- presample(y)
  rb &lt;- arbTrain(pf, sp, y)


  # Performs separate prediction on new data:
  xx &lt;- data.frame(replace(6, rnorm(nRow)))
  pred &lt;- predict(rb, xx)
  yPred &lt;- pred$yPred

  rb &lt;- Rborist(x,y)

  # Performs separate prediction on new data:
  xx &lt;- data.frame(replacate(6, rnorm(nRow)))
  pred &lt;- predict(rb, xx)
  yPred &lt;- pred$yPred

  # As above, but also records final indices of each tree walk:
  #
  pred &lt;- predict(rb, xx, indexing=TRUE)
  print(pred$indices[c(1:2), ])


  # As above, but predicts over \code{newdata} with unobserved values.
  # In the case of numerical data, only missing values are considered
  # unobserved.  Missing values are encoded as \code{NaN}, which are
  # incomparable, precipitating \code{false} on every test.  Prediction
  # therefore takes the \code{false} branch when encountering missing
  # values:
  #
  xxMissing &lt;- xx
  xxMissing[6, c(15, 32, 87, 101)] &lt;- NA
  pred &lt;- predict(rb, xxMissing)
  

  # As above, but returns a nonterminal score upon encountering
  # unobserved values. Neither the true nor the false branch from the
  # testing node is taken.  Instead, the score returned is derived
  # from all leaf nodes (terminals) reached by the testing
  # (nonterminal) node.
  #
  pred &lt;- predict(rb, xxMissing, trapUnobserved = TRUE)


  # Performs separate prediction, using original response as test
  # vector:
  pred &lt;- predict(rb, xx, y)
  mse &lt;- pred$mse
  rsq &lt;- pred$rsq


  # Performs separate prediction with (default) quantiles:
  pred &lt;- predict(rb, xx, quantiles="TRUE")
  qPred &lt;- pred$qPred


  # Performs separate prediction with deciles:
  pred &lt;- predict(rb, xx, quantVec = seq(0.1, 1.0, by = 0.10))
  qPred &lt;- pred$qPred


  # Classification examples:
  data(iris)
  rb &lt;- Rborist(iris[-5], iris[5])


  # Generic prediction using training set.
  # Census as (default) votes:
  pred &lt;- predict(rb, iris[-5])
  yPred &lt;- pred$yPred
  census &lt;- pred$census

  # Using the \code{keyedFrame} option allows the columns of
  # \code{newdata} to appear in arbitrary order, so long as the
  # columns present during training appear as a subset:
  #
  pred &lt;- predict(rb, iris[c(2, 4, 3, 1)], keyedFrame=TRUE)


  # As above, but validation census to report class probabilities:
  pred &lt;- predict(rb, iris[-5], ctgCensus="prob")
  prob &lt;- pred$prob


  # As above, but with training reponse as test vector:
  pred &lt;- predict(rb, iris[-5], iris[5], ctgCensus = "prob")
  prob &lt;- pred$prob
  conf &lt;- pred$confusion
  misPred &lt;- pred$misPred

  # As above, but predicts nonterminal when encountering categories
  # not observed during training.  That is, prediction returns a score
  # derived from all terminal nodes (leaves) reached from the
  # (nonterminal) testing node.
  #
  # In this case, "unobserved" refers to categories not present in
  # the subpartition over which a splitting is performed.  As training
  # partitions the data into smaller and smaller regions, a given
  # category becomes less likely to appear in a region.
  #
  # More generally, unobserved data can include missing predictors as
  # well as categories appearing in \code{newdata} which were not
  # present during training.
  #
  pred &lt;- predict(rb, trapUnobserved=TRUE)

## End(Not run)
</code></pre>


</div>