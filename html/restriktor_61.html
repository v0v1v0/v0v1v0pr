<div class="container">

<table style="width: 100%;"><tr>
<td>iht</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>function for informative hypothesis testing (iht)</h2>

<h3>Description</h3>

<p><code>iht</code> tests linear equality and/or inequality 
restricted hypotheses for linear models. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">iht(...)

conTest(object, constraints = NULL, type = "summary", test = "F", 
        rhs = NULL, neq = 0, ...)

conTestD(model = NULL, data = NULL, constraints = NULL, 
         type = c("A","B"), R = 1000L, bootstrap.type = "bollen.stine", 
         return.test = TRUE, neq.alt = 0, 
         double.bootstrap = "standard", double.bootstrap.R = 249, 
         double.bootstrap.alpha = 0.05, 
         parallel = c("no", "multicore", "snow"), 
         ncpus = 1L, cl = NULL, verbose = FALSE, ...)        
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>lm</code> or <code>rlm</code>. In this 
case, the constraint syntax needs to be specified
</p>
<p>OR
</p>
<p>an object of class <code>restriktor</code>. The constraints are inherited 
from the fitted restriktor object and do not to be specified again.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>lavaan model syntax specifying the model. See <code>model.syntax</code> 
for more information. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>constraints</code></td>
<td>
<p>there are two ways to constrain parameters. 
First, the constraint syntax consists of one or more text-based
descriptions, where the syntax can be specified as a literal 
string enclosed by single quotes. Only the names of <code>coef(model)</code>
can be used as names. See details <code>restriktor</code> for more information. 
</p>
<p>Second, the constraint syntax consists of a matrix <code class="reqn">R</code> (or a vector in 
case of one constraint) and defines the left-hand side of the 
constraint <code class="reqn">R\theta \ge rhs</code>, where each row represents one 
constraint. The number of columns needs to correspond to the 
number of parameters estimated (<code class="reqn">\theta</code>) by model. The rows 
should be linear independent, otherwise the function gives an 
error. For more information about constructing the matrix <code class="reqn">R</code> and 
<code class="reqn">rhs</code> see the details in the <code>restriktor</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>the data frame containing the observed variables being used to 
fit the lavaan model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>hypothesis test type "A", "B", "C", "global", or 
"summary" (default). See details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>test statistic; for information about the 
null-distribution see details.
</p>

<ul>
<li>
<p> for object of class lm; if "F" (default), the F-bar 
statistic (Silvapulle, 1996) is computed. If "LRT", a 
likelihood ratio test statistic (Silvapulle and Sen, 2005, 
chp 3.) is computed. If "score", a global score test 
statistic (Silvapulle and Silvapulle, 1995) is 
computed. Note that, in case of equality constraints only, 
the usual unconstrained F-, Wald-, LR- and score-test 
statistic is computed. 
</p>
</li>
<li>
<p> for object of class rlm; if "F" (default), a robust 
likelihood ratio type test statistic (Silvapulle, 1992a) is 
computed. If "Wald", a robust Wald test statistic (Silvapulle, 1992b) 
is computed. If "score", a global score test statistic (Silvapulle, 
and Silvapulle, 1995) is computed. Note that, in case of equality 
constraints only, unconstrained robust F-, Wald-, score-test 
statistics are computed.
</p>
</li>
<li>
<p> for object of class glm; if "F" (default), the F-bar 
statistic (Silvapulle, 1996) is computed. If "LRT", a 
likelihood ratio test statistic (Silvapulle and Sen, 2005, 
chp 4.) is computed. If "score", a global score test 
statistic (Silvapulle and Silvapulle, 1995) is 
computed. Note that, in case of equality constraints only, 
the usual unconstrained F-, Wald-, LR- and score-test 
statistic is computed. 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs</code></td>
<td>
<p>vector on the right-hand side of the constraints; 
<code class="reqn">R\theta \ge rhs</code>. The length of this vector equals the 
number of rows of the constraints matrix <code class="reqn">R</code> and consists of 
zeros by default. Note: only used if constraints input is a 
matrix or vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neq</code></td>
<td>
<p>integer (default = 0) treating the number of 
constraints rows as equality constraints instead of inequality 
constraints. For example, if <code>neq = 2</code>, this means that the 
first two rows of the constraints matrix <code class="reqn">R</code> are treated as 
equality constraints. Note: only used if constraints input is a 
matrix or vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neq.alt</code></td>
<td>
<p>integer: number of equality constraints that are maintained under 
the alternative hypothesis (for hypothesis test type "B").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Integer; number of bootstrap draws. The default value is set to 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap.type</code></td>
<td>
<p>If <code>"parametric"</code>, the parametric bootstrap is used. 
If <code>"bollen.stine"</code>, the semi-nonparametric Bollen-Stine bootstrap 
is used. The default is set to <code>"bollen.stine"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return.test</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the function returns bootstrapped         
test-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>double.bootstrap</code></td>
<td>
<p>If <code>"standard"</code> (default) the genuine double bootstrap is 
used to compute an additional set of plug-in p-values for each bootstrap       
sample. If <code>"no"</code>, no double bootstrap is used. If <code>"FDB"</code>, 
the fast double bootstrap is used to compute second level LRT-values for 
each bootstrap sample. Note that the <code>"FDB"</code> is experimental and should 
not be used by inexperienced users.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>double.bootstrap.R</code></td>
<td>
<p>Integer; number of double bootstrap draws. The default 
value is set to 249.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>double.bootstrap.alpha</code></td>
<td>
<p>The significance level to compute the adjusted 
alpha based on the plugin p-values. Only used if <code>double.bootstrap = "standard"</code>. 
The default value is set to 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, 
the default is set "no".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>Integer: number of processes to be used in parallel operation: 
typically one would chose this to the number of available CPUs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if 
<code>parallel = "snow"</code>. If not supplied, a cluster on the local machine 
is created for the duration of the <code>InformativeTesting</code> call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, information is shown at each bootstrap         
draw.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>futher options for the <code>iht</code> and/or 
<code>restriktor</code> function. See details for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The following hypothesis tests are available:
</p>

<ul>
<li>
<p> Type A: Test H0: all constraints with equalities ("=") 
active against HA: at least one inequality restriction ("&gt;") 
strictly true.
</p>
</li>
<li>
<p> Type B: Test H0: all constraints with inequalities ("&gt;") 
(including some equalities ("=")) active against HA: at least 
one restriction false (some equality constraints may be 
maintained).
</p>
</li>
<li>
<p> Type C: Test H0: at least one restriction false ("&lt;") 
against HA: all constraints strikty true ("&gt;"). This test is 
based on the intersection-union principle (Silvapulle and Sen, 
2005, chp 5.3). Note that, this test only makes sense in case 
of no equality constraints.
</p>
</li>
<li>
<p> Type global: equal to Type A but H0 contains additional 
equality constraints. This test is analogue to the global 
F-test in lm, where all coefficients but the intercept equal 0.
</p>
</li>
</ul>
<p>The null-distribution of hypothesis test Type C is based on a 
t-distribution (one-sided). Its power can be poor in case of many 
inequalty constraints. Its main role is to prevent wrong 
conclusions from significant results from hypothesis test Type A.
</p>
<p>The exact finite sample distributions of the non-robust F-, 
score- and LR-test statistics based on restricted OLS estimates 
and normally distributed errors, are a mixture of F-distributions 
under the null hypothesis (Wolak, 1987). For the robust tests, we 
found that the results based on these mixtures of F-distributions 
approximate the tail probabilities better than their asymptotic 
distributions. 
</p>
<p>Note that, in case of equality constraints only, the 
null-distribution of the (non-)robust F-test statistics are 
based on an F-distribution. The (non-)robust Wald- and (non-)robust 
score-test statistics are based on chi-square distributions.
</p>
<p>If object is of class <code>lm</code> or <code>rlm</code>, the <code>conTest</code> function
internally calls the <code>restriktor</code> function. Arguments for the 
<code>restriktor</code> function can be passed on via the <code>...</code>. Additional
arguments for the <code>conTest</code> function can also passed on via the <code>...</code>.
See for example <code>conTestF</code> for all available arguments.
</p>


<h3>Value</h3>

<p>An object of class conTest or conTestLavaan for which a print is available. 
</p>


<h3>Author(s)</h3>

<p>Leonard Vanbrabant and Yves Rosseel</p>


<h3>References</h3>

<p>Robertson, T., Wright, F.T. and Dykstra, R.L. (1988). <em>Order Restricted 
Statistical Inference</em> New York: Wiley.
</p>
<p>Shapiro, A. (1988). Towards a unified theory of inequality-constrained 
testing in multivariate analysis. <em>International Statistical 
Review</em> <b>56</b>, 49–62.
</p>
<p>Silvapulle, M. (1992a). Robust tests of inequality constraints and 
one-sided hypotheses in the linear model. <em>Biometrika</em>, 
<b>79</b>, 621–630.
</p>
<p>Silvapulle, M. (1992b). Robust Wald-Type Tests of One-Sided Hypotheses 
in the Linear Model. <em>Journal of the American Statistical Association</em>, 
<b>87</b>, 156–161.
</p>
<p>Silvapulle, M. and Silvapulle, P. (1995). A score test against 
one-sided alternatives. <em>American statistical association</em>, 
<b>90</b>, 342–349.
</p>
<p>Silvapulle, M. (1996) On an F-type statistic for testing one-sided 
hypotheses and computation of chi-bar-squared weights. 
<em>Statistics and probability letters</em>, <b>28</b>, 137–141.
</p>
<p>Silvapulle, M. (1996) Robust bounded influence tests against 
one-sided hypotheses in general parametric models. 
<em>Statistics and probability letters</em>, <b>31</b>, 45–50.
</p>
<p>Silvapulle, M.J. and Sen, P.K. (2005). <em>Constrained 
Statistical Inference</em>. Wiley, New York
</p>
<p>Vanbrabant, L., Van de Schoot, R., Van Loey, N.E.E. and Rosseel, Y. (2017). 
A General Procedure for Testing Inequality Constrained Hypotheses in SEM.
<em>Methodology European Journal of Research Methods for the Behavioral and Social Sciences</em>,
<b>13</b>, 61-70.
</p>
<p>Van de Schoot, R., Hoijtink, H., and Dekovic, M. (2010). 
Testing inequality constrained hypotheses in SEM models. 
<em>Structural Equation Modeling</em>, <b>17</b>, 443-463.
</p>
<p>Van de Schoot, R., Strohmeier, D. (2011). 
Testing informative hypotheses in SEM increases power: An 
illustration contrasting classical. <em>International Journal 
of Behavioral Development</em>, <b>35</b>, 180-190.
</p>
<p>Wolak, F. (1987). An exact test for multiple inequality and 
equality constraints in the linear regression model. 
<em>Journal of the American statistical association</em>, 
<b>82</b>, 782–793.
</p>


<h3>See Also</h3>

 
<p>quadprog, 
<code>conTest</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## example 1:
# the data consist of ages (in months) at which an 
# infant starts to walk alone.

# prepare data
DATA1 &lt;- subset(ZelazoKolb1972, Group != "Control")

# fit unrestricted linear model
fit1.lm &lt;- lm(Age ~ -1 + Group, data = DATA1)

# the variable names can be used to impose constraints on
# the corresponding regression parameters.
coef(fit1.lm)

# constraint syntax: assuming that the walking 
# exercises would not have a negative effect of increasing the 
# mean age at which a child starts to walk. 
myConstraints1 &lt;- ' GroupActive &lt; GroupPassive &lt; GroupNo '

iht(fit1.lm, myConstraints1)


# another way is to first fit the restricted model
fit.restr1 &lt;- restriktor(fit1.lm, constraints = myConstraints1)

iht(fit.restr1)


# Or in matrix notation.
Amat1 &lt;- rbind(c(-1, 0,  1),
               c( 0, 1, -1))
myRhs1 &lt;- rep(0L, nrow(Amat1)) 
myNeq1 &lt;- 0

iht(fit1.lm, constraints = Amat1, rhs = myRhs1, neq = myNeq1)

#########################
## Artificial examples ##
#########################
# generate data
n &lt;- 10
means &lt;- c(1,2,1,3)
nm &lt;- length(means)
group &lt;- as.factor(rep(1:nm, each = n))
y &lt;- rnorm(n * nm, rep(means, each = n))
DATA2 &lt;- data.frame(y, group)

# fit unrestricted linear model
fit2.lm &lt;- lm(y ~ -1 + group, data = DATA2)
coef(fit2.lm)

## example 2: increasing means
myConstraints2 &lt;- ' group1 &lt; group2 &lt; group3 &lt; group4 '

# compute F-test for hypothesis test Type A and compute the tail 
# probability based on the parametric bootstrap. We only generate 9 
# bootstrap samples in this example; in practice you may wish to 
# use a much higher number.
iht(fit2.lm, constraints = myConstraints2, type = "A", 
    boot = "parametric", R = 9)


# or fit restricted linear model
fit2.con &lt;- restriktor(fit2.lm, constraints = myConstraints2)

iht(fit2.con)

# increasing means in matrix notation.
Amat2 &lt;- rbind(c(-1, 1, 0, 0),
               c( 0,-1, 1, 0),
               c( 0, 0,-1, 1))
myRhs2 &lt;- rep(0L, nrow(Amat2)) 
myNeq2 &lt;- 0

iht(fit2.con, constraints = Amat2, rhs = myRhs2, neq = myNeq2, 
    type = "A", boot = "parametric", R = 9)

## example 3: equality constraints only.
myConstraints3 &lt;- ' group1 = group2 = group3 = group4 '

iht(fit2.lm, constraints = myConstraints3)

# or
fit3.con &lt;- restriktor(fit2.lm, constraints = myConstraints3)
iht(fit3.con)


## example 4:
# combination of equality and inequality constraints.
myConstraints4 &lt;- ' group1 = group2
                    group3 &lt; group4 '

iht(fit2.lm, constraints = myConstraints4, type = "B", neq.alt = 1)

# fit resticted model and compute model-based bootstrapped 
# standard errors. We only generate 9 bootstrap samples in this 
# example; in practice you may wish to use a much higher number.
# Note that, a warning message may be thrown because the number of 
# bootstrap samples is too low.
fit4.con &lt;- restriktor(fit2.lm, constraints = myConstraints4, 
                       se = "boot.model.based", B = 9)
iht(fit4.con, type = "B", neq.alt = 1)


## example 5:
# restriktor can also be used to define effects using the := operator 
# and impose constraints on them. For example, is the 
# average effect (AVE) larger than zero?
# generate data
n &lt;- 30
b0 &lt;- 10; b1 = 0.5; b2 = 1; b3 = 1.5
X &lt;- c(rep(c(0), n/2), rep(c(1), n/2))
set.seed(90) 
Z &lt;- rnorm(n, 16, 5)
y &lt;- b0 + b1*X + b2*Z + b3*X*Z + rnorm(n, 0, sd = 10) 
DATA3 = data.frame(cbind(y, X, Z))

# fit linear model with interaction
fit5.lm &lt;- lm(y ~ X*Z, data = DATA3)

# constraint syntax
myConstraints5 &lt;- ' AVE := X + 16.86137*X.Z; 
                    AVE &gt; 0 '

iht(fit5.lm, constraints = myConstraints5)

# or
fit5.con &lt;- restriktor(fit5.lm, constraints = ' AVE := X + 16.86137*X.Z; 
                                                AVE &gt; 0 ')
iht(fit5.con)


# testing equality and/or inequality restrictions in SEM:

#########################
### real data example ###
#########################
# Multiple group path model for facial burns example.

# model syntax with starting values.
burns.model &lt;- 'Selfesteem ~ Age + c(m1, f1)*TBSA + HADS +
                           start(-.10, -.20)*TBSA  
             HADS ~ Age + c(m2, f2)*TBSA + RUM +
                    start(.10, .20)*TBSA '


# constraints syntax
burns.constraints &lt;- 'f2 &gt; 0  ; m1 &lt; 0
                      m2 &gt; 0  ; f1 &lt; 0
                      f2 &gt; m2 ; f1 &lt; m1'

# we only generate 2 bootstrap samples in this example; in practice
# you may wish to use a much higher number. 
# the double bootstrap was switched off; in practice you probably 
# want to set it to "standard".
example6 &lt;- iht(model = burns.model, data = FacialBurns,
                R = 2, constraints = burns.constraints,
                double.bootstrap = "no", group = "Sex")

example6

##########################
### artificial example ###
##########################

# Simple ANOVA model with 3 groups (N = 20 per group)
set.seed(1234)
Y &lt;- cbind(c(rnorm(20,0,1), rnorm(20,0.5,1), rnorm(20,1,1)))
grp &lt;- c(rep("1", 20), rep("2", 20), rep("3", 20))
Data &lt;- data.frame(Y, grp)

#create model matrix
fit.lm &lt;- lm(Y ~ grp, data = Data)
mfit &lt;- fit.lm$model
mm &lt;- model.matrix(mfit)

Y &lt;- model.response(mfit)
X &lt;- data.frame(mm[,2:3])
names(X) &lt;- c("d1", "d2")
Data.new &lt;- data.frame(Y, X)

# model
model &lt;- 'Y ~ 1 + a1*d1 + a2*d2'

# fit without constraints
fit &lt;- lavaan::sem(model, data = Data.new)

# constraints syntax: mu1 &lt; mu2 &lt; mu3
constraints &lt;- ' a1 &gt; 0
                 a1 &lt; a2 '

# we only generate 10 bootstrap samples in this example; in practice
# you may wish to use a much higher number, say &gt; 1000. The double 
# bootstrap is not necessary in case of an univariate ANOVA model.
example7 &lt;- iht(model = model, data = Data.new, 
                start = lavaan::parTable(fit),
                R = 10L, double.bootstrap = "no",
                constraints = constraints)
example7

</code></pre>


</div>