<div class="container">

<table style="width: 100%;"><tr>
<td>hnsw_build</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build an hnswlib nearest neighbor index</h2>

<h3>Description</h3>

<p>Build an hnswlib nearest neighbor index
</p>


<h3>Usage</h3>

<pre><code class="language-R">hnsw_build(
  X,
  distance = "euclidean",
  M = 16,
  ef = 200,
  verbose = FALSE,
  progress = "bar",
  n_threads = 0,
  grain_size = 1,
  byrow = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix of data to search for neighbors. If <code>byrow = TRUE</code>
(the default) then each row of <code>X</code> is an item to be searched. Otherwise,
each item should be stored in the columns of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>Type of distance to calculate. One of:
</p>

<ul>
<li> <p><code>"l2"</code> Squared L2, i.e. squared Euclidean.
</p>
</li>
<li> <p><code>"euclidean"</code> Euclidean.
</p>
</li>
<li> <p><code>"cosine"</code> Cosine.
</p>
</li>
<li> <p><code>"ip"</code> Inner product: 1 - sum(ai * bi), i.e. the cosine distance
where the vectors are not normalized. This can lead to negative distances
and other non-metric behavior.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Controls the number of bi-directional links created for each element
during index construction. Higher values lead to better results at the
expense of memory consumption. Typical values are <code>2 - 100</code>, but
for most datasets a range of <code>12 - 48</code> is suitable. Can't be smaller
than 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ef</code></td>
<td>
<p>Size of the dynamic list used during construction.
A larger value means a better quality index, but increases build time.
Should be an integer value between 1 and the size of the dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code>, log messages to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>defunct and has no effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_threads</code></td>
<td>
<p>Maximum number of threads to use. The exact number is
determined by <code>grain_size</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grain_size</code></td>
<td>
<p>Minimum amount of work to do (rows in <code>X</code> to add) per
thread. If the number of rows in <code>X</code> isn't sufficient, then fewer than
<code>n_threads</code> will be used. This is useful in cases where the overhead
of context switching with too many threads outweighs the gains due to
parallelism.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>byrow</code></td>
<td>
<p>if <code>TRUE</code> (the default), this indicates that the items in <code>X</code>
to be indexed are stored in each row. Otherwise, the items are stored in
the columns of <code>X</code>. Storing items in each column reduces the overhead of
copying data to a form that can be indexed by the <code>hnsw</code> library.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an instance of a <code>HnswL2</code>, <code>HnswCosine</code> or <code>HnswIp</code> class.
</p>


<h3>Examples</h3>

<pre><code class="language-R">irism &lt;- as.matrix(iris[, -5])
ann &lt;- hnsw_build(irism)
iris_nn &lt;- hnsw_search(irism, ann, k = 5)
</code></pre>


</div>