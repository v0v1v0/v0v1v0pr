<div class="container">

<table style="width: 100%;"><tr>
<td>getInfRobIC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Generic Function for the Computation of Optimally Robust ICs </h2>

<h3>Description</h3>

<p>Generic function for the computation of optimally robust ICs 
in case of infinitesimal robust models. This function is 
rarely called directly. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">getInfRobIC(L2deriv, risk, neighbor, ...)

## S4 method for signature 'UnivariateDistribution,asCov,ContNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, Finfo, trafo, verbose = NULL)

## S4 method for signature 'UnivariateDistribution,asCov,TotalVarNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, Finfo, trafo, verbose = NULL)

## S4 method for signature 'RealRandVariable,asCov,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor, Distr, Finfo, trafo, QuadForm = diag(nrow(trafo)),
                       verbose = NULL)

## S4 method for signature 'UnivariateDistribution,asBias,UncondNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, symm, trafo, maxiter, tol, warn, Finfo,
                       verbose = NULL, ...)

## S4 method for signature 'RealRandVariable,asBias,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor, Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, z.start, A.start, Finfo, trafo,
                       maxiter, tol, warn, verbose = NULL, ...)

## S4 method for signature 'UnivariateDistribution,asHampel,UncondNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, symm, Finfo, trafo, upper = NULL,
                       lower=NULL, maxiter, tol, warn, noLow = FALSE,
                       verbose = NULL, checkBounds = TRUE, ...)

## S4 method for signature 'RealRandVariable,asHampel,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor, Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, Finfo, trafo, onesetLM = FALSE,
                       z.start, A.start, upper = NULL, lower=NULL,
                       OptOrIter = "iterate", maxiter, tol, warn,
                       verbose = NULL, checkBounds = TRUE, ...,
                       .withEvalAsVar = TRUE)

## S4 method for signature 
## 'UnivariateDistribution,asAnscombe,UncondNeighborhood'
getInfRobIC(
                       L2deriv, risk, neighbor, symm, Finfo, trafo, upper = NULL,
                       lower=NULL, maxiter, tol, warn, noLow = FALSE,
                       verbose = NULL, checkBounds = TRUE, ...)

## S4 method for signature 'RealRandVariable,asAnscombe,UncondNeighborhood'
getInfRobIC(L2deriv, 
                       risk, neighbor, Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, Finfo, trafo, onesetLM = FALSE,
                       z.start, A.start, upper = NULL, lower=NULL,
                       OptOrIter = "iterate", maxiter, tol, warn,
                       verbose = NULL, checkBounds = TRUE, ...)

## S4 method for signature 'UnivariateDistribution,asGRisk,UncondNeighborhood'
getInfRobIC(L2deriv,
                       risk, neighbor, symm, Finfo, trafo, upper = NULL,
                       lower = NULL, maxiter, tol, warn, noLow = FALSE,
                       verbose = NULL, ...)

## S4 method for signature 'RealRandVariable,asGRisk,UncondNeighborhood'
getInfRobIC(L2deriv, risk,
                       neighbor,  Distr, DistrSymm, L2derivSymm,
                       L2derivDistrSymm, Finfo, trafo, onesetLM = FALSE, z.start,
                       A.start, upper = NULL, lower = NULL, OptOrIter = "iterate",
                       maxiter, tol, warn, verbose = NULL, withPICcheck = TRUE,
                       ..., .withEvalAsVar = TRUE)

## S4 method for signature 
## 'UnivariateDistribution,asUnOvShoot,UncondNeighborhood'
getInfRobIC(
                       L2deriv, risk, neighbor, symm, Finfo, trafo,
                       upper, lower, maxiter, tol, warn, verbose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family 
of probability measures. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional parameters (mainly for <code>optim</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>symm</code></td>
<td>
<p> logical: indicating symmetry of <code>L2deriv</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DistrSymm</code></td>
<td>
<p> object of class <code>"DistributionSymmetry"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2derivSymm</code></td>
<td>
<p> object of class <code>"FunSymmList"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2derivDistrSymm</code></td>
<td>
<p> object of class <code>"DistrSymmList"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Finfo</code></td>
<td>
<p> Fisher information matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.start</code></td>
<td>
<p> initial value for the centering constant. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p> upper bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p> lower bound for the optimal clipping bound. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p> logical: print warnings. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noLow</code></td>
<td>
<p> logical: is lower case to be computed? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onesetLM</code></td>
<td>
<p> logical: use one set of Lagrange multipliers? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>QuadForm</code></td>
<td>
<p> matrix of (or which may coerced to) class 
<code>PosSemDefSymmMatrix</code> for use of different 
(standardizing) norm </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkBounds</code></td>
<td>
<p> logical: if <code>TRUE</code>, minimal and maximal clipping bound are 
computed to check if a valid bound was specified. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withPICcheck</code></td>
<td>
<p>logical: at the end of the algorithm, shall we check
how accurately this is a pIC; this will only be done if
<code>withPICcheck &amp;&amp; verbose</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.withEvalAsVar</code></td>
<td>
<p>logical (of length 1):
if <code>TRUE</code>, risks based on covariances are to be
evaluated (default), otherwise just a call is returned.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The optimally robust IC is computed.</p>


<h3>Methods</h3>


<dl>
<dt>L2deriv = "UnivariateDistribution", risk = "asCov", 
neighbor = "ContNeighborhood"</dt>
<dd> 
<p>computes the classical optimal influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = "UnivariateDistribution", risk = "asCov", 
neighbor = "TotalVarNeighborhood"</dt>
<dd>
<p>computes the classical optimal influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = "RealRandVariable", risk = "asCov", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the classical optimal influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = "UnivariateDistribution", risk = "asBias", 
neighbor = "UncondNeighborhood"</dt>
<dd> 
<p>computes the bias optimal influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = "RealRandVariable", risk = "asBias", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the bias optimal influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate. </p>
</dd>
<dt>L2deriv = "UnivariateDistribution", risk = "asHampel", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = "RealRandVariable", risk = "asHampel", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = "UnivariateDistribution", risk = "asAnscombe", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the optimally bias-robust influence curve to given ARE in the
ideal model for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = "RealRandVariable", risk = "asAnscombe", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the optimally bias-robust influence curve to given ARE in the
ideal modelfor L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = "UnivariateDistribution", risk = "asGRisk", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown one-dimensional parameter. </p>
</dd>
<dt>L2deriv = "RealRandVariable", risk = "asGRisk", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the optimally robust influence curve for L2 differentiable 
parametric families with unknown <code class="reqn">k</code>-dimensional parameter 
(<code class="reqn">k &gt; 1</code>) where the underlying distribution is univariate;
for total variation neighborhoods only is implemented for the case
where there is a <code class="reqn">1\times k</code> transformation <code>trafo</code>
matrix. </p>
</dd>
<dt>L2deriv = "UnivariateDistribution", risk = "asUnOvShoot", 
neighbor = "UncondNeighborhood"</dt>
<dd>
<p>computes the optimally robust influence curve for one-dimensional
L2 differentiable parametric families and 
asymptotic under-/overshoot risk. </p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br>
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106-115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <b>22</b>: 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code>InfRobModel-class</code></p>


</div>