<div class="container">

<table style="width: 100%;"><tr>
<td>locw</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Locally weighted models</h2>

<h3>Description</h3>

<p><code>locw</code> and <code>locwlv</code> are generic working functions returning predictions of KNN locally weighted (LW) models. One specific (= local) model is fitted for each observation to predict, and a prediction is returned. See the wrapper <code>lwplsr</code> (KNN-LWPLSR) for an example of use. 
</p>
<p>In KNN-LW models, the prediction is built from two sequential steps, therafter referred to as <code class="reqn">weighting "1"</code> and <code class="reqn">weighting "2"</code>, respectively. For each new observation to predict, the two steps are as follow:
</p>
<p>- <code class="reqn">Weighting "1"</code>. The <code class="reqn">k</code> nearest neighbors (in the training data set) are selected and the prediction model is fitted (in the next step) only on this neighborhood. It is equivalent to give a weight = 1 to the neighbors, and a weight = 0 to the other training observations, which corresponds to a binary weighting.
</p>
<p>- <code class="reqn">Weighting "2"</code>. Each of the <code class="reqn">k</code> nearest neighbors eventually receives a weight (different from the usual <code class="reqn">1/k</code>) before fitting the model. The weight depend from the dissimilarity (preliminary calculated) between the observation and the neighbor. This corresponds to a within-neighborhood weighting.
</p>
<p>The prediction model used in step <code class="reqn">"2"</code> has to be defined in a function specified in argument <code>fun</code>. If there are <code class="reqn">m</code> new observations to predict, a list of <code class="reqn">m</code> vectors defining the <code class="reqn">m</code> neighborhoods has to be provided (argument <code>listnn</code>). Each of the <code class="reqn">m</code> vectors contains the indexes of the nearest neighbors in the training set. The <code class="reqn">m</code> vectors are not necessary of same length, i.e. the neighborhood size can vary between observations to predict. If there is a weighting in step <code class="reqn">"2"</code>, a list of <code class="reqn">m</code> vectors of weights have to be provided  (argument <code>listw</code>). Then  <code>locw</code> fits the model successively for each of the <code class="reqn">m</code> neighborhoods, and returns the corresponding <code class="reqn">m</code> predictions.
</p>
<p>Function  <code>locwlv</code> is dedicated to prediction models based on latent variables (LVs) calculations, such as PLSR. It is much faster and recommended.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">
locw(Xtrain, Ytrain, X, listnn, listw = NULL, fun, verb = FALSE, ...)

locwlv(Xtrain, Ytrain, X, listnn, listw = NULL, fun, nlv, verb = FALSE, ...)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Xtrain</code></td>
<td>
<p>Training X-data (<code class="reqn">n, p</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ytrain</code></td>
<td>
<p>Training Y-data (<code class="reqn">n, q</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>New X-data (<code class="reqn">m, p</code>) to predict.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listnn</code></td>
<td>
<p>A list of <code class="reqn">m</code> vectors defining weighting "1". Component <code class="reqn">i</code> of this list is a vector (of length between 1 and <code class="reqn">n</code>) of indexes. These indexes define the training observations that are the nearest neighbors of new observation <code class="reqn">i</code>. Typically, <code>listnn</code> can be built from <code>getknn</code>, but any other list of length <code class="reqn">m</code> can be provided. The <code class="reqn">m</code> vectors can have equal length (i.e. the <code class="reqn">m</code> neighborhoods are of equal size) or not (the number of neighbors varies between the observations to predict).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>listw</code></td>
<td>
<p>A list of <code class="reqn">m</code> vectors defining weighting "2". Component <code class="reqn">i</code> of this list is a vector (that must have the same length as component <code class="reqn">i</code> of <code>listnn</code>) of the weights given to the nearest neighbors when the prediction model is fitted. Internally, weights are "normalized" to sum to 1 in each component. Default to <code>NULL</code> (weights are set to <code class="reqn">1 / k</code> where <code class="reqn">k</code>is the size of the neihborhodd).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>A function corresponding to the prediction model to fit on the <code class="reqn">m</code> neighborhoods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlv</code></td>
<td>
<p>For <code>locwlv</code> : The number of LVs to calculate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p>Logical. If <code>TRUE</code>, fitting information are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional arguments to pass in function <code>fun</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table><tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>matrix or list of matrices (if <code>nlv</code> is a vector), with predictions</p>
</td>
</tr></table>
<h3>References</h3>

<p>Lesnoff M, Metz M, Roger J-M. Comparison of locally weighted PLS strategies for regression and discrimination on agronomic NIR data. Journal of Chemometrics. 2020;n/a(n/a):e3209. doi:10.1002/cem.3209.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
n &lt;- 50 ; p &lt;- 30
Xtrain &lt;- matrix(rnorm(n * p), ncol = p, byrow = TRUE)
ytrain &lt;- rnorm(n)
Ytrain &lt;- cbind(ytrain, 100 * ytrain)
m &lt;- 4
Xtest &lt;- matrix(rnorm(m * p), ncol = p, byrow = TRUE)
ytest &lt;- rnorm(m)
Ytest &lt;- cbind(ytest, 10 * ytest)

k &lt;- 5
z &lt;- getknn(Xtrain, Xtest, k = k)
listnn &lt;- z$listnn
listd &lt;- z$listd
listnn
listd

listw &lt;- lapply(listd, wdist, h = 2)
listw

nlv &lt;- 2  
locw(Xtrain, Ytrain, Xtest, 
     listnn = listnn, fun = plskern, nlv = nlv)
locw(Xtrain, Ytrain, Xtest, 
     listnn = listnn, listw = listw, fun = plskern, nlv = nlv)

locwlv(Xtrain, Ytrain, Xtest, 
     listnn = listnn, listw = listw, fun = plskern, nlv = nlv)
locwlv(Xtrain, Ytrain, Xtest, 
     listnn = listnn, listw = listw, fun = plskern, nlv = 0:nlv)

</code></pre>


</div>