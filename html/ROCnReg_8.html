<div class="container">

<table style="width: 100%;"><tr>
<td>cROC.bnp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Nonparametric Bayesian inference for the covariate-specific ROC curve (cROC).
</h2>

<h3>Description</h3>

<p>This function estimates the covariate-specific ROC curve (cROC) using the nonparametric Bayesian approach proposed by Inacio de Carvalho et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class="language-R">cROC.bnp(formula.h, formula.d, group, tag.h, data, 
    newdata, standardise = TRUE, p = seq(0, 1, l = 101), ci.level = 0.95,
    compute.lpml = FALSE, compute.WAIC = FALSE, compute.DIC = FALSE, 
    pauc = pauccontrol(), density = densitycontrol(),
    prior.h = priorcontrol.bnp(), prior.d = priorcontrol.bnp(), 
    mcmc = mcmccontrol(),
    parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula.h</code></td>
<td>
<p>A <code>formula</code> object specifying the regression function associated to each component of the single-weights linear dependent Dirichlet process mixture of normals model used to estimate the conditional distribution function of the diagnostic test outcome in the healthy population. Regarding the modelling of continuous covariates, both linear and nonlinear effects are allowed, with nonlinear effects being modelled through B-spline basis expansions (see Note).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula.d</code></td>
<td>
<p>A <code>formula</code> object specifying the regression function associated to each component of the single weights linear dependent Dirichlet process mixture model used to estimate the conditional distribution function of the diagnostic test outcome in the diseased population. Both linear and nonlinear (through the use of smooth functions approximated by linear combinations of cubic B-splines basis functions) covariate effects are allowed (see Note).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame representing the data and containing all needed variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if computed) will be computed. If not supplied, the function <code>cROCData</code> is used to build a default dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardise</code></td>
<td>
<p>A logical value. If TRUE both the test outcomes and the continuous covariates assumed to have a linear effect are standardised (i.e., the resulting variables have mean zero and standard deviation of one). The default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-specific ROC curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the level for the credible interval. The default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.lpml</code></td>
<td>
<p>A logical value. If TRUE, the log pseudo marginal likelihood (LPML, Geisser and Eddy, 1979) and the conditional predictive ordinates (CPO) are computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.WAIC</code></td>
<td>
<p>A logical value. If TRUE, the widely applicable information criterion (WAIC, Gelman et al., 2014; Watanabe, 2010) is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.DIC</code></td>
<td>
<p>A logical value. If TRUE, the deviance information criterion (DIC)(Celeux et al., 2006, Spiegelhalter et al., 2002) is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>pauccontrol</code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>densitycontrol</code>. This argument is used to indicate whether the conditional densities of the marker in the healthy and diseased population should be computed, and in case it is to be computed, at which grid of test outcomes in each of the populations the conditional densities should be evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.h</code></td>
<td>
<p>Hyparameter specification for the healthy population. A list of control values to replace the default values returned by the function <code>priorcontrol.bnp</code>. See <code>priorcontrol.bnp</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.d</code></td>
<td>
<p>Hyparameter specification for the diseased population.  A list of control values to replace the default values returned by the function <code>priorcontrol.bnp</code>. See <code>priorcontrol.bnp</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code>mcmccontrol</code>. See <code>mcmccontrol</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either "no" (default), "multicore" (not available on Windows) or "snow".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = "snow". If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Estimates the covariate-specific ROC curve (cROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|\mathbf{x}) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p|\mathbf{x})|\mathbf{x}\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y|\mathbf{x}) = Pr(Y_{D} \leq y | \mathbf{X}_{D} = \mathbf{x}),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{x}) = Pr(Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>Note that, for the sake of clarity, we assume that the covariates of interest are the same in both the healthy and diseased populations. The method implemented in this function estimates <code class="reqn">F_{D}(\cdot|\mathbf{x})</code> and <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{x})</code> by means of a single-weights linear dependent Dirichlet process mixture of normals model (De Iorio et al., 2009). More precisely, and letting <code class="reqn">\{(\mathbf{x}_{\bar{D}i},y_{\bar{D}i})\}_{i=1}^{n_{\bar{D}}}</code>  and <code class="reqn">\{(\mathbf{x}_{Dj},y_{Dj})\}_{j=1}^{n_{D}}</code> be two independent random samples from the nondiseased and diseased populations, respectively, our postulated model for the conditional distribution in each group function takes the following form 
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i}|\mathbf{X}_{\bar{D}}=\mathbf{x}_{\bar{D}i}) = \sum_{l=1}^{L_{\bar{D}}}\omega_{l\bar{D}}\Phi(y_{\bar{D}i}\mid\mu_{l\bar{D}}(\mathbf{x}_{\bar{D}i}),\sigma_{l\bar{D}}^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{D}(y_{Dj}|\mathbf{X}_{D} = \mathbf{x}_{Dj}) = \sum_{l=1}^{L_{D}}\omega_{lD}\Phi(y_{Dj}\mid\mu_{lD}(\mathbf{x}_{\bar{D}i}),\sigma_{lD}^2),</code>
</p>

<p>where <code class="reqn">\Phi(y|\mu, \sigma^2)</code> denotes the cumulative distribution function of the normal distribution, evaluated at <code class="reqn">y</code>, with mean <code class="reqn">mu</code> and variance <code class="reqn">\sigma^2</code>. The regression function <code class="reqn">\mu_{ld}(\mathbf{x}_{di})</code> can incorportate both linear and nonlinear (through B-splines) effects of continuous covariates, categorical covariates (factors) as well as interactions. Interactions between categorical and (nonlinear) continuous covariates are also allowed (factor-by curve interactions). For the sake of simplicity we write <code class="reqn">\mu_{ld}(\mathbf{x}_{di}) = \mathbf{z}_{di}^{T}\mathbf{\beta}_{ld}</code>, where <code class="reqn">\mathbf{z}_{di}</code> is the <code class="reqn">i</code>th column of the design matrix (possibly containing a basis representation of some/all continuous covariates), <code class="reqn">d \in \{D, \bar{D}\}</code>. Here <code class="reqn">L_d</code> is a pre-specified upper bound on the number of mixture components. The <code class="reqn">\omega_{ld}</code>'s result from a truncated version of the stick-breaking construction (<code class="reqn">\omega_{1d} = v_{1d}</code>; <code class="reqn">\omega_{ld} = v_{ld}\prod_{r&lt;l}(1-v_{dr})</code>, <code class="reqn">l=2,\ldots,L_{d}</code>; <code class="reqn">v_{d1},\ldots,v_{L_{d}-1}\sim</code> Beta <code class="reqn">(1,\alpha_{d})</code>; <code class="reqn">v_{Ld} = 1</code>, <code class="reqn">\alpha_d \sim \Gamma(a_{\alpha_d},b_{\alpha_d})</code>), <code class="reqn">\mathbf{\beta}_{ld}\sim N_{Q_d}(\mathbf{m}_{d},\mathbf{S}_{d})</code>, and <code class="reqn">\sigma_{ld}^{-2}\sim\Gamma(a_{d},b_{d})</code>. It is further assumed that <code class="reqn">\mathbf{m}_{d} \sim N_{Q_k}(\mathbf{m}_{0d},\mathbf{S}_{0d})</code> and <code class="reqn">\mathbf{S}_{d}^{-1}\sim W(\nu,(\nu_k\Psi_d)^{-1})</code>. Here <code class="reqn">W(\nu,(\nu\Psi)^{-1})</code> denotes a Wishart distribution with <code class="reqn">\nu</code> degrees of freedom and expectation <code class="reqn">\Psi^{-1}</code>, Here <code class="reqn">\Gamma(a,b)</code> denotes a Gamma distribution with shape parameter <code class="reqn">a</code> and rate parameter <code class="reqn">b</code>, and <code class="reqn">Q_d</code> denotes the dimension of the vector <code class="reqn">\mathbf{z}_{di}</code>. It is worth mentioning that when <code class="reqn">L_d=1</code>, the model for the conditional distribution of the test outcomes reduces to a normal regression model (where continuous covariates effects are modelled either parametrically or nonparametrically). For a detailed description, we refer to Inacio de Carvalho et al. (2013). 
</p>
<p>The covariate-specific area under the curve is
</p>
<p style="text-align: center;"><code class="reqn">AUC(\mathbf{x})=\int_{0}^{1}ROC(p|\mathbf{x})dp.</code>
</p>

<p>When the upper bound on the number of mixture components is 1, i.e., <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the covariate-specific AUC (binormal model), which is used in the package. In contrast, when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code>, the integral is computed numerically using Simpson's rule. With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})=\int_0^{u_1} ROC(p|\mathbf{x})dp.</code>
</p>
 
<p>As for the AUC, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{FPF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})=\int_{u_2}^{1}ROC_{TNF}(p|\mathbf{x})dp,</code>
</p>

<p>where <code class="reqn">ROC_{TNF}(p|\mathbf{x})</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p|\mathbf{x}) = F_{\bar{D}}\{F_{D}^{-1}(1-p|\mathbf{x})|\mathbf{x}\}.</code> Again, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{TNF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>
<p>It is worth referring that with respect to the computation of the DIC, when <code class="reqn">L=1</code>, it is computed as in Spiegelhalter et al. (2002), and when <code class="reqn">L&gt;1</code>, DIC3 as described in Celeux et al. (2006) is computed. Also, for the computation of the conditional predictive ordinates (CPO) we follow the stable version proposed by Gelman et al. (2014).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>A data frame containing the values of the covariates at which the covariate-specific ROC curve (as well as the AUC, pAUC, dens and reg.fun, if required) was computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-specific ROC curve has been estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>A list returning the hyperparameter values in the healthy and diseased populations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ROC</code></td>
<td>
<p>A list returning the <code>np</code> (length of the vector <code>p</code>) by npred predicted covariate-specific ROC curves (cROC) (posterior mean) and <code>ci.level</code>*100% pointwise posterior credible bands.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-specific ROC curve (posterior mean) and <code>ci.level</code>*100% posterior credible band.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve (posterior mean) and <code>ci.level</code>*100%  credible
band. Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dens</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: <code>grid</code> (grid of test outcomes where the conditional densities were evaluated) and <code>dens</code> (MCMC realisations of the corresponding conditional densities).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reg.fun</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a data frame containing the predicted regression function (posterior mean) and <code>ci.level</code>*100% credible band.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpml</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: the log pseudo marginal likelihood (LPML) and the conditional predictive ordinates (CPO).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WAIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: widely applicable information criterion (WAIC) and associated complexity penalty (pW).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>DIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: deviance information criterion (DIC) and associated complexity penalty (pD).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>Named list of length two, with components <code>h</code> (healthy) and <code>d</code> (diseased). Each component is a list with the following information: (1) <code>formula</code>: the value of the argument <code>formula.h</code> or <code>formula.d</code> used in the call. (2) <code>mm</code>: information needed to construct the model matrix associated with single-weights linear dependent Dirichlet process mixture of normals model. (3) <code>beta</code>: array of dimension <code>nsave</code>x<code>L</code>x<code>Q</code> with the sampled regression coefficients. (4) <code>sd</code>: matrix of dimension <code>nsave</code>x<code>L</code> with the sampled variances. (4) <code>probs</code>: matrix of dimension <code>nsave</code>x<code>L</code> with the sampled components' weights. Here, <code>nsave</code> is the number of Gibbs sampler iterations saved, <code>L</code> is the maximum number of mixture components, and <code>Q</code> is the dimension of vector <code class="reqn">\mathbf{z}_{d}</code>, <code class="reqn">d \in \{D, \bar{D}\}</code>. (see also Details). (see also Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_model</code></td>
<td>
<p>A list with the data used in the fit: observed diagnostic test outcome and design matrices, separately for the healthy and diseased groups.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The input arguments <code>formula.h</code> and <code>formula.d</code> are similar to that used for the <code>glm</code> function, except that flexible specifications can be added by means of the function <code>f()</code>. For instance, specification <code class="reqn">y \sim x1 + f(x2, K = 3)</code> would assume a linear effect of <code>x1</code> (if <code>x1</code> continuous) and the effect of <code>x2</code> would be modeled using B-splines basis functions. The argument <code>K = 3</code> indicates that <code>3</code> internal knots will be used, with the quantiles of <code>x2</code> used for their location. Categorical variables (factors) can be also incorporated, as well as interaction terms. For example, to include the factor-by-curve interaction between <code>age</code> and <code>gender</code> we need to specify, e.g., <code class="reqn">y \sim gender + f(age, by = gender, K = c(3, 5))</code>. Note that, in this case, the number of knots can be different for each level of the factor. The order of the vector <code>K</code> of knots should match the levels of the factor.</p>


<h3>References</h3>

<p>Celeux, G., Forbes, F., Robert C. P., and Titerrington, D. M. (2006). Deviance information criteria for missing data models. Bayesian Analysis, <b>1</b>, 651–674.
</p>
<p>De Iorio, M., Johnson, W. O., Muller, P., and Rosner, G. L. (2009). Bayesian nonparametric nonproportional hazards survival modeling. Biometrics, <b>65</b>, 762–775.
</p>
<p>Geisser, S. and Eddy, W.F. (1979) A Predictive Approach to Model Selection, Journal of the American Statistical Association, <b>74</b>, 153–160.
</p>
<p>Gelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A., and Rubin, D.B. (2014). Bayesian Data Analysis, 3rd ed. CRC Press: Boca Raton, FL.
</p>
<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. Statistics and Computing, <b>24</b>, 997–1010.
</p>
<p>Hillis, S. L. and Metz, C.E. (2012). An Analytic Expression for the Binormal Partial Area under the ROC Curve. Academic Radiology, <b>19</b>, 1491–1498.
</p>
<p>Inacio de Carvalho, V., Jara, A., Hanson, T. E., and de Carvalho, M. (2013). Bayesian nonparametric ROC regression modeling. Bayesian Analysis, <b>8</b>, 623–646.
</p>
<p>Speigelhalter, D. J., Best, N. G., Carlin, B. P., and van der Linde, A. (2002). Bayesian measures of model comparison and fit. Journal of the Royal Statistical Society, Ser. B, <b>64</b>, 583–639.
</p>
<p>Watanabe, S. (2010). Asymptotic Equivalence of Bayes Cross Validation and Widely Applicable Information Criterion in Singular Learning Theory. Journal of Machine Learning Research, <b>11</b>, 3571–3594.
</p>


<h3>See Also</h3>

<p><code>AROC.bnp</code>, <code>AROC.sp</code>, <code>AROC.kernel</code>, <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code>, <code>pooledROC.dpm</code>, <code>cROC.bnp</code>, <code>cROC.sp</code> or <code>AROC.kernel</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
               formula.d = l_marker1 ~ f(age, K = 0),
               group = "status", 
               tag.h = 0,
               data = newpsa,
               standardise = TRUE, 
               p = seq(0, 1, len = 101),
               compute.lpml = TRUE, 
               compute.WAIC = TRUE,
               compute.DIC = TRUE, 
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               density = densitycontrol(compute = TRUE, grid.h = NA, grid.d = NA),
               mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))
summary(cROC_bnp)

plot(cROC_bnp)


</code></pre>


</div>