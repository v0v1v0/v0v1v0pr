<div class="container">

<table style="width: 100%;"><tr>
<td>read.sparse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read Sparse Matrix from Text File</h2>

<h3>Description</h3>

<p>Read a labelled sparse CSR matrix in text format as used by libraries
such as SVMLight, LibSVM, ThunderSVM, LibFM, xLearn, XGBoost, LightGBM, and more.
</p>
<p>The format is as follows:
</p>
<p><code>&lt;label(s)&gt; &lt;column&gt;:&lt;value&gt; &lt;column&gt;:&lt;value&gt; ...</code>
</p>
<p>with one line per observation/row.
</p>
<p>Example line (row):
</p>
<p><code>1 1:1.234 3:20</code>
</p>
<p>This line denotes a row with label (target variable) equal to 1, a value
for the first column of 1.234, a value of zero for the second column (which is
missing), and a value of 20 for the third column.
</p>
<p>The labels might be decimal (for regression), and each row might contain more
than one label (must be integers in this case), separated by commas <b>without</b>
spaces inbetween - e.g.:
</p>
<p><code>1,5,10 1:1.234 3:20</code>
</p>
<p>This line indicates a row with labels 1, 5, and 10 (for multi-class classification).
If the line has no labels, it should still include a space before the features.
</p>
<p>The rows might additionally contain a 'qid' parameter as used in ranking algorithms,
which should always lay inbetween the labels and the features and must be an integer - e.g.:
</p>
<p><code>1 qid:2 1:1.234 3:20</code>
</p>
<p>The file might optionally contain a header as the first line with metadata
(number of rows, number of columns, number of classes). Presence of a header will be
automatically detected, and is recommended to include it for speed purposes. Datasets
from the extreme classification repository (see references) usually include such a header.
</p>
<p>Lines might include comments, which start after a '#' character. Lines consisting
of only a '#' will be ignored. When reading from a file, such file might have a
BOM (information about encoding uses in Windows sytems), which will be automatically
skipped.
</p>


<h3>Usage</h3>

<pre><code class="language-R">read.sparse(
  file,
  multilabel = FALSE,
  has_qid = FALSE,
  integer_labels = FALSE,
  index1 = TRUE,
  sort_indices = TRUE,
  ignore_zeros = TRUE,
  min_cols = 0L,
  min_classes = 0L,
  limit_nrows = 0L,
  use_altrep = TRUE,
  from_string = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>Either a file path from which the data will be read, or a string
('character' variable) containing the text from which the data will be read.
In the latter case, must pass 'from_string=TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multilabel</code></td>
<td>
<p>Whether the input file can have multiple labels per observation.
If passing 'multilabel=FALSE' and it turns out to have multiple labels, will only
take the first one for each row. If the labels are non-integers or have decimal point,
the results will be invalid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>has_qid</code></td>
<td>
<p>Whether the input file has 'qid' field (used for ranking). If passing
'FALSE' and the file does turns out to have 'qid', the features will not be read for any
observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>integer_labels</code></td>
<td>
<p>Whether to output the observation labels as integers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index1</code></td>
<td>
<p>Whether the input file uses numeration starting at 1 for the column
numbers (and for the label numbers when passing 'multilabel=TRUE'). This is usually
the case for files downloaded from the repositories in the references. The function
will check for whether any of the column indices is zero, and will ignore this
option if so (i.e. will assume it is 'FALSE').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort_indices</code></td>
<td>
<p>Whether to sort the indices of the columns after reading the data.
These should already be sorted in the files from the repositories in the references.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_zeros</code></td>
<td>
<p>Whether to avoid adding features which have a value of zero.
If the zeros are caused due to numerical rounding in the software that wrote the
input file, they can be post-processed by passing 'ignore_zeros=FALSE' and then
something like 'X@x[X@x == 0] = 1e-8'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_cols</code></td>
<td>
<p>Minimum number of columns that the output 'X' object should have,
in case some columns are all missing in the input data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_classes</code></td>
<td>
<p>Minimum number of columns that the output 'y' object should have,
in case some columns are all missing in the input data. Only used when passing
'multilabel=TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limit_nrows</code></td>
<td>
<p>Maximum number of rows to read from the data. If there are more
than this number of rows, it will only read the first 'limit_nrows' rows.
If passing zero (the default), there will be no row limit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_altrep</code></td>
<td>
<p>Whether to use R's ALTREP system to return C++ vector objects
without generating extra data copies. If passing 'FALSE', each piece of data will
be copied into a an R-allocated vector and returned as such.
</p>
<p>Passing 'TRUE' is faster and uses less memory (as there are no redundant data copies),
but these ALTREP'd objects can potentially result in some functions/methods running
slower on them than on R objects (for example, manually sub-setting the vectors in
the S4 Matrix classes that are returned can potentially be slower by some microseconds).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from_string</code></td>
<td>
<p>Whether to read the data from a string variable instead of a file.
If passing 'from_string=TRUE', then 'file' is assumed to be a variable with the
data contents on it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that this function:</p>

<ul>
<li>
<p> Will not make any checks for negative column indices.
</p>
</li>
<li>
<p> Has a precision of C type 'int' for column indices and integer labels
(the maximum value that this type can hold can be checked in '.Machine$integer.max').
</p>
</li>
<li>
<p> Will fill missing labels with NAs when passing 'multilabel=FALSE'.
</p>
</li>
<li>
<p> Will fill with zeros (empty values) the lines that are empty (that is,
they generate a row in the data), but will ignore (that is, will not generate
a row in the data) the lines that start with '#'.
</p>
</li>
</ul>
<p>Be aware that the data is represented as a CSR matrix with index pointer of
class C 'int', thus the number of rows/columns/non-zero-elements cannot exceed
'.Machine$integer.max'.
</p>
<p>On 64-bit Windows systems, if compiling the library with a compiler other than MinGW
or MSVC, it will not be able to read files larger than 2GB. This should not be a concern
if installing it from CRAN or from R itself, as the Windows version at the time
of writing can only be compiled with MinGW.
</p>
<p>If the file contains a header, and this header denotes a larger number of columns
or of labels than the largest index in the data, the resulting object will have
this dimension set according to the header. The third entry in the header (number
of classes/labels) will be ignored when passing 'multilabel=FALSE'.
</p>
<p>The function uses different code paths when reading from a file or from a string,
and there might be slight differences between the obtained results from them.
For example, reading from a file might produce the desired output if the file
uses tabs as separators instead of spaces (not supported by most other software
and not standard), whereas reading from a string will not.
If any such difference is encountered, please submit a bug report in the
package's GitHub page.
</p>


<h3>Value</h3>

<p>A list with the following entries:</p>

<ul>
<li>
<p> 'X': the features, as a CSR Matrix from package 'Matrix' (class 'dgRMatrix').
</p>
</li>
<li>
<p> 'y': the labels. If passing 'multilabel=FALSE' (the default), will be a vector
(class 'numeric' when passing 'integer_labels=FALSE', class 'integer' when passing
'integer_labels=TRUE'), otherwise will be a binary CSR Matrix (class 'ngRMatrix').
</p>
</li>
<li>
<p> 'qid': the query IDs used for ranking, as an integer vector.
This entry will <b>only</b> be present when passing 'has_qid=TRUE'.
</p>
</li>
</ul>
<p>These can be easily transformed to other sparse matrix types through e.g.
'X &lt;- as(X, "CsparseMatrix")'.
</p>


<h3>References</h3>

<p>Datasets in this format can be found here:</p>

<ul>
<li>
<p> LibSVM Data: <a href="https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/">https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/</a>
</p>
</li>
<li>
<p> Extreme Classification Repository: <a href="http://manikvarma.org/downloads/XC/XMLRepository.html">http://manikvarma.org/downloads/XC/XMLRepository.html</a>
</p>
</li>
</ul>
<p>The format is also described at the SVMLight webpage: <a href="http://svmlight.joachims.org">http://svmlight.joachims.org</a>.
</p>


<h3>See Also</h3>

<p>write.sparse
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(Matrix)
library(readsparse)

### Example input file
"1 2:1.21 5:2.05
-1 1:0.45 3:0.001 4:-10" -&gt; coded.matrix

r &lt;- read.sparse(coded.matrix, from_string=TRUE)
print(r)

### Convert it back to text
recoded.matrix &lt;- write.sparse(file=NULL, X=r$X, y=r$y, to_string=TRUE)
cat(recoded.matrix)

### Example with real file I/O
## generate a random sparse matrix and labels
set.seed(1)
X &lt;- rsparsematrix(nrow=5, ncol=10, nnz=8)
y &lt;- rnorm(5)

## save into a text file
temp_file &lt;- file.path(tempdir(), "matrix.txt")
write.sparse(temp_file, X, y, integer_labels=FALSE)

## inspect the text file
cat(paste(readLines(temp_file), collapse="\n"))

## read it back
r &lt;- read.sparse(temp_file)
print(r)

### (Note that columns with all-zeros are discarded,
###  this behavior can be avoided with 'add_header=TRUE')
</code></pre>


</div>