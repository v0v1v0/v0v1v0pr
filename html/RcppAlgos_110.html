<div class="container">

<table style="width: 100%;"><tr>
<td>primeFactorizeSieve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate Prime Factorization for Numbers in a Range
</h2>

<h3>Description</h3>

<p>Generates the prime factorization of all numbers between <code>bound1</code> and <code>bound2</code> (if supplied) or all numbers up to <code>bound1</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">primeFactorizeSieve(bound1, bound2 = NULL, namedList = FALSE, nThreads = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bound1</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound2</code></td>
<td>
<p>Positive integer or numeric value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namedList</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, a named list is returned. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is useful when many prime factorizations are needed. Instead of generating the prime factorization on the fly, one can reference the indices/names of the generated list.
</p>
<p>This algorithm benefits greatly from the fast integer division library 'libdivide'. The following is from <a href="https://libdivide.com/">https://libdivide.com/</a>:
</p>
<ul><li>
<p>“<em>libdivide allows you to replace expensive integer divides with comparatively cheap multiplication and bitshifts. Compilers usually do this, but only when the divisor is known at compile time. libdivide allows you to take advantage of it at runtime. The result is that integer division can become faster - a lot faster.</em>”</p>
</li></ul>
<h3>Value</h3>

<p>Returns a named/unnamed list of integer vectors if <code>max(bound1, bound2)</code> <code class="reqn">&lt; 2^{31}</code>, or a list of numeric vectors otherwise.
</p>


<h3>Note</h3>

<p>The maximum value for either of the bounds is <code class="reqn">2^{53} - 1</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Prime_factor">Prime Factor</a>
</p>
</li>
<li>
<p><a href="https://ridiculousfish.com/">ridiculousfish (author of libdivide)</a>
</p>
</li>
<li>
<p><a href="https://github.com/ridiculousfish/libdivide">github.com/ridiculousfish/libdivide</a>
</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">53-bit significand precision</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>primeFactorize</code>, <code>divisorsSieve</code>, <code>factorize</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate some random data
set.seed(28)
mySamp &lt;- sample(10^5, 5*10^4)

## Generate prime factorizations up
## to 10^5 (max element from mySamp)
system.time(allPFacs &lt;- primeFactorizeSieve(10^5))

## Use generated prime factorization for further
## analysis by accessing the index of allPFacs
for (s in mySamp) {
    pFac &lt;- allPFacs[[s]]
    ## Continue algorithm
}

## Generating prime factorizations over
## a range is efficient as well
system.time(primeFactorizeSieve(10^12, 10^12 + 10^5))

## Set 'namedList' to TRUE to return a named list
primeFactorizeSieve(27, 30, namedList = TRUE)

## Using nThreads
system.time(primeFactorizeSieve(1e4, 5e4, nThreads = 2))
</code></pre>


</div>