<div class="container">

<table style="width: 100%;"><tr>
<td>swirl_2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Swirl the values around an origin in 2 dimensions</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>The values are swirled counterclockwise around a specified origin.
The swirling is done by rotating around the origin with the degrees based
on the distances to the origin as so: </p>
<p style="text-align: center;"><code class="reqn">degrees = scale_fn(distances) / (2 * radius) * 360</code>
</p>

<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and swirling around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class="language-R">swirl_2d(
  data,
  radius,
  x_col = NULL,
  y_col = NULL,
  suffix = "_swirled",
  origin = NULL,
  origin_fn = NULL,
  scale_fn = identity,
  keep_original = TRUE,
  degrees_col_name = ".degrees",
  radius_col_name = ".radius",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Radius of the most-inner swirl on the x-axis in the <em>simplest</em> case.
A negative number changes the direction to clockwise rotation.
Can be a <code>vector</code> with multiple radiuses.
</p>
<p>Note: With a custom <code>`scaling_fn`</code>, this might not be the actual swirl radius anymore. Think of
it more as a width setting where a larger number leads to fewer full rotations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x_col</code></td>
<td>
<p>Name of x column in <code>`data`</code>. If <code>NULL</code> and <code>`data`</code> is a <code>vector</code>,
the index of <code>`data`</code> is used. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y_col</code></td>
<td>
<p>Name of y column in <code>`data`</code>. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin</code></td>
<td>
<p>Coordinates of the origin to swirl around.
<code>Vector</code> with 2 elements (i.e. origin_x, origin_y).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code>create_origin_fn()</code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code>centroid()</code>,
<code>most_centered()</code>,
and <code>midrange()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_fn</code></td>
<td>
<p>Function for scaling the distances before calculating the degrees.
</p>
<p><strong>Input</strong>: A <code>numeric vector</code> (the distances).
</p>
<p><strong>Output</strong>: A <code>numeric vector</code> (the scaled distances) of the same length.
</p>
<p>E.g.:
</p>
<p><code>function(d){</code>
</p>
<p><code style="white-space: pre;">⁠  ⁠</code><code>d ^ 1.5</code>
</p>
<p><code>}</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degrees_col_name</code></td>
<td>
<p>Name of new column with the degrees. If <code>NULL</code>, no column is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius_col_name</code></td>
<td>
<p>Name of new column with the radius. If <code>NULL</code>, no column is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with three new columns containing
the swirled x- and y-values, the degrees, the radius, and the origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code>apply_transformation_matrix()</code>,
<code>cluster_groups()</code>,
<code>dim_values()</code>,
<code>expand_distances()</code>,
<code>expand_distances_each()</code>,
<code>flip_values()</code>,
<code>roll_values()</code>,
<code>rotate_2d()</code>,
<code>rotate_3d()</code>,
<code>shear_2d()</code>,
<code>shear_3d()</code>,
<code>swirl_3d()</code>
</p>
<p>Other rotation functions: 
<code>rotate_2d()</code>,
<code>rotate_3d()</code>,
<code>swirl_3d()</code>
</p>
<p>Other distance functions: 
<code>closest_to()</code>,
<code>dim_values()</code>,
<code>distance()</code>,
<code>expand_distances()</code>,
<code>expand_distances_each()</code>,
<code>furthest_from()</code>,
<code>swirl_3d()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(4)

# Create a data frame
df &lt;- data.frame(
  "x" = 1:50,
  "y" = 1,
  "r1" = runif(50),
  "r2" = runif(50) * 35,
  "g" = rep(1:5, each = 10)
)

# Swirl values around (0, 0)
swirl_2d(
  data = df,
  radius = 45,
  x_col = "x",
  y_col = "y",
  origin = c(0, 0)
)


# Swirl around the centroid
# with 6 different radius settings
# Scale the distances with custom function
df_swirled &lt;- swirl_2d(
  data = df,
  radius = c(95, 96, 97, 98, 99, 100),
  x_col = "x",
  y_col = "y",
  origin_fn = centroid,
  scale_fn = function(d) {
    d^1.6
  }
)

df_swirled

# Plot swirls
if (has_ggplot){
  df_swirled %&gt;%
    ggplot(aes(x = x_swirled, y = y_swirled, color = factor(.radius))) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = ".radius")
}


#
# Swirl random data
# The trick lies in finding the right radius
#

# Swirl the random columns
df_swirled &lt;- swirl_2d(
  data = df,
  radius = 5,
  x_col = "r1",
  y_col = "r2",
  origin_fn = centroid
)

# Plot swirls
if (has_ggplot){
  df_swirled %&gt;%
    ggplot(aes(x = r1_swirled, y = r2_swirled)) +
    geom_point() +
    theme_minimal() +
    labs(x = "r1", y = "r2")
}
</code></pre>


</div>