<div class="container">

<table style="width: 100%;"><tr>
<td>extract.am.density</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Mixture of Lognormal Extraction for American Options</h2>

<h3>Description</h3>

<p><code>extract.am.density</code> extracts the mixture of three lognormals from American options.</p>


<h3>Usage</h3>

<pre><code class="language-R">extract.am.density(initial.values = rep(NA, 10), r, te, s0, market.calls, 
  call.weights = NA, market.puts, put.weights = NA, strikes, lambda = 1, 
  hessian.flag = F, cl = list(maxit = 10000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>initial.values</code></td>
<td>
<p>initial values for the optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>risk free rate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>te</code></td>
<td>
<p>time to expiration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s0</code></td>
<td>
<p>current asset value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>market.calls</code></td>
<td>
<p>market calls (most expensive to cheapest)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call.weights</code></td>
<td>
<p>weights to be used for calls.  Set to 1 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>market.puts</code></td>
<td>
<p>market calls (cheapest to most expensive)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>put.weights</code></td>
<td>
<p>weights to be used for puts.  Set to 1 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strikes</code></td>
<td>
<p>strikes (smallest to largest)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Penalty parameter to enforce the martingale condition</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian.flag</code></td>
<td>
<p>If FALSE then no Hessian is produced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>List of parameter values to be passed to the optimization function</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The extracted density is in the form of f(x) = p.1 * f1(x) + p.2 * f2(x) + (1 - p.1 - p.2) * f3(x), 
where f1, f2, and f3 are lognormal densities with log means u.1,u.2, and u.3 and
standard deviations sigma.1, sigma.2, and sigma.3 respectively.
</p>
<p>For the description of w.1 and w.2 see equations (7) &amp; (8) of Melick and Thomas paper below.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>w.1 </code></td>
<td>
<p>First weight, a number between 0 and 1, to weigh the option price bounds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.2 </code></td>
<td>
<p>Second weight, a number between 0 and 1, to weigh the option price bounds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u.1 </code></td>
<td>
<p>log mean of the first lognormal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u.2 </code></td>
<td>
<p>log mean of the second lognormal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u.3 </code></td>
<td>
<p>log mean of the third lognormal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.1 </code></td>
<td>
<p>log sd of the first lognormal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.2 </code></td>
<td>
<p>log sd of the second lognormal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma.3 </code></td>
<td>
<p>log sd of the third lognormal</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.1</code></td>
<td>
<p>weight assigned to the first density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.2</code></td>
<td>
<p>weight assigned to the second density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge.result</code></td>
<td>
<p>Captures the convergence result</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>Hessian Matrix</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Kam Hamidieh</p>


<h3>References</h3>

<p>Melick, W. R. and Thomas, C. P. (1997). Recovering an asset's implied pdf from option prices: An
application to crude oil during the gulf crisis. <em>Journal of Financial and Quantitative Analysis</em>,
32(1), 91-115.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
###
### Try with synthetic data first.
###

r       = 0.01
te      = 60/365
w.1     = 0.4
w.2     = 0.25
u.1     = 4.2
u.2     = 4.5
u.3     = 4.8
sigma.1 = 0.30
sigma.2 = 0.20
sigma.3 = 0.15
p.1     = 0.25
p.2     = 0.45
theta   = c(w.1,w.2,u.1,u.2,u.3,sigma.1,sigma.2,sigma.3,p.1,p.2)
p.3     = 1 - p.1 - p.2

###
### Generate some synthetic American calls &amp; puts
###

expected.f0   =  sum(c(p.1, p.2, p.3) * exp(c(u.1,u.2,u.3) + 
                    (c(sigma.1, sigma.2, sigma.3)^2)/2) )
expected.f0  
 
strikes = 50:150

market.calls = numeric(length(strikes))
market.puts  = numeric(length(strikes))

for (i in 1:length(strikes))
{

  if ( strikes[i] &lt; expected.f0) {
    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
  }  else {

    market.calls[i] = price.am.option(k = strikes[i], r = r, te = te, w = w.2, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$call.value

    market.puts[i]  = price.am.option(k = strikes[i], r = r, te = te, w = w.1, u.1 = u.1, 
                      u.2 = u.2, u.3 = u.3, sigma.1 = sigma.1, sigma.2 = sigma.2, 
                      sigma.3 = sigma.3, p.1 = p.1, p.2 = p.2)$put.value 
     }

}


###
### ** IMPORTANT **:  The code that follows may take 1-2 minutes.
###                   Copy and paste onto R console the commands
###                   that follow the greater sign &gt;.
###
### Try the optimization with exact inital values.  
### They should be close the actual initials.
###
#
# &gt; s0      = expected.f0 * exp(-r * te)
# &gt; s0
#
# &gt; extract.am.density(initial.values = theta, r = r, te = te, s0 = s0, 
#                  market.calls = market.calls, market.puts = market.puts, strikes = strikes, 
#                  lambda = 1, hessian.flag = FALSE)
#
# &gt; theta
#
###
### Now try without our the correct initial values...
###
#
# &gt; optim.obj.no.init = extract.am.density( r = r, te = te, s0 = s0, 
#                   market.calls = market.calls, market.puts = market.puts, strikes = strikes, 
#                    lambda = 1, hessian.flag = FALSE)
#
# &gt; optim.obj.no.init
# &gt; theta
#
###
### We do get different values but how do the densities look like?
###
#
###
### plot the two densities side by side
###
#
# &gt; x = 10:190
#
# &gt; y.1 = dmln.am(x = x, p.1 = theta[9], p.2 = theta[10],
#           u.1 = theta[3], u.2 = theta[4], u.3 = theta[5], 
#          sigma.1 = theta[6], sigma.2 = theta[7], sigma.3 = theta[8] )
#
# &gt; o = optim.obj.no.init
#
# &gt; y.2 = dmln.am(x = x, p.1 = o$p.1, p.2 = o$p.2,
#           u.1 = o$u.1, u.2 = o$u.2, u.3 = o$u.3, 
#           sigma.1 = o$sigma.1, sigma.2 = o$sigma.2, sigma.3 = o$sigma.3 )
#
# &gt; matplot(x, cbind(y.1,y.2), main = "Exact = Black, Approx = Red", type="l", lty=1)
#
###
### Densities are close.
###


</code></pre>


</div>