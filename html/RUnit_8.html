<div class="container">

<table style="width: 100%;"><tr>
<td>checkFuncs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>RUnit check functions</h2>

<h3>Description</h3>

<p>A set of functions used to check the results of some test
calculation. If these functions are called within the RUnit framework,
the results of the checks are stored and reported in the test
protocol.
</p>
<p><code>checkEquals</code> compares two R objects by invoking <code>all.equal</code> on
the two objects. If the objects are not equal an error is
generated and the failure is reported to the test logger such that it
appears in the test protocol.
</p>
<p><code>checkEqualsNumeric</code> works just like <code>checkEquals</code> except
that it invokes <code>all.equal.numeric</code> instead of <code>all.equal</code>
</p>
<p><code>checkIdentical</code> is a convenience wrapper around identical using
the error logging mechanism of RUnit.
</p>
<p><code>checkTrue</code> uses the function <code>identical</code> to check if the expression
provided as first argument evaluates to <code>TRUE</code>. If not, an error is
generated and the failure is reported to the test logger such that it
appears in the test protocol.
</p>
<p><code>checkException</code> evaluates the passed expression and uses the
<code>try</code> mechanism to check if the evaluation generates an error.
If it does the test is OK. Otherwise an error is
generated and the failure is reported to the test logger such that it
appears in the test protocol. 
</p>
<p><code>DEACTIVATED</code> interrupts the test function and reports the test case
as deactivated. In the test protocol deactivated test functions are
listed separately. Test case deactivation can be useful in the case of
major refactoring. Alternatively, test cases can be commented out
completely but then it is easy to forget the test case altogether.
</p>


<h3>Usage</h3>

<pre><code class="language-R">checkEquals(target, current, msg,
            tolerance = .Machine$double.eps^0.5, 
            checkNames = TRUE, ...)
checkEqualsNumeric(target, current, msg,
                   tolerance = .Machine$double.eps^0.5, ...)
checkIdentical(target, current, msg)
checkTrue(expr, msg)
checkException(expr, msg, silent = getOption("RUnit")$silent)
DEACTIVATED(msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>current, target</code></td>
<td>
<p>objects to be compared (<code>checkEqualsNumeric</code> cannot 
handle S4 class objects).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msg</code></td>
<td>
<p>an optional message to document a check and to facilitate
the identification of a possible failure. The message only appears
as text in the test protocol, it is not further used in any of the check 
functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>numeric &gt;= 0.  A numeric check does not fail if
differences are smaller than ‘tolerance’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>checkNames</code></td>
<td>
<p>flag, if <code>FALSE</code> the names attributes are set to 
<code>NULL</code>
for both current and target before performing the check.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>syntactically valid R expression which can be evaluated
and must return a logical scalar (<code>TRUE</code>|<code>FALSE</code>). A named 
expression is also allowed but the name is disregarded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>flag passed on to <code>try</code>, which determines if the
error message generated by the checked function is displayed. Queried from 
global options set for RUnit at package load.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments passed to <code>all.equal</code> or 
<code>all.equal.numeric</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The check functions are direct equivalents of the various
methods of the class junit.framework.Assert of Javas JUnit framework
which served as basis for the RUnit package.
</p>
<p>For functions defined inside a package equipped with a namespace only
exported functions can be accessed inside test cases directly. For
functions not exported the only way to test them is to use the 
'<code>:::</code>'
operator combined with the package name as a prefix.
</p>
<p>Special care is required if test cases are written for S4 classes and
methods. If a new class is defined inside a test case via a
<code>setClass</code> call the class is added to the global class
cache and thus available outside the test case. It will persist until
explicitly removed via a <code>removeClass</code>
call. Same applies for new method
and generic definitions. Be sure to remove methods and classes in
each test case they are defined after the checks have been
performed. This is an advise gained from the cumbersome experience:
not doing so leads to difficult to pin down error causes incurred
from previously executed test cases.
For a simple example see the provided test cases in
/private/var/folders/wx/qv_075m16yx5lqwvjfwswfqm0000gn/T/RtmphiFfme/filef08ea5a81d3/RUnit/examples/runitVirtualClassTest.r.
</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>See Also</h3>

<p><code>all.equal</code>, <code>all.equal.numeric</code> and
<code>identical</code> are the underlying comparison functions.
<code>try</code> is used for error catching.
<code>.setUp</code> for details on test case setup. See
RUnit-options for global options controlling log out.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
checkTrue(1 &lt; 2, "check1")     ## passes fine
## checkTrue(1 &gt; 2, "check2")  ## appears as failure in the test protocol

v &lt;- 1:3
w &lt;- 1:3
checkEquals(v, w)               ## passes fine
names(v) &lt;- c("A", "B", "C")
## checkEquals(v, w)            ## fails because v and w have different names
checkEqualsNumeric(v, w)        ## passes fine because names are ignored


x &lt;- rep(1:12, 2)
y &lt;- rep(0:1, 12)
res &lt;- list(a=1:3, b=letters, LM=lm(y ~ x))
res2 &lt;- list(a=seq(1,3,by=1), b=letters, LM=lm(y ~ x))
checkEquals( res, res2)        ## passes fine
checkIdentical( res, res)
checkIdentical( res2, res2)
## checkIdentical( res, res2)  ## fails because element 'a' differs in type


fun &lt;- function(x) {
  if(x)
  {
   stop("stop conditions signaled")
  }
  return()
}

checkException(fun(TRUE))      ## passes fine
## checkException(fun(FALSE))  ## failure, because fun raises no error
checkException(fun(TRUE), silent=TRUE)

##  special constants
##  same behaviour as for underlying base functions
checkEquals(NA, NA)
checkEquals(NaN, NaN)
checkEquals(Inf, Inf)

checkIdentical(NA, NA)
checkIdentical(NaN, NaN)
checkIdentical(-Inf, -Inf)

## DEACTIVATED("here one can document on the reason for deactivation")
</code></pre>


</div>