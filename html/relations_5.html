<div class="container">

<table style="width: 100%;"><tr>
<td>algebra</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Relational Algebra</h2>

<h3>Description</h3>

<p>Various “relational algebra”-like operations.</p>


<h3>Usage</h3>

<pre><code class="language-R">relation_projection(x, margin = NULL)
relation_selection(x, subset)
relation_cartesian(x, y, ...)
relation_complement(x, y)
relation_intersection(x, y, ...)
relation_union(x, y, ...)
relation_symdiff(x, y)
relation_division(x, y)
relation_remainder(x, y)
relation_join(x, y, ...)
relation_semijoin(x, y, ...)
relation_antijoin(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x, y</code></td>
<td>
<p>Relation objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>
<p>Either a character vector of domain names, or an integer
vector of domain indices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>Expression resulting in a logical vector of length equal
to the number of tuples in the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Relation objects for <code>relation_cartesian()</code>,
<code>relation_intersection()</code>, and <code>relation_union()</code>.
Otherwise, passed to <code>merge()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions provide functionality similar to the corresponding
operations defined in relational algebra theory as introduced by Codd
(1970).  Note, however, that domains in database relations, unlike the
concept of relations we use here, are unordered.  In fact, a database
relation (“table”) is defined as a set of elements called
“tuples”, where the “tuple” components are named, but
unordered.  So in fact, a “tuple” in this sense is a set of
mappings from the attribute names into the union of the attribute
domains.
</p>
<p>The <em>projection</em> of a relation on a specified margin (i.e., a
vector of domain names or indices) is the relation obtained when all
tuples are restricted to this margin. As a consequence, duplicate
tuples are removed.
</p>
<p>The <em>selection</em> of a relation is the relation obtained by taking
a subset of the relation graph, defined by some logical expression.
</p>
<p>The <em>Cartesian product</em> of two relations is obtained by basically
building the Cartesian product of all graph elements, but combining the
resulting pairs into single tuples.
</p>
<p>The <em>union</em> of two relations simply combines the graph elements
of both relations; the <em>complement</em> of two relations <code class="reqn">R</code> and
<code class="reqn">S</code> removes the tuples of <code class="reqn">S</code> from <code class="reqn">R</code>.
</p>
<p>The <em>intersection</em> (<em>symmetric difference</em>)
of two relations is the relation with all tuples they have (do not have)
in common.
</p>
<p>The <em>division</em> of relation <code class="reqn">R</code> by relation <code class="reqn">S</code> is the
reversed Cartesian product. The result is a relation with the domain
unique to <code class="reqn">R</code> and containing the maximum number of tuples which,
multiplied by <code class="reqn">S</code>, are contained in <code class="reqn">R</code>. The <em>remainder</em>
of this operation is the complement of <code class="reqn">R</code> and the division of
<code class="reqn">R</code> by <code class="reqn">S</code>. Note that for both operations, the domain of
<code class="reqn">S</code> must be contained in the domain of <code class="reqn">R</code>.
</p>
<p>The (natural) <em>join</em> of two relations is their Cartesian product,
restricted to the subset where the elements of the common attributes
do match. The left/right/full outer join of two relations
<code class="reqn">R</code> and <code class="reqn">S</code> is
the union of <code class="reqn">R</code>/<code class="reqn">S</code>/<code class="reqn">R</code> and <code class="reqn">S</code>,
and the inner join of <code class="reqn">R</code> and <code class="reqn">S</code>.
The implementation uses <code>merge()</code>, and so the
left/right/full outer joins are obtained by setting
<code>all.x</code>/<code>all.y</code>/<code>all</code> to <code>TRUE</code> in
<code>relation_join()</code>.
The domains to be matched are specified using <code>by</code>.
</p>
<p>The left (right) <em>semijoin</em> of two relations <code class="reqn">R</code> and <code class="reqn">S</code>
is the join of these, projected to the attributes of <code class="reqn">R</code>
(<code class="reqn">S</code>). Thus, it yields all tuples of <code class="reqn">R</code>
(<code class="reqn">S</code>) participating in the join of <code class="reqn">R</code> and <code class="reqn">S</code>. 
</p>
<p>The left (right) <em>antijoin</em> of two relations <code class="reqn">R</code> and <code class="reqn">S</code>
is the complement of <code class="reqn">R</code> (<code class="reqn">S</code>) and the join of both,
projected to the attributes of <code class="reqn">R</code> (<code class="reqn">S</code>).
Thus, it yields all tuples of <code class="reqn">R</code>
(<code class="reqn">S</code>) <em>not</em> participating in the join of <code class="reqn">R</code> and <code class="reqn">S</code>. 
</p>
<p>The operators <code>%&gt;&lt;%</code>, <code>%=&gt;&lt;%</code>, <code>%&gt;&lt;=%</code>,
<code>%=&gt;&lt;=%</code>, <code>%|&gt;&lt;%</code>, <code>%&gt;&lt;|%</code>, <code>%|&gt;&lt;|%</code>,
<code>%|&gt;%</code>, <code>%&lt;|%</code>, and <code>%U%</code> can be used for the
Cartesian product, left outer join, right outer join, full outer join,
left semi-join, right semi-join, join, left antijoin, right antijoin,
and union, respectively.
</p>


<h3>References</h3>

<p>E. F. Codd (1970),
A relational model of data for large shared data banks.
<em>Communications of the ACM</em>, <b>13</b>/6, 377–387.
<a href="https://doi.org/10.1145/362384.362685">doi:10.1145/362384.362685</a>.
</p>


<h3>See Also</h3>

<p><code>relation()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## projection
Person &lt;-
    data.frame(Name = c("Harry", "Sally", "George", "Helena", "Peter"),
               Age = c(34, 28, 29, 54, 34),
               Weight = c(80, 64, 70, 54, 80),
               stringsAsFactors = FALSE)
Person &lt;- as.relation(Person)
relation_table(Person)
relation_table(relation_projection(Person, c("Age", "Weight")))

## selection
relation_table(R1 &lt;- relation_selection(Person, Age &lt; 29))
relation_table(R2 &lt;- relation_selection(Person, Age &gt;= 34))
relation_table(R3 &lt;- relation_selection(Person, Age == Weight))

## union
relation_table(R1 %U% R2)

## works only for the same domains:
relation_table(R2 | R3)

## complement
relation_table(Person - R2)

## intersection
relation_table(relation_intersection(R2, R3))

## works only for the same domains:
relation_table(R2 &amp; R3)

## symmetric difference
relation_table(relation_symdiff(R2, R3))

## Cartesian product
Employee &lt;-
    data.frame(Name =
               c("Harry", "Sally", "George", "Harriet", "John"),
               EmpId = c(3415, 2241, 3401, 2202, 3999),
               DeptName =
               c("Finance", "Sales", "Finance", "Sales", "N.N."),
	       stringsAsFactors = FALSE)
Employee &lt;- as.relation(Employee)
relation_table(Employee)
Dept &lt;- data.frame(DeptName = c("Finance", "Sales", "Production"),
                   Manager = c("George", "Harriet", "Charles"),
                   stringsAsFactors = FALSE)
Dept &lt;- as.relation(Dept)
relation_table(Dept)

relation_table(Employee %&gt;&lt;% Dept)

## Natural join
relation_table(Employee %|&gt;&lt;|% Dept)

## left (outer) join
relation_table(Employee %=&gt;&lt;% Dept)

## right (outer) join
relation_table(Employee %&gt;&lt;=% Dept)

## full outer join
relation_table(Employee %=&gt;&lt;=% Dept)

## antijoin
relation_table(Employee %|&gt;% Dept)
relation_table(Employee %&lt;|% Dept)

## semijoin
relation_table(Employee %|&gt;&lt;% Dept)
relation_table(Employee %&gt;&lt;|% Dept)

## division
Completed &lt;-
    data.frame(Student = c("Fred", "Fred", "Fred", "Eugene",
                           "Eugene", "Sara", "Sara"),
               Task = c("Database1", "Database2", "Compiler1",
                        "Database1", "Compiler1", "Database1",
                        "Database2"),
               stringsAsFactors = FALSE)
Completed &lt;- as.relation(Completed)
relation_table(Completed)
DBProject &lt;- data.frame(Task = c("Database1", "Database2"),
                        stringsAsFactors = FALSE)
DBProject &lt;- as.relation(DBProject)
relation_table(DBProject)

relation_table(Completed %/% DBProject)

## division remainder
relation_table(Completed %% DBProject)

</code></pre>


</div>