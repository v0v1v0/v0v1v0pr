<div class="container">

<table style="width: 100%;"><tr>
<td>getInfLM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions to determine Lagrange multipliers</h2>

<h3>Description</h3>

<p>Functions to determine Lagrange multipliers <code>A</code> and <code>a</code>
in a Hampel problem or in a(n) (inner) loop in a MSE problem; can be done
either by optimization or by fixed point iteration. These functions are
rarely called directly.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getLagrangeMultByIter(b, L2deriv, risk, trafo,
                      neighbor, biastype, normtype, Distr,
                      a.start, z.start, A.start, w.start, std, z.comp,
                      A.comp, maxiter, tol, verbose = NULL,
                      warnit = TRUE, ...)
getLagrangeMultByOptim(b, L2deriv, risk, FI, trafo,
                      neighbor, biastype, normtype, Distr,
                      a.start, z.start, A.start, w.start,  std, z.comp,
                      A.comp, maxiter, tol, verbose = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>numeric; (<code class="reqn">&gt;b_{\rm\scriptstyle min}</code>; clipping bound
for which the Lagrange multipliers are searched</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2deriv</code></td>
<td>
<p> L2-derivative of some L2-differentiable family
of probability measures. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p> object of class <code>"RiskType"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FI</code></td>
<td>
<p> matrix: Fisher information. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trafo</code></td>
<td>
<p> matrix: transformation of the parameter. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>"Neighborhood"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>biastype</code></td>
<td>
<p>object of class <code>"BiasType"</code> — the bias type with we work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normtype</code></td>
<td>
<p>object of class <code>"NormType"</code> — the norm type with we work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Distr</code></td>
<td>
<p> object of class <code>"Distribution"</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.start</code></td>
<td>
<p> initial value for the centering constant (in <code>p</code>-space). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.start</code></td>
<td>
<p> initial value for the centering constant (in <code>k</code>-space). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.start</code></td>
<td>
<p> initial value for the standardizing matrix. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.start</code></td>
<td>
<p> initial value for the weight function. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std</code></td>
<td>
<p> matrix of (or which may coerced to) class
<code>PosSemDefSymmMatrix</code> for use of different
(standardizing) norm. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.comp</code></td>
<td>
<p> logical vector: indication which components of the
centering constant have to be computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A.comp</code></td>
<td>
<p> matrix: indication which components of the standardizing
matrix have to be computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warnit</code></td>
<td>
<p> logical: if <code>TRUE</code> warning is issued if
maximal number of iterations is reached. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional parameters for <code>optim</code> and <code>E</code>. </p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list with items
</p>
<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>Lagrange multiplier <code>A</code> (standardizing matrix)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Lagrange multiplier <code>a</code> (centering in <code>p</code>-space)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Lagrange multiplier <code>z</code> (centering in <code>k</code>-space)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>weight function involving Lagrange multipliers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>biastype</code></td>
<td>
<p>(possibly modified) bias type <code>biastype</code> from argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normtype</code></td>
<td>
<p>(possibly modified) norm type <code>normtype</code> from argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normtype.old</code></td>
<td>
<p>(possibly modified) norm type <code>normtype</code>
before last (internal) update</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>risk</code></td>
<td>
<p>(possibly [norm-]modified) risk <code>risk</code> from argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std</code></td>
<td>
<p>(possibly modified) argument <code>std</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>number of iterations needed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prec</code></td>
<td>
<p>precision achieved</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>used clippng height <code>b</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>call with which either <code>getLagrangeMultByIter</code> or
<code>getLagrangeMultByOptim</code> was called </p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Rieder, H. (1980) Estimates derived from robust tests. Ann. Stats. <b>8</b>: 106-115.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>Ruckdeschel, P. and Rieder, H. (2004) Optimal Influence Curves for
General Loss Functions. Statistics &amp; Decisions <b>22</b>: 201-223.
</p>
<p>Ruckdeschel, P. (2005) Optimally One-Sided Bounded Influence Curves.
Mathematical Methods in Statistics <em>14</em>(1), 105-131.
</p>
<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>.
Bayreuth: Dissertation.
</p>


<h3>See Also</h3>

<p><code>InfRobModel-class</code></p>


</div>