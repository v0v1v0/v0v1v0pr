<div class="container">

<table style="width: 100%;"><tr>
<td>pslg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a Planar Straight Line Graph object</h2>

<h3>Description</h3>

<p>A Planar Straight Line Graph (PSLG) is a collection of vertices
and segments. Segments are edges whose endpoints are vertices in
the PSLG, and whose presence in any mesh generated from the PSLG
is enforced.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pslg(P, PB = NA, PA = NA, S = NA, SB = NA, H = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>A 2-column matrix of x-y co-ordinates of vertices. There
is one row per vertex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PB</code></td>
<td>
<p>Vector of <em>boundary markers</em> of vertices. For each
vertex this is 1 if the point should be on a boundary of any mesh
generated from the PSLG and 0 otherwise. There should be as many
elements in <code>VB</code> as there are vertices in <code>V</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PA</code></td>
<td>
<p>Matrix of <em>attributes</em> which are typically
floating-point values of physical quantities (such as mass or
conductivity) associated with the nodes of a finite element
mesh. When triangulating using <code>triangulate</code> these are
copied unchanged to existing points in the output mesh and each
new Steiner point added to the mesh will have quantities assigned
to it by linear interpolation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>A 2-column matrix of <em>segments</em> in which each row is
a <em>segment</em>. Segments are edges whose endpoints are vertices
in the PSLG, and whose presence in any mesh generated from the
PSLG is enforced. Each segment refers to the indices in <code>V</code>
of the endpoints of the segment. By default the segments are not
specified (<code>NA</code>), in which case the convex hull of the
vertices are taken to be the segments. Any vertices outside the
region enclosed by the segments are eaten away by the
triangulation algorithm. If the segments do not enclose a region
the whole triangulation may be eaten away.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SB</code></td>
<td>
<p>Vector of boundary markers of segments. For each segment
this is 1 if the segment should be on a boundary of any mesh
generated from the PSLG and 0 otherwise. There should be as many
elements in <code>SB</code> as there are segments in <code>S</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>2-column matrix of <em>holes</em>,  with one hole per
row.Holes are specified by identifying a point inside each
hole. After the triangulation is formed, Triangle creates holes by
eating triangles, spreading out from each hole point until its
progress is blocked by PSLG segments; you must be careful to
enclose each hole in segments, or your whole triangulation might
be eaten away. If the two triangles abutting a segment are eaten,
the segment itself is also eaten. Do not place a hole directly on
a segment; if you do, Triangle will choose one side of the segment
arbitrarily.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object containing the input of type <code>pslg</code> that
contains the information supplied in the inputs. This function
does some sanity checking of its inputs.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


</div>