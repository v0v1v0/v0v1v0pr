<div class="container">

<table style="width: 100%;"><tr>
<td>score.calc.epistasis.score.MC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate -log10(p) of epistatic effects with score test (multi-cores)</h2>

<h3>Description</h3>

<p>Calculate -log10(p) of epistatic effects with score test (multi-cores)
</p>


<h3>Usage</h3>

<pre><code class="language-R">score.calc.epistasis.score.MC(
  M.now,
  y,
  X.now,
  ZETA.now,
  n.core = 2,
  parallel.method = "mclapply",
  Gu,
  Ge,
  P0,
  map,
  haplotype = TRUE,
  num.hap = NULL,
  window.size.half = 5,
  window.slide = 1,
  chi0.mixture = 0.5,
  gene.set = NULL,
  dominance.eff = TRUE,
  skip.self.int = FALSE,
  min.MAF = 0.02,
  count = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>M.now</code></td>
<td>
<p>A <code class="reqn">n \times m</code> genotype matrix where <code class="reqn">n</code> is sample size and <code class="reqn">m</code> is the number of markers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A <code class="reqn">n \times 1</code> vector. A vector of phenotypic values should be used. NA is allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.now</code></td>
<td>
<p>A <code class="reqn">n \times p</code> matrix. You should assign mean vector (rep(1, n)) and covariates. NA is not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ZETA.now</code></td>
<td>
<p>A list of variance (relationship) matrix (K; <code class="reqn">m \times m</code>) and its design matrix (Z; <code class="reqn">n \times m</code>) of random effects. You can use only one kernel matrix.
For example, ZETA = list(A = list(Z = Z, K = K))
Please set names of list "Z" and "K"!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.core</code></td>
<td>
<p>Setting n.core &gt; 1 will enable parallel execution on a machine with multiple cores.
This argument is not valid when 'parallel.method = "furrr"'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.method</code></td>
<td>
<p>Method for parallel computation. We offer three methods, "mclapply", "furrr", and "foreach".
</p>
<p>When 'parallel.method = "mclapply"', we utilize <code>pbmclapply</code> function in the 'pbmcapply' package
with 'count = TRUE' and <code>mclapply</code> function in the 'parallel' package with 'count = FALSE'.
</p>
<p>When 'parallel.method = "furrr"', we utilize <code>future_map</code> function in the 'furrr' package.
With 'count = TRUE', we also utilize <code>progressor</code> function in the 'progressr' package to show the progress bar,
so please install the 'progressr' package from github (<a href="https://github.com/HenrikBengtsson/progressr">https://github.com/HenrikBengtsson/progressr</a>).
For 'parallel.method = "furrr"', you can perform multi-thread parallelization by
sharing memories, which results in saving your memory, but quite slower compared to 'parallel.method = "mclapply"'.
</p>
<p>When 'parallel.method = "foreach"', we utilize <code>foreach</code> function in the 'foreach' package
with the utilization of <code>makeCluster</code> function in 'parallel' package,
and <code>registerDoParallel</code> function in 'doParallel' package.
With 'count = TRUE', we also utilize <code>setTxtProgressBar</code> and
<code>txtProgressBar</code> functions in the 'utils' package to show the progress bar.
</p>
<p>We recommend that you use the option 'parallel.method = "mclapply"', but for Windows users,
this parallelization method is not supported. So, if you are Windows user,
we recommend that you use the option 'parallel.method = "foreach"'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gu</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign <code class="reqn">ZKZ'</code>, where K is covariance (relationship) matrix and Z is its design matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ge</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. You should assign identity matrix I (diag(n)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P0</code></td>
<td>
<p>A <code class="reqn">n \times n</code> matrix. The Moore-Penrose generalized inverse of <code class="reqn">SV0S</code>, where <code class="reqn">S = X(X'X)^{-1}X'</code> and
<code class="reqn">V0 = \sigma^2_u Gu + \sigma^2_e Ge</code>. <code class="reqn">\sigma^2_u</code> and <code class="reqn">\sigma^2_e</code> are estimators of the null model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>Data frame of map information where the first column is the marker names,
the second and third column is the chromosome amd map position, and the forth column is -log10(p) for each marker.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>haplotype</code></td>
<td>
<p>If the number of lines of your data is large (maybe &gt; 100), you should set haplotype = TRUE.
When haplotype = TRUE, haplotype-based kernel will be used for calculating -log10(p).
(So the dimension of this gram matrix will be smaller.)
The result won't be changed, but the time for the calculation will be shorter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.hap</code></td>
<td>
<p>When haplotype = TRUE, you can set the number of haplotypes which you expect.
Then similar arrays are considered as the same haplotype, and then make kernel(K.SNP) whose dimension is num.hap x num.hap.
When num.hap = NULL (default), num.hap will be set as the maximum number which reflects the difference between lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window.size.half</code></td>
<td>
<p>This argument decides how many SNPs (around the SNP you want to test) are used to calculated K.SNP.
More precisely, the number of SNPs will be 2 * window.size.half + 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window.slide</code></td>
<td>
<p>This argument determines how often you test markers. If window.slide = 1, every marker will be tested.
If you want to perform SNP set by bins, please set window.slide = 2 * window.size.half + 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chi0.mixture</code></td>
<td>
<p>RAINBOWR assumes the test statistic <code class="reqn">l1' F l1</code> is considered to follow a x chisq(df = 0) + (1 - a) x chisq(df = r).
where l1 is the first derivative of the log-likelihood and F is the Fisher information. And r is the degree of freedom.
The argument chi0.mixture is a (0 &lt;= a &lt; 1), and default is 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene.set</code></td>
<td>
<p>If you have information of gene, you can use it to perform kernel-based GWAS.
You should assign your gene information to gene.set in the form of a "data.frame" (whose dimension is (the number of gene) x 2).
In the first column, you should assign the gene name. And in the second column, you should assign the names of each marker,
which correspond to the marker names of "geno" argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dominance.eff</code></td>
<td>
<p>If this argument is TRUE, dominance effect is included in the model,
and additive x dominance and dominance x dominance are also tested as epistatic effects.
When you use inbred lines, please set this argument FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip.self.int</code></td>
<td>
<p>As default, the function also tests the self-interactions among the same SNP-sets.
If you want to avoid this, please set 'skip.self.int = TRUE'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF).
If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>When count is TRUE, you can know how far RGWAS has ended with percent display.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>-log10(p) of epistatic effects for each SNP-set
</p>


<h3>References</h3>

<p>Listgarten, J. et al. (2013) A powerful and efficient set test
for genetic markers that handles confounders. Bioinformatics. 29(12): 1526-1533.
</p>
<p>Lippert, C. et al. (2014) Greater power and computational efficiency for kernel-based
association testing of sets of genetic variants. Bioinformatics. 30(22): 3206-3214.
</p>
<p>Jiang, Y. and Reif, J.C. (2015) Modeling epistasis in genomic selection. Genetics. 201(2): 759-768.
</p>


</div>