<div class="container">

<table style="width: 100%;"><tr>
<td>integration.constant</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the integration constant for distance density functions</h2>

<h3>Description</h3>

<p>Using numerical integration, this function computes
the area under a distance function between two limits (<code>w.lo</code>
and <code>w.hi</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">integration.constant(
  dist,
  density,
  a,
  covars,
  w.lo,
  w.hi,
  series,
  expansions,
  pointSurvey
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>
<p>Vector of detection distance values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>density</code></td>
<td>
<p>A likelihood function for which the
integration constant is sought. This function
must be capable of evaluating values between <code>w.lo</code>
and <code>w.hi</code> and have the following parameters:
</p>

<ul>
<li> <p>‘<span class="samp">⁠a⁠</span>’ = Parameter vector.
</p>
</li>
<li> <p>‘<span class="samp">⁠dist⁠</span>’ = Vector of distances.
</p>
</li>
<li> <p>‘<span class="samp">⁠covars⁠</span>’ = If the density allows covariates, 
the covariate matrix.
</p>
</li>
<li> <p>‘<span class="samp">⁠w.lo⁠</span>’ = Lower limit or left truncation value.
</p>
</li>
<li> <p>‘<span class="samp">⁠w.hi⁠</span>’ = Upper limit or right truncation value.
</p>
</li>
<li> <p>‘<span class="samp">⁠series⁠</span>’ = Form of the series expansions, if any.
</p>
</li>
<li> <p>‘<span class="samp">⁠expansions⁠</span>’ = Number of expansion terms.
</p>
</li>
<li> <p>‘<span class="samp">⁠scale⁠</span>’ = Whether to scale function to integrate to 1.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>Vector of parameters to pass to <code>density</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covars</code></td>
<td>
<p>Matrix of covariate values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.lo</code></td>
<td>
<p>The lower limit of integration, or the left truncation
value for perpendicular distances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w.hi</code></td>
<td>
<p>The upper limit of integration, or the right truncation
value for perpendicular distances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>series</code></td>
<td>
<p>The series to use for expansions. 
If <code>expansions</code> &gt; 0, this string 
specifies the type of expansion. Valid values at 
present are 'simple', 'hermite', and 'cosine'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expansions</code></td>
<td>
<p>Number of expansions in <code>density</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pointSurvey</code></td>
<td>
<p>Boolean. TRUE if point transect data,
FALSE if line transect data.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The trapezoid rule is used to numerically integrate
<code>density</code> from <code>w.lo</code> to <code>w.hi</code>. Two-hundred
(200) equal-sized trapezoids are used in the integration.  The number
of trapezoids to use is fixed and cannot be changed without
re-writing this routine.
</p>


<h3>Value</h3>

<p>A scalar (or vector of scalars if covariates are present)
that is the area under <code>density</code> between <code>w.lo</code> and <code>w.hi</code>.
This scalar can be used as a divisor to scale density such that
it integrates to 1.0. If x = density(...), then
x / <code>integration.constant(density, ...)</code> will integrate to 1.0.
</p>


<h3>See Also</h3>

<p><code>dfuncEstim</code>, <code>halfnorm.like</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Can put any number for first argument (1 used here)
scl &lt;- integration.constant(dist=units::set_units(1,"m")
                          , density=logistic.like
                          , covars = NULL
                          , pointSurvey = FALSE
                          , w.lo = units::set_units(0,"m")
                          , w.hi = units::set_units(100,"m")
                          , expansions = 0
                          , a=c(75,25))
print(scl) # Should be 75.1

x &lt;- units::set_units(seq(0,100,length=200), "m")
y &lt;- logistic.like( c(75,25), x, scale=FALSE ) / scl
int.y &lt;- (x[2]-x[1]) * sum(y[-length(y)]+y[-1]) / 2  # the trapezoid rule, should be 1.0
print(int.y) # Should be 1

</code></pre>


</div>