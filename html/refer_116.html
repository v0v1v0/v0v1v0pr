<div class="container">

<table style="width: 100%;"><tr>
<td>ref</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create Reference to an Object</h2>

<h3>Description</h3>

<p>Create a reference to an arbitrary R object. Use <code>deref</code> or <code>`!`</code> to obtain the values
within the referenced object. Use <code>sref</code> to create a safer reference that limits modification
in place.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ref(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object to be referenced. <code>x</code> can be a symbol, character, or an expression containing a symbol.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Since R does not have reference semantics outside of environments, <code>ref</code> records the environment location
of an object rather than its memory address.<code>ref(x)</code> searches for object with name <code>"x"</code> within the
search path. If found, a reference to the environment and the name <code>"x"</code> are recorded. Otherwise, an
error is returned.
</p>
<p><code>ref</code> can also create a reference to objects within an expression. <code>ref</code> searches the uncalled names
within the expression and replaces them with a reference to the object and a call to deref. For example,
<code>ref(x[[y]][2])</code> inserts a reference to variable <code>x</code> and variable <code>y</code> from the search path into
the expression then wraps the expression into an object of class <code>"ref_exp"</code>. These objects are
dereferenced by evaluating the expression. An error is returned only if the corresponding variables cannot
be found along the search path.
</p>
<p><code>deref</code> can be used to find the objects at the referenced location. This usually results in a
copy of the objects. If the object is no longer available, <code>NULL</code> will be returned. Generic functions on
a <code>ref</code> object, such as arithmetic or <code>`sqrt`</code>, will automatically dereference the object before
applying the generic function. See Methods and Extract for a list of available functions
where explicit dereferencing is not needed. If this behavior is not desired, then <code>sref</code> can
be used to force the explicit use of <code>deref</code>.
</p>
<p>See Extract and <code>modify_by</code> for functions that modify the underlying value in place.
</p>
<p>An active binding could also be used instead of creating a reference. Active bindings, though, can be more
difficult to pass around and may have additional overhead since they are functions.
</p>
<p><code>ref</code> can provide unsafe or inconsistent code that is susceptible to side-effects. Apply caution and
restraint with its use and be sure to <code>deref</code> before exporting any <code>ref</code> objects.
</p>


<h3>Value</h3>

<p>a list of class <code>"ref"</code> containing a reference to the environment of the object and the name of
the object to be found within the environment, or an expression of class <code>"rfexpr"</code> containing references
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create a vectors of random numbers
x &lt;- rnorm(10)
y &lt;- runif(10)

# Create a reference to the random numbers
ref_to_x &lt;- ref(x)
ref_to_y &lt;- ref(y)

# Place references in a list
list_of_refs &lt;- list(x = ref_to_x, y = ref_to_y)

# Check sum of refs 'x' and 'y'
# Note that both `+` and `sum` automatically deref
sum1 &lt;- sum(list_of_refs$x + list_of_refs$y)

# Update 'x' and calculate new sum
x &lt;- rnorm(10)
sum2 &lt;- sum(list_of_refs$x + list_of_refs$y)

# check diff in sums to see if 'list_of_refs' updated
sum2 - sum1

# Obtain a reference to an expression
ref_to_part &lt;- ref(x[2:5] + 3)
deref(ref_to_part)

# Another expression reference
refs_to_list &lt;- ref(list(x, y))
deref(refs_to_list)

x &lt;- "hello"
y &lt;- "world"

deref(refs_to_list)

# Alternative, `!` can be used for dereferencing
!refs_to_list

identical(!refs_to_list, deref(refs_to_list))

# Referencing data.frame columns
dat &lt;- data.frame(first = 1:4, second = 5:8)
ref_to_first &lt;- ref(dat$first)
mean1 &lt;- mean(!ref_to_first)

dat$first &lt;- dat$first * 4
mean2 &lt;- mean(!ref_to_first)

mean2 == 4*mean1

# Many operations automatically dereference
ref_to_first * 5
ref_to_x == ref_to_y
cos(ref_to_first)
max(ref_to_first)

</code></pre>


</div>