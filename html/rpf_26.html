<div class="container">

<table style="width: 100%;"><tr>
<td>EAPscores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Expected A Posteriori (EAP) scores</h2>

<h3>Description</h3>

<p>If you have missing data then you must specify
<code>minItemsPerScore</code>.  This option will set scores to NA when
there are too few items to make an accurate score estimate.  If
you are using the scores as point estimates without considering
the standard error then you should set <code>minItemsPerScore</code> as
high as you can tolerate. This will increase the amount of missing
data but scores will be more accurate. If you are carefully
considering the standard errors of the scores then you can set
<code>minItemsPerScore</code> to 1. This will mimic the behavior of most
other IFA software wherein scores are estimated if there is at
least 1 non-NA item for the score. However, it may make more sense
to set <code>minItemsPerScore</code> to 0. When set to 0, all NA rows
are scored to the prior distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">EAPscores(grp, ..., compressed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>grp</code></td>
<td>
<p>a list containing the model and data. See the details section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compressed</code></td>
<td>
<p>output one score per observed data row even when freqColumn is set (default FALSE)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Output is not affected by the presence of a <code>weightColumn</code>.
</p>


<h3>Format of a group</h3>

<p>A model, or group within a model, is represented as a named list.
</p>

<dl>
<dt>spec</dt>
<dd>
<p>list of response model objects</p>
</dd>
<dt>param</dt>
<dd>
<p>numeric matrix of item parameters</p>
</dd>
<dt>free</dt>
<dd>
<p>logical matrix of indicating which parameters are free (TRUE) or fixed (FALSE)</p>
</dd>
<dt>mean</dt>
<dd>
<p>numeric vector giving the mean of the latent distribution</p>
</dd>
<dt>cov</dt>
<dd>
<p>numeric matrix giving the covariance of the latent distribution</p>
</dd>
<dt>data</dt>
<dd>
<p>data.frame containing observed item responses, and optionally,
weights and frequencies</p>
</dd>
<dt>score</dt>
<dd>
<p>factors scores with response patterns in rows</p>
</dd>
<dt>weightColumn</dt>
<dd>
<p>name of the data column containing the numeric row weights (optional)</p>
</dd>
<dt>freqColumn</dt>
<dd>
<p>name of the data column containing the integral row frequencies (optional)</p>
</dd>
<dt>qwidth</dt>
<dd>
<p>width of the quadrature expressed in Z units</p>
</dd>
<dt>qpoints</dt>
<dd>
<p>number of quadrature points</p>
</dd>
<dt>minItemsPerScore</dt>
<dd>
<p>minimum number of non-missing items when estimating factor scores</p>
</dd>
</dl>
<p>The <code>param</code> matrix stores items parameters by column. If a
column has more rows than are required to fully specify a model
then the extra rows are ignored.  The order of the items in
<code>spec</code> and order of columns in <code>param</code> are assumed to
match. All items should have the same number of latent dimensions.
Loadings on latent dimensions are given in the first few rows and
can be named by setting rownames. Item names are assigned by
<code>param</code> colnames.
</p>
<p>Currently only a multivariate normal distribution is available,
parameterized by the <code>mean</code> and <code>cov</code>. If <code>mean</code> and
<code>cov</code> are not specified then a standard normal distribution is
assumed. The quadrature consists of equally spaced points. For
example, <code>qwidth=2</code> and <code>qpoints=5</code> would produce points
-2, -1, 0, 1, and 2. The quadrature specification is part of the
group and not passed as extra arguments for the sake of
consistency. As currently implemented, OpenMx uses EAP scores to
estimate latent distribution parameters. By default, the exact same
EAP scores should be produced by EAPscores.
</p>


<h3>See Also</h3>

<p>Other scoring: 
<code>bestToOmit()</code>,
<code>itemOutcomeBySumScore()</code>,
<code>observedSumScore()</code>,
<code>omitItems()</code>,
<code>omitMostMissing()</code>,
<code>sumScoreEAP()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">spec &lt;- list()
spec[1:3] &lt;- list(rpf.grm(outcomes=3))
param &lt;- sapply(spec, rpf.rparam)
data &lt;- rpf.sample(5, spec, param)
colnames(param) &lt;- colnames(data)
grp &lt;- list(spec=spec, param=param, data=data, minItemsPerScore=1L)
EAPscores(grp)
</code></pre>


</div>