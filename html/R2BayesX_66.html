<div class="container">

<table style="width: 100%;"><tr>
<td>predict.bayesx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Prediction from fitted BayesX objects
</h2>

<h3>Description</h3>

<p>Takes a fitted <code>"bayesx"</code> object returned from <code>bayesx</code> and produces predictions
by refitting the initial model with weights set to zero for new observations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'bayesx'
predict(object, newdata, model = NULL,
  type = c("response", "link", "terms", "model"),
  na.action = na.pass, digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>"bayesx"</code> or <code>"bayesx.hpc"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>a data frame or list containing the values of the model covariates at which
predictions are required. If missing <code>newdata</code> is the <code>model.frame</code> of the provided
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>for which model should predictions be calculated, either an integer or 
a character, e.g. <code>model = "mcmc.model"</code>. Note that exactly one model must be selected
within argument <code>model</code> to compute predicted values!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>when <code>type = "response"</code>, the default, predictions on the scale of the response
are returned, <code>"link"</code> returns the linear predictor. When <code>type = "terms"</code>, each
component of the linear predictor is returned, but excludes any offset and intercept.
If <code>type = "model"</code>, the full model returned from updating the initial model with weights,
that is used for computing predictions, is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>function determining what should be done with missing values in <code>newdata</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>predictions should usually be based on the new values provided in argument
<code>newdata</code>. However, since this prediction method uses refitting of the model with
weights, predictions for model terms need to be matched with the new observations. <span class="pkg">BayesX</span>
returns values with a lower precision than <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>, therefore argument <code>digits</code> is used to round
values when <code>type = "terms"</code>, to find matching <code>newdata</code> pairs in the fitted objects
returned from the refitted model and the new data. Note that this is a workaround and not 100%
bulletproof. It is recommended to compute predictions for <code>type = "response"</code> or
<code>type = "link"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

 
<p>Depending on the specifications of argument <code>type</code>.
</p>


<h3>Note</h3>

<p>This prediction method is based on refitting the initial model with weights, i.e., if new
observations lie outside the domain of the respective covariate, the knot locations when using
e.g. P-splines are calculated using the old and the new data. Hence, if there are large gaps
between the old data domain and new observations, this could affect the overall fit of the
estimated spline, i.e., compared to the initial model fit there will be smaller or larger
differences depending on the <code>newdata</code> provided. 
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis.
</p>


<h3>See Also</h3>

<p><code>fitted.bayesx</code>, <code>bayesx</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## generate some data
set.seed(121)
n &lt;- 500

## regressors
dat &lt;- data.frame(x = runif(n, -3, 3), z = runif(n, 0, 1),
  w = runif(n, 0, 3))

## generate response 
dat$y &lt;- with(dat, 1.5 + sin(x) + z -3 * w + rnorm(n, sd = 0.6))

## estimate model
b &lt;- bayesx(y ~ sx(x) + z + w, data = dat)

## create some data for which predictions are required
nd &lt;- data.frame(x = seq(2, 5, length = 100), z = 1, w = 0)

## prediction model from refitting with weights
nd$fit &lt;- predict(b, newdata = nd)
plot(fit ~ x, type = "l", data = nd)

## End(Not run)
</code></pre>


</div>