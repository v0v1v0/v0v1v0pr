<div class="container">

<table style="width: 100%;"><tr>
<td>expand</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Time series utility functions</h2>

<h3>Description</h3>

<p>ICU data as handled by <code>ricu</code> is mostly comprised of time series data and as
such, several utility functions are available for working with time series
data in addition to a class dedicated to representing time series data (see
<code>ts_tbl()</code>). Some terminology to begin with: a time series is considered
to have gaps if, per (combination of) ID variable value(s), some time steps
are missing. Expanding and collapsing mean to change between
representations where time steps are explicit or encoded as interval with
start and end times. For sliding window-type operations, <code>slide()</code> means to
iterate over time-windows, <code>slide_index()</code> means to iterate over certain
time-windows, selected relative to the index and <code>hop()</code> means to iterate
over time-windows selected in absolute terms.
</p>


<h3>Usage</h3>

<pre><code class="language-R">expand(
  x,
  start_var = index_var(x),
  end_var = NULL,
  step_size = time_step(x),
  new_index = start_var,
  keep_vars = NULL,
  aggregate = FALSE
)

collapse(
  x,
  id_vars = NULL,
  index_var = NULL,
  start_var = "start",
  end_var = "end",
  env = NULL,
  as_win_tbl = TRUE,
  ...
)

has_no_gaps(x)

has_gaps(...)

is_regular(x)

fill_gaps(x, limits = collapse(x), start_var = "start", end_var = "end")

remove_gaps(x)

slide(x, expr, before, after = hours(0L), ...)

slide_index(x, expr, index, before, after = hours(0L), ...)

hop(
  x,
  expr,
  windows,
  full_window = FALSE,
  lwr_col = "min_time",
  upr_col = "max_time",
  left_closed = TRUE,
  right_closed = TRUE,
  eval_env = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>ts_tbl</code> object to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_var, end_var</code></td>
<td>
<p>Name of the columns that represent lower and upper
windows bounds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step_size</code></td>
<td>
<p>Controls the step size used to interpolate between
<code>start_var</code> and <code>end_var</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_index</code></td>
<td>
<p>Name of the new index column</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_vars</code></td>
<td>
<p>Names of the columns to hold onto</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p>Function for aggregating values in overlapping intervals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_vars, index_var</code></td>
<td>
<p>ID and index variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>Environment used as parent to the environment used to evaluate
expressions passes as <code>...</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_win_tbl</code></td>
<td>
<p>Logical flag indicating whether to return a <code>win_tbl</code> or
an <code>id_tbl</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Passed to <code>hop_quo()</code> and ultimately to
<code>data.table::[()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>
<p>A table with columns for lower and upper window bounds or a
length 2 difftime vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>Expression (quoted for <code style="white-space: pre;">⁠*_quo⁠</code> and unquoted otherwise) to be
evaluated over each window</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>before, after</code></td>
<td>
<p>Time span to look back/forward</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>A vector of times around which windows are spanned (relative
to the index)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>windows</code></td>
<td>
<p>An <code>icu_tbl</code> defining the windows to span</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>full_window</code></td>
<td>
<p>Logical flag controlling how the situation is handled
where the sliding window extends beyond available data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwr_col, upr_col</code></td>
<td>
<p>Names of columns (in <code>windows</code>) of lower/upper
window bounds</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>left_closed, right_closed</code></td>
<td>
<p>Logical flag indicating whether intervals
are closed (default) or open.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval_env</code></td>
<td>
<p>Environment in which <code>expr</code> is substituted; <code>NULL</code> resolves
to the environment in which <code>expr</code> was created</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A gap in a <code>ts_tbl</code> object is a missing time step, i.e. a missing entry in
the sequence <code>seq(min(index), max(index), by = interval)</code> in at least one
group (as defined by <code>id_vars()</code>, where the extrema are calculated per
group. In this case, <code>has_gaps()</code> will return <code>TRUE</code>. The function
<code>is_regular()</code> checks whether the time series has no gaps, in addition to
the object being sorted and unique (see <code>is_sorted()</code> and <code>is_unique()</code>).
In order to transform a time series containing gaps into a regular time
series, <code>fill_gaps()</code> will fill missing time steps with <code>NA</code> values in all
<code>data_vars()</code> columns, while <code>remove_gaps()</code> provides the inverse operation
of removing time steps that consist of <code>NA</code> values in <code>data_vars()</code> columns.
</p>
<p>An <code>expand()</code> operation performed on an object inheriting from <code>data.table</code>
yields a <code>ts_tbl</code> where time-steps encoded by columns <code>start_var</code> and
<code>end_var</code> are made explicit with values in <code>keep_vars</code> being appropriately
repeated. The inverse operation is available as <code>collapse()</code>, which groups
by <code>id_vars</code>, represents <code>index_var</code> as group-wise extrema in two new
columns <code>start_var</code> and <code>end_var</code> and allows for further data summary using
<code>...</code>. An aspect to keep in mind when applying <code>expand()</code> to a <code>win_tbl</code>
object is that values simply are repeated for all time-steps that fall into
a given validity interval. This gives correct results when a <code>win_tbl</code> for
example contains data on infusions as rates, but might not lead to correct
results when infusions are represented as drug amounts administered over a
given time-span. In such a scenario it might be desirable to evenly
distribute the total amount over the corresponding time steps (currently not
implemented).
</p>
<p>Sliding-window type operations are available as <code>slide()</code>, <code>slide_index()</code>
and <code>hop()</code> (function naming is inspired by the CRAN package <code>slider</code>). The
most flexible of the three, <code>hop</code> takes as input a <code>ts_tbl</code> object <code>x</code>
containing the data, an <code>id_tbl</code> object <code>windows</code>, containing for each ID
the desired windows represented by two columns <code>lwr_col</code> and <code>upr_col</code>, as
well as an expression <code>expr</code> to be evaluated per window. At the other end
of the spectrum, <code>slide()</code> spans windows for every ID and available
time-step using the arguments <code>before</code> and <code>after</code>, while <code>slide_index()</code>
can be seen as a compromise between the two, where windows are spanned for
certain time-points, specified by <code>index</code>.
</p>


<h3>Value</h3>

<p>Most functions return <code>ts_tbl</code> objects with the exception of
<code>has_gaps()</code>/<code>has_no_gaps()</code>/<code>is_regular()</code>, which return logical flags.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (FALSE) {
tbl &lt;- ts_tbl(x = 1:5, y = hours(1:5), z = hours(2:6), val = rnorm(5),
              index_var = "y")
exp &lt;- expand(tbl, "y", "z", step_size = 1L, new_index = "y",
              keep_vars = c("x", "val"))
col &lt;- collapse(exp, start_var = "y", end_var = "z", val = unique(val))
all.equal(tbl, col, check.attributes = FALSE)

tbl &lt;- ts_tbl(x = rep(1:5, 1:5), y = hours(sequence(1:5)), z = 1:15)

win &lt;- id_tbl(x = c(3, 4), a = hours(c(2, 1)), b = hours(c(3, 4)))
hop(tbl, list(z = sum(z)), win, lwr_col = "a", upr_col = "b")
slide_index(tbl, list(z = sum(z)), hours(c(4, 5)), before = hours(2))
slide(tbl, list(z = sum(z)), before = hours(2))

tbl &lt;- ts_tbl(x = rep(3:4, 3:4), y = hours(sequence(3:4)), z = 1:7)
has_no_gaps(tbl)
is_regular(tbl)

tbl[1, 2] &lt;- hours(2)
has_no_gaps(tbl)
is_regular(tbl)

tbl[6, 2] &lt;- hours(2)
has_no_gaps(tbl)
is_regular(tbl)
}

</code></pre>


</div>