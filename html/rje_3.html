<div class="container">

<table style="width: 100%;"><tr>
<td>armijo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic functions to aid finding local minima given search direction</h2>

<h3>Description</h3>

<p>Allows use of an Armijo rule or coarse line search as part of minimisation
(or maximisation) of a differentiable function of multiple arguments (via
gradient descent or similar).  Repeated application of one of these rules
should (hopefully) lead to a local minimum.
</p>


<h3>Usage</h3>

<pre><code class="language-R">armijo(
  fun,
  x,
  dx,
  beta = 3,
  sigma = 0.5,
  grad,
  maximise = FALSE,
  searchup = TRUE,
  adj.start = 1,
  ...
)

coarseLine(fun, x, dx, beta = 3, maximise = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>a function whose first argument is a numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a starting value to be passed to <code>fun</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx</code></td>
<td>
<p>numeric vector containing feasible direction for search; defaults
to <code>-grad</code> for ordinary gradient descent</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>numeric value (greater than 1) giving factor by which to adjust
step size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>numeric value (less than 1) giving steepness criterion for move</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grad</code></td>
<td>
<p>numeric gradient of <code>f</code> at <code>x</code> (will be estimated if
not provided)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximise</code></td>
<td>
<p>logical: if set to <code>TRUE</code> search is for a maximum
rather than a minimum.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>searchup</code></td>
<td>
<p>logical: if set to <code>TRUE</code> method will try to find
largest move satisfying Armijo criterion, rather than just accepting the
first it sees</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj.start</code></td>
<td>
<p>an initial adjustment factor for the step size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments to be passed to <code>fun</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>coarseLine</code> performs a stepwise search and tries to find the integer
<code class="reqn">k</code> minimising <code class="reqn">f(x_k)</code> where </p>
<p style="text-align: center;"><code class="reqn">x_k = x + \beta^k dx.</code>
</p>
<p> Note
<code class="reqn">k</code> may be negative.  This is genearlly quicker and dirtier
than the Armijo rule.
</p>
<p><code>armijo</code> implements an Armijo rule for moving, which is to say that
</p>
<p style="text-align: center;"><code class="reqn">f(x_k) - f(x) &lt; - \sigma \beta^k dx \cdot \nabla_x f.</code>
</p>
<p> This has better convergence guarantees than a
simple line search, but may be slower in practice.  See Bertsekas (1999) for
theory underlying the Armijo rule.
</p>
<p>Each of these rules should be applied repeatedly to achieve convergence (see
example below).
</p>


<h3>Value</h3>

<p>A list comprising </p>
<table>
<tr style="vertical-align: top;">
<td><code>best</code></td>
<td>
<p>the value of the function at the final
point of evaluation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adj</code></td>
<td>
<p>the constant in the step, i.e.
<code class="reqn">\beta^n</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>move</code></td>
<td>
<p>the final move; i.e. <code class="reqn">\beta^n dx</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>code</code></td>
<td>
<p>an integer indicating the result of the function; 0 = returned
OK, 1 = very small move suggested, may be at minimum already, 2 = failed to
find minimum: function evaluated to <code>NA</code> or was always larger than
<code class="reqn">f(x)</code> (direction might be infeasible), 3 = failed to find minimum:
stepsize became too small or large without satisfying rule.</p>
</td>
</tr>
</table>
<h3>Functions</h3>


<ul><li> <p><code>coarseLine</code>: Coarse line search
</p>
</li></ul>
<h3>Author(s)</h3>

<p>Robin Evans
</p>


<h3>References</h3>

<p>Bertsekas, D.P. <em>Nonlinear programming</em>, 2nd Edition.
Athena, 1999.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# minimisation of simple function of three variables
x = c(0,-1,4)
f = function(x) ((x[1]-3)^2 + sin(x[2])^2 + exp(x[3]) - x[3])

tol = .Machine$double.eps
mv = 1

while (mv &gt; tol) {
  # or replace with coarseLine()
  out = armijo(f, x, sigma=0.1)
  x = out$x
  mv = sum(out$move^2)
}

# correct solution is c(3,0,0) (or c(3,k*pi,0) for any integer k)
x


</code></pre>


</div>