<div class="container">

<table style="width: 100%;"><tr>
<td>RMXEOMSEMBREOBRE</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Optimally robust estimation: RMXE, OMSE, MBRE, and OBRE </h2>

<h3>Description</h3>

<p>These are wrapper functions to 'roptest' to compute
optimally robust estimates, more specifically RMXEs, OMSEs, MBREs, and OBREs,
for L2-differentiable parametric families via k-step construction.
</p>


<h3>Usage</h3>

<pre><code class="language-R">RMXEstimator(x, L2Fam, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
OMSEstimator(x, L2Fam, eps=0.5, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
OBREstimator(x, L2Fam, eff=0.95, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
MBREstimator(x, L2Fam, fsCor = 1, initial.est, neighbor = ContNeighborhood(),
             steps = 1L, distance = CvMDist, startPar = NULL, verbose = NULL,
             OptOrIter = "iterate", useLast = getRobAStBaseOption("kStepUseLast"),
             withUpdateInKer = getRobAStBaseOption("withUpdateInKer"),
             IC.UpdateInKer = getRobAStBaseOption("IC.UpdateInKer"),
             withICList = getRobAStBaseOption("withICList"),
             withPICList = getRobAStBaseOption("withPICList"), na.rm = TRUE,
             initial.est.ArgList, ..., withLogScale = TRUE, ..withCheck=FALSE,
             withTimings = FALSE, withMDE = NULL, withEvalAsVar = NULL,
             withMakeIC = FALSE, modifyICwarn = NULL, E.argList = NULL,
             diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> sample </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L2Fam</code></td>
<td>
<p> object of class <code>"L2ParamFamily"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eff</code></td>
<td>
<p> positive real (0 &lt;= <code>eff</code> &lt;= 1): amount of asymptotic
efficiency loss in the ideal model. See details below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors.
See details below. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsCor</code></td>
<td>
<p> positive real: factor used to correct the neighborhood radius;
see details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.est</code></td>
<td>
<p> initial estimate for unknown parameter. If missing 
minimum distance estimator is computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbor</code></td>
<td>
<p> object of class <code>"UncondNeighborhood"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p> positive integer: number of steps used for k-steps construction </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p> distance function used in <code>MDEstimator</code>, which in turn
is used as (default) starting estimator. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startPar</code></td>
<td>
<p> initial information used by <code>optimize</code> resp. <code>optim</code>;
i.e; if (total) parameter is of length 1, <code>startPar</code> is 
a search interval, else it is an initial parameter value; if <code>NULL</code>
slot <code>startPar</code> of <code>ParamFamily</code> is used to produce it;
in the multivariate case, <code>startPar</code> may also be of class <code>Estimate</code>,
in which case slot <code>untransformed.estimate</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p> logical: if <code>TRUE</code>, some messages are printed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useLast</code></td>
<td>
<p> which parameter estimate (initial estimate or
k-step estimate) shall be used to fill the slots <code>pIC</code>,
<code>asvar</code> and <code>asbias</code> of the return value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>OptOrIter</code></td>
<td>
<p>character; which method to be used for determining Lagrange
multipliers <code>A</code> and <code>a</code>: if (partially) matched to <code>"optimize"</code>,
<code>getLagrangeMultByOptim</code> is used; otherwise: by default, or if matched to
<code>"iterate"</code> or to <code>"doubleiterate"</code>,
<code>getLagrangeMultByIter</code> is used. More specifically,
when using <code>getLagrangeMultByIter</code>, and if argument <code>risk</code> is of
class <code>"asGRisk"</code>, by default and if matched to <code>"iterate"</code>
we use only one (inner) iteration, if matched to <code>"doubleiterate"</code>
we use up to <code>Maxiter</code> (inner) iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withUpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>, shall
the parameter be updated on <code class="reqn">{\rm ker}(D)</code>?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IC.UpdateInKer</code></td>
<td>
<p>if there is a non-trivial trafo in the model with matrix <code class="reqn">D</code>,
the IC to be used for this; if <code>NULL</code> the result of <code>getboundedIC(L2Fam,D)</code> is taken;
this IC will then be projected onto <code class="reqn">{\rm ker}(D)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withPICList</code></td>
<td>
<p>logical: shall slot <code>pICList</code> of return value
be filled?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withICList</code></td>
<td>
<p>logical: shall slot <code>ICList</code> of return value
be filled?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial.est.ArgList</code></td>
<td>
<p>a list of arguments to be given to argument <code>start</code> if the latter
is a function; this list by default already starts with two unnamed items,
the sample <code>x</code>, and the model <code>L2Fam</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withLogScale</code></td>
<td>
<p>logical; shall a scale component (if existing and found
with name <code>scalename</code>) be computed on log-scale and backtransformed
afterwards? This avoids crossing 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>..withCheck</code></td>
<td>
<p>logical: if <code>TRUE</code>, debugging info is issued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withTimings</code></td>
<td>
<p>logical: if <code>TRUE</code>, separate (and aggregate)
timings for the three steps evaluating the starting value, finding
the starting influence curve, and evaluating the k-step estimator is
issued.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withMDE</code></td>
<td>
<p> logical or <code>NULL</code>: Shall a minimum distance estimator be used as
starting estimator—in addition to the function given in slot
<code>startPar</code> of the L2 family? If <code>NULL</code> (default), the content
of slot <code>.withMDE</code> in the L2 family is used instead to take
this decision.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withEvalAsVar</code></td>
<td>
<p>logical or <code>NULL</code>: if <code>TRUE</code> (default), tells R
to evaluate the asymptotic variance or if <code>FALSE</code> just to produces a call
to do so. If <code>withEvalAsVar</code> is <code>NULL</code> (default),  the content
of slot <code>.withEvalAsVar</code> in the L2 family is used instead to take
this decision.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withMakeIC</code></td>
<td>
<p>logical; if <code>TRUE</code> the [p]IC is passed through
<code>makeIC</code> before return.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modifyICwarn</code></td>
<td>
<p>logical: should a (warning) information be added if
<code>modifyIC</code> is applied and hence some optimality information could
no longer be valid? Defaults to <code>NULL</code> in which case this value
is taken from <code>RobAStBaseOptions</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>E.argList</code></td>
<td>
<p><code>NULL</code> (default) or a list of arguments to be passed
to calls to <code>E</code> from (a) <code>MDEstimator</code>
(here this additional argument is only used if
<code>initial.est</code> is missing), (b) <code>getStartIC</code>,
and (c) <code>kStepEstimator</code>. Potential clashes with
arguments of the same name in <code>...</code> are resolved by inserting
the items of argument list <code>E.argList</code> as named items, so
in case of collisions the item of <code>E.argList</code> overwrites the
existing one from <code>...</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>,
diagnostic information on the performed integrations is gathered and
shipped out as an attribute <code>diagnostic</code> of the return value
of the estimators. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The functions compute optimally robust estimator for a given L2 differentiable
parametric family; more specifically they are RMXEs, OMSEs, MBREs, and OBREs.
The computation uses a k-step construction with an
appropriate initial estimate; cf. also <code>kStepEstimator</code>. 
Valid candidates are e.g. Kolmogorov(-Smirnov) or von Mises minimum 
distance estimators (default); cf. Rieder (1994) and Kohl (2005).
</p>
<p>For OMSE, i.e., the asymptotically linear estimator with minimax mean squared
error on this neighborhood of given size, the amount of gross errors
(contamination) is assumed to be known, and is specified by <code>eps</code>.
The radius of the corresponding infinitesimal
contamination neighborhood is obtained by multiplying <code>eps</code> 
by the square root of the sample size. 
</p>
<p>If the amount of gross errors (contamination) is unknown, RMXE should be used,
i.e., the radius-minimax estimator in the sense of
Rieder et al. (2001, 2008), respectively Section 2.2 of Kohl (2005) is returned.
</p>
<p>The OBRE, i.e., the optimal bias-robust (asymptotically linear) estimator;
(terminology due to Hampel et al (1985)), expects an efficiency loss (at the
ideal model) to be specified and then, according to an (asymptotic) Anscombe
criterion computes the the bias bound achieving this efficiency loss.
</p>
<p>The MBRE, i.e., the most bias-robust (asymptotically linear) estimator;
(terminology due to Hampel et al (1985)), uses the influence curve with
minimal possible bias bound, hence minimaxes bias on these neighborhoods
(in an infinitesimal sense)..
</p>
<p>Finite-sample and higher order results suggest that the asymptotically
optimal procedure is to liberal. Using <code>fsCor</code> the radius can be
modified - as a rule enlarged - to obtain a more conservative estimate.
In case of normal location and scale there is function 
<code>finiteSampleCorrection</code> which returns a finite-sample 
corrected (enlarged) radius based on the results of large Monte-Carlo
studies.
</p>
<p>The default value of argument <code>useLast</code> is set by the
global option <code>kStepUseLast</code> which by default is set to 
<code>FALSE</code>. In case of general models <code>useLast</code> 
remains unchanged during the computations. However, if 
slot <code>CallL2Fam</code> of <code>IC</code> generates an object of 
class <code>"L2GroupParamFamily"</code> the value of <code>useLast</code> 
is changed to <code>TRUE</code>.
Explicitly setting <code>useLast</code> to <code>TRUE</code> should
be done with care as in this situation the influence curve
is re-computed using the value of the one-step estimate
which may take quite a long time depending on the model.
</p>
<p>If <code>useLast</code> is set to <code>TRUE</code> the computation of <code>asvar</code>, 
<code>asbias</code> and <code>IC</code> is based on the k-step estimate.
</p>
<p>All these estimators are realized as wrappers to function <code>roptest</code>.
</p>
<p>Timings for the steps run through in these estimators are available
in attributes <code>timings</code>, and for the step of the
<code>kStepEstimator</code> in <code>kStepTimings</code>.
</p>
<p>One may also use the arguments <code>startCtrl</code>, <code>startICCtrl</code>, and
<code>kStepCtrl</code> of function <code>robest</code>. This allows for individual
settings of <code>E.argList</code>, <code>withEvalAsVar</code>, and
<code>withMakeIC</code> for the different steps. If any of the three arguments
<code>startCtrl</code>, <code>startICCtrl</code>, and <code>kStepCtrl</code> is used, the
respective attributes set in the correspondig argument are used and, if
colliding with arguments directly passed to the estimator function, the directly
passed ones are ignored.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there are attributes <code>diagnostic</code>
and <code>kStepDiagnostic</code> attached to the return value, which may be inspected
and assessed through <code>showDiagnostic</code> and
<code>getDiagnostic</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>.  In addition, it has
an attribute <code>"timings"</code> where computation time is stored.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br>
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Kohl, M. (2005) <em>Numerical Contributions to the Asymptotic Theory of Robustness</em>. 
Bayreuth: Dissertation. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P. (2010): R package distrMod: 
Object-Oriented Implementation of Probability Models. 
J. Statist. Softw.  <b>35</b>(10), 1–27. <a href="https://doi.org/10.18637/jss.v035.i10">doi:10.18637/jss.v035.i10</a>.
</p>
<p>Kohl, M. and Ruckdeschel, P., and Rieder, H. (2010):
Infinitesimally Robust Estimation in General Smoothly Parametrized Models.
<em>Stat. Methods Appl.</em>, <b>19</b>, 333–354. 
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
<a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2008) The Costs of not Knowing
the Radius. Statistical Methods and Applications <b>17</b>(1) 13-40.
<a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>.
</p>
<p>Rieder, H., Kohl, M. and Ruckdeschel, P. (2001) The Costs of not Knowing
the Radius. Appeared as discussion paper Nr. 81. 
SFB 373 (Quantification and Simulation of Economic Processes),
Humboldt University, Berlin; also available under
<a href="https://doi.org/10.18452/3638">doi:10.18452/3638</a>
</p>


<h3>See Also</h3>

 <p><code>roptest</code>, <code>robest</code>,
<code>roblox</code>,
<code>L2ParamFamily-class</code>
<code>UncondNeighborhood-class</code>,
<code>RiskType-class</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">#############################
## 1. Binomial data
#############################
## generate a sample of contaminated data
set.seed(123)
ind &lt;- rbinom(100, size=1, prob=0.05)
x &lt;- rbinom(100, size=25, prob=(1-ind)*0.25 + ind*0.9)

## ML-estimate
MLE.bin &lt;- MLEstimator(x, BinomFamily(size = 25))
## compute optimally robust estimators
OMSE.bin &lt;- OMSEstimator(x, BinomFamily(size = 25), steps = 3)
MBRE.bin &lt;- MBREstimator(x, BinomFamily(size = 25), steps = 3)
estimate(MLE.bin)
estimate(MBRE.bin)
estimate(OMSE.bin)

  ## to reduce time load at CRAN tests
RMXE.bin &lt;- RMXEstimator(x, BinomFamily(size = 25), steps = 3)
OBRE.bin &lt;- OBREstimator(x, BinomFamily(size = 25), steps = 3)
estimate(RMXE.bin)
estimate(OBRE.bin)

  ## to reduce time load at CRAN tests
#############################
## 2. Poisson data
#############################

## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
x &lt;- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532),
       rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27),
       rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))

## ML-estimate
MLE.pois &lt;- MLEstimator(x, PoisFamily())
OBRE.pois &lt;- OBREstimator(x, PoisFamily(), steps = 3)
OMSE.pois &lt;- OMSEstimator(x, PoisFamily(), steps = 3)
MBRE.pois &lt;- MBREstimator(x, PoisFamily(), steps = 3)
RMXE.pois &lt;- RMXEstimator(x, PoisFamily(), steps = 3)
estimate(MLE.pois)
estimate(OBRE.pois)
estimate(RMXE.pois)
estimate(MBRE.pois)
estimate(OMSE.pois)


 ## to reduce time load at CRAN tests
#############################
## 3. Normal (Gaussian) location and scale
#############################
## 24 determinations of copper in wholemeal flour
library(MASS)
data(chem)

MLE.n &lt;- MLEstimator(chem, NormLocationScaleFamily())
MBRE.n &lt;- MBREstimator(chem, NormLocationScaleFamily(), steps = 3)
OMSE.n &lt;- OMSEstimator(chem, NormLocationScaleFamily(), steps = 3)
OBRE.n &lt;- OBREstimator(chem, NormLocationScaleFamily(), steps = 3)
RMXE.n &lt;- RMXEstimator(chem, NormLocationScaleFamily(), steps = 3)

estimate(MLE.n)
estimate(MBRE.n)
estimate(OMSE.n)
estimate(OBRE.n)
estimate(RMXE.n)

</code></pre>


</div>