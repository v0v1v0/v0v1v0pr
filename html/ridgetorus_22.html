<div class="container">

<table style="width: 100%;"><tr>
<td>ridge_scores</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Scores and scales for Fourier-fitted ridge curves</h2>

<h3>Description</h3>

<p>Computation of PCA scores for 
Fourier-fitted ridge curves. The scores are defined as follows:
</p>

<ul>
<li>
<p> First scores: signed distances along the ridge curve of the data
projections to <code class="reqn">\mu</code>.
</p>
</li>
<li>
<p> Second scores: signed toroidal distances from the data points to
their ridge projections.
</p>
</li>
</ul>
<p>The scores can be scaled to <code class="reqn">(-\pi, \pi)</code> or remain as
<code class="reqn">(l / 2, m_2)</code>, where <code class="reqn">l</code> is the length of the curve and <code class="reqn">m_2</code>
is the maximal absolute second score.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ridge_scores(
  x,
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  N = 500,
  scale = TRUE,
  at2 = TRUE
)

max_score_2(
  mu = c(0, 0),
  coefs = list(cos_a = c(0, 0), sin_b = 0),
  ind_var = 1,
  L = 25,
  f = 2,
  at2 = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a matrix of size <code>c(nx, 2)</code> with angular coordinates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>a vector of size <code>2</code> giving <code class="reqn">(\mu_1, \mu_2)</code>. Defaults
to <code>c(0, 0)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefs</code></td>
<td>
<p>list of coefficients <code>cos_a</code> (<code class="reqn">a_k</code>) and
<code>sin_b</code> (<code class="reqn">b_k</code> giving the Fourier fit of the ridge curve.
Defaults to <code>list(cos_a = c(0, 0), sin_b = 0)</code>. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_var</code></td>
<td>
<p>index <code class="reqn">j</code> of the variable that parametrizes the ridge.
Defaults to <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>number of discretization points for approximating curve lengths.
Defaults to <code>5e2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>scale the resulting scores to <code class="reqn">[-\pi, \pi)^2</code>? Defaults
to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at2</code></td>
<td>
<p>do the <code>atan2</code> fit instead of the sine fit (only using
<code class="reqn">S_m</code>)? Defaults to <code>TRUE</code>. <code>at2 = FALSE</code> is not
recommended to use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>grid along he variable <code>ind_var</code> used for searching the
maximum allowed second score. Defaults to <code>25</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>factor for shrinking the grid on the variable that is different to
<code>ind_var</code>. Defaults to <code>2</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The mean <code class="reqn">\mu</code> corresponds to the first score being null.
</p>


<h3>Value</h3>

<p><code>ridge_scores</code> returns a list with:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>a matrix of size <code>c(nx, 2)</code> with the ridge scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scales</code></td>
<td>
<p>a vector of length 2 with the scale limits for the axes.</p>
</td>
</tr>
</table>
<p><code>max_score_2</code> computes the maximum allowed second score to rescale if
<code>scale = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">mu &lt;- c(-0.5, 1.65)
th &lt;- seq(-pi, pi, l = 200)
K &lt;- 5
coefs &lt;- list(cos_a = 1 / (1:(K + 1))^3, sin_b = 1 / (1:K)^3)
n &lt;- 10
col &lt;- rainbow(n)

set.seed(13213)
old_par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2, 2))
for (j in 1:2) {

  # Simulate synthetic data close to the ridge curve
  rid &lt;- ridge_curve(theta = th, mu = mu, coefs = coefs, ind_var = j)
  ind &lt;- sort(sample(length(th), size = n))
  eps &lt;- 0.25 * matrix(runif(2 * n, -1, 1), nrow = n, ncol = 2)
  x &lt;- sdetorus::toPiInt(rid[ind, ] + eps)

  # Plot ridge and synthetic data, with signs from the second scores
  s &lt;- ridge_scores(x, mu = mu, coefs = coefs, ind_var = j)$scores
  plot(x, xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
       xlab = expression(theta[1]), ylab = expression(theta[2]), col = col,
       pch = ifelse(sign(s[, 2]) == 1, "+", "-"), cex = 1.25)
  sdetorus::linesTorus(rid[, 1], rid[, 2], lwd = 2)
  abline(v = mu[1], lty = 3)
  abline(h = mu[2], lty = 3)
  points(mu[1], mu[2], pch = "*", cex = 3)
  sdetorus::torusAxis()

  # Projections
  theta_projs &lt;- proj_ridge_curve(x = x, mu = mu, coefs = coefs,
                                  ind_var = j, ridge_curve_grid = rid,
                                  )$theta_proj
  projs &lt;- ridge_curve(theta = theta_projs, mu = mu, coefs = coefs,
                       ind_var = j)
  for (i in 1:n) {

    sdetorus::linesTorus(x = c(x[i, 1], projs[i, 1]),
                         y = c(x[i, 2], projs[i, 2]),
                         col = col[i], lty = 3)

  }

  # Scores plot
  plot(s, xlim = c(-pi, pi), ylim = c(-pi, pi), axes = FALSE,
       xlab = "Score 1", ylab = "Score 2", col = col,
       pch = ifelse(sign(s[, 2]) == 1, "+", "-"))
  sdetorus::torusAxis()
  abline(v = 0, lty = 3)
  abline(h = 0, lty = 3)
  points(0, 0, pch = "*", cex = 3)

}
par(old_par)
</code></pre>


</div>