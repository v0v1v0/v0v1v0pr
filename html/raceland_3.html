<div class="container">

<table style="width: 100%;"><tr>
<td>calculate_metrics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate Metrics</h2>

<h3>Description</h3>

<p>Calculates exposure matrix and quantifies it by calculating four IT-derived metrics: entropy (ent), joint entropy (joinent), conditional entropy (condent) and mutual information (mutinf).
Entropy is associated with measuring racial diversity and mutual information is associated with measuring racial segregation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">calculate_metrics(
  x,
  w,
  neighbourhood = 4,
  fun,
  size = NULL,
  shift = NULL,
  na_action = "replace",
  base = "log2",
  ordered = TRUE,
  threshold = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>SpatRaster with realizations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>SpatRaster with local densities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours: <code>4</code> (rook's case), <code>8</code> (queen's case). The default is <code>4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign value from the focal cell</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>Expressed in the numbers of cells, is a length of the side of a square-shaped block of cells. It defines the extent of a local pattern. If <code>size=NULL</code> calculations are performed for a whole area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>Defines the shift between adjacent squares of cells along with the N-S and W-E directions. It describes the density (resolution) of the output grid. The resolution of the output map will be reduced to the original resolution multiplied by the shift. If shift=size the input map will be divided into a grid of non-overlapping square windows. Each square window defines the extent of a local pattern. If shift &lt; size - results in the grid of overlapping square windows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_action</code></td>
<td>
<p>Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p>The unit in which entropy is measured. The default is "log2", which compute entropy in "bits". <code>"log"</code> and <code>"log10"</code> can be also used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>The type of pairs considered. Either ordered (<code>TRUE</code>) or unordered (<code>FALSE</code>). The default is <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The share of NA cells to allow metrics calculation in a square-shaped window</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
x = create_realizations(race_raster, n = 5)
w = create_densities(x, race_raster, window_size = 10)

#1
df = calculate_metrics(x, w, neighbourhood = 4, fun = "mean")

#2
df2 = calculate_metrics(x, w, neighbourhood = 4, fun = "mean", size = 10, threshold = 0.5)
my_grid = create_grid(x, size = 10)

df3 = dplyr::filter(df2, realization == 2)
result = dplyr::left_join(my_grid, df2, by = c("row", "col"))
plot(result)
</code></pre>


</div>