<div class="container">

<table style="width: 100%;"><tr>
<td>runINMF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform iNMF on scaled datasets</h2>

<h3>Description</h3>

<p>Performs integrative non-negative matrix factorization (iNMF) (J.D. Welch,
2019) using block coordinate descent (alternating non-negative
least squares, ANLS) to return factorized <code class="reqn">H</code>, <code class="reqn">W</code>, and <code class="reqn">V</code>
matrices. The objective function is stated as
</p>
<p style="text-align: center;"><code class="reqn">\arg\min_{H\ge0,W\ge0,V\ge0}\sum_{i}^{d}||E_i-(W+V_i)Hi||^2_F+
\lambda\sum_{i}^{d}||V_iH_i||_F^2</code>
</p>

<p>where <code class="reqn">E_i</code> is the input non-negative matrix of the i'th dataset, <code class="reqn">d</code>
is the total number of datasets. <code class="reqn">E_i</code> is of size <code class="reqn">m \times n_i</code> for
<code class="reqn">m</code> variable genes and <code class="reqn">n_i</code> cells, <code class="reqn">H_i</code> is of size
<code class="reqn">n_i \times k</code>, <code class="reqn">V_i</code> is of size <code class="reqn">m \times k</code>, and <code class="reqn">W</code> is of
size <code class="reqn">m \times k</code>.
</p>
<p>The factorization produces a shared <code class="reqn">W</code> matrix (genes by k), and for each
dataset, an <code class="reqn">H</code> matrix (k by cells) and a <code class="reqn">V</code> matrix (genes by k).
The <code class="reqn">H</code> matrices represent the cell factor loadings. <code class="reqn">W</code> is held
consistent among all datasets, as it represents the shared components of the
metagenes across datasets. The <code class="reqn">V</code> matrices represent the
dataset-specific components of the metagenes.
</p>
<p>This function adopts highly optimized fast and memory efficient
implementation extended from Planc (Kannan, 2016). Pre-installation of
extension package <code>RcppPlanc</code> is required. The underlying algorithm
adopts the identical ANLS strategy as <code>optimizeALS</code> in the old
version of LIGER.
</p>


<h3>Usage</h3>

<pre><code class="language-R">runINMF(object, k = 20, lambda = 5, ...)

## S3 method for class 'liger'
runINMF(
  object,
  k = 20,
  lambda = 5,
  nIteration = 30,
  nRandomStarts = 1,
  HInit = NULL,
  WInit = NULL,
  VInit = NULL,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'Seurat'
runINMF(
  object,
  k = 20,
  lambda = 5,
  datasetVar = "orig.ident",
  layer = "ligerScaleData",
  assay = NULL,
  reduction = "inmf",
  nIteration = 30,
  nRandomStarts = 1,
  HInit = NULL,
  WInit = NULL,
  VInit = NULL,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A liger object or a Seurat object with
non-negative scaled data of variable features (Done with
<code>scaleNotCenter</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Inner dimension of factorization (number of factors). Generally, a
higher <code>k</code> will be needed for datasets with more sub-structure. Default
<code>20</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
<code>lambda</code> increases). Default <code>5</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIteration</code></td>
<td>
<p>Total number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nRandomStarts</code></td>
<td>
<p>Number of restarts to perform (iNMF objective function
is non-convex, so taking the best objective from multiple successive
initialization is recommended). For easier reproducibility, this increments
the random seed by 1 for each consecutive restart, so future factorization
of the same dataset can be run with one rep if necessary. Default <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">H</code> matrices. A list object where
each element is the initial <code class="reqn">H</code> matrix of each dataset. Default
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">W</code> matrix. A matrix object.
Default <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>VInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">V</code> matrices. A list object where
each element is the initial <code class="reqn">V</code> matrix of each dataset. Default
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nCores</code></td>
<td>
<p>The number of parallel tasks to speed up the computation.
Default <code>2L</code>. Only supported for platform with OpenMP support.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>datasetVar</code></td>
<td>
<p>Metadata variable name that stores the dataset source
annotation. Default <code>"orig.ident"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>layer</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to retrieve input
non-negative scaled data. Default <code>"ligerScaleData"</code>. For older Seurat,
always retrieve from <code>scale.data</code> slot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p>Name of the reduction to store result. Also used as the
feature key. Default <code>"inmf"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li>
<p>liger method - Returns updated input liger object
</p>

<ul>
<li>
<p>A list of all <code class="reqn">H</code> matrices can be accessed with
<code>getMatrix(object, "H")</code>
</p>
</li>
<li>
<p>A list of all <code class="reqn">V</code> matrices can be accessed with
<code>getMatrix(object, "V")</code>
</p>
</li>
<li>
<p>The <code class="reqn">W</code> matrix can be accessed with
<code>getMatrix(object, "W")</code>
</p>
</li>
</ul>
</li>
<li>
<p>Seurat method - Returns updated input Seurat object
</p>

<ul>
<li>
<p><code class="reqn">H</code> matrices for all datasets will be concatenated and
transposed (all cells by k), and form a DimReduc object in the
<code>reductions</code> slot named by argument <code>reduction</code>.
</p>
</li>
<li>
<p><code class="reqn">W</code> matrix will be presented as <code>feature.loadings</code> in the
same DimReduc object.
</p>
</li>
<li>
<p><code class="reqn">V</code> matrices, an objective error value and the dataset
variable used for the factorization is currently stored in
<code>misc</code> slot of the same DimReduc object.
</p>
</li>
</ul>
</li>
</ul>
<h3>Difference from optimizeALS()</h3>

<p>In the old version implementation, we compute the objective error at the end
of each iteration, and then compares if the algorithm is reaching a
convergence, using an argument <code>thresh</code>. Now, since the computation of
objective error is indeed expensive, we canceled this feature and directly
runs a default of 30 (<code>nIteration</code>) iterations, which empirically leads
to a convergence most of the time. Given that the new version is highly
optimized, running this many iteration should be acceptable.
</p>


<h3>References</h3>

<p>Joshua D. Welch and et al., Single-Cell Multi-omic Integration
Compares and Contrasts Features of Brain Cell Identity, Cell, 2019
</p>


<h3>Examples</h3>

<pre><code class="language-R">pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- runINMF(pbmc)
}
</code></pre>


</div>