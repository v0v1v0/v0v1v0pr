<div class="container">

<table style="width: 100%;"><tr>
<td>redundant</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Eliminate redundant rows of H-representation and V-representation</h2>

<h3>Description</h3>

<p>Eliminate redundant rows from H-representation (intersection of half spaces)
or V-representation (convex hull of points and directions) of convex polytope.
</p>


<h3>Usage</h3>

<pre><code class="language-R">redundant(input, representation = c("H", "V"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>either H-representation or V-representation of
convex polyhedron (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>representation</code></td>
<td>
<p>if <code>"H"</code>, then <code>input</code> is
an H-representation, otherwise a V-representation.  May also be
obtained from a <code>"representation"</code> attribute of <code>input</code>,
if present.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>cddlibman.pdf</code> in the <code>doc</code> directory of this package,
especially Sections 1 and 2.
</p>
<p>Both representations are (in R) matrices, the first two columns are
special.  Let <code>foo</code> be either an H-representation or
a V-representation and
</p>
<pre>
      l &lt;- foo[ , 1]
      b &lt;- foo[ , 2]
      v &lt;- foo[ , - c(1, 2)]
      a &lt;- (- v)
  </pre>
<p>In the H-representation the convex polyhedron in question is the set of
points <code>x</code> satisfying
</p>
<pre>
      axb &lt;- a %*% x - b
      all(axb &lt;= 0)
      all(l * axb == 0)
  </pre>
<p>In the V-representation the convex polyhedron in question is the set of
points <code>x</code> for which there exists a <code>lambda</code> such that
</p>
<pre>
      x &lt;- t(lambda) %*% v
  </pre>
<p>where <code>lambda</code> satisfies the constraints
</p>
<pre>
      all(lambda * (1 - l) &gt;= 0)
      sum(b * lambda) == max(b)
  </pre>
<p>An H-representation or V-representation object can be checked for validity
using the function <code>validcdd</code>.
</p>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>The input matrix with redundant rows removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>implied.linearity</code></td>
<td>
<p>For an H-representation, row numbers of inequality
constraint rows that together imply equality constraints.  For a
V-representation, row numbers of rays that together imply lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>redundant</code></td>
<td>
<p>Row numbers of redundant rows.  Note: this is set
<code>redset</code> output by the <code>dd_MatrixCanonicalize</code> function
in <code>cddlib</code>.  It apparently does not consider all rows it deletes
“redundant”.  Redundancy can also be determined from the
following component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new.position</code></td>
<td>
<p>Integer vector of length <code>nrow(input)</code>.  Says
for each input row which output row it becomes or zero to indicate
redundant.</p>
</td>
</tr>
</table>
<h3>Rational Arithmetic</h3>

<p>The input representation may
have type <code>"character"</code> in which case its elements are interpreted
as unlimited precision rational numbers.  They consist of an optional
minus sign, a string of digits of any length (the numerator),
a slash, and another string of digits of any length (the denominator).
The denominator must be positive.  If the denominator is one, the
slash and the denominator may be omitted.  This package
provides several functions (see ConvertGMP and ArithmeticGMP)
for conversion back and forth between R floating point numbers and rationals
and for arithmetic on GMP rationals.
</p>


<h3>Warning</h3>

<p>If you want correct answers, use rational arithmetic.  If you do not,
this function may (1) produce approximately correct answers, (2) fail with
an error, (3) give answers that are nowhere near correct with no error or
warning, or (4) crash R losing all work done to that point.  In large
simulations (1) is most frequent, (2) occurs roughly one time in a thousand,
(3) occurs roughly one time in ten thousand, and (4) has only occurred once.
So the R floating point
arithmetic version does mostly work, but you cannot trust its results unless
you can check them independently.
</p>


<h3>See Also</h3>

<p><code>ArithmeticGMP</code>, <code>ConvertGMP</code>,
<code>validcdd</code>, <code>makeH</code></p>


<h3>Examples</h3>

<pre><code class="language-R">hrep &lt;- rbind(c(0, 0,  1,  1,  0),
              c(0, 0, -1,  0,  0),
              c(0, 0,  0, -1,  0),
              c(0, 0,  0,  0, -1),
              c(0, 0, -1, -1, -1))

redundant(d2q(hrep), representation = "H")

foo &lt;- c(1, 0, -1)
hrep &lt;- cbind(0, 1, rep(foo, each = 9), rep(foo, each = 3), foo)
print(hrep)
redundant(d2q(hrep), representation = "V")
</code></pre>


</div>