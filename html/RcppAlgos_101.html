<div class="container">

<table style="width: 100%;"><tr>
<td>comboSample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Sample Combinations and Permutations
</h2>

<h3>Description</h3>


<ul>
<li>
<p> Generate a specific (lexicographically) or random sample of combinations/permutations.
</p>
</li>
<li>
<p> Produce results in parallel using the <code>Parallel</code> or <code>nThreads</code> arguments.
</p>
</li>
<li>
<p> GMP support allows for exploration of combinations/permutations of vectors with many elements.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">comboSample(v, m = NULL, ...)
permuteSample(v, m = NULL, ...)

## S3 method for class 'numeric'
comboSample(v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
            sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
            nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...)

## S3 method for class 'numeric'
permuteSample(v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
              sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
              nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...)

## S3 method for class 'factor'
comboSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
    nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)
## S3 method for class 'factor'
permuteSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, FUN = NULL, Parallel = FALSE,
    nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)

## Default S3 method:
comboSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL, sampleVec = NULL,
    seed = NULL, FUN = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)
## Default S3 method:
permuteSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL, sampleVec = NULL,
    seed = NULL, FUN = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)

## S3 method for class 'table'
comboSample(
    v, m = NULL, n = NULL, sampleVec = NULL, seed = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)
## S3 method for class 'table'
permuteSample(
    v, m = NULL, n = NULL, sampleVec = NULL, seed = NULL, FUN = NULL,
    Parallel = FALSE, nThreads = NULL, namedSample = FALSE, FUN.VALUE = NULL, ...
)

## S3 method for class 'list'
comboSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, namedSample = FALSE, ...
)
## S3 method for class 'list'
permuteSample(
    v, m = NULL, repetition = FALSE, freqs = NULL, n = NULL,
    sampleVec = NULL, seed = NULL, namedSample = FALSE, ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Source vector. If <code>v</code> is a positive integer, it will be converted to the sequence <code>1:v</code>. If <code>v</code> is a negative integer, it will be converted to the sequence <code>v:-1</code>. All atomic types are supported (See <code>is.atomic</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>Number of elements to choose.  If <code>repetition = TRUE</code> or <code>freqs</code> is utilized, <code>m</code> can exceed the length of <code>v</code>. If <code>m = NULL</code>, the length will default to <code>length(v)</code> or <code>sum(freqs)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetition</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be with or without repetition. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freqs</code></td>
<td>
<p>A vector of frequencies used for producing all combinations/permutations of a multiset of <code>v</code>. Each element of <code>freqs</code> represents how many times each element of the source vector, <code>v</code>, is repeated. It is analogous to the <code>times</code> argument in <code>rep</code>. The default value is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of combinations/permutations to return. The default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampleVec</code></td>
<td>
<p>A vector of indices representing the lexicographical combination/permutations to return. Accepts whole numbers as well as vectors of class <code>bigz</code> as well as vectors of characters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Random seed initialization. The default is <code>NULL</code>. N.B. If the gmp library is needed, this parameter must be set in order to have reproducible results (<em>E.g</em> <code>set.seed()</code> has no effect in these cases).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>Function to be applied to each combination/permutation. The default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Parallel</code></td>
<td>
<p>Logical value indicating whether combinations/permutations should be generated in parallel. The default is <code>FALSE</code>. If <code>TRUE</code> and <code>nThreads = NULL</code>, the number of threads used is equal to the minimum of one minus the number of threads available on your system and the number of results requested (<em>e.g.</em> if user has 16 threads and only needs 5 results, 5 threads will be used (<em>i.e.</em> <code>min(16 - 1, 5) = 5</code>)). If <code>nThreads</code> is not <code>NULL</code>, it will be given preference (<em>e.g.</em> if user has 8 threads with <code>Parallel = TRUE</code> and <code>nThreads = 4</code>, only 4 threads will be spawned). If your system is single-threaded, the arguments <code>Parallel</code> and <code>nThreads</code> are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nThreads</code></td>
<td>
<p>Specific number of threads to be used. The default is <code>NULL</code>. See <code>Parallel</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>namedSample</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, <code>rownames</code> corresponding to the lexicographical combination/permutation, will be added to the returned matrix. The default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN.VALUE</code></td>
<td>
<p>A template for the return value from <code>FUN</code>. See 'Details' of <code>vapply</code> for more information.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These algorithms rely on efficiently generating the <code class="reqn">n^{th}</code> lexicographical combination/permutation. This is the process of <a href="https://rosettacode.org/wiki/Permutations/Rank_of_a_permutation">unranking</a>.
</p>


<h3>Value</h3>


<ul>
<li>
<p> In general, a matrix with <code class="reqn">m</code> or <code class="reqn">m + 1</code> columns, depending on the value of <code>keepResults</code>
</p>
</li>
<li>
<p> If <code>FUN</code> is utilized and <code>FUN.VALUE = NULL</code>, a list is returned
</p>
</li>
<li>
<p> When both <code>FUN</code> and <code>FUN.VALUE</code> are not <code>NULL</code>, the return is modeled after the return of <code>vapply</code>. See the 'Value' section of <code>vapply</code>.
</p>
</li>
</ul>
<h3>Note</h3>


<ul>
<li> <p><code>Parallel</code> and <code>nThreads</code> will be ignored in the following cases:
</p>

<ul>
<li>
<p> If the class of the vector passed is <code>character</code> (N.B. <code>Rcpp::CharacterMatrix</code> is not thread safe). Alternatively, you can generate an indexing matrix in parallel.
</p>
</li>
<li>
<p> If <code>FUN</code> is utilized.
</p>
</li>
</ul>
</li>
<li> <p><code>n</code> and <code>sampleVec</code> cannot both be <code>NULL</code>.
</p>
</li>
<li>
<p> Factor vectors are accepted. Class and level attributes are preserved except when <code>FUN</code> is used.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Joseph Wood
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Lexicographical_order">Lexicographical order</a>
</p>


<h3>See Also</h3>

<p><code>comboRank</code>, <code>permuteRank</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## generate 10 random combinations
comboSample(30, 8, TRUE, n = 5, seed = 10)

## Using sampleVec to generate specific permutations
fqs   = c(1,2,2,1,2,2,1,2,1,2,2,1,2,1,1)
s_idx = c(1, 10^2, 10^5, 10^8, 10^11)

permuteSample(15, 10, freqs = fqs, sampleVec = s_idx)

## Same example using 'table' method
permuteSample(table(rep(1:15, times = fqs)), 10, sampleVec = s_idx)

## Generate each result one by one...
## Same, but not as efficient as generating iteratively
all.equal(comboSample(10, 5, sampleVec = 1:comboCount(10, 5)),
          comboGeneral(10, 5))

## Examples with enormous number of total permutations
num = permuteCount(10000, 20)
gmp::log2.bigz(num)

first  = gmp::urand.bigz(n = 1, size = 265, seed = 123)
mySamp = do.call(c, lapply(0:10, function(x) gmp::add.bigz(first, x)))

class(mySamp)

## using permuteSample
pSamp = permuteSample(10000, 20, sampleVec = mySamp)

## using permuteGeneral
pGeneral = permuteGeneral(10000, 20,
                          lower = first,
                          upper = gmp::add.bigz(first, 10))

identical(pSamp, pGeneral)

## Using nThreads
permPar = permuteSample(10000, 50, n = 8, seed = 10, nThreads = 2)

## Using FUN
permuteSample(10000, 50, n = 4, seed = 10, FUN = sd)

## Not run: 
## Using Parallel
permuteSample(10000, 50, n = 80, seed = 10, Parallel = TRUE)

## End(Not run)
</code></pre>


</div>