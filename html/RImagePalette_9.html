<div class="container">

<table style="width: 100%;"><tr>
<td>scale_color_image</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Image color scales</h2>

<h3>Description</h3>

<p>Uses the image color scale.
</p>


<h3>Usage</h3>

<pre><code class="language-R">scale_color_image(..., image, n = 3, choice = mean, volume = FALSE,
  discrete = TRUE)

scale_colour_image(..., image, n = 3, choice = mean, volume = FALSE,
  discrete = TRUE)

scale_fill_image(..., image, n = 3, choice = mean, volume = FALSE,
  discrete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters to <code>discrete_scale</code> or <code>scale_fill_gradientn</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>image</code></td>
<td>
<p>Matrix The image from which the palette will be extracted from. Should
be a 3 (or more) dimensional matrix. The output of a function such as <code>readJPG()</code>
or <code>readPNG()</code> are suitable as <code>image</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>For continuous color scales, you may optionally pass in an integer, n.
This allows some control over the scale, if n is too large the scale has too many
colors and ceases to be meaningul. n = 3 to n = 5 is recommended.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>choice</code></td>
<td>
<p>Function Defines how the color will be chosen from the final color cubes.
The default choice is to take the <code>mean</code> value of the image cube, but other choices
may return a subjectively superior scale. Try <code>median</code>, or <code>min</code>, or <code>max</code>, or
whatever summary statistic suits your fancy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>volume</code></td>
<td>
<p>Logical volume controls the method for choosing which color cube to split
at each iteration of the algorithm. The default choice (when <code>volume = FALSE</code>) is to
choose the cube which contains the largest extent (that is, the largest range
of some color). When <code>volume = TRUE</code>, the cube with the largest volume is chosen to split.
Occasionally, setting to <code>TRUE</code> returns a better palette.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>discrete</code></td>
<td>
<p>generate a discrete palette? (default: <code>FALSE</code> - generate continuous palette)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code>discrete == TRUE</code> (the default) the function will return a <code>discrete_scale</code> with the plot-computed
number of colors. All other arguments are as to
scale_fill_gradientn or scale_color_gradientn.
</p>
<p>See image_palette for more information on the color scale.
</p>


<h3>See Also</h3>

<p><code>median_cut</code> <code>image_palette</code> <code>vbox</code>
<code>display_image</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(ggplot2)

# ripped from the pages of ggplot2
your_image &lt;- jpeg::readJPEG(system.file("img", "Rlogo.jpg", package="jpeg"))
display_image(your_image)

#Discrete scale example
p &lt;- ggplot(mtcars, aes(wt, mpg))
p + geom_point(size=4, aes(colour = factor(cyl))) +
    scale_color_image(image = your_image) +
    theme_bw()

#Continuous scale example
dsub &lt;- subset(diamonds, x &gt; 5 &amp; x &lt; 6 &amp; y &gt; 5 &amp; y &lt; 6)
dsub$diff &lt;- with(dsub, sqrt(abs(x-y))* sign(x-y))
d &lt;- ggplot(dsub, aes(x, y, colour=diff)) + geom_point()
d + scale_color_image(image = your_image, discrete=FALSE) + theme_bw()
</code></pre>


</div>