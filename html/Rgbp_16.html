<div class="container">

<table style="width: 100%;"><tr>
<td>gbp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Gaussian, Poisson, and Binomial Hierarchical Models</h2>

<h3>Description</h3>

<p><code>gbp</code> fits Bayesian hierarchical models using the Uniform distribution on the second level variance component (variance of the prior distribution), which enables good frequentist repeated sampling properties. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">gbp(y, se.or.n, covariates, mean.PriorDist, model, intercept, 
           confidence.lvl, n.AR, n.AR.factor, trial.scale, save.result,
           normal.CI, t, u)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>a (<em>k</em> by 1) vector of <em>k</em> groups' sample means for Gaussian or of each group's number of successful trials for Binomial and Poisson data, where <em>k</em> is the number of groups (or units) in a dataset.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.or.n</code></td>
<td>

<p>a (<em>k</em> by 1) vector composed of the standard errors of all groups for Gaussian or 
of each group's total number of trials for Binomial and Poisson data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariates</code></td>
<td>

<p>(optional) a matrix of covariate(s) each column of which corresponds to one covariate.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.PriorDist</code></td>
<td>

<p>(optional) a numeric value for the second-level mean parameter, <em>i.e.</em> the mean of prior
distribution, if you know this value a priori.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>a character string indicating which hierarchical model to fit. "gaussian" for Gaussian data, 
"poisson" for Poisson, and "binomial" for Binomial. Default is "gaussian"
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code> flag indicating whether an intercept should be
included in the regression. Default is <code>TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confidence.lvl</code></td>
<td>

<p>a <code>float</code> between 0 and 1 to estimate 100*confidence.lvl% intervals. Default is 0.95.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.AR</code></td>
<td>

<p>Only for Binomial model. If <code>n.AR = 1000</code>, all the results will be based on 1000 posterior samples using the acceptance-rejection sampling. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.AR.factor</code></td>
<td>

<p>Only for Binomial model. If <code>n.AR = 1000</code> and <code>n.AR.factor = 4</code>, then the acceptance-rejection method will sample 4 * 1000 trial samples, and accept or reject them until the method gets n.AR posterior samples. Default is 4.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trial.scale</code></td>
<td>

<p>A scale used in the trial distribution of <code class="reqn">\alpha</code>. If resultant weight has too mamy 0's, scale should be smaller than before. If resultant weight has too few 0's, scale should be larger than before. If there are relatively huge weights, scale should be larger than before. Default is 1.3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>save.result</code></td>
<td>

<p>Only for Binomial model with the acceptance-rejection sampling. <br> If <code>save.result</code> is TRUE, all the results of weights and posterior samples will be saved in the gbp object. Default is TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normal.CI</code></td>
<td>

<p>Only applicable for Gaussian data. If <code>TRUE</code> then a Normal
approximation is used to construct intervals for the level 1 group
means. If <code>FALSE</code> (default) then a Skew-Normal distribution is
used. Setting the value to <code>TRUE</code> may result in speed
improvements but may lead to intervals that under cover. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>

<p>Non-negative constant to determine the hyper-prior distribution of r for the Binomial model with the acceptance-rejection method. If t is positive, then the hyper-prior distribution of r is proper, otherwise improper. <code class="reqn">dr/(t + r)^{u+1}</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>u</code></td>
<td>

<p>A positive constant to determine the hyper-prior distribution of r for the Binomial model with the acceptance-rejection method. <code class="reqn">dr/(t + r)^{u+1}</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>gbp</code> fits a hierarchical model whose first-level hierarchy is a distribution of observed data and second-level is a conjugate prior distribution on the first-level parameter. To be specific, for Normal data, <code>gbp</code> constructs a two-level Normal-Normal multilevel model. <code class="reqn">V_{j}</code> (=<code class="reqn">\sigma^{2}/n_{j}</code>) is assumed to be known or to be accurately estimated, and subscript <em>j</em> indicates <em>j</em>-th group 
(or unit) in a dataset.
</p>
<p style="text-align: center;"><code class="reqn">(y_{j} | \theta_{j}) \stackrel{ind}{\sim} N(\theta_{j}, \sigma^{2}_{j})</code>
</p>

<p style="text-align: center;"><code class="reqn">(\theta_{j} |\mu_{0j} , A) \stackrel{ind}{\sim} N(\mu_{0j}, A)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_{0j} = x_{j}'\beta</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, k</code>, where <em>k</em> is the number of groups (units) in a dataset.
</p>
<p>For Poisson data, <code>gbp</code> builds a two-level Poisson-Gamma multilevel model. A square bracket below indicates [mean, variance] of distribution, a constant multiplied to the notation representing Gamma distribution (Gam) is a scale, and <code class="reqn">y_{j}=\frac{z_{j}}{n_{j}}</code>.
</p>
<p style="text-align: center;"><code class="reqn">(z_{j} | \theta_{j}) \stackrel{ind}{\sim} Pois(n_{j}\theta_{j})</code>
</p>

<p style="text-align: center;"><code class="reqn">(\theta_{j} | r, \mu_{0j}) \stackrel{ind}{\sim} \frac{1}{r}Gam(r\mu_{0j})\stackrel{ind}{\sim}Gam[\mu_{0j}, \mu_{0j} / r] </code>
</p>

<p style="text-align: center;"><code class="reqn">log(\mu_{0j}) = x_{j}'\beta</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, k</code>, where <em>k</em> is the number of groups (units) in a dataset.
</p>
<p>For Binomial data, <code>gbp</code> sets a two-level Binomial-Beta multilevel model. A square bracket below indicates [mean, variance] of distribution and <code class="reqn">y_{j} = \frac{z_{j}}{n_{j}}</code>.
</p>
<p style="text-align: center;"><code class="reqn">(z_{j} | \theta_{j}) \stackrel{ind}{\sim} Bin(n_{j}, \theta_{j})</code>
</p>

<p style="text-align: center;"><code class="reqn">(\theta_{j} | r, \mu_{0j}) \stackrel{ind}{\sim} Beta(r\mu_{0j}, r(1-\mu_{0j})) \stackrel{ind}{\sim} Beta[\mu_{0j}, \mu_{0j}(1 - \mu_{0j}) / (r + 1)]</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(\mu_{0j}) = x_{j}'\beta</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, k</code>, where <em>k</em> is the number of groups (units) in a dataset.
</p>
<p>For reference, based on the above notations, the Uniform prior distribution on the second level variance component (variance of the prior distribution) is <em>dA</em> for Gaussian and <code class="reqn">d(\frac{1}{r})</code> 
(= <code class="reqn">\frac{dr}{r^{2}}</code>) for Binomial and Poisson data. The second level variance component can be interpreted as variation among the first-level parameters (<code class="reqn">\theta_{j}</code>) or variance of ensemble information.
</p>
<p>Under this setting, the argument <code>y</code> in <code>gbp</code> is a (<em>k</em> by 1) vector of <em>k</em> groups' sample means (<code class="reqn">y_{j}'s</code> in the description of Normal-Normal model above) for Gaussian or of each group's number of successful trials (<code class="reqn">z_{j}'s</code>) for Binomial and Poisson data, where <em>k</em> is the number of groups (or units) in a dataset.
</p>
<p>The argument <code>se.or.n</code> is a (<em>k</em> by 1) vector composed of the standard errors (<code class="reqn">V_{j}'s</code>) of all groups for Gaussian or of each group's total number of trials (<code class="reqn">n_{j}'s</code>) for Binomial and Poisson data.
</p>
<p>As for two optional arguments, <code>covariates</code> and <code>mean.PriorDist</code>, there are three feasible 
combinations of them to run <code>gbp</code>. The first situation is when we do not have any covariate and do not 
know a mean of the prior distribution (<code class="reqn">\mu_{0}</code>) a priori. In this case, assigning none of two
optional arguments, such as "<code>gbp(z, n, model = "binomial")</code>", will lead to a correct model. <code>gbp</code> 
will automatically fit a regression with only an intercept term to estimate a common mean of the prior
distribution (exchangeability).
</p>
<p>The second situation is when we have covariate(s) and do not know a mean of the prior distribution (<code class="reqn">\mu_{0}</code>) a priori. In this case, assigning a matrix, <em>X</em>, each column of which corresponds to one covariate, such as "<code>gbp(z, n, X, model = "poisson")</code>", will lead to a correct model. Default of <code>gbp</code> is to fit a regression including an intercept term to estimate a mean of the prior distribution. Double exchangeability will hold in this case.
</p>
<p>The last case is when we know a mean of the prior distribution (<code class="reqn">\mu_{0}</code>) a priori. Now, we do
not need to estimate regression coefficients at all because we know a true value of <code class="reqn">\mu_{0}</code> (strong assumption).
Designating this value into the argument of <code>gbp</code> like 
"<code>gbp(y, se, mean.PriorDist = 3)</code>" is enough to account for it. For reference, 
<code>mean.PriorDist</code> has a stronger priority than <code>covariates</code>, which means that when both
arguments are designated, <code>gbp</code> will fit a hierarchical model using the known mean of prior distribution, <code>mean.PriorDist</code>.
</p>
<p><code>gbp</code> returns an object of class "<code>gbp</code>" which provides three relevant functions <code>plot</code>, <code>print</code>, and <code>summary</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>gbp</code> comprises of:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sample.mean</code></td>
<td>
<p>sample mean of each group (or unit)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>if Gaussian data, standard error of sample mean in each group (or unit)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>if Binomial and Poisson data, total number of trials of each group (or unit)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mean</code></td>
<td>
<p>numeric if entered, NA if not entered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior.mean.hat</code></td>
<td>
<p>estimate of prior mean by a regression if prior mean is not assigned a priori</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shrinkage</code></td>
<td>
<p>shrinkage estimate of each group (adjusted posterior mean)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd.shrinkage</code></td>
<td>
<p>posterior standard deviation of shrinkage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post.mean</code></td>
<td>
<p>posterior mean of each group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post.sd</code></td>
<td>
<p>posterior standard deviation of each group</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post.intv.low</code></td>
<td>
<p>lower bound of 100*confidence.lvl% posterior interval (quantile of posterior distribution)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>post.intv.upp</code></td>
<td>
<p>upper bound of 100*confidence.lvl% posterior interval (quantile of posterior distribution)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>"gaussian" for Gaussian, "poisson" for Poisson, and "binomial" for Binomial data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a covariate vector or matrix if designated. NA if not</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.new</code></td>
<td>
<p>regression coefficient estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.var</code></td>
<td>
<p>estimated variance matrix of regression coefficient</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>whether TRUE or FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.new</code></td>
<td>
<p>a posterior mode of <code class="reqn">\alpha</code> defined as log(<em>A</em>) for Gaussian or log(<code class="reqn">\frac{1}{r}</code>) for Binomial and Poisson data. Practical meaning (variation of ensemble information) of estimating <code class="reqn">\alpha</code> will appear in <code>summary(gbp.object)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a.var</code></td>
<td>
<p>posterior variance of <code class="reqn">\alpha</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confidence.lvl</code></td>
<td>
<p>confidence level based on which confidence interval is constructed </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>
<p>(only for Binomial model) weights for acceptance-rejection method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(only for Binomial model) posterior samples of p based on the acceptance-rejection method, if this method was used. This is a (k by nsim) matrix. Each row contains posteiror samples of each random effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>(only for Binomial model) posterior samples of alpha based on the acceptance-rejection method, if this method was used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>(only for Binomial model) posterior samples of beta based on the acceptance-rejection method, if this method was used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>accept.rate</code></td>
<td>
<p>(only for Binomial model) the acceptance rate of the acceptance-rejection method, if this method was used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.AR</code></td>
<td>
<p>(Only for Binomial model) If <code>n.AR = 1000</code>, all the results will be based on 1000 posterior samples using the acceptance-rejection sampling. Default is 0.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.AR.factor</code></td>
<td>
<p>(only for Binomial model) If <code>n.AR = 1000</code> and <code>n.AR.factor = 4</code>, then the acceptance-rejection method will sample 4 * 1000 trial posteior samples, and accept or reject them. Default is 4.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Hyungsuk Tak, Joseph Kelly, and Carl Morris
</p>


<h3>References</h3>

<p>Tak, H., Kelly, J., and Morris, C. (2017) Rgbp: An R Package for Gaussian, Poisson, and Binomial Random Effects Models with Frequency Coverage Evaluations. <em>Journal of Statistical Software</em>. <b>78</b>, 5, 1–33.
</p>
<p>Morris, C. and Lysy, M. (2012). Shrinkage Estimation in Multilevel Normal Models. 
<em>Statistical Science</em>. <b>27</b>, 1, 115–134.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  # Loading datasets
  data(schools)
  y &lt;- schools$y
  se &lt;- schools$se

  # Arbitrary covariate for schools data
  x2 &lt;- rep(c(-1, 0, 1, 2), 2)
  
  # baseball data where z is Hits and n is AtBats
  z &lt;- c(18, 17, 16, 15, 14, 14, 13, 12, 11, 11, 10, 10, 10, 10, 10,  9,  8,  7)
  n &lt;- c(45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45)

  # One covariate: 1 if a player is an outfielder and 0 otherwise
  x1 &lt;- c(1,  1,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  0,  1,  1,  0,  0,  0)

  ################################################################
  # Gaussian Regression Interactive Multilevel Modeling (GRIMM) #
  ################################################################

    ###################################################################################
    # If we do not have any covariate and do not know a mean of the prior distribution#
    ###################################################################################

    g &lt;- gbp(y, se, model = "gaussian")
    g
    print(g, sort = FALSE)
    summary(g)
    plot(g)
    plot(g, sort = FALSE)

    ### when we want to simulate pseudo datasets considering the estimated values 
    ### as true ones.
    gcv &lt;- coverage(g, nsim = 10)  

    ### gcv$coverageRB, gcv$coverage10, gcv$average.coverageRB, gcv$average.coverage10,
    ### gcv$minimum.coverageRB, gcv$minimum.coverage10, gcv$raw.resultRB, 
    ### gcv$raw.result10.

    ### when we want to simulate pseudo datasets based on different values of A
    ### and a regression coefficient (intercept), 
    ### not using estimated values as true ones.
    gcv &lt;- coverage(g, A.or.r = 9, reg.coef = 10, nsim = 10)  

    ##################################################################################
    # If we have one covariate and do not know a mean of the prior distribution yet, #
    ##################################################################################

    g &lt;- gbp(y, se, x2, model = "gaussian")
    g
    print(g, sort = FALSE)
    summary(g)
    plot(g)
    plot(g, sort = FALSE)

    ### when we want to simulate pseudo datasets considering the estimated values 
    ### as true ones.
    gcv &lt;- coverage(g, nsim = 10)  
 
    ### gcv$coverageRB, gcv$coverage10, gcv$average.coverageRB, gcv$average.coverage10,
    ### gcv$minimum.coverageRB, gcv$minimum.coverage10, gcv$raw.resultRB, 
    ### gcv$raw.result10.

    ### when we want to simulate pseudo datasets based on different values of A
    ### and regression coefficients, not using estimated values 
    ### as true ones. Two values of reg.coef are for beta0 and beta1
    gcv &lt;- coverage(g, A.or.r = 9, reg.coef = c(10, 1), nsim = 10)  

    ################################################
    # If we know a mean of the prior distribution, #
    ################################################

    g &lt;- gbp(y, se, mean.PriorDist = 8, model = "gaussian")
    g
    print(g, sort = FALSE)
    summary(g)
    plot(g)
    plot(g, sort = FALSE)

    ### when we want to simulate pseudo datasets considering the estimated values 
    ### as true ones.
    gcv &lt;- coverage(g, nsim = 10)  

    ### gcv$coverageRB, gcv$coverage10, gcv$average.coverageRB, gcv$average.coverage10,
    ### gcv$minimum.coverageRB, gcv$minimum.coverage10, gcv$raw.resultRB, 
    ### gcv$raw.result10.

    ### when we want to simulate pseudo datasets based on different values of A and
    ### 2nd level mean as true ones, not using estimated values as true ones.
    coverage(g, A.or.r = 9, mean.PriorDist = 5, nsim = 10)  

  ###############################################################
  # Binomial Regression Interactive Multilevel Modeling (BRIMM) #
  ###############################################################

    ###################################################################################
    # If we do not have any covariate and do not know a mean of the prior distribution#
    ###################################################################################

    b &lt;- gbp(z, n, model = "binomial")
    b
    print(b, sort = FALSE)
    summary(b)
    plot(b)
    plot(b, sort = FALSE)

    ### when we want to simulate pseudo datasets considering the estimated values 
    ### as true ones.
    bcv &lt;- coverage(b, nsim = 10)  

    ### bcv$coverageRB, bcv$coverage10, bcv$average.coverageRB, bcv$average.coverage10,
    ### bcv$minimum.coverageRB, bcv$minimum.coverage10, bcv$raw.resultRB, 
    ### bcv$raw.result10.

    ### when we want to simulate pseudo datasets based on different values of r
    ### and a regression coefficient (intercept), 
    ### not using estimated values as true ones.
    bcv &lt;- coverage(b, A.or.r = 60, reg.coef = -1, nsim = 10)  

    ##################################################################################
    # If we have one covariate and do not know a mean of the prior distribution yet, #
    ##################################################################################

    b &lt;- gbp(z, n, x1, model = "binomial")
    b
    print(b, sort = FALSE)
    summary(b)
    plot(b)
    plot(b, sort = FALSE)

    ### when we want to simulate pseudo datasets considering the estimated values 
    ### as true ones.
    bcv &lt;- coverage(b, nsim = 10)  

    ### bcv$coverageRB, bcv$coverage10, bcv$average.coverageRB, bcv$average.coverage10,
    ### bcv$minimum.coverageRB, bcv$minimum.coverage10, bcv$raw.resultRB, 
    ### bcv$raw.result10.

    ### when we want to simulate pseudo datasets based on different values of r
    ### and regression coefficients, not using estimated values 
    ### as true ones. Two values of reg.coef are for beta0 and beta1
    bcv &lt;- coverage(b, A.or.r = 60, reg.coef = c(-1, 0), nsim = 10)  

    ################################################
    # If we know a mean of the prior distribution, #
    ################################################

    b &lt;- gbp(z, n, mean.PriorDist = 0.265, model = "binomial")
    b
    print(b, sort = FALSE)
    summary(b)
    plot(b)
    plot(b, sort = FALSE)

    ### when we want to simulate pseudo datasets considering the estimated values 
    ### as true ones.
    bcv &lt;- coverage(b, nsim = 10)  

    ### bcv$coverageRB, bcv$coverage10, bcv$average.coverageRB, bcv$average.coverage10,
    ### bcv$minimum.coverageRB, bcv$minimum.coverage10, bcv$raw.resultRB, 
    ### bcv$raw.result10.

    ### when we want to simulate pseudo datasets based on different values of r and
    ### 2nd level mean as true ones, not using estimated values as true ones.
    bcv &lt;- coverage(b, A.or.r = 60, mean.PriorDist = 0.3, nsim = 10)  

  ##############################################################
  # Poisson Regression Interactive Multilevel Modeling (PRIMM) #
  ##############################################################

    ################################################
    # If we know a mean of the prior distribution, #
    ################################################

    p &lt;- gbp(z, n, mean.PriorDist = 0.265, model = "poisson")
    p
    print(p, sort = FALSE)
    summary(p)
    plot(p)
    plot(p, sort = FALSE)

    ### when we want to simulate pseudo datasets considering the estimated values 
    ### as true ones.
    pcv &lt;- coverage(p, nsim = 10)  

    ### pcv$coverageRB, pcv$coverage10, pcv$average.coverageRB, pcv$average.coverage10,
    ### pcv$minimum.coverageRB, pcv$minimum.coverage10, pcv$raw.resultRB, 
    ### pcv$raw.result10.

    ### when we want to simulate pseudo datasets based on different values of r and
    ### 2nd level mean as true ones, not using estimated values as true ones.
    pcv &lt;- coverage(p, A.or.r = 60, mean.PriorDist = 0.3, nsim = 10)  

</code></pre>


</div>