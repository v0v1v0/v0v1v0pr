<div class="container">

<table style="width: 100%;"><tr>
<td>cosines-signs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cosines and multivariate signs of a hyperspherical sample about a
given location</h2>

<h3>Description</h3>

<p>Computation of the cosines and multivariate signs of the
hyperspherical sample <code class="reqn">\mathbf{X}_1,\ldots,\mathbf{X}_n\in S^{p-1}</code> about a location
<code class="reqn">\boldsymbol{\theta}\in S^{p-1}</code>,
for <code class="reqn">S^{p-1}:=\{\mathbf{x}\in R^p:||\mathbf{x}||=1\}</code> with <code class="reqn">p\ge 2</code>.
The <em>cosines</em> are defined as
</p>
<p style="text-align: center;"><code class="reqn">V_i:=\mathbf{X}_i'\boldsymbol{\theta},\quad i=1,\ldots,n,</code>
</p>

<p>whereas the <em>multivariate signs</em> are the vectors
<code class="reqn">\mathbf{U}_1,\ldots,\mathbf{U}_n\in S^{p-2}</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{U}_i := \boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}_i/
||\boldsymbol{\Gamma}_{\boldsymbol{\theta}}\mathbf{X}_i||,\quad
i=1,\ldots,n.</code>
</p>

<p>The projection matrix
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is a
<code class="reqn">p\times (p-1)</code> semi-orthogonal matrix that satisfies
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}'
\boldsymbol{\Gamma}_{\boldsymbol{\theta}}=\mathbf{I}_{p-1}
\quad\mathrm{and}\quad\boldsymbol{\Gamma}_{\boldsymbol{\theta}}
\boldsymbol{\Gamma}_{\boldsymbol{\theta}}'=
\mathbf{I}_p-\boldsymbol{\theta}\boldsymbol{\theta}'.</code>
</p>

<p>where <code class="reqn">\mathbf{I}_p</code> is the identity matrix of dimension <code class="reqn">p</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">signs(X, theta, Gamma = NULL, check_X = FALSE)

cosines(X, theta, check_X = FALSE)

Gamma_theta(theta, eig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>hyperspherical data, a matrix of size <code>c(n, p)</code> with
unit-norm rows. <code>NA</code>s are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>a unit-norm vector of length <code>p</code>. Normalized internally
if it does not have unit norm (with a <code>warning</code> message).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gamma</code></td>
<td>
<p>output from <code>Gamma_theta(theta = theta)</code>. If <code>NULL</code>
(default), it is computed internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_X</code></td>
<td>
<p>whether to check the unit norms on the rows of <code>X</code>.
Defaults to <code>FALSE</code> for performance reasons.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eig</code></td>
<td>
<p>whether <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is to be found using an eigendecomposition of
<code class="reqn">\mathbf{I}_p-\boldsymbol{\theta}\boldsymbol{\theta}'</code> (inefficient). Defaults to <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that the projection matrix
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> is <em>not</em>
unique. In particular, any completion of <code class="reqn">\boldsymbol{\theta}</code>
to an orthonormal basis
<code class="reqn">\{\boldsymbol{\theta},\mathbf{v}_1,\ldots,\mathbf{v}_{p-1}\}</code> gives a set of <code class="reqn">p-1</code> orthonormal
<code class="reqn">p</code>-vectors <code class="reqn">\{\mathbf{v}_1,\ldots,\mathbf{v}_{p-1}\}</code> that conform the columns of
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code>. If
<code>eig = FALSE</code>, this approach is employed by rotating the canonical
completion of <code class="reqn">\mathbf{e}_1=(1,0,\ldots,0)</code>,
<code class="reqn">\{\mathbf{e}_2,\ldots,\mathbf{e}_p\}</code>, by the rotation matrix that rotates
<code class="reqn">\mathbf{e}_1</code> to <code class="reqn">\boldsymbol{\theta}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{H}_{\boldsymbol{\theta}}=
(\boldsymbol{\theta}+\mathbf{e}_1)(\boldsymbol{\theta}+\mathbf{e}_1)'/
(1+\theta_1)-\mathbf{I}_p.</code>
</p>
<p> If <code>eig = TRUE</code>, then a much more expensive
eigendecomposition of <code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}
\boldsymbol{\Gamma}_{\boldsymbol{\theta}}'=
\mathbf{I}_p-\boldsymbol{\theta}\boldsymbol{\theta}'</code> is performed for
determining <code class="reqn">\{\mathbf{v}_1,\ldots,\mathbf{v}_{p-1}\}</code>.
</p>
<p>If <code>signs</code> and <code>cosines</code> are called with <code>X</code> without unit
norms in the rows, then the results will be spurious. Setting
<code>check_X = TRUE</code> prevents this from happening.
</p>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>cosines</code>: a vector of length <code>n</code> with the cosines of
<code>X</code>.
</p>
</li>
<li> <p><code>signs</code>: a matrix of size <code>c(n, p - 1)</code> with the
multivariate signs of <code>X</code>.
</p>
</li>
<li> <p><code>Gamma_theta</code>: a projection matrix
<code class="reqn">\boldsymbol{\Gamma}_{\boldsymbol{\theta}}</code> of size
<code>c(p, p - 1)</code>.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Eduardo García-Portugués, Davy Paindaveine, and Thomas Verdebout.
</p>


<h3>References</h3>

<p>García-Portugués, E., Paindaveine, D., Verdebout, T. (2020) On optimal tests
for rotational symmetry against new classes of hyperspherical distributions.
<em>Journal of the American Statistical Association</em>, 115(532):1873–1887.
<a href="https://doi.org/10.1080/01621459.2019.1665527">doi:10.1080/01621459.2019.1665527</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Gamma_theta
theta &lt;- c(0, 1)
Gamma_theta(theta = theta)

# Signs and cosines for p = 2
L &lt;- rbind(c(1, 0.5),
           c(0.5, 1))
X &lt;- r_ACG(n = 1e3, Lambda = L)
par(mfrow = c(1, 2))
plot(signs(X = X, theta = theta), main = "Signs", xlab = expression(x[1]),
     ylab = expression(x[2]))
hist(cosines(X = X, theta = theta), prob = TRUE, main = "Cosines",
     xlab = expression(x * "'" * theta))

# Signs and cosines for p = 3
L &lt;- rbind(c(2, 0.25, 0.25),
           c(0.25, 0.5, 0.25),
           c(0.25, 0.25, 0.5))
X &lt;- r_ACG(n = 1e3, Lambda = L)
par(mfrow = c(1, 2))
theta &lt;- c(0, 1, 0)
plot(signs(X = X, theta = theta), main = "Signs", xlab = expression(x[1]),
     ylab = expression(x[2]))
hist(cosines(X = X, theta = theta), prob = TRUE, main = "Cosines",
     xlab = expression(x * "'" * theta))
</code></pre>


</div>