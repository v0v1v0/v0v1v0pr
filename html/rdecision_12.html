<div class="container">

<table style="width: 100%;"><tr>
<td>Digraph</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A directed graph</h2>

<h3>Description</h3>

<p>An R6 class representing a digraph (a directed graph).
</p>


<h3>Details</h3>

<p>Encapsulates and provides methods for computation and checking of
directed graphs (digraphs). Inherits from class <code>Graph</code>.
</p>


<h3>Super class</h3>

<p><code>rdecision::Graph</code> -&gt; <code>Digraph</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Digraph-new"><code>Digraph$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-digraph_adjacency_matrix"><code>Digraph$digraph_adjacency_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-digraph_incidence_matrix"><code>Digraph$digraph_incidence_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-topological_sort"><code>Digraph$topological_sort()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_connected"><code>Digraph$is_connected()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_weakly_connected"><code>Digraph$is_weakly_connected()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_acyclic"><code>Digraph$is_acyclic()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_tree"><code>Digraph$is_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_polytree"><code>Digraph$is_polytree()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-is_arborescence"><code>Digraph$is_arborescence()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-direct_successors"><code>Digraph$direct_successors()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-direct_predecessors"><code>Digraph$direct_predecessors()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-arrow_source"><code>Digraph$arrow_source()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-arrow_target"><code>Digraph$arrow_target()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-paths"><code>Digraph$paths()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-walk"><code>Digraph$walk()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-as_DOT"><code>Digraph$as_DOT()</code></a>
</p>
</li>
<li> <p><a href="#method-Digraph-clone"><code>Digraph$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="degree"><a href="../../rdecision/html/Graph.html#method-Graph-degree"><code>rdecision::Graph$degree()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_along"><a href="../../rdecision/html/Graph.html#method-Graph-edge_along"><code>rdecision::Graph$edge_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_at"><a href="../../rdecision/html/Graph.html#method-Graph-edge_at"><code>rdecision::Graph$edge_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_index"><a href="../../rdecision/html/Graph.html#method-Graph-edge_index"><code>rdecision::Graph$edge_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edge_label"><a href="../../rdecision/html/Graph.html#method-Graph-edge_label"><code>rdecision::Graph$edge_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="edges"><a href="../../rdecision/html/Graph.html#method-Graph-edges"><code>rdecision::Graph$edges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="graph_adjacency_matrix"><a href="../../rdecision/html/Graph.html#method-Graph-graph_adjacency_matrix"><code>rdecision::Graph$graph_adjacency_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_edge"><a href="../../rdecision/html/Graph.html#method-Graph-has_edge"><code>rdecision::Graph$has_edge()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="has_vertex"><a href="../../rdecision/html/Graph.html#method-Graph-has_vertex"><code>rdecision::Graph$has_vertex()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="is_simple"><a href="../../rdecision/html/Graph.html#method-Graph-is_simple"><code>rdecision::Graph$is_simple()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="neighbours"><a href="../../rdecision/html/Graph.html#method-Graph-neighbours"><code>rdecision::Graph$neighbours()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="order"><a href="../../rdecision/html/Graph.html#method-Graph-order"><code>rdecision::Graph$order()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="size"><a href="../../rdecision/html/Graph.html#method-Graph-size"><code>rdecision::Graph$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_along"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_along"><code>rdecision::Graph$vertex_along()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_at"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_at"><code>rdecision::Graph$vertex_at()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_index"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_index"><code>rdecision::Graph$vertex_index()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertex_label"><a href="../../rdecision/html/Graph.html#method-Graph-vertex_label"><code>rdecision::Graph$vertex_label()</code></a></span></li>
<li><span class="pkg-link" data-pkg="rdecision" data-topic="Graph" data-id="vertexes"><a href="../../rdecision/html/Graph.html#method-Graph-vertexes"><code>rdecision::Graph$vertexes()</code></a></span></li>
</ul></details><hr>
<a id="method-Digraph-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>Digraph</code> object from sets of nodes and
edges.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$new(V, A)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>V</code></dt>
<dd>
<p>A list of Nodes.</p>
</dd>
<dt><code>A</code></dt>
<dd>
<p>A list of Arrows.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A Digraph object.
</p>


<hr>
<a id="method-Digraph-digraph_adjacency_matrix"></a>



<h4>Method <code>digraph_adjacency_matrix()</code>
</h4>

<p>Compute the adjacency matrix for the digraph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$digraph_adjacency_matrix(boolean = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>boolean</code></dt>
<dd>
<p>If <code>TRUE</code>, the adjacency matrix is logical, each
cell is <code>{FALSE,TRUE}</code>.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Each cell contains the number of edges from the row vertex to
the column vertex, with the convention of self loops being counted once,
unless <code>boolean</code> is <code>TRUE</code> when cells are either <code>FALSE</code>
(not adjacent) or <code>TRUE</code> (adjacent).
</p>



<h5>Returns</h5>

<p>A square integer matrix with the number of rows and columns
equal to the order of the graph. The rows and columns are in the
same order as <code>V</code>. If the nodes have defined and unique labels the
dimnames of the matrix are the labels of the nodes.
</p>


<hr>
<a id="method-Digraph-digraph_incidence_matrix"></a>



<h4>Method <code>digraph_incidence_matrix()</code>
</h4>

<p>Compute the incidence matrix for the digraph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$digraph_incidence_matrix()</pre></div>



<h5>Details</h5>

<p>Each row is a vertex and each column is an edge. Edges leaving
a vertex have value -1 and edges entering have value +1. By convention
self loops have value 0 (1-1). If all vertexes have defined and unique
labels and all edges have defined and unique labels, the dimnames of the
matrix are the labels of the vertexes and edges.
</p>



<h5>Returns</h5>

<p>The incidence matrix of integers.
</p>


<hr>
<a id="method-Digraph-topological_sort"></a>



<h4>Method <code>topological_sort()</code>
</h4>

<p>Topologically sort the vertexes in the digraph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$topological_sort()</pre></div>



<h5>Details</h5>

<p>Uses Kahn's algorithm (Kahn, 1962).
</p>



<h5>Returns</h5>

<p>A list of vertexes, topologically sorted. If the digraph has
cycles, the returned ordered list will not contain all the vertexes
in the graph, but no error will be raised.
</p>


<hr>
<a id="method-Digraph-is_connected"></a>



<h4>Method <code>is_connected()</code>
</h4>

<p>Test whether the graph is connected.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_connected()</pre></div>



<h5>Details</h5>

<p>For digraphs this will always return <code>FALSE</code> because
<dfn>connected</dfn> is not defined. Function <code>weakly_connected</code>
calculates whether the underlying graph is connected.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if connected, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Digraph-is_weakly_connected"></a>



<h4>Method <code>is_weakly_connected()</code>
</h4>

<p>Test whether the digraph is weakly connected, i.e. if the
underlying graph is connected.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_weakly_connected()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if connected, <code>FALSE</code> if not.
</p>


<hr>
<a id="method-Digraph-is_acyclic"></a>



<h4>Method <code>is_acyclic()</code>
</h4>

<p>Checks for the presence of a cycle in the graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_acyclic()</pre></div>



<h5>Details</h5>

<p>Attempts to do a topological sort. If the sort does not contain
all vertexes, the digraph contains at least one cycle. This method
overrides <code>is_acyclic</code> in <code>Graph</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if no cycles detected.
</p>


<hr>
<a id="method-Digraph-is_tree"></a>



<h4>Method <code>is_tree()</code>
</h4>

<p>Is the digraph's underlying graph a tree?
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_tree()</pre></div>



<h5>Details</h5>

<p>It is a tree if it is connected and acyclic.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the underlying graph is a tree; <code>FALSE</code>
if not.
</p>


<hr>
<a id="method-Digraph-is_polytree"></a>



<h4>Method <code>is_polytree()</code>
</h4>

<p>Is the digraph's underlying graph a polytree?
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_polytree()</pre></div>



<h5>Details</h5>

<p>It is a polytree if it is directed, connected and acyclic.
Because the object is a digraph (directed), this is synonymous with
<code>tree</code>.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the underlying graph is a tree; <code>FALSE</code>
if not.
</p>


<hr>
<a id="method-Digraph-is_arborescence"></a>



<h4>Method <code>is_arborescence()</code>
</h4>

<p>Is the digraph an arborescence?
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$is_arborescence()</pre></div>



<h5>Details</h5>

<p>An <dfn>arborescence</dfn> is a tree with a single root and unique
paths from the root.
</p>



<h5>Returns</h5>

<p><code>TRUE</code> if the digraph is an arborescence; <code>FALSE</code>
if not.
</p>


<hr>
<a id="method-Digraph-direct_successors"></a>



<h4>Method <code>direct_successors()</code>
</h4>

<p>Find the direct successors of a node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$direct_successors(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>The index vertex (a scalar; does not accept a vector of nodes).</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of Nodes or an empty list if the specified
node has no successors.
</p>


<hr>
<a id="method-Digraph-direct_predecessors"></a>



<h4>Method <code>direct_predecessors()</code>
</h4>

<p>Find the direct predecessors of a node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$direct_predecessors(v)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>v</code></dt>
<dd>
<p>The index vertex (a scalar; does not accept an index of nodes).</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of Nodes or an empty list if the specified
node has no predecessors.
</p>


<hr>
<a id="method-Digraph-arrow_source"></a>



<h4>Method <code>arrow_source()</code>
</h4>

<p>Find the node that is the source of the given arrow.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$arrow_source(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt>
<dd>
<p>An arrow (directed edge), which must be in the digraph.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The source node is a property of the arrow, not the digraph of
which it is part, hence the canonical method for establishing the source
node of an arrow is via method <code>$source</code> of an <code>Arrow</code> object.
This function is provided for convenience when iterating the arrows of a
digraph. It raises an error if the arrow is not in the graph. It
returns the index of the source node, which is a property of the graph;
the node object itself may be retrieved using the <code>$vertex_at</code>
method of the graph.
</p>



<h5>Returns</h5>

<p>Index of the source node of the specified edge.
</p>


<hr>
<a id="method-Digraph-arrow_target"></a>



<h4>Method <code>arrow_target()</code>
</h4>

<p>Find the node that is the target of the given arrow.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$arrow_target(a)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt>
<dd>
<p>An arrow (directed edge), which must be in the digraph.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The target node is a property of the arrow, not the digraph of
which it is part, hence the canonical method for establishing the target
node of an arrow is via method <code>$target</code> of an <code>$Arrow</code> object.
This function is provided for convenience when iterating the arrows of a
digraph. It raises an error if the arrow is not in the graph. It
returns the index of the target node, which is a property of the graph;
the node itself may be retrieved using the <code>$vertex_at</code> method
of the graph.
</p>



<h5>Returns</h5>

<p>Index of the target node of the specified edge.
</p>


<hr>
<a id="method-Digraph-paths"></a>



<h4>Method <code>paths()</code>
</h4>

<p>Find all directed simple paths from source to target.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$paths(s, t)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s</code></dt>
<dd>
<p>Source node.</p>
</dd>
<dt><code>t</code></dt>
<dd>
<p>Target node.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>In simple paths all vertexes are unique. Uses a recursive
depth-first search algorithm.
</p>



<h5>Returns</h5>

<p>A list of ordered node lists.
</p>


<hr>
<a id="method-Digraph-walk"></a>



<h4>Method <code>walk()</code>
</h4>

<p>Sequence of edges which join the specified path.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$walk(P, what = "edge")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>P</code></dt>
<dd>
<p>A list of Nodes</p>
</dd>
<dt><code>what</code></dt>
<dd>
<p>One of "edge" or "index".</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A list of Edges for <code>what = "edge"</code> or a list of Edge
indices for <code>what = "index"</code>.
</p>


<hr>
<a id="method-Digraph-as_DOT"></a>



<h4>Method <code>as_DOT()</code>
</h4>

<p>Exports the digraph in DOT notation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$as_DOT(rankdir = "LR", width = 7, height = 7)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rankdir</code></dt>
<dd>
<p>One of "LR" (default), "TB", "RL" or "BT".</p>
</dd>
<dt><code>width</code></dt>
<dd>
<p>of the drawing, in inches</p>
</dd>
<dt><code>height</code></dt>
<dd>
<p>of the drawing, in inches</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Writes a representation of the digraph in the
<code>graphviz</code> DOT language
(<a href="https://graphviz.org/doc/info/lang.html">https://graphviz.org/doc/info/lang.html</a>) for drawing with one
of the <code>graphviz</code> tools, including <code>dot</code> (Gansner, 1993). If
all nodes have labels, these are used in the graph, otherwise the labels
are the node indices.
</p>



<h5>Returns</h5>

<p>A character vector. Intended for passing to <code>writeLines</code>
for saving as a text file.
</p>


<hr>
<a id="method-Digraph-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Digraph$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Author(s)</h3>

<p>Andrew Sims <a href="mailto:andrew.sims@newcastle.ac.uk">andrew.sims@newcastle.ac.uk</a>
</p>


<h3>References</h3>


<p>Gansner ER, Koutsofios E, North SC, Vo K-P. A technique for drawing
directed graphs. <em>IEEE Transactions on Software Engineering</em>,
1993;<b>19</b>:214â€“30, <a href="https://doi.org/10.1109/32.221135">doi:10.1109/32.221135</a>.
</p>
<p>Gross JL, Yellen J, Zhang P. Handbook of Graph Theory. Second edition,
Chapman and Hall/CRC.; 2013, <a href="https://doi.org/10.1201/b16132">doi:10.1201/b16132</a>.
</p>
<p>Kahn AB, Topological Sorting of Large Networks,
<em>Communications of the <abbr><span class="acronym">ACM</span></abbr></em>,
1962;<strong>5</strong>:558-562, <a href="https://doi.org/10.1145/368996.369025">doi:10.1145/368996.369025</a>.

</p>


</div>