<div class="container">

<table style="width: 100%;"><tr>
<td>matern.operators</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Rational approximations of stationary Gaussian Matern random fields</h2>

<h3>Description</h3>

<p><code>matern.operators</code> is used for computing a rational SPDE approximation
of a stationary Gaussian random fields on <code class="reqn">R^d</code> with a Matern covariance
function
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}
(\kappa h)^\nu K_\nu(\kappa h)</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">matern.operators(
  kappa = NULL,
  tau = NULL,
  alpha = NULL,
  sigma = NULL,
  range = NULL,
  nu = NULL,
  G = NULL,
  C = NULL,
  d = NULL,
  mesh = NULL,
  graph = NULL,
  range_mesh = NULL,
  loc_mesh = NULL,
  m = 1,
  type = c("covariance", "operator"),
  parameterization = c("spde", "matern"),
  compute_higher_order = FALSE,
  return_block_list = FALSE,
  type_rational_approximation = c("chebfun", "brasil", "chebfunLB"),
  fem_mesh_matrices = NULL,
  compute_logdet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>Parameter kappa of the SPDE representation. If <code>NULL</code>, the range parameter will be used. If the range is also <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Parameter tau of the SPDE representation. If both sigma and tau are <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter alpha of the SPDE representation. If <code>alpha</code> is <code>NULL</code>, a starting value will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Standard deviation of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If <code>NULL</code>, tau will be used. If tau is also <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range</code></td>
<td>
<p>Range parameter of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If range is <code>NULL</code>, a starting value based on the mesh will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Shape parameter of the covariance function. Used if <code>parameterization</code> is <code>matern</code>. If <code>NULL</code>, a starting value will be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>The stiffness matrix of a finite element discretization of the
domain of interest. Does not need to be given if either <code>mesh</code> or <code>graph</code> is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>The mass matrix of a finite element discretization of the domain
of interest. Does not need to be given if either <code>mesh</code> or <code>graph</code> is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>The dimension of the domain. Does not need to be given if either
<code>mesh</code> or <code>graph</code> is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>An optional fmesher mesh. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>An optional <code>metric_graph</code> object. Replaces <code>d</code>, <code>C</code> and <code>G</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>range_mesh</code></td>
<td>
<p>The range of the mesh. Will be used to provide starting values for the parameters. Will be used if <code>mesh</code> and <code>graph</code> are <code>NULL</code>, and if one of the parameters (kappa or tau for spde parameterization, or sigma or range for matern parameterization) are not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc_mesh</code></td>
<td>
<p>The mesh locations used to construct the matrices C and G. This option should be provided if one wants to use the <code>rspde_lme()</code> function and will not provide neither graph nor mesh. Only works for 1d data. Does not work for metric graphs. For metric graphs you should supply the graph using the <code>graph</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The order of the rational approximation, which needs to be a
positive integer. The default value is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of the rational approximation. The options are
"covariance" and "operator". The default is "covariance".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameterization</code></td>
<td>
<p>Which parameterization to use? <code>matern</code> uses range, std. deviation and nu (smoothness). <code>spde</code> uses kappa, tau and alpha. The default is <code>spde</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_higher_order</code></td>
<td>
<p>Logical. Should the higher order finite
element matrices be computed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_block_list</code></td>
<td>
<p>Logical. For <code>type = "covariance"</code>,
should the block parts of the precision matrix be returned
separately as a list?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type_rational_approximation</code></td>
<td>
<p>Which type of rational
approximation should be used? The current types are
"chebfun", "brasil" or "chebfunLB".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fem_mesh_matrices</code></td>
<td>
<p>A list containing FEM-related matrices.
The list should contain elements c0, g1, g2, g3, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_logdet</code></td>
<td>
<p>Should log determinants be computed while building the model? (For covariance-based models)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>type</code> is "covariance", we use the
covariance-based rational approximation of the fractional operator.
In the SPDE approach, we model <code class="reqn">u</code> as the solution of the following SPDE:
</p>
<p style="text-align: center;"><code class="reqn">L^{\alpha/2}(\tau u) = \mathcal{W},</code>
</p>

<p>where
<code class="reqn">L  = -\Delta +\kappa^2 I</code> and <code class="reqn">\mathcal{W}</code> is the standard
Gaussian white noise. The covariance operator of <code class="reqn">u</code> is given
by <code class="reqn">L^{-\alpha}</code>. Now, let <code class="reqn">L_h</code> be a finite-element
approximation of <code class="reqn">L</code>. We can use
a rational approximation of order <code class="reqn">m</code> on <code class="reqn">L_h^{-\alpha}</code> to
obtain the following approximation:
</p>
<p style="text-align: center;"><code class="reqn">L_{h,m}^{-\alpha} = L_h^{-m_\alpha} p(L_h^{-1})q(L_h^{-1})^{-1},</code>
</p>

<p>where <code class="reqn">m_\alpha = \lfloor \alpha\rfloor</code>, <code class="reqn">p</code> and <code class="reqn">q</code> are
polynomials arising from such rational approximation.
From this approximation we construct an approximate precision
matrix for <code class="reqn">u</code>.
</p>
<p>If <code>type</code> is "operator", the approximation is based on a
rational approximation of the fractional operator
<code class="reqn">(\kappa^2 -\Delta)^\beta</code>, where <code class="reqn">\beta = (\nu + d/2)/2</code>.
This results in an approximate model of the form </p>
<p style="text-align: center;"><code class="reqn">P_l u(s) = P_r W,</code>
</p>

<p>where <code class="reqn">P_j = p_j(L)</code> are non-fractional operators defined in terms
of polynomials <code class="reqn">p_j</code> for <code class="reqn">j=l,r</code>. The order of <code class="reqn">p_r</code> is given
by <code>m</code> and the order of <code class="reqn">p_l</code> is <code class="reqn">m + m_\beta</code>
where <code class="reqn">m_\beta</code> is the integer part of <code class="reqn">\beta</code> if <code class="reqn">\beta&gt;1</code> and
<code class="reqn">m_\beta = 1</code> otherwise.
</p>
<p>The discrete approximation can be written as <code class="reqn">u = P_r x</code> where
<code class="reqn">x \sim N(0,Q^{-1})</code> and <code class="reqn">Q = P_l^T C^{-1} P_l</code>.
Note that the matrices <code class="reqn">P_r</code> and <code class="reqn">Q</code> may be be
ill-conditioned for <code class="reqn">m&gt;1</code>. In this case, the methods in
<code>operator.operations()</code> should be used for operations involving
the matrices, since these methods are more numerically stable.
</p>


<h3>Value</h3>

<p>If <code>type</code> is "covariance", then <code>matern.operators</code>
returns an object of class "CBrSPDEobj".
This object is a list containing the
following quantities:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>The mass lumped mass matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ci</code></td>
<td>
<p>The inverse of <code>C</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GCi</code></td>
<td>
<p>The stiffness matrix G times <code>Ci</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gk</code></td>
<td>
<p>The stiffness matrix G along with the higher-order
FEM-related matrices G2, G3, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fem_mesh_matrices</code></td>
<td>
<p>A list containing the mass
lumped mass matrix, the stiffness matrix and
the higher-order FEM-related matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>The order of the rational approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The fractional power of the precision operator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>The dimension of the domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Shape parameter of the covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>Range parameter of the covariance function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>Scale parameter of the covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Standard deviation of the covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>String indicating the type of approximation.</p>
</td>
</tr>
</table>
<p>If <code>type</code> is "operator", then <code>matern.operators</code>
returns an object of class "rSPDEobj". This object contains the
quantities listed in the output of <code>fractional.operators()</code>,
the <code>G</code> matrix, the dimension of the domain, as well as the
parameters of the covariance function.
</p>


<h3>See Also</h3>

<p><code>fractional.operators()</code>,
<code>spde.matern.operators()</code>,
<code>matern.operators()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compute the covariance-based rational approximation of a
# Gaussian process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
nobs &lt;- 101
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op_cov &lt;- matern.operators(
  loc_mesh = x, nu = nu,
  range = range, sigma = sigma, d = 1, m = 2,
  parameterization = "matern"
)

v &lt;- t(rSPDE.A1d(x, 0.5))
# Compute the precision matrix
Q &lt;- op_cov$Q
# A matrix here is the identity matrix
A &lt;- Diagonal(nobs)
# We need to concatenate 3 A's since we are doing a covariance-based rational
# approximation of order 2
Abar &lt;- cbind(A, A, A)
w &lt;- rbind(v, v, v)
# The approximate covariance function:
c_cov.approx &lt;- (Abar) %*% solve(Q, w)
c.true &lt;- folded.matern.covariance.1d(rep(0.5, length(x)),
   abs(x), kappa, nu, sigma)

# plot the result and compare with the true Matern covariance
plot(x, c.true,
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximations"
)
lines(x, c_cov.approx, col = 2)


# Compute the operator-based rational approximation of a Gaussian
# process with a Matern covariance function on R
kappa &lt;- 10
sigma &lt;- 1
nu &lt;- 0.8
range &lt;- sqrt(8*nu)/kappa

# create mass and stiffness matrices for a FEM discretization
x &lt;- seq(from = 0, to = 1, length.out = 101)
fem &lt;- rSPDE.fem1d(x)

# compute rational approximation of covariance function at 0.5
op &lt;- matern.operators(
  range = range, sigma = sigma, nu = nu,
  loc_mesh = x, d = 1,
  type = "operator",
  parameterization = "matern"
)

v &lt;- t(rSPDE.A1d(x, 0.5))
c.approx &lt;- Sigma.mult(op, v)
c.true &lt;- folded.matern.covariance.1d(rep(0.5, length(x)),
  abs(x), kappa, nu, sigma)

# plot the result and compare with the true Matern covariance
plot(x, c.true,
  type = "l", ylab = "C(h)",
  xlab = "h", main = "Matern covariance and rational approximation"
)
lines(x, c.approx, col = 2)
</code></pre>


</div>