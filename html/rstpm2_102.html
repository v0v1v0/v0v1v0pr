<div class="container">

<table style="width: 100%;"><tr>
<td>vuniroot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Vectorised One Dimensional Root (Zero) Finding</h2>

<h3>Description</h3>

<p>The function <code>vuniroot</code> searches the interval from <code>lower</code>
to <code>upper</code> for a root (i.e., zero) of the vectorised function <code>f</code> with
respect to its first argument.
</p>
<p>Setting <code>extendInt</code> to a non-<code>"no"</code> string, means searching
for the correct <code>interval = c(lower,upper)</code> if <code>sign(f(x))</code>
does not satisfy the requirements at the interval end points; see the
‘Details’ section.
</p>


<h3>Usage</h3>

<pre><code class="language-R">vuniroot(f, interval, ...,
        lower, upper,
        f.lower = f(lower, ...), f.upper = f(upper, ...),
        extendInt = c("no", "yes", "downX", "upX"), check.conv = FALSE,
        tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0,
        n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>the function for which the root is sought.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>a matrix with two columns containing the end-points of the interval
to be searched for the root.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional named or unnamed arguments to be passed
to <code>f</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower, upper</code></td>
<td>
<p>the lower and upper end points of the interval to
be searched.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.lower, f.upper</code></td>
<td>
<p>the same as <code>f(upper)</code> and
<code>f(lower)</code>, respectively.  Passing these values from the caller
where they are often known is more economical as soon as <code>f()</code>
contains non-trivial computations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extendInt</code></td>
<td>
<p>character string specifying if the interval
<code>c(lower,upper)</code> should be extended or directly produce an error
when <code>f()</code> does not have differing signs at the endpoints.  The
default, <code>"no"</code>, keeps the search interval and hence produces
an error.  Can be abbreviated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.conv</code></td>
<td>
<p>logical indicating whether a convergence warning of the
underlying <code>vuniroot</code> should be caught as an error and if
non-convergence in <code>maxiter</code> iterations should be an error
instead of a warning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>the maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>integer number; if positive, tracing information is
produced.  Higher values giving more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer number; size of input vector to <code>f</code>
(only used if <code>lower</code> and <code>upper</code> are of length 1)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that arguments after <code>...</code> must be matched exactly.
</p>
<p>Either <code>interval</code> or both <code>lower</code> and <code>upper</code> must be
specified: the upper endpoint must be strictly larger than the lower
endpoint.
</p>
<p>The function values at the endpoints must be of opposite signs (or
zero), for <code>extendInt="no"</code>, the default.  Otherwise, if
<code>extendInt="yes"</code>, the interval is extended on both sides, in
search of a sign change, i.e., until the search interval <code class="reqn">[l,u]</code>
satisfies <code class="reqn">f(l) \cdot f(u) \le 0</code>.
</p>
<p>If it is <em>known how</em> <code class="reqn">f</code> changes sign at the root
<code class="reqn">x_0</code>, that is, if the function is increasing or decreasing there,
<code>extendInt</code> can (and typically should) be specified as
<code>"upX"</code> (for “upward crossing”) or <code>"downX"</code>,
respectively.  Equivalently, define <code class="reqn">S := \pm 1</code>, to
require <code class="reqn">S = \mathrm{sign}(f(x_0 + \epsilon))</code> at the solution.  In that case, the search interval <code class="reqn">[l,u]</code>
possibly is extended to be such that <code class="reqn">S\cdot f(l)\le 0</code> and <code class="reqn">S \cdot f(u) \ge 0</code>.
</p>
<p><code>vuniroot()</code> uses a C++ subroutine based on ‘<span class="file">"zeroin"</span>’ (from Netlib)
and algorithms given in the reference below.  They assume a
continuous function (which then is known to have at least one root in
the interval).
</p>
<p>Convergence is declared either if <code>f(x) == 0</code> or the change in
<code>x</code> for one step of the algorithm is less than <code>tol</code> (plus an
allowance for representation error in <code>x</code>).
</p>
<p>If the algorithm does not converge in <code>maxiter</code> steps, a warning
is printed and the current approximation is returned.
</p>
<p><code>f</code> will be called as <code>f(<var>x</var>, ...)</code> for a numeric value
of <var>x</var>.
</p>
<p>The argument passed to <code>f</code> has special semantics and used to be
shared between calls.  The function should not copy it.
</p>


<h3>Value</h3>

<p>A list with at least three components: <code>root</code> and <code>f.root</code>
give the location of the root and the value of the function evaluated
at that point. <code>iter</code> gives the number of
iterations used.
</p>
<p>Further components may be added in future: component <code>init.it</code>
was added in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> 3.1.0.  
</p>


<h3>Source</h3>

<p>Based on ‘<span class="file">zeroin.c</span>’ in <a href="https://netlib.org/c/brent.shar">https://netlib.org/c/brent.shar</a>.
</p>


<h3>References</h3>

<p>Brent, R. (1973)
<em>Algorithms for Minimization without Derivatives.</em>
Englewood Cliffs, NJ: Prentice-Hall.
</p>


<h3>See Also</h3>

<p><code>uniroot</code> for the standard single root solver
<code>polyroot</code> for all complex roots of a polynomial;
<code>optimize</code>, <code>nlm</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
require(utils) # for str

## some platforms hit zero exactly on the first step:
## if so the estimated precision is 2/3.
f &lt;- function (x, a) x - a
str(xmin &lt;- vuniroot(f, lower=c(0, 0), upper=c(1,1), tol = 0.0001, a = c(1/3,2/3)))
## same example with scalars for lower and upper -- using the n argument
str(xmin &lt;- vuniroot(f, lower=0, upper=1, tol = 0.0001, n=2, a = c(1/3,2/3)))

## handheld calculator example: fixed point of cos(.):
vuniroot(function(x) cos(x) - x, lower = -pi, upper = pi, tol = 1e-9)$root

str(vuniroot(function(x) x*(x^2-1) + .5, lower = -2, upper = 2,
            tol = 0.0001))
str(vuniroot(function(x) x*(x^2-1) + .5, lower = -2, upper = 2,
            tol = 1e-10))

## Find the smallest value x for which exp(x) &gt; 0 (numerically):
r &lt;- vuniroot(function(x) 1e80*exp(x) - 1e-300, cbind(-1000, 0), tol = 1e-15)
str(r, digits.d = 15) # around -745, depending on the platform.

exp(r$root)     # = 0, but not for r$root * 0.999...
minexp &lt;- r$root * (1 - 10*.Machine$double.eps)
exp(minexp)     # typically denormalized


##--- vuniroot() with new interval extension + checking features: --------------

f1 &lt;- function(x) (121 - x^2)/(x^2+1)
f2 &lt;- function(x) exp(-x)*(x - 12)

tools::assertCondition(vuniroot(f1, cbind(0,10)),
                       "error", verbose=TRUE)
tools::assertCondition(vuniroot(f2, cbind(0, 2)),
                       "error", verbose=TRUE)
##--&gt; error: f() .. end points not of opposite sign

## where as  'extendInt="yes"'  simply first enlarges the search interval:
u1 &lt;- vuniroot(f1, cbind(0,10),extendInt="yes", trace=1)
u2 &lt;- vuniroot(f2, cbind(0,2), extendInt="yes", trace=2)
stopifnot(all.equal(u1$root, 11, tolerance = 1e-5),
          all.equal(u2$root, 12, tolerance = 6e-6))

## The *danger* of interval extension:
## No way to find a zero of a positive function, but
## numerically, f(-|M|) becomes zero :
tools::assertCondition(u3 &lt;- vuniroot(exp, cbind(0,2), extendInt="yes", trace=TRUE),
                       "error", verbose=TRUE)

## Nonsense example (must give an error):
tools::assertCondition( vuniroot(function(x) 1, cbind(0,1), extendInt="yes"),
                       "error", verbose=TRUE)

## Convergence checking :
sinc_ &lt;- function(x) ifelse(x == 0, 1, sin(x)/x)
curve(sinc_, -6,18); abline(h=0,v=0, lty=3, col=adjustcolor("gray", 0.8))

vuniroot(sinc_, cbind(0,5), extendInt="yes", maxiter=4) #-&gt; "just" a warning


## now with  check.conv=TRUE, must signal a convergence error :

vuniroot(sinc_, cbind(0,5), extendInt="yes", maxiter=4, check.conv=TRUE)


### Weibull cumulative hazard (example origin, Ravi Varadhan):
cumhaz &lt;- function(t, a, b) b * (t/b)^a
froot &lt;- function(x, u, a, b) cumhaz(x, a, b) - u

n &lt;- 10
u &lt;- -log(runif(n))
a &lt;- 1/2
b &lt;- 1
## Find failure times
ru &lt;- vuniroot(froot, u=u, a=a, b=b, interval= cbind(rep(1.e-14,n), rep(1e4,n)),
               extendInt="yes")$root
ru2 &lt;- vuniroot(froot, u=u, a=a, b=b, interval= cbind(rep(0.01,n), rep(10,n)),
                extendInt="yes")$root
stopifnot(all.equal(ru, ru2, tolerance = 6e-6))

r1 &lt;- vuniroot(froot, u= 0.99, a=a, b=b, interval= cbind(0.01, 10),
             extendInt="up")
stopifnot(all.equal(0.99, cumhaz(r1$root, a=a, b=b)))

## An error if 'extendInt' assumes "wrong zero-crossing direction":

vuniroot(froot, u= 0.99, a=a, b=b, interval= cbind(0.1, 10), extendInt="down")


</code></pre>


</div>