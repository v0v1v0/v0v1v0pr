<div class="container">

<table style="width: 100%;"><tr>
<td>GroupedSolrFrame-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GroupedSolrFrame</h2>

<h3>Description</h3>

<p>The <code>GroupedSolrFrame</code> is a <em>highly experimental</em> extension
of <code>SolrFrame</code> that models each column as a list,
formed by splitting the original vector by a common set of grouping
factors.
</p>


<h3>Details</h3>

<p>A <code>GroupedSolrFrame</code> should more or less behave analogously to a
data frame where every column is split by a common grouping. Unlike
<code>SolrFrame</code>, columns are <em>always</em> extracted lazily. Typical
usage is to construct a <code>GroupedSolrFrame</code> by calling
<code>group</code> on a <code>SolrFrame</code>, and then to extract columns (as
promises) and aggregate them (by e.g. calling <code>mean</code>).
</p>
<p>Functions that group the data, such as <code>group</code> and
<code>aggregate</code>, simply add to the existing grouping. To clear the
grouping, call <code>ungroup</code> or just coerce to a <code>SolrFrame</code> or
<code>SolrList</code>.
</p>


<h3>Accessors</h3>

<p>As <code>GroupedSolrFrame</code> inherits much of its functionality from
<code>SolrFrame</code>; here we only outline concerns specific to grouped
data.
</p>

<ul>
<li>
<p><code>ndoc(x)</code>: Gets the number of documents per group

</p>
</li>
<li>
<p><code>rownames(x)</code>: Forms unique group identifiers by
concatenating the grouping factor values.

</p>
</li>
<li>
<p><code>x[i, j] &lt;- value</code>: Inserts <code>value</code> into the Solr
core, where <code>value</code> is a data.frame of lists, or just a list
(representing a single column). Preferably, <code>i</code> is a promise,
because we need to the IDs of the selected documents in order to
perform the atomic update, and the promise lets us avoid
downloading <em>all</em> of the IDs. But otherwise, if <code>i</code> is
atomic, then it indexes into the groups. If <code>i</code> is a list,
then its names are matched to the group names, and its elements
index into the matching group. The list does not need to be named
if the elements are character vectors (and thus represent document
IDs).

</p>
</li>
<li>
<p><code>x[i, j, drop=FALSE]</code>: Extracts data from <code>x</code>, as usual,
but see the entry immediate above this one for the expectations of
<code>i</code>. Try to make it a promise, so that we do not need to
download IDs and then try to serialize them into a query, which
has length limitations.

</p>
</li>
</ul>
<h3>Extended API</h3>

<p>Most of the typical data frame accessors and data manipulation
functions will work analogously on <code>GroupedSolrFrame</code> (see
Details). Below, we list some of the non-standard methods that might
be seen as an extension of the data frame API.
</p>

<ul>
<li>
<p><code>heads(x, n)</code>, <code>tails(x, n)</code>, <code>windows(x,
      start, end)</code>: Perform <code>head</code>, <code>tail</code> or <code>window</code> on
each group separately, returning a data.frame with grouped (list)
columns.

</p>
</li>
<li>
<p><code>ngroup(x)</code>: The number of groups, i.e., the number of
rows.

</p>
</li>
</ul>
<h3>Author(s)</h3>

<p> Michael Lawrence </p>


</div>