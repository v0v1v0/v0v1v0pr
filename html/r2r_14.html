<div class="container">

<table style="width: 100%;"><tr>
<td>hashtable</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hash maps and sets</h2>

<h3>Description</h3>

<p>Objects of class <code>hashmap</code> and <code>hashset</code> store
collections of key/value pairs (<code>hashmap</code>), or just keys
(<code>hashset</code>), providing constant time read and write operations. Both
the keys and the optional values can be arbitrary R objects. <code>hashmap</code>s
and <code>hashset</code>s provide an R implementation of
<a href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a>.
</p>
<p>See hashtable_methods for an overview of the available methods
for <code>hashmap</code> and <code>hashset</code> class objects. Note that both these
classes have a common parent class <code>hashtable</code>, from which they can also
inherit S3 methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hashmap(
  ...,
  hash_fn = default_hash_fn,
  compare_fn = identical,
  key_preproc_fn = identity,
  on_missing_key = "default",
  default = NULL
)

hashset(
  ...,
  hash_fn = default_hash_fn,
  compare_fn = identical,
  key_preproc_fn = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>these arguments can be used to specify a set of initial elements
to be inserted in the <code>hashmap</code> or <code>hashset</code>. For <code>hashmap()</code>,
each of these should be a <code>list</code> of two elements (a key-value pair).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hash_fn</code></td>
<td>
<p>the (string valued) hash function applied to keys.
Required for advanced use only; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compare_fn</code></td>
<td>
<p>the (boolean valued) comparison function used for
testing key equality. Required for advanced use only; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>key_preproc_fn</code></td>
<td>
<p>key pre-processing function applied to keys before
hashing and comparison. Required for advanced use only; see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>on_missing_key</code></td>
<td>
<p>either <code>"throw"</code> or <code>"default"</code>.
In the second case, an exception is thrown upon query of a missing key; otherwise, a default value
(specified through the <code>default</code> argument) is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default</code></td>
<td>
<p>default value associated with missing keys. This will be
returned only if <code>on_missing_key</code> is equal to <code>"default"</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>hashmap</code>s and <code>hashset</code>s implement hash tables,
building on top of base R built-in <code>environment</code>s,
which by themselves are, essentially, string -&gt; R object hash maps.
In order to handle keys of non-string type, a string valued hash function
<code>default_hash_fn()</code> is provided, which leverages on
<code>digest()</code> for handling arbitrary R object keys.
</p>
<p>By default, key equality is tested through <code>identical()</code>.
For some use cases, it may be sensible to employ a different comparison
function, which can be assigned through the <code>compare_fn</code> argument. In this
case, one must also make sure that equal (in the sense of
<code>compare_fn()</code>)
keys get also assigned the same hashes by <code>hash_fn()</code>. A simple way to
ensure this is to use to use a key pre-processing function, to be applied
before both key hashing <em>and</em> comparison. The <code>key_preproc_fn</code>
argument provides a short-cut to this, by automatically composing both the
provided <code>hash_fn()</code> and <code>compare_fn()</code> functions with
<code>key_preproc_fn()</code> function. This is illustrated in an example below.
</p>
<p>One might also want to set set specific hash and/or key comparison functions
for efficiency reasons, e.g. if the <code>default_hash_fn()</code> function produces
many collisions between inequivalent keys.
</p>
<p>When <code>on_missing_key</code> is equal to <code>"throw"</code>, querying a missing
key will cause an error. In this case, an rlang abort
condition  of class <code>"r2r_missing_key"</code> is returned, which can be useful
for testing purposes.
</p>


<h3>Value</h3>

<p>a <code>hashmap</code> and a <code>hashset</code> class object for
<code>hashmap()</code> and <code>hashset()</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Valerio Gherardi
</p>


<h3>See Also</h3>

<p>hashtable_methods
</p>


<h3>Examples</h3>

<pre><code class="language-R">m &lt;- hashmap(
        list("foo", 1),
        list("bar", 1:5),
        list(data.frame(x = letters, y = LETTERS), "baz")
        )
m[[ data.frame(x = letters, y = LETTERS) ]]

# Set of character keys, case insensitive.
s &lt;- hashset("A", "B", "C", key_preproc = tolower)
s[["a"]]

</code></pre>


</div>