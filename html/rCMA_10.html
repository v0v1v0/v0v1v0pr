<div class="container">

<table style="width: 100%;"><tr>
<td>cmaOptimDP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform a CMA-ES optimization with constraints (DP).</h2>

<h3>Description</h3>

<p>The optimization uses DP (death penalty) for handling constraint violations:
Each time an infeasible individual is encountered, it is thrown away
and a new individual is resampled from the CMA distribution.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cmaOptimDP(cma, fitFunc, isFeasible = function(x) {     TRUE },
  maxDimPrint = 5, iterPrint = 10, verbose = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>cma</code></td>
<td>
<p>CMA-ES Java object, already initialized with <code>cmaInit</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitFunc</code></td>
<td>
<p>a function to be minimized. Signature: accepts a vector <code>x</code>, returns a <code>double</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isFeasible</code></td>
<td>
<p>[<code>function(x){TRUE}</code>] a Boolean function checking the feasibility
of the vector <code>x</code>. The default is to return always <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxDimPrint</code></td>
<td>
<p>[5] how many dimensions of vector <code>x</code> to print in diagnostic output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterPrint</code></td>
<td>
<p>[10]  after how many iterations should diagnostic output be printed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>[2] possible values are 0 (no output), 1, 2 (much output)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This functions loops through iterations (generations) until a stop condition is met:
In each iteration, a population is sampled (infeasible individuals are replaced via
Java function <code>resampleSingle</code>), its fitness vector is evaluated and the CMA
distribution is updated according to this fitness vector.
</p>
<p>Every <code>iterPrint</code> generations a one-line diagnostic output of the form
</p>
<pre>
     iter  fitness | x1 x2 ... xp
</pre>
<p>is printed where <code>fitness</code> is the current best value of the fitness function to be minimized
and <code>x1 x2 ... xp</code> are the first <code>maxDimPrint</code> dimensions of the corresponding
best point in input space.
</p>


<h3>Value</h3>

<p><code>res</code>, a list with diagnostic output from the optimization run:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>sMsg</code></td>
<td>
<p>  a string vector with all console output from the optimization run.
To print it, use: <code> cat(sMsg) </code> or <code> for (x in sMsg) cat(x) </code>  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestX</code></td>
<td>
<p> vector of length <code>dimension</code> with the best-ever solution X </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestFitness</code></td>
<td>
<p>  the corresponding best-ever fitness  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bestEvalNum</code></td>
<td>
<p> the fitness function evaluation number which gave this best-ever result </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIter</code></td>
<td>
<p> number of iterations  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitnessVec</code></td>
<td>
<p> vector of length <code>nIter</code>: the best fitness after each iteration </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xMat</code></td>
<td>
<p>  (<code>nIter x dimension</code>)-matrix: <code>xMat[i,]</code> is the best solution X after iteration <code>i</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cfe</code></td>
<td>
<p>  number of constraint function evaluations (<code>isFeasible</code>) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ffe</code></td>
<td>
<p>  number of fitness function evaluations (<code>fitFunc</code>) </p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>If your fitness function depends on other parameters besides <code>x</code>, then
encapsulate it in a new function <code>fitFunc</code> at a place where the other parameters
are accessible and rely on R's mechanism to locate the other parameters
in the environment surrounding <code>fitFunc</code>:
</p>
<pre>
     par1 &lt;- someObject;
   </pre> <pre>
     fitFunc &lt;- function(x) {  myFuncWithOtherPars(x,par1); }
   </pre>


<h3>Author(s)</h3>

<p>Wolfgang Konen, FHK, 2013-2015
</p>


<h3>See Also</h3>

<p><code>cmaNew</code>, <code>cmaInit</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## demo/demoCMA2.R: demo usage of package rCMA.
##
## After doing the unconstrained sphere (as in demoCMA1.r, for later reference in plot), 
## the constrained sphere problem TR2 is solved. 
## The problem TR2 has in addition to the fitness function 'sphere' the constraint function
## 'above the hyperplane sum_i(x_i) = n', where n is the input space dimension.
## The constrained optimum is at (1,...,1) and it has the value fTarget2=n.
##
## Note that in this second case, the optimimum lies exactly at the boundary 
## of the feasible region: res2$bestX=c(1,...,1).
##
## This script does exactly the same as class CMAExampleConstr in cma_jAll.jar,
## but it allows to define the functions fitFunc and isFeasible on the R side. 
## They can be replaced by arbitrary other R functions, which may depend on other 
## R variables as well. 
##
## The constraint handling approach is a very simple one: death penalty, i.e. if we get an 
## infeasible individual, it is immediately discarded and a new one is drawn from the distribution. 
## (This approach will run into trouble if the current distribution does not allow to reach any  
## feasible solutions.)
## 
library(rCMA)
fitFunc &lt;- function(x) {  sum(x*x); }
isFeasible &lt;- function(x) {  (sum(x) - length(x)) &gt;= 0;  }
n = 2;

cma &lt;- cmaNew(propFile="CMAEvolutionStrategy.properties");
cmaInit(cma,seed=42,dimension=n,initialX=1.5, initialStandardDeviations=0.2);
res1 = cmaOptimDP(cma,fitFunc,iterPrint=30);

cma &lt;- cmaNew(propFile="CMAEvolutionStrategy.properties");
cmaInit(cma,seed=42,dimension=n,initialX=1.5, initialStandardDeviations=0.2);
res2 = cmaOptimDP(cma,fitFunc,isFeasible,iterPrint=30);

fTarget =c(0,n); 
plot(res1$fitnessVec-fTarget[1],type="l",log="y",xlim=c(1,max(res1$nIter,res2$nIter))
    ,xlab="Iteration",ylab="Distance to target fitness");
lines(res2$fitnessVec-fTarget[2],col="red");
legend("topright",legend=c("TR2","sphere"),lwd=rep(1,2),col=c("red","black"))
str(res2);

bestSolution=rCMA::cmaEvalMeanX(cma,fitFunc,isFeasible);
str(bestSolution);

</code></pre>


</div>